(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2014-06-30",
    "endpointPrefix": "cognito-identity",
    "jsonVersion": "1.1",
    "protocol": "json",
    "serviceFullName": "Amazon Cognito Identity",
    "serviceId": "Cognito Identity",
    "signatureVersion": "v4",
    "targetPrefix": "AWSCognitoIdentityService",
    "uid": "cognito-identity-2014-06-30"
  },
  "operations": {
    "CreateIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolName",
          "AllowUnauthenticatedIdentities"
        ],
        "members": {
          "IdentityPoolName": {},
          "AllowUnauthenticatedIdentities": {
            "type": "boolean"
          },
          "AllowClassicFlow": {
            "type": "boolean"
          },
          "SupportedLoginProviders": {
            "shape": "S5"
          },
          "DeveloperProviderName": {},
          "OpenIdConnectProviderARNs": {
            "shape": "S9"
          },
          "CognitoIdentityProviders": {
            "shape": "Sb"
          },
          "SamlProviderARNs": {
            "shape": "Sg"
          },
          "IdentityPoolTags": {
            "shape": "Sh"
          }
        }
      },
      "output": {
        "shape": "Sk"
      }
    },
    "DeleteIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityIdsToDelete"
        ],
        "members": {
          "IdentityIdsToDelete": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "UnprocessedIdentityIds": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityId": {},
                "ErrorCode": {}
              }
            }
          }
        }
      }
    },
    "DeleteIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      }
    },
    "DescribeIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {}
        }
      },
      "output": {
        "shape": "Sv"
      }
    },
    "DescribeIdentityPool": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "shape": "Sk"
      }
    },
    "GetCredentialsForIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "CustomRoleArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Credentials": {
            "type": "structure",
            "members": {
              "AccessKeyId": {},
              "SecretKey": {},
              "SessionToken": {},
              "Expiration": {
                "type": "timestamp"
              }
            }
          }
        }
      },
      "authtype": "none"
    },
    "GetId": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "AccountId": {},
          "IdentityPoolId": {},
          "Logins": {
            "shape": "S10"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      },
      "authtype": "none"
    },
    "GetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S1c"
          },
          "RoleMappings": {
            "shape": "S1e"
          }
        }
      }
    },
    "GetOpenIdToken": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      },
      "authtype": "none"
    },
    "GetOpenIdTokenForDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Logins"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "PrincipalTags": {
            "shape": "S1s"
          },
          "TokenDuration": {
            "type": "long"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "Token": {}
        }
      }
    },
    "GetPrincipalTagAttributeMap": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "IdentityProviderName"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityProviderName": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "IdentityProviderName": {},
          "UseDefaults": {
            "type": "boolean"
          },
          "PrincipalTags": {
            "shape": "S1s"
          }
        }
      }
    },
    "ListIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "MaxResults"
        ],
        "members": {
          "IdentityPoolId": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {},
          "HideDisabled": {
            "type": "boolean"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "Identities": {
            "type": "list",
            "member": {
              "shape": "Sv"
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListIdentityPools": {
      "input": {
        "type": "structure",
        "required": [
          "MaxResults"
        ],
        "members": {
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPools": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "IdentityPoolId": {},
                "IdentityPoolName": {}
              }
            }
          },
          "NextToken": {}
        }
      }
    },
    "ListTagsForResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn"
        ],
        "members": {
          "ResourceArn": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Tags": {
            "shape": "Sh"
          }
        }
      }
    },
    "LookupDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityId": {},
          "DeveloperUserIdentifier": {},
          "MaxResults": {
            "type": "integer"
          },
          "NextToken": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {},
          "DeveloperUserIdentifierList": {
            "type": "list",
            "member": {}
          },
          "NextToken": {}
        }
      }
    },
    "MergeDeveloperIdentities": {
      "input": {
        "type": "structure",
        "required": [
          "SourceUserIdentifier",
          "DestinationUserIdentifier",
          "DeveloperProviderName",
          "IdentityPoolId"
        ],
        "members": {
          "SourceUserIdentifier": {},
          "DestinationUserIdentifier": {},
          "DeveloperProviderName": {},
          "IdentityPoolId": {}
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityId": {}
        }
      }
    },
    "SetIdentityPoolRoles": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "Roles"
        ],
        "members": {
          "IdentityPoolId": {},
          "Roles": {
            "shape": "S1c"
          },
          "RoleMappings": {
            "shape": "S1e"
          }
        }
      }
    },
    "SetPrincipalTagAttributeMap": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityPoolId",
          "IdentityProviderName"
        ],
        "members": {
          "IdentityPoolId": {},
          "IdentityProviderName": {},
          "UseDefaults": {
            "type": "boolean"
          },
          "PrincipalTags": {
            "shape": "S1s"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IdentityPoolId": {},
          "IdentityProviderName": {},
          "UseDefaults": {
            "type": "boolean"
          },
          "PrincipalTags": {
            "shape": "S1s"
          }
        }
      }
    },
    "TagResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn",
          "Tags"
        ],
        "members": {
          "ResourceArn": {},
          "Tags": {
            "shape": "Sh"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UnlinkDeveloperIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "IdentityPoolId",
          "DeveloperProviderName",
          "DeveloperUserIdentifier"
        ],
        "members": {
          "IdentityId": {},
          "IdentityPoolId": {},
          "DeveloperProviderName": {},
          "DeveloperUserIdentifier": {}
        }
      }
    },
    "UnlinkIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "IdentityId",
          "Logins",
          "LoginsToRemove"
        ],
        "members": {
          "IdentityId": {},
          "Logins": {
            "shape": "S10"
          },
          "LoginsToRemove": {
            "shape": "Sw"
          }
        }
      },
      "authtype": "none"
    },
    "UntagResource": {
      "input": {
        "type": "structure",
        "required": [
          "ResourceArn",
          "TagKeys"
        ],
        "members": {
          "ResourceArn": {},
          "TagKeys": {
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {}
      }
    },
    "UpdateIdentityPool": {
      "input": {
        "shape": "Sk"
      },
      "output": {
        "shape": "Sk"
      }
    }
  },
  "shapes": {
    "S5": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S9": {
      "type": "list",
      "member": {}
    },
    "Sb": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "ProviderName": {},
          "ClientId": {},
          "ServerSideTokenCheck": {
            "type": "boolean"
          }
        }
      }
    },
    "Sg": {
      "type": "list",
      "member": {}
    },
    "Sh": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "Sk": {
      "type": "structure",
      "required": [
        "IdentityPoolId",
        "IdentityPoolName",
        "AllowUnauthenticatedIdentities"
      ],
      "members": {
        "IdentityPoolId": {},
        "IdentityPoolName": {},
        "AllowUnauthenticatedIdentities": {
          "type": "boolean"
        },
        "AllowClassicFlow": {
          "type": "boolean"
        },
        "SupportedLoginProviders": {
          "shape": "S5"
        },
        "DeveloperProviderName": {},
        "OpenIdConnectProviderARNs": {
          "shape": "S9"
        },
        "CognitoIdentityProviders": {
          "shape": "Sb"
        },
        "SamlProviderARNs": {
          "shape": "Sg"
        },
        "IdentityPoolTags": {
          "shape": "Sh"
        }
      }
    },
    "Sv": {
      "type": "structure",
      "members": {
        "IdentityId": {},
        "Logins": {
          "shape": "Sw"
        },
        "CreationDate": {
          "type": "timestamp"
        },
        "LastModifiedDate": {
          "type": "timestamp"
        }
      }
    },
    "Sw": {
      "type": "list",
      "member": {}
    },
    "S10": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1c": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1e": {
      "type": "map",
      "key": {},
      "value": {
        "type": "structure",
        "required": [
          "Type"
        ],
        "members": {
          "Type": {},
          "AmbiguousRoleResolution": {},
          "RulesConfiguration": {
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Claim",
                    "MatchType",
                    "Value",
                    "RoleARN"
                  ],
                  "members": {
                    "Claim": {},
                    "MatchType": {},
                    "Value": {},
                    "RoleARN": {}
                  }
                }
              }
            }
          }
        }
      }
    },
    "S1s": {
      "type": "map",
      "key": {},
      "value": {}
    }
  }
}
},{}],2:[function(require,module,exports){
module.exports={
  "pagination": {
    "ListIdentityPools": {
      "input_token": "NextToken",
      "limit_key": "MaxResults",
      "output_token": "NextToken",
      "result_key": "IdentityPools"
    }
  }
}
},{}],3:[function(require,module,exports){
module.exports={
  "acm": {
    "name": "ACM",
    "cors": true
  },
  "apigateway": {
    "name": "APIGateway",
    "cors": true
  },
  "applicationautoscaling": {
    "prefix": "application-autoscaling",
    "name": "ApplicationAutoScaling",
    "cors": true
  },
  "appstream": {
    "name": "AppStream"
  },
  "autoscaling": {
    "name": "AutoScaling",
    "cors": true
  },
  "batch": {
    "name": "Batch"
  },
  "budgets": {
    "name": "Budgets"
  },
  "clouddirectory": {
    "name": "CloudDirectory",
    "versions": [
      "2016-05-10*"
    ]
  },
  "cloudformation": {
    "name": "CloudFormation",
    "cors": true
  },
  "cloudfront": {
    "name": "CloudFront",
    "versions": [
      "2013-05-12*",
      "2013-11-11*",
      "2014-05-31*",
      "2014-10-21*",
      "2014-11-06*",
      "2015-04-17*",
      "2015-07-27*",
      "2015-09-17*",
      "2016-01-13*",
      "2016-01-28*",
      "2016-08-01*",
      "2016-08-20*",
      "2016-09-07*",
      "2016-09-29*",
      "2016-11-25*",
      "2017-03-25*",
      "2017-10-30*",
      "2018-06-18*",
      "2018-11-05*",
      "2019-03-26*"
    ],
    "cors": true
  },
  "cloudhsm": {
    "name": "CloudHSM",
    "cors": true
  },
  "cloudsearch": {
    "name": "CloudSearch"
  },
  "cloudsearchdomain": {
    "name": "CloudSearchDomain"
  },
  "cloudtrail": {
    "name": "CloudTrail",
    "cors": true
  },
  "cloudwatch": {
    "prefix": "monitoring",
    "name": "CloudWatch",
    "cors": true
  },
  "cloudwatchevents": {
    "prefix": "events",
    "name": "CloudWatchEvents",
    "versions": [
      "2014-02-03*"
    ],
    "cors": true
  },
  "cloudwatchlogs": {
    "prefix": "logs",
    "name": "CloudWatchLogs",
    "cors": true
  },
  "codebuild": {
    "name": "CodeBuild",
    "cors": true
  },
  "codecommit": {
    "name": "CodeCommit",
    "cors": true
  },
  "codedeploy": {
    "name": "CodeDeploy",
    "cors": true
  },
  "codepipeline": {
    "name": "CodePipeline",
    "cors": true
  },
  "cognitoidentity": {
    "prefix": "cognito-identity",
    "name": "CognitoIdentity",
    "cors": true
  },
  "cognitoidentityserviceprovider": {
    "prefix": "cognito-idp",
    "name": "CognitoIdentityServiceProvider",
    "cors": true
  },
  "cognitosync": {
    "prefix": "cognito-sync",
    "name": "CognitoSync",
    "cors": true
  },
  "configservice": {
    "prefix": "config",
    "name": "ConfigService",
    "cors": true
  },
  "cur": {
    "name": "CUR",
    "cors": true
  },
  "datapipeline": {
    "name": "DataPipeline"
  },
  "devicefarm": {
    "name": "DeviceFarm",
    "cors": true
  },
  "directconnect": {
    "name": "DirectConnect",
    "cors": true
  },
  "directoryservice": {
    "prefix": "ds",
    "name": "DirectoryService"
  },
  "discovery": {
    "name": "Discovery"
  },
  "dms": {
    "name": "DMS"
  },
  "dynamodb": {
    "name": "DynamoDB",
    "cors": true
  },
  "dynamodbstreams": {
    "prefix": "streams.dynamodb",
    "name": "DynamoDBStreams",
    "cors": true
  },
  "ec2": {
    "name": "EC2",
    "versions": [
      "2013-06-15*",
      "2013-10-15*",
      "2014-02-01*",
      "2014-05-01*",
      "2014-06-15*",
      "2014-09-01*",
      "2014-10-01*",
      "2015-03-01*",
      "2015-04-15*",
      "2015-10-01*",
      "2016-04-01*",
      "2016-09-15*"
    ],
    "cors": true
  },
  "ecr": {
    "name": "ECR",
    "cors": true
  },
  "ecs": {
    "name": "ECS",
    "cors": true
  },
  "efs": {
    "prefix": "elasticfilesystem",
    "name": "EFS",
    "cors": true
  },
  "elasticache": {
    "name": "ElastiCache",
    "versions": [
      "2012-11-15*",
      "2014-03-24*",
      "2014-07-15*",
      "2014-09-30*"
    ],
    "cors": true
  },
  "elasticbeanstalk": {
    "name": "ElasticBeanstalk",
    "cors": true
  },
  "elb": {
    "prefix": "elasticloadbalancing",
    "name": "ELB",
    "cors": true
  },
  "elbv2": {
    "prefix": "elasticloadbalancingv2",
    "name": "ELBv2",
    "cors": true
  },
  "emr": {
    "prefix": "elasticmapreduce",
    "name": "EMR",
    "cors": true
  },
  "es": {
    "name": "ES"
  },
  "elastictranscoder": {
    "name": "ElasticTranscoder",
    "cors": true
  },
  "firehose": {
    "name": "Firehose",
    "cors": true
  },
  "gamelift": {
    "name": "GameLift",
    "cors": true
  },
  "glacier": {
    "name": "Glacier"
  },
  "health": {
    "name": "Health"
  },
  "iam": {
    "name": "IAM",
    "cors": true
  },
  "importexport": {
    "name": "ImportExport"
  },
  "inspector": {
    "name": "Inspector",
    "versions": [
      "2015-08-18*"
    ],
    "cors": true
  },
  "iot": {
    "name": "Iot",
    "cors": true
  },
  "iotdata": {
    "prefix": "iot-data",
    "name": "IotData",
    "cors": true
  },
  "kinesis": {
    "name": "Kinesis",
    "cors": true
  },
  "kinesisanalytics": {
    "name": "KinesisAnalytics"
  },
  "kms": {
    "name": "KMS",
    "cors": true
  },
  "lambda": {
    "name": "Lambda",
    "cors": true
  },
  "lexruntime": {
    "prefix": "runtime.lex",
    "name": "LexRuntime",
    "cors": true
  },
  "lightsail": {
    "name": "Lightsail"
  },
  "machinelearning": {
    "name": "MachineLearning",
    "cors": true
  },
  "marketplacecommerceanalytics": {
    "name": "MarketplaceCommerceAnalytics",
    "cors": true
  },
  "marketplacemetering": {
    "prefix": "meteringmarketplace",
    "name": "MarketplaceMetering"
  },
  "mturk": {
    "prefix": "mturk-requester",
    "name": "MTurk",
    "cors": true
  },
  "mobileanalytics": {
    "name": "MobileAnalytics",
    "cors": true
  },
  "opsworks": {
    "name": "OpsWorks",
    "cors": true
  },
  "opsworkscm": {
    "name": "OpsWorksCM"
  },
  "organizations": {
    "name": "Organizations"
  },
  "pinpoint": {
    "name": "Pinpoint"
  },
  "polly": {
    "name": "Polly",
    "cors": true
  },
  "rds": {
    "name": "RDS",
    "versions": [
      "2014-09-01*"
    ],
    "cors": true
  },
  "redshift": {
    "name": "Redshift",
    "cors": true
  },
  "rekognition": {
    "name": "Rekognition",
    "cors": true
  },
  "resourcegroupstaggingapi": {
    "name": "ResourceGroupsTaggingAPI"
  },
  "route53": {
    "name": "Route53",
    "cors": true
  },
  "route53domains": {
    "name": "Route53Domains",
    "cors": true
  },
  "s3": {
    "name": "S3",
    "dualstackAvailable": true,
    "cors": true
  },
  "s3control": {
    "name": "S3Control",
    "dualstackAvailable": true,
    "xmlNoDefaultLists": true
  },
  "servicecatalog": {
    "name": "ServiceCatalog",
    "cors": true
  },
  "ses": {
    "prefix": "email",
    "name": "SES",
    "cors": true
  },
  "shield": {
    "name": "Shield"
  },
  "simpledb": {
    "prefix": "sdb",
    "name": "SimpleDB"
  },
  "sms": {
    "name": "SMS"
  },
  "snowball": {
    "name": "Snowball"
  },
  "sns": {
    "name": "SNS",
    "cors": true
  },
  "sqs": {
    "name": "SQS",
    "cors": true
  },
  "ssm": {
    "name": "SSM",
    "cors": true
  },
  "storagegateway": {
    "name": "StorageGateway",
    "cors": true
  },
  "stepfunctions": {
    "prefix": "states",
    "name": "StepFunctions"
  },
  "sts": {
    "name": "STS",
    "cors": true
  },
  "support": {
    "name": "Support"
  },
  "swf": {
    "name": "SWF"
  },
  "xray": {
    "name": "XRay",
    "cors": true
  },
  "waf": {
    "name": "WAF",
    "cors": true
  },
  "wafregional": {
    "prefix": "waf-regional",
    "name": "WAFRegional"
  },
  "workdocs": {
    "name": "WorkDocs",
    "cors": true
  },
  "workspaces": {
    "name": "WorkSpaces"
  },
  "codestar": {
    "name": "CodeStar"
  },
  "lexmodelbuildingservice": {
    "prefix": "lex-models",
    "name": "LexModelBuildingService",
    "cors": true
  },
  "marketplaceentitlementservice": {
    "prefix": "entitlement.marketplace",
    "name": "MarketplaceEntitlementService"
  },
  "athena": {
    "name": "Athena",
    "cors": true
  },
  "greengrass": {
    "name": "Greengrass"
  },
  "dax": {
    "name": "DAX"
  },
  "migrationhub": {
    "prefix": "AWSMigrationHub",
    "name": "MigrationHub"
  },
  "cloudhsmv2": {
    "name": "CloudHSMV2",
    "cors": true
  },
  "glue": {
    "name": "Glue"
  },
  "mobile": {
    "name": "Mobile"
  },
  "pricing": {
    "name": "Pricing",
    "cors": true
  },
  "costexplorer": {
    "prefix": "ce",
    "name": "CostExplorer",
    "cors": true
  },
  "mediaconvert": {
    "name": "MediaConvert"
  },
  "medialive": {
    "name": "MediaLive"
  },
  "mediapackage": {
    "name": "MediaPackage"
  },
  "mediastore": {
    "name": "MediaStore"
  },
  "mediastoredata": {
    "prefix": "mediastore-data",
    "name": "MediaStoreData",
    "cors": true
  },
  "appsync": {
    "name": "AppSync"
  },
  "guardduty": {
    "name": "GuardDuty"
  },
  "mq": {
    "name": "MQ"
  },
  "comprehend": {
    "name": "Comprehend",
    "cors": true
  },
  "iotjobsdataplane": {
    "prefix": "iot-jobs-data",
    "name": "IoTJobsDataPlane"
  },
  "kinesisvideoarchivedmedia": {
    "prefix": "kinesis-video-archived-media",
    "name": "KinesisVideoArchivedMedia",
    "cors": true
  },
  "kinesisvideomedia": {
    "prefix": "kinesis-video-media",
    "name": "KinesisVideoMedia",
    "cors": true
  },
  "kinesisvideo": {
    "name": "KinesisVideo",
    "cors": true
  },
  "sagemakerruntime": {
    "prefix": "runtime.sagemaker",
    "name": "SageMakerRuntime"
  },
  "sagemaker": {
    "name": "SageMaker"
  },
  "translate": {
    "name": "Translate",
    "cors": true
  },
  "resourcegroups": {
    "prefix": "resource-groups",
    "name": "ResourceGroups",
    "cors": true
  },
  "alexaforbusiness": {
    "name": "AlexaForBusiness"
  },
  "cloud9": {
    "name": "Cloud9"
  },
  "serverlessapplicationrepository": {
    "prefix": "serverlessrepo",
    "name": "ServerlessApplicationRepository"
  },
  "servicediscovery": {
    "name": "ServiceDiscovery"
  },
  "workmail": {
    "name": "WorkMail"
  },
  "autoscalingplans": {
    "prefix": "autoscaling-plans",
    "name": "AutoScalingPlans"
  },
  "transcribeservice": {
    "prefix": "transcribe",
    "name": "TranscribeService"
  },
  "connect": {
    "name": "Connect",
    "cors": true
  },
  "acmpca": {
    "prefix": "acm-pca",
    "name": "ACMPCA"
  },
  "fms": {
    "name": "FMS"
  },
  "secretsmanager": {
    "name": "SecretsManager",
    "cors": true
  },
  "iotanalytics": {
    "name": "IoTAnalytics",
    "cors": true
  },
  "iot1clickdevicesservice": {
    "prefix": "iot1click-devices",
    "name": "IoT1ClickDevicesService"
  },
  "iot1clickprojects": {
    "prefix": "iot1click-projects",
    "name": "IoT1ClickProjects"
  },
  "pi": {
    "name": "PI"
  },
  "neptune": {
    "name": "Neptune"
  },
  "mediatailor": {
    "name": "MediaTailor"
  },
  "eks": {
    "name": "EKS"
  },
  "macie": {
    "name": "Macie"
  },
  "dlm": {
    "name": "DLM"
  },
  "signer": {
    "name": "Signer"
  },
  "chime": {
    "name": "Chime"
  },
  "pinpointemail": {
    "prefix": "pinpoint-email",
    "name": "PinpointEmail"
  },
  "ram": {
    "name": "RAM"
  },
  "route53resolver": {
    "name": "Route53Resolver"
  },
  "pinpointsmsvoice": {
    "prefix": "sms-voice",
    "name": "PinpointSMSVoice"
  },
  "quicksight": {
    "name": "QuickSight"
  },
  "rdsdataservice": {
    "prefix": "rds-data",
    "name": "RDSDataService"
  },
  "amplify": {
    "name": "Amplify"
  },
  "datasync": {
    "name": "DataSync"
  },
  "robomaker": {
    "name": "RoboMaker"
  },
  "transfer": {
    "name": "Transfer"
  },
  "globalaccelerator": {
    "name": "GlobalAccelerator"
  },
  "comprehendmedical": {
    "name": "ComprehendMedical",
    "cors": true
  },
  "kinesisanalyticsv2": {
    "name": "KinesisAnalyticsV2"
  },
  "mediaconnect": {
    "name": "MediaConnect"
  },
  "fsx": {
    "name": "FSx"
  },
  "securityhub": {
    "name": "SecurityHub"
  },
  "appmesh": {
    "name": "AppMesh",
    "versions": [
      "2018-10-01*"
    ]
  },
  "licensemanager": {
    "prefix": "license-manager",
    "name": "LicenseManager"
  },
  "kafka": {
    "name": "Kafka"
  },
  "apigatewaymanagementapi": {
    "name": "ApiGatewayManagementApi"
  },
  "apigatewayv2": {
    "name": "ApiGatewayV2"
  },
  "docdb": {
    "name": "DocDB"
  },
  "backup": {
    "name": "Backup"
  },
  "worklink": {
    "name": "WorkLink"
  },
  "textract": {
    "name": "Textract"
  },
  "managedblockchain": {
    "name": "ManagedBlockchain"
  },
  "mediapackagevod": {
    "prefix": "mediapackage-vod",
    "name": "MediaPackageVod"
  },
  "groundstation": {
    "name": "GroundStation"
  },
  "iotthingsgraph": {
    "name": "IoTThingsGraph"
  },
  "iotevents": {
    "name": "IoTEvents"
  },
  "ioteventsdata": {
    "prefix": "iotevents-data",
    "name": "IoTEventsData"
  },
  "personalize": {
    "name": "Personalize",
    "cors": true
  },
  "personalizeevents": {
    "prefix": "personalize-events",
    "name": "PersonalizeEvents",
    "cors": true
  },
  "personalizeruntime": {
    "prefix": "personalize-runtime",
    "name": "PersonalizeRuntime",
    "cors": true
  },
  "applicationinsights": {
    "prefix": "application-insights",
    "name": "ApplicationInsights"
  },
  "servicequotas": {
    "prefix": "service-quotas",
    "name": "ServiceQuotas"
  },
  "ec2instanceconnect": {
    "prefix": "ec2-instance-connect",
    "name": "EC2InstanceConnect"
  },
  "eventbridge": {
    "name": "EventBridge"
  },
  "lakeformation": {
    "name": "LakeFormation"
  },
  "forecastservice": {
    "prefix": "forecast",
    "name": "ForecastService",
    "cors": true
  },
  "forecastqueryservice": {
    "prefix": "forecastquery",
    "name": "ForecastQueryService",
    "cors": true
  },
  "qldb": {
    "name": "QLDB"
  },
  "qldbsession": {
    "prefix": "qldb-session",
    "name": "QLDBSession"
  },
  "workmailmessageflow": {
    "name": "WorkMailMessageFlow"
  },
  "codestarnotifications": {
    "prefix": "codestar-notifications",
    "name": "CodeStarNotifications"
  },
  "savingsplans": {
    "name": "SavingsPlans"
  },
  "sso": {
    "name": "SSO"
  },
  "ssooidc": {
    "prefix": "sso-oidc",
    "name": "SSOOIDC"
  },
  "marketplacecatalog": {
    "prefix": "marketplace-catalog",
    "name": "MarketplaceCatalog"
  },
  "dataexchange": {
    "name": "DataExchange"
  },
  "sesv2": {
    "name": "SESV2"
  },
  "migrationhubconfig": {
    "prefix": "migrationhub-config",
    "name": "MigrationHubConfig"
  },
  "connectparticipant": {
    "name": "ConnectParticipant"
  },
  "appconfig": {
    "name": "AppConfig"
  },
  "iotsecuretunneling": {
    "name": "IoTSecureTunneling"
  },
  "wafv2": {
    "name": "WAFV2"
  },
  "elasticinference": {
    "prefix": "elastic-inference",
    "name": "ElasticInference"
  },
  "imagebuilder": {
    "name": "Imagebuilder"
  },
  "schemas": {
    "name": "Schemas"
  },
  "accessanalyzer": {
    "name": "AccessAnalyzer"
  },
  "codegurureviewer": {
    "prefix": "codeguru-reviewer",
    "name": "CodeGuruReviewer"
  },
  "codeguruprofiler": {
    "name": "CodeGuruProfiler"
  },
  "computeoptimizer": {
    "prefix": "compute-optimizer",
    "name": "ComputeOptimizer"
  },
  "frauddetector": {
    "name": "FraudDetector"
  },
  "kendra": {
    "name": "Kendra"
  },
  "networkmanager": {
    "name": "NetworkManager"
  },
  "outposts": {
    "name": "Outposts"
  },
  "augmentedairuntime": {
    "prefix": "sagemaker-a2i-runtime",
    "name": "AugmentedAIRuntime"
  },
  "ebs": {
    "name": "EBS"
  },
  "kinesisvideosignalingchannels": {
    "prefix": "kinesis-video-signaling",
    "name": "KinesisVideoSignalingChannels",
    "cors": true
  },
  "detective": {
    "name": "Detective"
  },
  "codestarconnections": {
    "prefix": "codestar-connections",
    "name": "CodeStarconnections"
  },
  "synthetics": {
    "name": "Synthetics"
  },
  "iotsitewise": {
    "name": "IoTSiteWise"
  },
  "macie2": {
    "name": "Macie2"
  },
  "codeartifact": {
    "name": "CodeArtifact"
  },
  "honeycode": {
    "name": "Honeycode"
  },
  "ivs": {
    "name": "IVS"
  },
  "braket": {
    "name": "Braket"
  },
  "identitystore": {
    "name": "IdentityStore"
  },
  "appflow": {
    "name": "Appflow"
  },
  "redshiftdata": {
    "prefix": "redshift-data",
    "name": "RedshiftData"
  },
  "ssoadmin": {
    "prefix": "sso-admin",
    "name": "SSOAdmin"
  },
  "timestreamquery": {
    "prefix": "timestream-query",
    "name": "TimestreamQuery"
  },
  "timestreamwrite": {
    "prefix": "timestream-write",
    "name": "TimestreamWrite"
  },
  "s3outposts": {
    "name": "S3Outposts"
  },
  "databrew": {
    "name": "DataBrew"
  },
  "servicecatalogappregistry": {
    "prefix": "servicecatalog-appregistry",
    "name": "ServiceCatalogAppRegistry"
  },
  "networkfirewall": {
    "prefix": "network-firewall",
    "name": "NetworkFirewall"
  },
  "mwaa": {
    "name": "MWAA"
  },
  "amplifybackend": {
    "name": "AmplifyBackend"
  },
  "appintegrations": {
    "name": "AppIntegrations"
  },
  "connectcontactlens": {
    "prefix": "connect-contact-lens",
    "name": "ConnectContactLens"
  },
  "devopsguru": {
    "prefix": "devops-guru",
    "name": "DevOpsGuru"
  },
  "ecrpublic": {
    "prefix": "ecr-public",
    "name": "ECRPUBLIC"
  },
  "lookoutvision": {
    "name": "LookoutVision"
  },
  "sagemakerfeaturestoreruntime": {
    "prefix": "sagemaker-featurestore-runtime",
    "name": "SageMakerFeatureStoreRuntime"
  },
  "customerprofiles": {
    "prefix": "customer-profiles",
    "name": "CustomerProfiles"
  },
  "auditmanager": {
    "name": "AuditManager"
  },
  "emrcontainers": {
    "prefix": "emr-containers",
    "name": "EMRcontainers"
  },
  "healthlake": {
    "name": "HealthLake"
  },
  "sagemakeredge": {
    "prefix": "sagemaker-edge",
    "name": "SagemakerEdge"
  },
  "amp": {
    "name": "Amp"
  },
  "greengrassv2": {
    "name": "GreengrassV2"
  },
  "iotdeviceadvisor": {
    "name": "IotDeviceAdvisor"
  },
  "iotfleethub": {
    "name": "IoTFleetHub"
  },
  "iotwireless": {
    "name": "IoTWireless"
  },
  "location": {
    "name": "Location",
    "cors": true
  },
  "wellarchitected": {
    "name": "WellArchitected"
  },
  "lexmodelsv2": {
    "prefix": "models.lex.v2",
    "name": "LexModelsV2"
  },
  "lexruntimev2": {
    "prefix": "runtime.lex.v2",
    "name": "LexRuntimeV2",
    "cors": true
  },
  "fis": {
    "name": "Fis"
  },
  "lookoutmetrics": {
    "name": "LookoutMetrics"
  },
  "mgn": {
    "name": "Mgn"
  },
  "lookoutequipment": {
    "name": "LookoutEquipment"
  },
  "nimble": {
    "name": "Nimble"
  },
  "finspace": {
    "name": "Finspace"
  },
  "finspacedata": {
    "prefix": "finspace-data",
    "name": "Finspacedata"
  },
  "ssmcontacts": {
    "prefix": "ssm-contacts",
    "name": "SSMContacts"
  },
  "ssmincidents": {
    "prefix": "ssm-incidents",
    "name": "SSMIncidents"
  },
  "applicationcostprofiler": {
    "name": "ApplicationCostProfiler"
  },
  "apprunner": {
    "name": "AppRunner"
  },
  "proton": {
    "name": "Proton"
  },
  "route53recoverycluster": {
    "prefix": "route53-recovery-cluster",
    "name": "Route53RecoveryCluster"
  },
  "route53recoverycontrolconfig": {
    "prefix": "route53-recovery-control-config",
    "name": "Route53RecoveryControlConfig"
  },
  "route53recoveryreadiness": {
    "prefix": "route53-recovery-readiness",
    "name": "Route53RecoveryReadiness"
  },
  "chimesdkidentity": {
    "prefix": "chime-sdk-identity",
    "name": "ChimeSDKIdentity"
  },
  "chimesdkmessaging": {
    "prefix": "chime-sdk-messaging",
    "name": "ChimeSDKMessaging"
  },
  "snowdevicemanagement": {
    "prefix": "snow-device-management",
    "name": "SnowDeviceManagement"
  },
  "memorydb": {
    "name": "MemoryDB"
  },
  "opensearch": {
    "name": "OpenSearch"
  },
  "kafkaconnect": {
    "name": "KafkaConnect"
  },
  "voiceid": {
    "prefix": "voice-id",
    "name": "VoiceID"
  },
  "wisdom": {
    "name": "Wisdom"
  },
  "account": {
    "name": "Account"
  },
  "cloudcontrol": {
    "name": "CloudControl"
  },
  "grafana": {
    "name": "Grafana"
  },
  "panorama": {
    "name": "Panorama"
  },
  "chimesdkmeetings": {
    "prefix": "chime-sdk-meetings",
    "name": "ChimeSDKMeetings"
  },
  "resiliencehub": {
    "name": "Resiliencehub"
  },
  "migrationhubstrategy": {
    "name": "MigrationHubStrategy"
  },
  "appconfigdata": {
    "name": "AppConfigData"
  },
  "drs": {
    "name": "Drs"
  },
  "migrationhubrefactorspaces": {
    "prefix": "migration-hub-refactor-spaces",
    "name": "MigrationHubRefactorSpaces"
  },
  "evidently": {
    "name": "Evidently"
  },
  "inspector2": {
    "name": "Inspector2"
  },
  "rbin": {
    "name": "Rbin"
  },
  "rum": {
    "name": "RUM"
  },
  "backupgateway": {
    "prefix": "backup-gateway",
    "name": "BackupGateway"
  },
  "iottwinmaker": {
    "name": "IoTTwinMaker"
  },
  "workspacesweb": {
    "prefix": "workspaces-web",
    "name": "WorkSpacesWeb"
  },
  "amplifyuibuilder": {
    "name": "AmplifyUIBuilder"
  },
  "keyspaces": {
    "name": "Keyspaces"
  },
  "billingconductor": {
    "name": "Billingconductor"
  },
  "gamesparks": {
    "name": "GameSparks"
  },
  "pinpointsmsvoicev2": {
    "prefix": "pinpoint-sms-voice-v2",
    "name": "PinpointSMSVoiceV2"
  },
  "ivschat": {
    "name": "Ivschat"
  },
  "chimesdkmediapipelines": {
    "prefix": "chime-sdk-media-pipelines",
    "name": "ChimeSDKMediaPipelines"
  },
  "emrserverless": {
    "prefix": "emr-serverless",
    "name": "EMRServerless"
  },
  "m2": {
    "name": "M2"
  },
  "connectcampaigns": {
    "name": "ConnectCampaigns"
  },
  "redshiftserverless": {
    "prefix": "redshift-serverless",
    "name": "RedshiftServerless"
  },
  "rolesanywhere": {
    "name": "RolesAnywhere"
  },
  "licensemanagerusersubscriptions": {
    "prefix": "license-manager-user-subscriptions",
    "name": "LicenseManagerUserSubscriptions"
  },
  "backupstorage": {
    "name": "BackupStorage"
  },
  "privatenetworks": {
    "name": "PrivateNetworks"
  },
  "supportapp": {
    "prefix": "support-app",
    "name": "SupportApp"
  },
  "controltower": {
    "name": "ControlTower"
  }
}
},{}],4:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2006-03-01",
    "checksumFormat": "md5",
    "endpointPrefix": "s3",
    "globalEndpoint": "s3.amazonaws.com",
    "protocol": "rest-xml",
    "serviceAbbreviation": "Amazon S3",
    "serviceFullName": "Amazon Simple Storage Service",
    "serviceId": "S3",
    "signatureVersion": "s3",
    "uid": "s3-2006-03-01"
  },
  "operations": {
    "AbortMultipartUpload": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "CompleteMultipartUpload": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MultipartUpload": {
            "locationName": "CompleteMultipartUpload",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Parts": {
                "locationName": "Part",
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "ETag": {},
                    "ChecksumCRC32": {},
                    "ChecksumCRC32C": {},
                    "ChecksumSHA1": {},
                    "ChecksumSHA256": {},
                    "PartNumber": {
                      "type": "integer"
                    }
                  }
                },
                "flattened": true
              }
            }
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          }
        },
        "payload": "MultipartUpload"
      },
      "output": {
        "type": "structure",
        "members": {
          "Location": {},
          "Bucket": {},
          "Key": {},
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "ETag": {},
          "ChecksumCRC32": {},
          "ChecksumCRC32C": {},
          "ChecksumSHA1": {},
          "ChecksumSHA256": {},
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "CopyObject": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CopySource",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-checksum-algorithm"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "CopySource": {
            "location": "header",
            "locationName": "x-amz-copy-source"
          },
          "CopySourceIfMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-match"
          },
          "CopySourceIfModifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-modified-since",
            "type": "timestamp"
          },
          "CopySourceIfNoneMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-none-match"
          },
          "CopySourceIfUnmodifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-unmodified-since",
            "type": "timestamp"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S1b",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "MetadataDirective": {
            "location": "header",
            "locationName": "x-amz-metadata-directive"
          },
          "TaggingDirective": {
            "location": "header",
            "locationName": "x-amz-tagging-directive"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1i",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "CopySourceSSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
          },
          "CopySourceSSECustomerKey": {
            "shape": "S1k",
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key"
          },
          "CopySourceSSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1o",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ExpectedSourceBucketOwner": {
            "location": "header",
            "locationName": "x-amz-source-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CopyObjectResult": {
            "type": "structure",
            "members": {
              "ETag": {},
              "LastModified": {
                "type": "timestamp"
              },
              "ChecksumCRC32": {},
              "ChecksumCRC32C": {},
              "ChecksumSHA1": {},
              "ChecksumSHA256": {}
            }
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "CopySourceVersionId": {
            "location": "header",
            "locationName": "x-amz-copy-source-version-id"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1i",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "CopyObjectResult"
      },
      "alias": "PutObjectCopy"
    },
    "CreateBucket": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CreateBucketConfiguration": {
            "locationName": "CreateBucketConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "LocationConstraint": {}
            }
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "ObjectLockEnabledForBucket": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-enabled",
            "type": "boolean"
          },
          "ObjectOwnership": {
            "location": "header",
            "locationName": "x-amz-object-ownership"
          }
        },
        "payload": "CreateBucketConfiguration"
      },
      "output": {
        "type": "structure",
        "members": {
          "Location": {
            "location": "header",
            "locationName": "Location"
          }
        }
      },
      "alias": "PutBucket"
    },
    "CreateMultipartUpload": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?uploads"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S1b",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1i",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1o",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-checksum-algorithm"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AbortDate": {
            "location": "header",
            "locationName": "x-amz-abort-date",
            "type": "timestamp"
          },
          "AbortRuleId": {
            "location": "header",
            "locationName": "x-amz-abort-rule-id"
          },
          "Bucket": {
            "locationName": "Bucket"
          },
          "Key": {},
          "UploadId": {},
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1i",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-checksum-algorithm"
          }
        }
      },
      "alias": "InitiateMultipartUpload"
    },
    "DeleteBucket": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketAnalyticsConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?analytics",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketCors": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?cors",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketEncryption": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?encryption",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketIntelligentTieringConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?intelligent-tiering",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      }
    },
    "DeleteBucketInventoryConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?inventory",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketLifecycle": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?lifecycle",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketMetricsConfiguration": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?metrics",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketOwnershipControls": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?ownershipControls",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketPolicy": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?policy",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketReplication": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?replication",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketTagging": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?tagging",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteBucketWebsite": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?website",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "DeleteObject": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "DeleteObjectTagging": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}/{Key+}?tagging",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          }
        }
      }
    },
    "DeleteObjects": {
      "http": {
        "requestUri": "/{Bucket}?delete"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Delete"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delete": {
            "locationName": "Delete",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Objects"
            ],
            "members": {
              "Objects": {
                "locationName": "Object",
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Key"
                  ],
                  "members": {
                    "Key": {},
                    "VersionId": {}
                  }
                },
                "flattened": true
              },
              "Quiet": {
                "type": "boolean"
              }
            }
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          }
        },
        "payload": "Delete"
      },
      "output": {
        "type": "structure",
        "members": {
          "Deleted": {
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Key": {},
                "VersionId": {},
                "DeleteMarker": {
                  "type": "boolean"
                },
                "DeleteMarkerVersionId": {}
              }
            },
            "flattened": true
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "Errors": {
            "locationName": "Error",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Key": {},
                "VersionId": {},
                "Code": {},
                "Message": {}
              }
            },
            "flattened": true
          }
        }
      },
      "alias": "DeleteMultipleObjects",
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "DeletePublicAccessBlock": {
      "http": {
        "method": "DELETE",
        "requestUri": "/{Bucket}?publicAccessBlock",
        "responseCode": 204
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "GetBucketAccelerateConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?accelerate"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Status": {}
        }
      }
    },
    "GetBucketAcl": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Owner": {
            "shape": "S3d"
          },
          "Grants": {
            "shape": "S3g",
            "locationName": "AccessControlList"
          }
        }
      }
    },
    "GetBucketAnalyticsConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AnalyticsConfiguration": {
            "shape": "S3p"
          }
        },
        "payload": "AnalyticsConfiguration"
      }
    },
    "GetBucketCors": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?cors"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CORSRules": {
            "shape": "S44",
            "locationName": "CORSRule"
          }
        }
      }
    },
    "GetBucketEncryption": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?encryption"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ServerSideEncryptionConfiguration": {
            "shape": "S4h"
          }
        },
        "payload": "ServerSideEncryptionConfiguration"
      }
    },
    "GetBucketIntelligentTieringConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?intelligent-tiering"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IntelligentTieringConfiguration": {
            "shape": "S4n"
          }
        },
        "payload": "IntelligentTieringConfiguration"
      }
    },
    "GetBucketInventoryConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "InventoryConfiguration": {
            "shape": "S4x"
          }
        },
        "payload": "InventoryConfiguration"
      }
    },
    "GetBucketLifecycle": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Rules": {
            "shape": "S5d",
            "locationName": "Rule"
          }
        }
      },
      "deprecated": true
    },
    "GetBucketLifecycleConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Rules": {
            "shape": "S5t",
            "locationName": "Rule"
          }
        }
      }
    },
    "GetBucketLocation": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?location"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LocationConstraint": {}
        }
      }
    },
    "GetBucketLogging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?logging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LoggingEnabled": {
            "shape": "S65"
          }
        }
      }
    },
    "GetBucketMetricsConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "MetricsConfiguration": {
            "shape": "S6d"
          }
        },
        "payload": "MetricsConfiguration"
      }
    },
    "GetBucketNotification": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "shape": "S6h"
      },
      "output": {
        "shape": "S6i"
      },
      "deprecated": true
    },
    "GetBucketNotificationConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "shape": "S6h"
      },
      "output": {
        "shape": "S6t"
      }
    },
    "GetBucketOwnershipControls": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?ownershipControls"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "OwnershipControls": {
            "shape": "S7a"
          }
        },
        "payload": "OwnershipControls"
      }
    },
    "GetBucketPolicy": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?policy"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Policy": {}
        },
        "payload": "Policy"
      }
    },
    "GetBucketPolicyStatus": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?policyStatus"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "PolicyStatus": {
            "type": "structure",
            "members": {
              "IsPublic": {
                "locationName": "IsPublic",
                "type": "boolean"
              }
            }
          }
        },
        "payload": "PolicyStatus"
      }
    },
    "GetBucketReplication": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?replication"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ReplicationConfiguration": {
            "shape": "S7m"
          }
        },
        "payload": "ReplicationConfiguration"
      }
    },
    "GetBucketRequestPayment": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?requestPayment"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Payer": {}
        }
      }
    },
    "GetBucketTagging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "TagSet"
        ],
        "members": {
          "TagSet": {
            "shape": "S3v"
          }
        }
      }
    },
    "GetBucketVersioning": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?versioning"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Status": {},
          "MFADelete": {
            "locationName": "MfaDelete"
          }
        }
      }
    },
    "GetBucketWebsite": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?website"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "RedirectAllRequestsTo": {
            "shape": "S8p"
          },
          "IndexDocument": {
            "shape": "S8s"
          },
          "ErrorDocument": {
            "shape": "S8u"
          },
          "RoutingRules": {
            "shape": "S8v"
          }
        }
      }
    },
    "GetObject": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "IfMatch": {
            "location": "header",
            "locationName": "If-Match"
          },
          "IfModifiedSince": {
            "location": "header",
            "locationName": "If-Modified-Since",
            "type": "timestamp"
          },
          "IfNoneMatch": {
            "location": "header",
            "locationName": "If-None-Match"
          },
          "IfUnmodifiedSince": {
            "location": "header",
            "locationName": "If-Unmodified-Since",
            "type": "timestamp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Range": {
            "location": "header",
            "locationName": "Range"
          },
          "ResponseCacheControl": {
            "location": "querystring",
            "locationName": "response-cache-control"
          },
          "ResponseContentDisposition": {
            "location": "querystring",
            "locationName": "response-content-disposition"
          },
          "ResponseContentEncoding": {
            "location": "querystring",
            "locationName": "response-content-encoding"
          },
          "ResponseContentLanguage": {
            "location": "querystring",
            "locationName": "response-content-language"
          },
          "ResponseContentType": {
            "location": "querystring",
            "locationName": "response-content-type"
          },
          "ResponseExpires": {
            "location": "querystring",
            "locationName": "response-expires",
            "type": "timestamp",
            "timestampFormat": "rfc822"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ChecksumMode": {
            "location": "header",
            "locationName": "x-amz-checksum-mode"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "accept-ranges"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-restore"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-missing-meta",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentRange": {
            "location": "header",
            "locationName": "Content-Range"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "Metadata": {
            "shape": "S1b",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-replication-status"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-mp-parts-count",
            "type": "integer"
          },
          "TagCount": {
            "location": "header",
            "locationName": "x-amz-tagging-count",
            "type": "integer"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1o",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        },
        "payload": "Body"
      },
      "httpChecksum": {
        "requestValidationModeMember": "ChecksumMode",
        "responseAlgorithms": [
          "CRC32",
          "CRC32C",
          "SHA256",
          "SHA1"
        ]
      }
    },
    "GetObjectAcl": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Owner": {
            "shape": "S3d"
          },
          "Grants": {
            "shape": "S3g",
            "locationName": "AccessControlList"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      }
    },
    "GetObjectAttributes": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?attributes"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "ObjectAttributes"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "MaxParts": {
            "location": "header",
            "locationName": "x-amz-max-parts",
            "type": "integer"
          },
          "PartNumberMarker": {
            "location": "header",
            "locationName": "x-amz-part-number-marker",
            "type": "integer"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ObjectAttributes": {
            "location": "header",
            "locationName": "x-amz-object-attributes",
            "type": "list",
            "member": {}
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ETag": {},
          "Checksum": {
            "type": "structure",
            "members": {
              "ChecksumCRC32": {},
              "ChecksumCRC32C": {},
              "ChecksumSHA1": {},
              "ChecksumSHA256": {}
            }
          },
          "ObjectParts": {
            "type": "structure",
            "members": {
              "TotalPartsCount": {
                "locationName": "PartsCount",
                "type": "integer"
              },
              "PartNumberMarker": {
                "type": "integer"
              },
              "NextPartNumberMarker": {
                "type": "integer"
              },
              "MaxParts": {
                "type": "integer"
              },
              "IsTruncated": {
                "type": "boolean"
              },
              "Parts": {
                "locationName": "Part",
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "PartNumber": {
                      "type": "integer"
                    },
                    "Size": {
                      "type": "integer"
                    },
                    "ChecksumCRC32": {},
                    "ChecksumCRC32C": {},
                    "ChecksumSHA1": {},
                    "ChecksumSHA256": {}
                  }
                },
                "flattened": true
              }
            }
          },
          "StorageClass": {},
          "ObjectSize": {
            "type": "long"
          }
        }
      }
    },
    "GetObjectLegalHold": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?legal-hold"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "LegalHold": {
            "shape": "Sa9"
          }
        },
        "payload": "LegalHold"
      }
    },
    "GetObjectLockConfiguration": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?object-lock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ObjectLockConfiguration": {
            "shape": "Sac"
          }
        },
        "payload": "ObjectLockConfiguration"
      }
    },
    "GetObjectRetention": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?retention"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Retention": {
            "shape": "Sak"
          }
        },
        "payload": "Retention"
      }
    },
    "GetObjectTagging": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        }
      },
      "output": {
        "type": "structure",
        "required": [
          "TagSet"
        ],
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "TagSet": {
            "shape": "S3v"
          }
        }
      }
    },
    "GetObjectTorrent": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}?torrent"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "Body"
      }
    },
    "GetPublicAccessBlock": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?publicAccessBlock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "PublicAccessBlockConfiguration": {
            "shape": "Sar"
          }
        },
        "payload": "PublicAccessBlockConfiguration"
      }
    },
    "HeadBucket": {
      "http": {
        "method": "HEAD",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      }
    },
    "HeadObject": {
      "http": {
        "method": "HEAD",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "IfMatch": {
            "location": "header",
            "locationName": "If-Match"
          },
          "IfModifiedSince": {
            "location": "header",
            "locationName": "If-Modified-Since",
            "type": "timestamp"
          },
          "IfNoneMatch": {
            "location": "header",
            "locationName": "If-None-Match"
          },
          "IfUnmodifiedSince": {
            "location": "header",
            "locationName": "If-Unmodified-Since",
            "type": "timestamp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Range": {
            "location": "header",
            "locationName": "Range"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ChecksumMode": {
            "location": "header",
            "locationName": "x-amz-checksum-mode"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-delete-marker",
            "type": "boolean"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "accept-ranges"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-restore"
          },
          "ArchiveStatus": {
            "location": "header",
            "locationName": "x-amz-archive-status"
          },
          "LastModified": {
            "location": "header",
            "locationName": "Last-Modified",
            "type": "timestamp"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-missing-meta",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "Metadata": {
            "shape": "S1b",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-replication-status"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-mp-parts-count",
            "type": "integer"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1o",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          }
        }
      }
    },
    "ListBucketAnalyticsConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "AnalyticsConfigurationList": {
            "locationName": "AnalyticsConfiguration",
            "type": "list",
            "member": {
              "shape": "S3p"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBucketIntelligentTieringConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?intelligent-tiering"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "IntelligentTieringConfigurationList": {
            "locationName": "IntelligentTieringConfiguration",
            "type": "list",
            "member": {
              "shape": "S4n"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBucketInventoryConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "ContinuationToken": {},
          "InventoryConfigurationList": {
            "locationName": "InventoryConfiguration",
            "type": "list",
            "member": {
              "shape": "S4x"
            },
            "flattened": true
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "NextContinuationToken": {}
        }
      }
    },
    "ListBucketMetricsConfigurations": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "MetricsConfigurationList": {
            "locationName": "MetricsConfiguration",
            "type": "list",
            "member": {
              "shape": "S6d"
            },
            "flattened": true
          }
        }
      }
    },
    "ListBuckets": {
      "http": {
        "method": "GET"
      },
      "output": {
        "type": "structure",
        "members": {
          "Buckets": {
            "type": "list",
            "member": {
              "locationName": "Bucket",
              "type": "structure",
              "members": {
                "Name": {},
                "CreationDate": {
                  "type": "timestamp"
                }
              }
            }
          },
          "Owner": {
            "shape": "S3d"
          }
        }
      },
      "alias": "GetService"
    },
    "ListMultipartUploads": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?uploads"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "KeyMarker": {
            "location": "querystring",
            "locationName": "key-marker"
          },
          "MaxUploads": {
            "location": "querystring",
            "locationName": "max-uploads",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "UploadIdMarker": {
            "location": "querystring",
            "locationName": "upload-id-marker"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Bucket": {},
          "KeyMarker": {},
          "UploadIdMarker": {},
          "NextKeyMarker": {},
          "Prefix": {},
          "Delimiter": {},
          "NextUploadIdMarker": {},
          "MaxUploads": {
            "type": "integer"
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "Uploads": {
            "locationName": "Upload",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "UploadId": {},
                "Key": {},
                "Initiated": {
                  "type": "timestamp"
                },
                "StorageClass": {},
                "Owner": {
                  "shape": "S3d"
                },
                "Initiator": {
                  "shape": "Sbr"
                },
                "ChecksumAlgorithm": {}
              }
            },
            "flattened": true
          },
          "CommonPrefixes": {
            "shape": "Sbs"
          },
          "EncodingType": {}
        }
      }
    },
    "ListObjectVersions": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?versions"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "KeyMarker": {
            "location": "querystring",
            "locationName": "key-marker"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "VersionIdMarker": {
            "location": "querystring",
            "locationName": "version-id-marker"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "KeyMarker": {},
          "VersionIdMarker": {},
          "NextKeyMarker": {},
          "NextVersionIdMarker": {},
          "Versions": {
            "locationName": "Version",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "ETag": {},
                "ChecksumAlgorithm": {
                  "shape": "Sc1"
                },
                "Size": {
                  "type": "integer"
                },
                "StorageClass": {},
                "Key": {},
                "VersionId": {},
                "IsLatest": {
                  "type": "boolean"
                },
                "LastModified": {
                  "type": "timestamp"
                },
                "Owner": {
                  "shape": "S3d"
                }
              }
            },
            "flattened": true
          },
          "DeleteMarkers": {
            "locationName": "DeleteMarker",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "Owner": {
                  "shape": "S3d"
                },
                "Key": {},
                "VersionId": {},
                "IsLatest": {
                  "type": "boolean"
                },
                "LastModified": {
                  "type": "timestamp"
                }
              }
            },
            "flattened": true
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sbs"
          },
          "EncodingType": {}
        }
      },
      "alias": "GetBucketObjectVersions"
    },
    "ListObjects": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "Marker": {
            "location": "querystring",
            "locationName": "marker"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "Marker": {},
          "NextMarker": {},
          "Contents": {
            "shape": "Sca"
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sbs"
          },
          "EncodingType": {}
        }
      },
      "alias": "GetBucket"
    },
    "ListObjectsV2": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}?list-type=2"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Delimiter": {
            "location": "querystring",
            "locationName": "delimiter"
          },
          "EncodingType": {
            "location": "querystring",
            "locationName": "encoding-type"
          },
          "MaxKeys": {
            "location": "querystring",
            "locationName": "max-keys",
            "type": "integer"
          },
          "Prefix": {
            "location": "querystring",
            "locationName": "prefix"
          },
          "ContinuationToken": {
            "location": "querystring",
            "locationName": "continuation-token"
          },
          "FetchOwner": {
            "location": "querystring",
            "locationName": "fetch-owner",
            "type": "boolean"
          },
          "StartAfter": {
            "location": "querystring",
            "locationName": "start-after"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "IsTruncated": {
            "type": "boolean"
          },
          "Contents": {
            "shape": "Sca"
          },
          "Name": {},
          "Prefix": {},
          "Delimiter": {},
          "MaxKeys": {
            "type": "integer"
          },
          "CommonPrefixes": {
            "shape": "Sbs"
          },
          "EncodingType": {},
          "KeyCount": {
            "type": "integer"
          },
          "ContinuationToken": {},
          "NextContinuationToken": {},
          "StartAfter": {}
        }
      }
    },
    "ListParts": {
      "http": {
        "method": "GET",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "MaxParts": {
            "location": "querystring",
            "locationName": "max-parts",
            "type": "integer"
          },
          "PartNumberMarker": {
            "location": "querystring",
            "locationName": "part-number-marker",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "AbortDate": {
            "location": "header",
            "locationName": "x-amz-abort-date",
            "type": "timestamp"
          },
          "AbortRuleId": {
            "location": "header",
            "locationName": "x-amz-abort-rule-id"
          },
          "Bucket": {},
          "Key": {},
          "UploadId": {},
          "PartNumberMarker": {
            "type": "integer"
          },
          "NextPartNumberMarker": {
            "type": "integer"
          },
          "MaxParts": {
            "type": "integer"
          },
          "IsTruncated": {
            "type": "boolean"
          },
          "Parts": {
            "locationName": "Part",
            "type": "list",
            "member": {
              "type": "structure",
              "members": {
                "PartNumber": {
                  "type": "integer"
                },
                "LastModified": {
                  "type": "timestamp"
                },
                "ETag": {},
                "Size": {
                  "type": "integer"
                },
                "ChecksumCRC32": {},
                "ChecksumCRC32C": {},
                "ChecksumSHA1": {},
                "ChecksumSHA256": {}
              }
            },
            "flattened": true
          },
          "Initiator": {
            "shape": "Sbr"
          },
          "Owner": {
            "shape": "S3d"
          },
          "StorageClass": {},
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "ChecksumAlgorithm": {}
        }
      }
    },
    "PutBucketAccelerateConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?accelerate"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "AccelerateConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "AccelerateConfiguration": {
            "locationName": "AccelerateConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Status": {}
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          }
        },
        "payload": "AccelerateConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": false
      }
    },
    "PutBucketAcl": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "AccessControlPolicy": {
            "shape": "Scp",
            "locationName": "AccessControlPolicy",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "AccessControlPolicy"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketAnalyticsConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?analytics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "AnalyticsConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "AnalyticsConfiguration": {
            "shape": "S3p",
            "locationName": "AnalyticsConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "AnalyticsConfiguration"
      }
    },
    "PutBucketCors": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?cors"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CORSConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CORSConfiguration": {
            "locationName": "CORSConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "CORSRules"
            ],
            "members": {
              "CORSRules": {
                "shape": "S44",
                "locationName": "CORSRule"
              }
            }
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "CORSConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketEncryption": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?encryption"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "ServerSideEncryptionConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ServerSideEncryptionConfiguration": {
            "shape": "S4h",
            "locationName": "ServerSideEncryptionConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "ServerSideEncryptionConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketIntelligentTieringConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?intelligent-tiering"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "IntelligentTieringConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "IntelligentTieringConfiguration": {
            "shape": "S4n",
            "locationName": "IntelligentTieringConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "IntelligentTieringConfiguration"
      }
    },
    "PutBucketInventoryConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?inventory"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "InventoryConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "InventoryConfiguration": {
            "shape": "S4x",
            "locationName": "InventoryConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "InventoryConfiguration"
      }
    },
    "PutBucketLifecycle": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "LifecycleConfiguration": {
            "locationName": "LifecycleConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "shape": "S5d",
                "locationName": "Rule"
              }
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "LifecycleConfiguration"
      },
      "deprecated": true,
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketLifecycleConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?lifecycle"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "LifecycleConfiguration": {
            "locationName": "LifecycleConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Rules"
            ],
            "members": {
              "Rules": {
                "shape": "S5t",
                "locationName": "Rule"
              }
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "LifecycleConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketLogging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?logging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "BucketLoggingStatus"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "BucketLoggingStatus": {
            "locationName": "BucketLoggingStatus",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "LoggingEnabled": {
                "shape": "S65"
              }
            }
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "BucketLoggingStatus"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketMetricsConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?metrics"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Id",
          "MetricsConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Id": {
            "location": "querystring",
            "locationName": "id"
          },
          "MetricsConfiguration": {
            "shape": "S6d",
            "locationName": "MetricsConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "MetricsConfiguration"
      }
    },
    "PutBucketNotification": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "NotificationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "NotificationConfiguration": {
            "shape": "S6i",
            "locationName": "NotificationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "NotificationConfiguration"
      },
      "deprecated": true,
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketNotificationConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?notification"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "NotificationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "NotificationConfiguration": {
            "shape": "S6t",
            "locationName": "NotificationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "SkipDestinationValidation": {
            "location": "header",
            "locationName": "x-amz-skip-destination-validation",
            "type": "boolean"
          }
        },
        "payload": "NotificationConfiguration"
      }
    },
    "PutBucketOwnershipControls": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?ownershipControls"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "OwnershipControls"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "OwnershipControls": {
            "shape": "S7a",
            "locationName": "OwnershipControls",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          }
        },
        "payload": "OwnershipControls"
      },
      "httpChecksum": {
        "requestChecksumRequired": true
      }
    },
    "PutBucketPolicy": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?policy"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Policy"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ConfirmRemoveSelfBucketAccess": {
            "location": "header",
            "locationName": "x-amz-confirm-remove-self-bucket-access",
            "type": "boolean"
          },
          "Policy": {},
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "Policy"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketReplication": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?replication"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "ReplicationConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ReplicationConfiguration": {
            "shape": "S7m",
            "locationName": "ReplicationConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Token": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-token"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "ReplicationConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketRequestPayment": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?requestPayment"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "RequestPaymentConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "RequestPaymentConfiguration": {
            "locationName": "RequestPaymentConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "required": [
              "Payer"
            ],
            "members": {
              "Payer": {}
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "RequestPaymentConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketTagging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Tagging"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "Tagging": {
            "shape": "Sdf",
            "locationName": "Tagging",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "Tagging"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketVersioning": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?versioning"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "VersioningConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "MFA": {
            "location": "header",
            "locationName": "x-amz-mfa"
          },
          "VersioningConfiguration": {
            "locationName": "VersioningConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "MFADelete": {
                "locationName": "MfaDelete"
              },
              "Status": {}
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "VersioningConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutBucketWebsite": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?website"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "WebsiteConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "WebsiteConfiguration": {
            "locationName": "WebsiteConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "ErrorDocument": {
                "shape": "S8u"
              },
              "IndexDocument": {
                "shape": "S8s"
              },
              "RedirectAllRequestsTo": {
                "shape": "S8p"
              },
              "RoutingRules": {
                "shape": "S8v"
              }
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "WebsiteConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutObject": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "Content-Language"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ContentType": {
            "location": "header",
            "locationName": "Content-Type"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "Expires": {
            "location": "header",
            "locationName": "Expires",
            "type": "timestamp"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Metadata": {
            "shape": "S1b",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-storage-class"
          },
          "WebsiteRedirectLocation": {
            "location": "header",
            "locationName": "x-amz-website-redirect-location"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1i",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Tagging": {
            "location": "header",
            "locationName": "x-amz-tagging"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-object-lock-mode"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1o",
            "location": "header",
            "locationName": "x-amz-object-lock-retain-until-date"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-object-lock-legal-hold"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "Body"
      },
      "output": {
        "type": "structure",
        "members": {
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-expiration"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSEKMSEncryptionContext": {
            "shape": "S1i",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-context"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": false
      }
    },
    "PutObjectAcl": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?acl"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "ACL": {
            "location": "header",
            "locationName": "x-amz-acl"
          },
          "AccessControlPolicy": {
            "shape": "Scp",
            "locationName": "AccessControlPolicy",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "GrantFullControl": {
            "location": "header",
            "locationName": "x-amz-grant-full-control"
          },
          "GrantRead": {
            "location": "header",
            "locationName": "x-amz-grant-read"
          },
          "GrantReadACP": {
            "location": "header",
            "locationName": "x-amz-grant-read-acp"
          },
          "GrantWrite": {
            "location": "header",
            "locationName": "x-amz-grant-write"
          },
          "GrantWriteACP": {
            "location": "header",
            "locationName": "x-amz-grant-write-acp"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "AccessControlPolicy"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutObjectLegalHold": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?legal-hold"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "LegalHold": {
            "shape": "Sa9",
            "locationName": "LegalHold",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "LegalHold"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutObjectLockConfiguration": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?object-lock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ObjectLockConfiguration": {
            "shape": "Sac",
            "locationName": "ObjectLockConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "Token": {
            "location": "header",
            "locationName": "x-amz-bucket-object-lock-token"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "ObjectLockConfiguration"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutObjectRetention": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?retention"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "Retention": {
            "shape": "Sak",
            "locationName": "Retention",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "BypassGovernanceRetention": {
            "location": "header",
            "locationName": "x-amz-bypass-governance-retention",
            "type": "boolean"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "Retention"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutObjectTagging": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}?tagging"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "Tagging"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "Tagging": {
            "shape": "Sdf",
            "locationName": "Tagging",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          }
        },
        "payload": "Tagging"
      },
      "output": {
        "type": "structure",
        "members": {
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-version-id"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "PutPublicAccessBlock": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}?publicAccessBlock"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "PublicAccessBlockConfiguration"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "PublicAccessBlockConfiguration": {
            "shape": "Sar",
            "locationName": "PublicAccessBlockConfiguration",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "PublicAccessBlockConfiguration"
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": true
      }
    },
    "RestoreObject": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?restore"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "VersionId": {
            "location": "querystring",
            "locationName": "versionId"
          },
          "RestoreRequest": {
            "locationName": "RestoreRequest",
            "xmlNamespace": {
              "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            "type": "structure",
            "members": {
              "Days": {
                "type": "integer"
              },
              "GlacierJobParameters": {
                "type": "structure",
                "required": [
                  "Tier"
                ],
                "members": {
                  "Tier": {}
                }
              },
              "Type": {},
              "Tier": {},
              "Description": {},
              "SelectParameters": {
                "type": "structure",
                "required": [
                  "InputSerialization",
                  "ExpressionType",
                  "Expression",
                  "OutputSerialization"
                ],
                "members": {
                  "InputSerialization": {
                    "shape": "Se5"
                  },
                  "ExpressionType": {},
                  "Expression": {},
                  "OutputSerialization": {
                    "shape": "Sek"
                  }
                }
              },
              "OutputLocation": {
                "type": "structure",
                "members": {
                  "S3": {
                    "type": "structure",
                    "required": [
                      "BucketName",
                      "Prefix"
                    ],
                    "members": {
                      "BucketName": {},
                      "Prefix": {},
                      "Encryption": {
                        "type": "structure",
                        "required": [
                          "EncryptionType"
                        ],
                        "members": {
                          "EncryptionType": {},
                          "KMSKeyId": {
                            "shape": "Sr"
                          },
                          "KMSContext": {}
                        }
                      },
                      "CannedACL": {},
                      "AccessControlList": {
                        "shape": "S3g"
                      },
                      "Tagging": {
                        "shape": "Sdf"
                      },
                      "UserMetadata": {
                        "type": "list",
                        "member": {
                          "locationName": "MetadataEntry",
                          "type": "structure",
                          "members": {
                            "Name": {},
                            "Value": {}
                          }
                        }
                      },
                      "StorageClass": {}
                    }
                  }
                }
              }
            }
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "RestoreRequest"
      },
      "output": {
        "type": "structure",
        "members": {
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          },
          "RestoreOutputPath": {
            "location": "header",
            "locationName": "x-amz-restore-output-path"
          }
        }
      },
      "alias": "PostObjectRestore",
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": false
      }
    },
    "SelectObjectContent": {
      "http": {
        "requestUri": "/{Bucket}/{Key+}?select&select-type=2"
      },
      "input": {
        "locationName": "SelectObjectContentRequest",
        "xmlNamespace": {
          "uri": "http://s3.amazonaws.com/doc/2006-03-01/"
        },
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "Expression",
          "ExpressionType",
          "InputSerialization",
          "OutputSerialization"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "Expression": {},
          "ExpressionType": {},
          "RequestProgress": {
            "type": "structure",
            "members": {
              "Enabled": {
                "type": "boolean"
              }
            }
          },
          "InputSerialization": {
            "shape": "Se5"
          },
          "OutputSerialization": {
            "shape": "Sek"
          },
          "ScanRange": {
            "type": "structure",
            "members": {
              "Start": {
                "type": "long"
              },
              "End": {
                "type": "long"
              }
            }
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "Payload": {
            "type": "structure",
            "members": {
              "Records": {
                "type": "structure",
                "members": {
                  "Payload": {
                    "eventpayload": true,
                    "type": "blob"
                  }
                },
                "event": true
              },
              "Stats": {
                "type": "structure",
                "members": {
                  "Details": {
                    "eventpayload": true,
                    "type": "structure",
                    "members": {
                      "BytesScanned": {
                        "type": "long"
                      },
                      "BytesProcessed": {
                        "type": "long"
                      },
                      "BytesReturned": {
                        "type": "long"
                      }
                    }
                  }
                },
                "event": true
              },
              "Progress": {
                "type": "structure",
                "members": {
                  "Details": {
                    "eventpayload": true,
                    "type": "structure",
                    "members": {
                      "BytesScanned": {
                        "type": "long"
                      },
                      "BytesProcessed": {
                        "type": "long"
                      },
                      "BytesReturned": {
                        "type": "long"
                      }
                    }
                  }
                },
                "event": true
              },
              "Cont": {
                "type": "structure",
                "members": {},
                "event": true
              },
              "End": {
                "type": "structure",
                "members": {},
                "event": true
              }
            },
            "eventstream": true
          }
        },
        "payload": "Payload"
      }
    },
    "UploadPart": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "Key",
          "PartNumber",
          "UploadId"
        ],
        "members": {
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentMD5": {
            "location": "header",
            "locationName": "Content-MD5"
          },
          "ChecksumAlgorithm": {
            "location": "header",
            "locationName": "x-amz-sdk-checksum-algorithm"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          }
        },
        "payload": "Body"
      },
      "output": {
        "type": "structure",
        "members": {
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "ETag": {
            "location": "header",
            "locationName": "ETag"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-checksum-sha256"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        }
      },
      "httpChecksum": {
        "requestAlgorithmMember": "ChecksumAlgorithm",
        "requestChecksumRequired": false
      }
    },
    "UploadPartCopy": {
      "http": {
        "method": "PUT",
        "requestUri": "/{Bucket}/{Key+}"
      },
      "input": {
        "type": "structure",
        "required": [
          "Bucket",
          "CopySource",
          "Key",
          "PartNumber",
          "UploadId"
        ],
        "members": {
          "Bucket": {
            "location": "uri",
            "locationName": "Bucket"
          },
          "CopySource": {
            "location": "header",
            "locationName": "x-amz-copy-source"
          },
          "CopySourceIfMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-match"
          },
          "CopySourceIfModifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-modified-since",
            "type": "timestamp"
          },
          "CopySourceIfNoneMatch": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-none-match"
          },
          "CopySourceIfUnmodifiedSince": {
            "location": "header",
            "locationName": "x-amz-copy-source-if-unmodified-since",
            "type": "timestamp"
          },
          "CopySourceRange": {
            "location": "header",
            "locationName": "x-amz-copy-source-range"
          },
          "Key": {
            "location": "uri",
            "locationName": "Key"
          },
          "PartNumber": {
            "location": "querystring",
            "locationName": "partNumber",
            "type": "integer"
          },
          "UploadId": {
            "location": "querystring",
            "locationName": "uploadId"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKey": {
            "shape": "Sk",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "CopySourceSSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-algorithm"
          },
          "CopySourceSSECustomerKey": {
            "shape": "S1k",
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key"
          },
          "CopySourceSSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-copy-source-server-side-encryption-customer-key-MD5"
          },
          "RequestPayer": {
            "location": "header",
            "locationName": "x-amz-request-payer"
          },
          "ExpectedBucketOwner": {
            "location": "header",
            "locationName": "x-amz-expected-bucket-owner"
          },
          "ExpectedSourceBucketOwner": {
            "location": "header",
            "locationName": "x-amz-source-expected-bucket-owner"
          }
        }
      },
      "output": {
        "type": "structure",
        "members": {
          "CopySourceVersionId": {
            "location": "header",
            "locationName": "x-amz-copy-source-version-id"
          },
          "CopyPartResult": {
            "type": "structure",
            "members": {
              "ETag": {},
              "LastModified": {
                "type": "timestamp"
              },
              "ChecksumCRC32": {},
              "ChecksumCRC32C": {},
              "ChecksumSHA1": {},
              "ChecksumSHA256": {}
            }
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-algorithm"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-customer-key-MD5"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-server-side-encryption-aws-kms-key-id"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-request-charged"
          }
        },
        "payload": "CopyPartResult"
      }
    },
    "WriteGetObjectResponse": {
      "http": {
        "requestUri": "/WriteGetObjectResponse"
      },
      "input": {
        "type": "structure",
        "required": [
          "RequestRoute",
          "RequestToken"
        ],
        "members": {
          "RequestRoute": {
            "hostLabel": true,
            "location": "header",
            "locationName": "x-amz-request-route"
          },
          "RequestToken": {
            "location": "header",
            "locationName": "x-amz-request-token"
          },
          "Body": {
            "streaming": true,
            "type": "blob"
          },
          "StatusCode": {
            "location": "header",
            "locationName": "x-amz-fwd-status",
            "type": "integer"
          },
          "ErrorCode": {
            "location": "header",
            "locationName": "x-amz-fwd-error-code"
          },
          "ErrorMessage": {
            "location": "header",
            "locationName": "x-amz-fwd-error-message"
          },
          "AcceptRanges": {
            "location": "header",
            "locationName": "x-amz-fwd-header-accept-ranges"
          },
          "CacheControl": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Cache-Control"
          },
          "ContentDisposition": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Content-Disposition"
          },
          "ContentEncoding": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Content-Encoding"
          },
          "ContentLanguage": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Content-Language"
          },
          "ContentLength": {
            "location": "header",
            "locationName": "Content-Length",
            "type": "long"
          },
          "ContentRange": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Content-Range"
          },
          "ContentType": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Content-Type"
          },
          "ChecksumCRC32": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-checksum-crc32"
          },
          "ChecksumCRC32C": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-checksum-crc32c"
          },
          "ChecksumSHA1": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-checksum-sha1"
          },
          "ChecksumSHA256": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-checksum-sha256"
          },
          "DeleteMarker": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-delete-marker",
            "type": "boolean"
          },
          "ETag": {
            "location": "header",
            "locationName": "x-amz-fwd-header-ETag"
          },
          "Expires": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Expires",
            "type": "timestamp"
          },
          "Expiration": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-expiration"
          },
          "LastModified": {
            "location": "header",
            "locationName": "x-amz-fwd-header-Last-Modified",
            "type": "timestamp"
          },
          "MissingMeta": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-missing-meta",
            "type": "integer"
          },
          "Metadata": {
            "shape": "S1b",
            "location": "headers",
            "locationName": "x-amz-meta-"
          },
          "ObjectLockMode": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-object-lock-mode"
          },
          "ObjectLockLegalHoldStatus": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-object-lock-legal-hold"
          },
          "ObjectLockRetainUntilDate": {
            "shape": "S1o",
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-object-lock-retain-until-date"
          },
          "PartsCount": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-mp-parts-count",
            "type": "integer"
          },
          "ReplicationStatus": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-replication-status"
          },
          "RequestCharged": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-request-charged"
          },
          "Restore": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-restore"
          },
          "ServerSideEncryption": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-server-side-encryption"
          },
          "SSECustomerAlgorithm": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm"
          },
          "SSEKMSKeyId": {
            "shape": "Sr",
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id"
          },
          "SSECustomerKeyMD5": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5"
          },
          "StorageClass": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-storage-class"
          },
          "TagCount": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-tagging-count",
            "type": "integer"
          },
          "VersionId": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-version-id"
          },
          "BucketKeyEnabled": {
            "location": "header",
            "locationName": "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled",
            "type": "boolean"
          }
        },
        "payload": "Body"
      },
      "authtype": "v4-unsigned-body",
      "endpoint": {
        "hostPrefix": "{RequestRoute}."
      }
    }
  },
  "shapes": {
    "Sk": {
      "type": "blob",
      "sensitive": true
    },
    "Sr": {
      "type": "string",
      "sensitive": true
    },
    "S1b": {
      "type": "map",
      "key": {},
      "value": {}
    },
    "S1i": {
      "type": "string",
      "sensitive": true
    },
    "S1k": {
      "type": "blob",
      "sensitive": true
    },
    "S1o": {
      "type": "timestamp",
      "timestampFormat": "iso8601"
    },
    "S3d": {
      "type": "structure",
      "members": {
        "DisplayName": {},
        "ID": {}
      }
    },
    "S3g": {
      "type": "list",
      "member": {
        "locationName": "Grant",
        "type": "structure",
        "members": {
          "Grantee": {
            "shape": "S3i"
          },
          "Permission": {}
        }
      }
    },
    "S3i": {
      "type": "structure",
      "required": [
        "Type"
      ],
      "members": {
        "DisplayName": {},
        "EmailAddress": {},
        "ID": {},
        "Type": {
          "locationName": "xsi:type",
          "xmlAttribute": true
        },
        "URI": {}
      },
      "xmlNamespace": {
        "prefix": "xsi",
        "uri": "http://www.w3.org/2001/XMLSchema-instance"
      }
    },
    "S3p": {
      "type": "structure",
      "required": [
        "Id",
        "StorageClassAnalysis"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3s"
            },
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3v",
                  "flattened": true,
                  "locationName": "Tag"
                }
              }
            }
          }
        },
        "StorageClassAnalysis": {
          "type": "structure",
          "members": {
            "DataExport": {
              "type": "structure",
              "required": [
                "OutputSchemaVersion",
                "Destination"
              ],
              "members": {
                "OutputSchemaVersion": {},
                "Destination": {
                  "type": "structure",
                  "required": [
                    "S3BucketDestination"
                  ],
                  "members": {
                    "S3BucketDestination": {
                      "type": "structure",
                      "required": [
                        "Format",
                        "Bucket"
                      ],
                      "members": {
                        "Format": {},
                        "BucketAccountId": {},
                        "Bucket": {},
                        "Prefix": {}
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "S3s": {
      "type": "structure",
      "required": [
        "Key",
        "Value"
      ],
      "members": {
        "Key": {},
        "Value": {}
      }
    },
    "S3v": {
      "type": "list",
      "member": {
        "shape": "S3s",
        "locationName": "Tag"
      }
    },
    "S44": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "AllowedMethods",
          "AllowedOrigins"
        ],
        "members": {
          "ID": {},
          "AllowedHeaders": {
            "locationName": "AllowedHeader",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "AllowedMethods": {
            "locationName": "AllowedMethod",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "AllowedOrigins": {
            "locationName": "AllowedOrigin",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "ExposeHeaders": {
            "locationName": "ExposeHeader",
            "type": "list",
            "member": {},
            "flattened": true
          },
          "MaxAgeSeconds": {
            "type": "integer"
          }
        }
      },
      "flattened": true
    },
    "S4h": {
      "type": "structure",
      "required": [
        "Rules"
      ],
      "members": {
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "members": {
              "ApplyServerSideEncryptionByDefault": {
                "type": "structure",
                "required": [
                  "SSEAlgorithm"
                ],
                "members": {
                  "SSEAlgorithm": {},
                  "KMSMasterKeyID": {
                    "shape": "Sr"
                  }
                }
              },
              "BucketKeyEnabled": {
                "type": "boolean"
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S4n": {
      "type": "structure",
      "required": [
        "Id",
        "Status",
        "Tierings"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3s"
            },
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3v",
                  "flattened": true,
                  "locationName": "Tag"
                }
              }
            }
          }
        },
        "Status": {},
        "Tierings": {
          "locationName": "Tiering",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "Days",
              "AccessTier"
            ],
            "members": {
              "Days": {
                "type": "integer"
              },
              "AccessTier": {}
            }
          },
          "flattened": true
        }
      }
    },
    "S4x": {
      "type": "structure",
      "required": [
        "Destination",
        "IsEnabled",
        "Id",
        "IncludedObjectVersions",
        "Schedule"
      ],
      "members": {
        "Destination": {
          "type": "structure",
          "required": [
            "S3BucketDestination"
          ],
          "members": {
            "S3BucketDestination": {
              "type": "structure",
              "required": [
                "Bucket",
                "Format"
              ],
              "members": {
                "AccountId": {},
                "Bucket": {},
                "Format": {},
                "Prefix": {},
                "Encryption": {
                  "type": "structure",
                  "members": {
                    "SSES3": {
                      "locationName": "SSE-S3",
                      "type": "structure",
                      "members": {}
                    },
                    "SSEKMS": {
                      "locationName": "SSE-KMS",
                      "type": "structure",
                      "required": [
                        "KeyId"
                      ],
                      "members": {
                        "KeyId": {
                          "shape": "Sr"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "IsEnabled": {
          "type": "boolean"
        },
        "Filter": {
          "type": "structure",
          "required": [
            "Prefix"
          ],
          "members": {
            "Prefix": {}
          }
        },
        "Id": {},
        "IncludedObjectVersions": {},
        "OptionalFields": {
          "type": "list",
          "member": {
            "locationName": "Field"
          }
        },
        "Schedule": {
          "type": "structure",
          "required": [
            "Frequency"
          ],
          "members": {
            "Frequency": {}
          }
        }
      }
    },
    "S5d": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Prefix",
          "Status"
        ],
        "members": {
          "Expiration": {
            "shape": "S5f"
          },
          "ID": {},
          "Prefix": {},
          "Status": {},
          "Transition": {
            "shape": "S5k"
          },
          "NoncurrentVersionTransition": {
            "shape": "S5m"
          },
          "NoncurrentVersionExpiration": {
            "shape": "S5o"
          },
          "AbortIncompleteMultipartUpload": {
            "shape": "S5p"
          }
        }
      },
      "flattened": true
    },
    "S5f": {
      "type": "structure",
      "members": {
        "Date": {
          "shape": "S5g"
        },
        "Days": {
          "type": "integer"
        },
        "ExpiredObjectDeleteMarker": {
          "type": "boolean"
        }
      }
    },
    "S5g": {
      "type": "timestamp",
      "timestampFormat": "iso8601"
    },
    "S5k": {
      "type": "structure",
      "members": {
        "Date": {
          "shape": "S5g"
        },
        "Days": {
          "type": "integer"
        },
        "StorageClass": {}
      }
    },
    "S5m": {
      "type": "structure",
      "members": {
        "NoncurrentDays": {
          "type": "integer"
        },
        "StorageClass": {},
        "NewerNoncurrentVersions": {
          "type": "integer"
        }
      }
    },
    "S5o": {
      "type": "structure",
      "members": {
        "NoncurrentDays": {
          "type": "integer"
        },
        "NewerNoncurrentVersions": {
          "type": "integer"
        }
      }
    },
    "S5p": {
      "type": "structure",
      "members": {
        "DaysAfterInitiation": {
          "type": "integer"
        }
      }
    },
    "S5t": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Status"
        ],
        "members": {
          "Expiration": {
            "shape": "S5f"
          },
          "ID": {},
          "Prefix": {
            "deprecated": true
          },
          "Filter": {
            "type": "structure",
            "members": {
              "Prefix": {},
              "Tag": {
                "shape": "S3s"
              },
              "ObjectSizeGreaterThan": {
                "type": "long"
              },
              "ObjectSizeLessThan": {
                "type": "long"
              },
              "And": {
                "type": "structure",
                "members": {
                  "Prefix": {},
                  "Tags": {
                    "shape": "S3v",
                    "flattened": true,
                    "locationName": "Tag"
                  },
                  "ObjectSizeGreaterThan": {
                    "type": "long"
                  },
                  "ObjectSizeLessThan": {
                    "type": "long"
                  }
                }
              }
            }
          },
          "Status": {},
          "Transitions": {
            "locationName": "Transition",
            "type": "list",
            "member": {
              "shape": "S5k"
            },
            "flattened": true
          },
          "NoncurrentVersionTransitions": {
            "locationName": "NoncurrentVersionTransition",
            "type": "list",
            "member": {
              "shape": "S5m"
            },
            "flattened": true
          },
          "NoncurrentVersionExpiration": {
            "shape": "S5o"
          },
          "AbortIncompleteMultipartUpload": {
            "shape": "S5p"
          }
        }
      },
      "flattened": true
    },
    "S65": {
      "type": "structure",
      "required": [
        "TargetBucket",
        "TargetPrefix"
      ],
      "members": {
        "TargetBucket": {},
        "TargetGrants": {
          "type": "list",
          "member": {
            "locationName": "Grant",
            "type": "structure",
            "members": {
              "Grantee": {
                "shape": "S3i"
              },
              "Permission": {}
            }
          }
        },
        "TargetPrefix": {}
      }
    },
    "S6d": {
      "type": "structure",
      "required": [
        "Id"
      ],
      "members": {
        "Id": {},
        "Filter": {
          "type": "structure",
          "members": {
            "Prefix": {},
            "Tag": {
              "shape": "S3s"
            },
            "AccessPointArn": {},
            "And": {
              "type": "structure",
              "members": {
                "Prefix": {},
                "Tags": {
                  "shape": "S3v",
                  "flattened": true,
                  "locationName": "Tag"
                },
                "AccessPointArn": {}
              }
            }
          }
        }
      }
    },
    "S6h": {
      "type": "structure",
      "required": [
        "Bucket"
      ],
      "members": {
        "Bucket": {
          "location": "uri",
          "locationName": "Bucket"
        },
        "ExpectedBucketOwner": {
          "location": "header",
          "locationName": "x-amz-expected-bucket-owner"
        }
      }
    },
    "S6i": {
      "type": "structure",
      "members": {
        "TopicConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Events": {
              "shape": "S6l",
              "locationName": "Event"
            },
            "Event": {
              "deprecated": true
            },
            "Topic": {}
          }
        },
        "QueueConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Event": {
              "deprecated": true
            },
            "Events": {
              "shape": "S6l",
              "locationName": "Event"
            },
            "Queue": {}
          }
        },
        "CloudFunctionConfiguration": {
          "type": "structure",
          "members": {
            "Id": {},
            "Event": {
              "deprecated": true
            },
            "Events": {
              "shape": "S6l",
              "locationName": "Event"
            },
            "CloudFunction": {},
            "InvocationRole": {}
          }
        }
      }
    },
    "S6l": {
      "type": "list",
      "member": {},
      "flattened": true
    },
    "S6t": {
      "type": "structure",
      "members": {
        "TopicConfigurations": {
          "locationName": "TopicConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "TopicArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "TopicArn": {
                "locationName": "Topic"
              },
              "Events": {
                "shape": "S6l",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S6w"
              }
            }
          },
          "flattened": true
        },
        "QueueConfigurations": {
          "locationName": "QueueConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "QueueArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "QueueArn": {
                "locationName": "Queue"
              },
              "Events": {
                "shape": "S6l",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S6w"
              }
            }
          },
          "flattened": true
        },
        "LambdaFunctionConfigurations": {
          "locationName": "CloudFunctionConfiguration",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "LambdaFunctionArn",
              "Events"
            ],
            "members": {
              "Id": {},
              "LambdaFunctionArn": {
                "locationName": "CloudFunction"
              },
              "Events": {
                "shape": "S6l",
                "locationName": "Event"
              },
              "Filter": {
                "shape": "S6w"
              }
            }
          },
          "flattened": true
        },
        "EventBridgeConfiguration": {
          "type": "structure",
          "members": {}
        }
      }
    },
    "S6w": {
      "type": "structure",
      "members": {
        "Key": {
          "locationName": "S3Key",
          "type": "structure",
          "members": {
            "FilterRules": {
              "locationName": "FilterRule",
              "type": "list",
              "member": {
                "type": "structure",
                "members": {
                  "Name": {},
                  "Value": {}
                }
              },
              "flattened": true
            }
          }
        }
      }
    },
    "S7a": {
      "type": "structure",
      "required": [
        "Rules"
      ],
      "members": {
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "ObjectOwnership"
            ],
            "members": {
              "ObjectOwnership": {}
            }
          },
          "flattened": true
        }
      }
    },
    "S7m": {
      "type": "structure",
      "required": [
        "Role",
        "Rules"
      ],
      "members": {
        "Role": {},
        "Rules": {
          "locationName": "Rule",
          "type": "list",
          "member": {
            "type": "structure",
            "required": [
              "Status",
              "Destination"
            ],
            "members": {
              "ID": {},
              "Priority": {
                "type": "integer"
              },
              "Prefix": {
                "deprecated": true
              },
              "Filter": {
                "type": "structure",
                "members": {
                  "Prefix": {},
                  "Tag": {
                    "shape": "S3s"
                  },
                  "And": {
                    "type": "structure",
                    "members": {
                      "Prefix": {},
                      "Tags": {
                        "shape": "S3v",
                        "flattened": true,
                        "locationName": "Tag"
                      }
                    }
                  }
                }
              },
              "Status": {},
              "SourceSelectionCriteria": {
                "type": "structure",
                "members": {
                  "SseKmsEncryptedObjects": {
                    "type": "structure",
                    "required": [
                      "Status"
                    ],
                    "members": {
                      "Status": {}
                    }
                  },
                  "ReplicaModifications": {
                    "type": "structure",
                    "required": [
                      "Status"
                    ],
                    "members": {
                      "Status": {}
                    }
                  }
                }
              },
              "ExistingObjectReplication": {
                "type": "structure",
                "required": [
                  "Status"
                ],
                "members": {
                  "Status": {}
                }
              },
              "Destination": {
                "type": "structure",
                "required": [
                  "Bucket"
                ],
                "members": {
                  "Bucket": {},
                  "Account": {},
                  "StorageClass": {},
                  "AccessControlTranslation": {
                    "type": "structure",
                    "required": [
                      "Owner"
                    ],
                    "members": {
                      "Owner": {}
                    }
                  },
                  "EncryptionConfiguration": {
                    "type": "structure",
                    "members": {
                      "ReplicaKmsKeyID": {}
                    }
                  },
                  "ReplicationTime": {
                    "type": "structure",
                    "required": [
                      "Status",
                      "Time"
                    ],
                    "members": {
                      "Status": {},
                      "Time": {
                        "shape": "S88"
                      }
                    }
                  },
                  "Metrics": {
                    "type": "structure",
                    "required": [
                      "Status"
                    ],
                    "members": {
                      "Status": {},
                      "EventThreshold": {
                        "shape": "S88"
                      }
                    }
                  }
                }
              },
              "DeleteMarkerReplication": {
                "type": "structure",
                "members": {
                  "Status": {}
                }
              }
            }
          },
          "flattened": true
        }
      }
    },
    "S88": {
      "type": "structure",
      "members": {
        "Minutes": {
          "type": "integer"
        }
      }
    },
    "S8p": {
      "type": "structure",
      "required": [
        "HostName"
      ],
      "members": {
        "HostName": {},
        "Protocol": {}
      }
    },
    "S8s": {
      "type": "structure",
      "required": [
        "Suffix"
      ],
      "members": {
        "Suffix": {}
      }
    },
    "S8u": {
      "type": "structure",
      "required": [
        "Key"
      ],
      "members": {
        "Key": {}
      }
    },
    "S8v": {
      "type": "list",
      "member": {
        "locationName": "RoutingRule",
        "type": "structure",
        "required": [
          "Redirect"
        ],
        "members": {
          "Condition": {
            "type": "structure",
            "members": {
              "HttpErrorCodeReturnedEquals": {},
              "KeyPrefixEquals": {}
            }
          },
          "Redirect": {
            "type": "structure",
            "members": {
              "HostName": {},
              "HttpRedirectCode": {},
              "Protocol": {},
              "ReplaceKeyPrefixWith": {},
              "ReplaceKeyWith": {}
            }
          }
        }
      }
    },
    "Sa9": {
      "type": "structure",
      "members": {
        "Status": {}
      }
    },
    "Sac": {
      "type": "structure",
      "members": {
        "ObjectLockEnabled": {},
        "Rule": {
          "type": "structure",
          "members": {
            "DefaultRetention": {
              "type": "structure",
              "members": {
                "Mode": {},
                "Days": {
                  "type": "integer"
                },
                "Years": {
                  "type": "integer"
                }
              }
            }
          }
        }
      }
    },
    "Sak": {
      "type": "structure",
      "members": {
        "Mode": {},
        "RetainUntilDate": {
          "shape": "S5g"
        }
      }
    },
    "Sar": {
      "type": "structure",
      "members": {
        "BlockPublicAcls": {
          "locationName": "BlockPublicAcls",
          "type": "boolean"
        },
        "IgnorePublicAcls": {
          "locationName": "IgnorePublicAcls",
          "type": "boolean"
        },
        "BlockPublicPolicy": {
          "locationName": "BlockPublicPolicy",
          "type": "boolean"
        },
        "RestrictPublicBuckets": {
          "locationName": "RestrictPublicBuckets",
          "type": "boolean"
        }
      }
    },
    "Sbr": {
      "type": "structure",
      "members": {
        "ID": {},
        "DisplayName": {}
      }
    },
    "Sbs": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "Prefix": {}
        }
      },
      "flattened": true
    },
    "Sc1": {
      "type": "list",
      "member": {},
      "flattened": true
    },
    "Sca": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "Key": {},
          "LastModified": {
            "type": "timestamp"
          },
          "ETag": {},
          "ChecksumAlgorithm": {
            "shape": "Sc1"
          },
          "Size": {
            "type": "integer"
          },
          "StorageClass": {},
          "Owner": {
            "shape": "S3d"
          }
        }
      },
      "flattened": true
    },
    "Scp": {
      "type": "structure",
      "members": {
        "Grants": {
          "shape": "S3g",
          "locationName": "AccessControlList"
        },
        "Owner": {
          "shape": "S3d"
        }
      }
    },
    "Sdf": {
      "type": "structure",
      "required": [
        "TagSet"
      ],
      "members": {
        "TagSet": {
          "shape": "S3v"
        }
      }
    },
    "Se5": {
      "type": "structure",
      "members": {
        "CSV": {
          "type": "structure",
          "members": {
            "FileHeaderInfo": {},
            "Comments": {},
            "QuoteEscapeCharacter": {},
            "RecordDelimiter": {},
            "FieldDelimiter": {},
            "QuoteCharacter": {},
            "AllowQuotedRecordDelimiter": {
              "type": "boolean"
            }
          }
        },
        "CompressionType": {},
        "JSON": {
          "type": "structure",
          "members": {
            "Type": {}
          }
        },
        "Parquet": {
          "type": "structure",
          "members": {}
        }
      }
    },
    "Sek": {
      "type": "structure",
      "members": {
        "CSV": {
          "type": "structure",
          "members": {
            "QuoteFields": {},
            "QuoteEscapeCharacter": {},
            "RecordDelimiter": {},
            "FieldDelimiter": {},
            "QuoteCharacter": {}
          }
        },
        "JSON": {
          "type": "structure",
          "members": {
            "RecordDelimiter": {}
          }
        }
      }
    }
  }
}
},{}],5:[function(require,module,exports){
module.exports={
  "pagination": {
    "ListBuckets": {
      "result_key": "Buckets"
    },
    "ListMultipartUploads": {
      "input_token": [
        "KeyMarker",
        "UploadIdMarker"
      ],
      "limit_key": "MaxUploads",
      "more_results": "IsTruncated",
      "output_token": [
        "NextKeyMarker",
        "NextUploadIdMarker"
      ],
      "result_key": [
        "Uploads",
        "CommonPrefixes"
      ]
    },
    "ListObjectVersions": {
      "input_token": [
        "KeyMarker",
        "VersionIdMarker"
      ],
      "limit_key": "MaxKeys",
      "more_results": "IsTruncated",
      "output_token": [
        "NextKeyMarker",
        "NextVersionIdMarker"
      ],
      "result_key": [
        "Versions",
        "DeleteMarkers",
        "CommonPrefixes"
      ]
    },
    "ListObjects": {
      "input_token": "Marker",
      "limit_key": "MaxKeys",
      "more_results": "IsTruncated",
      "output_token": "NextMarker || Contents[-1].Key",
      "result_key": [
        "Contents",
        "CommonPrefixes"
      ]
    },
    "ListObjectsV2": {
      "input_token": "ContinuationToken",
      "limit_key": "MaxKeys",
      "output_token": "NextContinuationToken",
      "result_key": [
        "Contents",
        "CommonPrefixes"
      ]
    },
    "ListParts": {
      "input_token": "PartNumberMarker",
      "limit_key": "MaxParts",
      "more_results": "IsTruncated",
      "output_token": "NextPartNumberMarker",
      "result_key": "Parts"
    }
  }
}
},{}],6:[function(require,module,exports){
module.exports={
  "version": 2,
  "waiters": {
    "BucketExists": {
      "delay": 5,
      "operation": "HeadBucket",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 200,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 301,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 403,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 404,
          "matcher": "status",
          "state": "retry"
        }
      ]
    },
    "BucketNotExists": {
      "delay": 5,
      "operation": "HeadBucket",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 404,
          "matcher": "status",
          "state": "success"
        }
      ]
    },
    "ObjectExists": {
      "delay": 5,
      "operation": "HeadObject",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 200,
          "matcher": "status",
          "state": "success"
        },
        {
          "expected": 404,
          "matcher": "status",
          "state": "retry"
        }
      ]
    },
    "ObjectNotExists": {
      "delay": 5,
      "operation": "HeadObject",
      "maxAttempts": 20,
      "acceptors": [
        {
          "expected": 404,
          "matcher": "status",
          "state": "success"
        }
      ]
    }
  }
}

},{}],7:[function(require,module,exports){
module.exports={
  "version": "2.0",
  "metadata": {
    "apiVersion": "2011-06-15",
    "endpointPrefix": "sts",
    "globalEndpoint": "sts.amazonaws.com",
    "protocol": "query",
    "serviceAbbreviation": "AWS STS",
    "serviceFullName": "AWS Security Token Service",
    "serviceId": "STS",
    "signatureVersion": "v4",
    "uid": "sts-2011-06-15",
    "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"
  },
  "operations": {
    "AssumeRole": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          },
          "Tags": {
            "shape": "S8"
          },
          "TransitiveTagKeys": {
            "type": "list",
            "member": {}
          },
          "ExternalId": {},
          "SerialNumber": {},
          "TokenCode": {},
          "SourceIdentity": {}
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Si"
          },
          "AssumedRoleUser": {
            "shape": "Sn"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "SourceIdentity": {}
        }
      }
    },
    "AssumeRoleWithSAML": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "PrincipalArn",
          "SAMLAssertion"
        ],
        "members": {
          "RoleArn": {},
          "PrincipalArn": {},
          "SAMLAssertion": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithSAMLResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Si"
          },
          "AssumedRoleUser": {
            "shape": "Sn"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Subject": {},
          "SubjectType": {},
          "Issuer": {},
          "Audience": {},
          "NameQualifier": {},
          "SourceIdentity": {}
        }
      }
    },
    "AssumeRoleWithWebIdentity": {
      "input": {
        "type": "structure",
        "required": [
          "RoleArn",
          "RoleSessionName",
          "WebIdentityToken"
        ],
        "members": {
          "RoleArn": {},
          "RoleSessionName": {},
          "WebIdentityToken": {},
          "ProviderId": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "Policy": {},
          "DurationSeconds": {
            "type": "integer"
          }
        }
      },
      "output": {
        "resultWrapper": "AssumeRoleWithWebIdentityResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Si"
          },
          "SubjectFromWebIdentityToken": {},
          "AssumedRoleUser": {
            "shape": "Sn"
          },
          "PackedPolicySize": {
            "type": "integer"
          },
          "Provider": {},
          "Audience": {},
          "SourceIdentity": {}
        }
      }
    },
    "DecodeAuthorizationMessage": {
      "input": {
        "type": "structure",
        "required": [
          "EncodedMessage"
        ],
        "members": {
          "EncodedMessage": {}
        }
      },
      "output": {
        "resultWrapper": "DecodeAuthorizationMessageResult",
        "type": "structure",
        "members": {
          "DecodedMessage": {}
        }
      }
    },
    "GetAccessKeyInfo": {
      "input": {
        "type": "structure",
        "required": [
          "AccessKeyId"
        ],
        "members": {
          "AccessKeyId": {}
        }
      },
      "output": {
        "resultWrapper": "GetAccessKeyInfoResult",
        "type": "structure",
        "members": {
          "Account": {}
        }
      }
    },
    "GetCallerIdentity": {
      "input": {
        "type": "structure",
        "members": {}
      },
      "output": {
        "resultWrapper": "GetCallerIdentityResult",
        "type": "structure",
        "members": {
          "UserId": {},
          "Account": {},
          "Arn": {}
        }
      }
    },
    "GetFederationToken": {
      "input": {
        "type": "structure",
        "required": [
          "Name"
        ],
        "members": {
          "Name": {},
          "Policy": {},
          "PolicyArns": {
            "shape": "S4"
          },
          "DurationSeconds": {
            "type": "integer"
          },
          "Tags": {
            "shape": "S8"
          }
        }
      },
      "output": {
        "resultWrapper": "GetFederationTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Si"
          },
          "FederatedUser": {
            "type": "structure",
            "required": [
              "FederatedUserId",
              "Arn"
            ],
            "members": {
              "FederatedUserId": {},
              "Arn": {}
            }
          },
          "PackedPolicySize": {
            "type": "integer"
          }
        }
      }
    },
    "GetSessionToken": {
      "input": {
        "type": "structure",
        "members": {
          "DurationSeconds": {
            "type": "integer"
          },
          "SerialNumber": {},
          "TokenCode": {}
        }
      },
      "output": {
        "resultWrapper": "GetSessionTokenResult",
        "type": "structure",
        "members": {
          "Credentials": {
            "shape": "Si"
          }
        }
      }
    }
  },
  "shapes": {
    "S4": {
      "type": "list",
      "member": {
        "type": "structure",
        "members": {
          "arn": {}
        }
      }
    },
    "S8": {
      "type": "list",
      "member": {
        "type": "structure",
        "required": [
          "Key",
          "Value"
        ],
        "members": {
          "Key": {},
          "Value": {}
        }
      }
    },
    "Si": {
      "type": "structure",
      "required": [
        "AccessKeyId",
        "SecretAccessKey",
        "SessionToken",
        "Expiration"
      ],
      "members": {
        "AccessKeyId": {},
        "SecretAccessKey": {},
        "SessionToken": {},
        "Expiration": {
          "type": "timestamp"
        }
      }
    },
    "Sn": {
      "type": "structure",
      "required": [
        "AssumedRoleId",
        "Arn"
      ],
      "members": {
        "AssumedRoleId": {},
        "Arn": {}
      }
    }
  }
}
},{}],8:[function(require,module,exports){
module.exports={
  "pagination": {
  }
}

},{}],9:[function(require,module,exports){
require('./lib/browser_loader');

var AWS = require('./lib/core');
if (typeof window !== 'undefined') window.AWS = AWS;
if (typeof module !== 'undefined') module.exports = AWS;
if (typeof self !== 'undefined') self.AWS = AWS;
},{"./lib/browser_loader":20,"./lib/core":23}],10:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['cognitoidentity'] = {};
AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);
Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {
  get: function get() {
    var model = require('../apis/cognito-identity-2014-06-30.min.json');
    model.paginators = require('../apis/cognito-identity-2014-06-30.paginators.json').pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.CognitoIdentity;

},{"../apis/cognito-identity-2014-06-30.min.json":1,"../apis/cognito-identity-2014-06-30.paginators.json":2,"../lib/core":23,"../lib/node_loader":20}],11:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['s3'] = {};
AWS.S3 = Service.defineService('s3', ['2006-03-01']);
require('../lib/services/s3');
Object.defineProperty(apiLoader.services['s3'], '2006-03-01', {
  get: function get() {
    var model = require('../apis/s3-2006-03-01.min.json');
    model.paginators = require('../apis/s3-2006-03-01.paginators.json').pagination;
    model.waiters = require('../apis/s3-2006-03-01.waiters2.json').waiters;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.S3;

},{"../apis/s3-2006-03-01.min.json":4,"../apis/s3-2006-03-01.paginators.json":5,"../apis/s3-2006-03-01.waiters2.json":6,"../lib/core":23,"../lib/node_loader":20,"../lib/services/s3":67}],12:[function(require,module,exports){
require('../lib/node_loader');
var AWS = require('../lib/core');
var Service = AWS.Service;
var apiLoader = AWS.apiLoader;

apiLoader.services['sts'] = {};
AWS.STS = Service.defineService('sts', ['2011-06-15']);
require('../lib/services/sts');
Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {
  get: function get() {
    var model = require('../apis/sts-2011-06-15.min.json');
    model.paginators = require('../apis/sts-2011-06-15.paginators.json').pagination;
    return model;
  },
  enumerable: true,
  configurable: true
});

module.exports = AWS.STS;

},{"../apis/sts-2011-06-15.min.json":7,"../apis/sts-2011-06-15.paginators.json":8,"../lib/core":23,"../lib/node_loader":20,"../lib/services/sts":69}],13:[function(require,module,exports){
function apiLoader(svc, version) {
  if (!apiLoader.services.hasOwnProperty(svc)) {
    throw new Error('InvalidService: Failed to load api for ' + svc);
  }
  return apiLoader.services[svc][version];
}

/**
 * @api private
 *
 * This member of AWS.apiLoader is private, but changing it will necessitate a
 * change to ../scripts/services-table-generator.ts
 */
apiLoader.services = {};

/**
 * @api private
 */
module.exports = apiLoader;

},{}],14:[function(require,module,exports){
var Hmac = require('./browserHmac');
var Md5 = require('./browserMd5');
var Sha1 = require('./browserSha1');
var Sha256 = require('./browserSha256');

/**
 * @api private
 */
module.exports = exports = {
    createHash: function createHash(alg) {
      alg = alg.toLowerCase();
      if (alg === 'md5') {
        return new Md5();
      } else if (alg === 'sha256') {
        return new Sha256();
      } else if (alg === 'sha1') {
        return new Sha1();
      }

      throw new Error('Hash algorithm ' + alg + ' is not supported in the browser SDK');
    },
    createHmac: function createHmac(alg, key) {
      alg = alg.toLowerCase();
      if (alg === 'md5') {
        return new Hmac(Md5, key);
      } else if (alg === 'sha256') {
        return new Hmac(Sha256, key);
      } else if (alg === 'sha1') {
        return new Hmac(Sha1, key);
      }

      throw new Error('HMAC algorithm ' + alg + ' is not supported in the browser SDK');
    },
    createSign: function() {
      throw new Error('createSign is not implemented in the browser');
    }
  };

},{"./browserHmac":16,"./browserMd5":17,"./browserSha1":18,"./browserSha256":19}],15:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;

/**
 * This is a polyfill for the static method `isView` of `ArrayBuffer`, which is
 * e.g. missing in IE 10.
 *
 * @api private
 */
if (
    typeof ArrayBuffer !== 'undefined' &&
    typeof ArrayBuffer.isView === 'undefined'
) {
    ArrayBuffer.isView = function(arg) {
        return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;
    };
}

/**
 * @api private
 */
var viewStrings = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]',
    '[object DataView]',
];

/**
 * @api private
 */
function isEmptyData(data) {
    if (typeof data === 'string') {
        return data.length === 0;
    }
    return data.byteLength === 0;
}

/**
 * @api private
 */
function convertToBuffer(data) {
    if (typeof data === 'string') {
        data = new Buffer(data, 'utf8');
    }

    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }

    return new Uint8Array(data);
}

/**
 * @api private
 */
module.exports = exports = {
    isEmptyData: isEmptyData,
    convertToBuffer: convertToBuffer,
};

},{"buffer/":93}],16:[function(require,module,exports){
var hashUtils = require('./browserHashUtils');

/**
 * @api private
 */
function Hmac(hashCtor, secret) {
    this.hash = new hashCtor();
    this.outer = new hashCtor();

    var inner = bufferFromSecret(hashCtor, secret);
    var outer = new Uint8Array(hashCtor.BLOCK_SIZE);
    outer.set(inner);

    for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {
        inner[i] ^= 0x36;
        outer[i] ^= 0x5c;
    }

    this.hash.update(inner);
    this.outer.update(outer);

    // Zero out the copied key buffer.
    for (var i = 0; i < inner.byteLength; i++) {
        inner[i] = 0;
    }
}

/**
 * @api private
 */
module.exports = exports = Hmac;

Hmac.prototype.update = function (toHash) {
    if (hashUtils.isEmptyData(toHash) || this.error) {
        return this;
    }

    try {
        this.hash.update(hashUtils.convertToBuffer(toHash));
    } catch (e) {
        this.error = e;
    }

    return this;
};

Hmac.prototype.digest = function (encoding) {
    if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
    }

    return this.outer.digest(encoding);
};

function bufferFromSecret(hashCtor, secret) {
    var input = hashUtils.convertToBuffer(secret);
    if (input.byteLength > hashCtor.BLOCK_SIZE) {
        var bufferHash = new hashCtor;
        bufferHash.update(input);
        input = bufferHash.digest();
    }
    var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);
    buffer.set(input);
    return buffer;
}

},{"./browserHashUtils":15}],17:[function(require,module,exports){
var hashUtils = require('./browserHashUtils');
var Buffer = require('buffer/').Buffer;

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 16;

var INIT = [
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
];

/**
 * @api private
 */
function Md5() {
    this.state = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
    ];
    this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
}

/**
 * @api private
 */
module.exports = exports = Md5;

Md5.BLOCK_SIZE = BLOCK_SIZE;

Md5.prototype.update = function (sourceData) {
    if (hashUtils.isEmptyData(sourceData)) {
        return this;
    } else if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    var data = hashUtils.convertToBuffer(sourceData);
    var position = 0;
    var byteLength = data.byteLength;
    this.bytesHashed += byteLength;
    while (byteLength > 0) {
        this.buffer.setUint8(this.bufferLength++, data[position++]);
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
        }
    }

    return this;
};

Md5.prototype.digest = function (encoding) {
    if (!this.finished) {
        var _a = this, buffer = _a.buffer, undecoratedLength = _a.bufferLength, bytesHashed = _a.bytesHashed;
        var bitsHashed = bytesHashed * 8;
        buffer.setUint8(this.bufferLength++, 128);
        // Ensure the final block has enough room for the hashed length
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                buffer.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
            buffer.setUint8(i, 0);
        }
        buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
        buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 0x100000000), true);
        this.hashBuffer();
        this.finished = true;
    }
    var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
    for (var i = 0; i < 4; i++) {
        out.setUint32(i * 4, this.state[i], true);
    }
    var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);
    return encoding ? buff.toString(encoding) : buff;
};

Md5.prototype.hashBuffer = function () {
    var _a = this, buffer = _a.buffer, state = _a.state;
    var a = state[0], b = state[1], c = state[2], d = state[3];
    a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 0xd76aa478);
    d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 0xe8c7b756);
    c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 0x242070db);
    b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 0xc1bdceee);
    a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 0xf57c0faf);
    d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 0x4787c62a);
    c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 0xa8304613);
    b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 0xfd469501);
    a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 0x698098d8);
    d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 0x8b44f7af);
    c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 0xffff5bb1);
    b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 0x895cd7be);
    a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 0x6b901122);
    d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 0xfd987193);
    c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 0xa679438e);
    b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 0x49b40821);
    a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 0xf61e2562);
    d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 0xc040b340);
    c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 0x265e5a51);
    b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 0xe9b6c7aa);
    a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 0xd62f105d);
    d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 0x02441453);
    c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 0xd8a1e681);
    b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 0xe7d3fbc8);
    a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 0x21e1cde6);
    d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 0xc33707d6);
    c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 0xf4d50d87);
    b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 0x455a14ed);
    a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 0xa9e3e905);
    d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 0xfcefa3f8);
    c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 0x676f02d9);
    b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 0x8d2a4c8a);
    a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 0xfffa3942);
    d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 0x8771f681);
    c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 0x6d9d6122);
    b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 0xfde5380c);
    a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 0xa4beea44);
    d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 0x4bdecfa9);
    c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 0xf6bb4b60);
    b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 0xbebfbc70);
    a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 0x289b7ec6);
    d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 0xeaa127fa);
    c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 0xd4ef3085);
    b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 0x04881d05);
    a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 0xd9d4d039);
    d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 0xe6db99e5);
    c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 0x1fa27cf8);
    b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 0xc4ac5665);
    a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 0xf4292244);
    d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 0x432aff97);
    c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 0xab9423a7);
    b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 0xfc93a039);
    a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 0x655b59c3);
    d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 0x8f0ccc92);
    c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 0xffeff47d);
    b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 0x85845dd1);
    a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 0x6fa87e4f);
    d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 0xfe2ce6e0);
    c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 0xa3014314);
    b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 0x4e0811a1);
    a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 0xf7537e82);
    d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 0xbd3af235);
    c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 0x2ad7d2bb);
    b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 0xeb86d391);
    state[0] = (a + state[0]) & 0xFFFFFFFF;
    state[1] = (b + state[1]) & 0xFFFFFFFF;
    state[2] = (c + state[2]) & 0xFFFFFFFF;
    state[3] = (d + state[3]) & 0xFFFFFFFF;
};

function cmn(q, a, b, x, s, t) {
    a = (((a + q) & 0xFFFFFFFF) + ((x + t) & 0xFFFFFFFF)) & 0xFFFFFFFF;
    return (((a << s) | (a >>> (32 - s))) + b) & 0xFFFFFFFF;
}

function ff(a, b, c, d, x, s, t) {
    return cmn((b & c) | ((~b) & d), a, b, x, s, t);
}

function gg(a, b, c, d, x, s, t) {
    return cmn((b & d) | (c & (~d)), a, b, x, s, t);
}

function hh(a, b, c, d, x, s, t) {
    return cmn(b ^ c ^ d, a, b, x, s, t);
}

function ii(a, b, c, d, x, s, t) {
    return cmn(c ^ (b | (~d)), a, b, x, s, t);
}

},{"./browserHashUtils":15,"buffer/":93}],18:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;
var hashUtils = require('./browserHashUtils');

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 20;

var KEY = new Uint32Array([
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc | 0,
    0xca62c1d6 | 0
]);

var INIT = [
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
];

var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

/**
 * @api private
 */
function Sha1() {
    this.h0 = 0x67452301;
    this.h1 = 0xEFCDAB89;
    this.h2 = 0x98BADCFE;
    this.h3 = 0x10325476;
    this.h4 = 0xC3D2E1F0;
    // The first 64 bytes (16 words) is the data chunk
    this.block = new Uint32Array(80);
    this.offset = 0;
    this.shift = 24;
    this.totalLength = 0;
}

/**
 * @api private
 */
module.exports = exports = Sha1;

Sha1.BLOCK_SIZE = BLOCK_SIZE;

Sha1.prototype.update = function (data) {
    if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    if (hashUtils.isEmptyData(data)) {
        return this;
    }

    data = hashUtils.convertToBuffer(data);

    var length = data.length;
    this.totalLength += length * 8;
    for (var i = 0; i < length; i++) {
        this.write(data[i]);
    }

    return this;
};

Sha1.prototype.write = function write(byte) {
    this.block[this.offset] |= (byte & 0xff) << this.shift;
    if (this.shift) {
        this.shift -= 8;
    } else {
        this.offset++;
        this.shift = 24;
    }

    if (this.offset === 16) this.processBlock();
};

Sha1.prototype.digest = function (encoding) {
    // Pad
    this.write(0x80);
    if (this.offset > 14 || (this.offset === 14 && this.shift < 24)) {
      this.processBlock();
    }
    this.offset = 14;
    this.shift = 24;

    // 64-bit length big-endian
    this.write(0x00); // numbers this big aren't accurate in javascript anyway
    this.write(0x00); // ..So just hard-code to zero.
    this.write(this.totalLength > 0xffffffffff ? this.totalLength / 0x10000000000 : 0x00);
    this.write(this.totalLength > 0xffffffff ? this.totalLength / 0x100000000 : 0x00);
    for (var s = 24; s >= 0; s -= 8) {
        this.write(this.totalLength >> s);
    }
    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    var out = new Buffer(DIGEST_LENGTH);
    var outView = new DataView(out.buffer);
    outView.setUint32(0, this.h0, false);
    outView.setUint32(4, this.h1, false);
    outView.setUint32(8, this.h2, false);
    outView.setUint32(12, this.h3, false);
    outView.setUint32(16, this.h4, false);

    return encoding ? out.toString(encoding) : out;
};

Sha1.prototype.processBlock = function processBlock() {
    // Extend the sixteen 32-bit words into eighty 32-bit words:
    for (var i = 16; i < 80; i++) {
      var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];
      this.block[i] = (w << 1) | (w >>> 31);
    }

    // Initialize hash value for this chunk:
    var a = this.h0;
    var b = this.h1;
    var c = this.h2;
    var d = this.h3;
    var e = this.h4;
    var f, k;

    // Main loop:
    for (i = 0; i < 80; i++) {
      if (i < 20) {
        f = d ^ (b & (c ^ d));
        k = 0x5A827999;
      }
      else if (i < 40) {
        f = b ^ c ^ d;
        k = 0x6ED9EBA1;
      }
      else if (i < 60) {
        f = (b & c) | (d & (b | c));
        k = 0x8F1BBCDC;
      }
      else {
        f = b ^ c ^ d;
        k = 0xCA62C1D6;
      }
      var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i]|0);
      e = d;
      d = c;
      c = (b << 30 | b >>> 2);
      b = a;
      a = temp;
    }

    // Add this chunk's hash to result so far:
    this.h0 = (this.h0 + a) | 0;
    this.h1 = (this.h1 + b) | 0;
    this.h2 = (this.h2 + c) | 0;
    this.h3 = (this.h3 + d) | 0;
    this.h4 = (this.h4 + e) | 0;

    // The block is now reusable.
    this.offset = 0;
    for (i = 0; i < 16; i++) {
        this.block[i] = 0;
    }
};

},{"./browserHashUtils":15,"buffer/":93}],19:[function(require,module,exports){
var Buffer = require('buffer/').Buffer;
var hashUtils = require('./browserHashUtils');

var BLOCK_SIZE = 64;

var DIGEST_LENGTH = 32;

var KEY = new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);

var INIT = [
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19,
];

var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;

/**
 * @private
 */
function Sha256() {
    this.state = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19,
    ];
    this.temp = new Int32Array(64);
    this.buffer = new Uint8Array(64);
    this.bufferLength = 0;
    this.bytesHashed = 0;
    /**
     * @private
     */
    this.finished = false;
}

/**
 * @api private
 */
module.exports = exports = Sha256;

Sha256.BLOCK_SIZE = BLOCK_SIZE;

Sha256.prototype.update = function (data) {
    if (this.finished) {
        throw new Error('Attempted to update an already finished hash.');
    }

    if (hashUtils.isEmptyData(data)) {
        return this;
    }

    data = hashUtils.convertToBuffer(data);

    var position = 0;
    var byteLength = data.byteLength;
    this.bytesHashed += byteLength;
    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error('Cannot hash more than 2^53 - 1 bits');
    }

    while (byteLength > 0) {
        this.buffer[this.bufferLength++] = data[position++];
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
            this.hashBuffer();
            this.bufferLength = 0;
        }
    }

    return this;
};

Sha256.prototype.digest = function (encoding) {
    if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 0x80);
        // Ensure the final block has enough room for the hashed length
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
            for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                bufferView.setUint8(i, 0);
            }
            this.hashBuffer();
            this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
            bufferView.setUint8(i, 0);
        }
        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 0x100000000), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
    }
    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    var out = new Buffer(DIGEST_LENGTH);
    for (var i = 0; i < 8; i++) {
        out[i * 4] = (this.state[i] >>> 24) & 0xff;
        out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
        out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
        out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }
    return encoding ? out.toString(encoding) : out;
};

Sha256.prototype.hashBuffer = function () {
    var _a = this,
        buffer = _a.buffer,
        state = _a.state;
    var state0 = state[0],
        state1 = state[1],
        state2 = state[2],
        state3 = state[3],
        state4 = state[4],
        state5 = state[5],
        state6 = state[6],
        state7 = state[7];
    for (var i = 0; i < BLOCK_SIZE; i++) {
        if (i < 16) {
            this.temp[i] = (((buffer[i * 4] & 0xff) << 24) |
                ((buffer[(i * 4) + 1] & 0xff) << 16) |
                ((buffer[(i * 4) + 2] & 0xff) << 8) |
                (buffer[(i * 4) + 3] & 0xff));
        }
        else {
            var u = this.temp[i - 2];
            var t1_1 = (u >>> 17 | u << 15) ^
                (u >>> 19 | u << 13) ^
                (u >>> 10);
            u = this.temp[i - 15];
            var t2_1 = (u >>> 7 | u << 25) ^
                (u >>> 18 | u << 14) ^
                (u >>> 3);
            this.temp[i] = (t1_1 + this.temp[i - 7] | 0) +
                (t2_1 + this.temp[i - 16] | 0);
        }
        var t1 = (((((state4 >>> 6 | state4 << 26) ^
            (state4 >>> 11 | state4 << 21) ^
            (state4 >>> 25 | state4 << 7))
            + ((state4 & state5) ^ (~state4 & state6))) | 0)
            + ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) | 0;
        var t2 = (((state0 >>> 2 | state0 << 30) ^
            (state0 >>> 13 | state0 << 19) ^
            (state0 >>> 22 | state0 << 10)) + ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = (state3 + t1) | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = (t1 + t2) | 0;
    }
    state[0] += state0;
    state[1] += state1;
    state[2] += state2;
    state[3] += state3;
    state[4] += state4;
    state[5] += state5;
    state[6] += state6;
    state[7] += state7;
};

},{"./browserHashUtils":15,"buffer/":93}],20:[function(require,module,exports){
(function (process){(function (){
var util = require('./util');

// browser specific modules
util.crypto.lib = require('./browserCryptoLib');
util.Buffer = require('buffer/').Buffer;
util.url = require('url/');
util.querystring = require('querystring/');
util.realClock = require('./realclock/browserClock');
util.environment = 'js';
util.createEventStream = require('./event-stream/buffered-create-event-stream').createEventStream;
util.isBrowser = function() { return true; };
util.isNode = function() { return false; };

var AWS = require('./core');

/**
 * @api private
 */
module.exports = AWS;

require('./credentials');
require('./credentials/credential_provider_chain');
require('./credentials/temporary_credentials');
require('./credentials/chainable_temporary_credentials');
require('./credentials/web_identity_credentials');
require('./credentials/cognito_identity_credentials');
require('./credentials/saml_credentials');

// Load the DOMParser XML parser
AWS.XML.Parser = require('./xml/browser_parser');

// Load the XHR HttpClient
require('./http/xhr');

if (typeof process === 'undefined') {
  var process = {
    browser: true
  };
}

}).call(this)}).call(this,require('_process'))

},{"./browserCryptoLib":14,"./core":23,"./credentials":24,"./credentials/chainable_temporary_credentials":25,"./credentials/cognito_identity_credentials":26,"./credentials/credential_provider_chain":27,"./credentials/saml_credentials":28,"./credentials/temporary_credentials":29,"./credentials/web_identity_credentials":30,"./event-stream/buffered-create-event-stream":32,"./http/xhr":40,"./realclock/browserClock":57,"./util":80,"./xml/browser_parser":81,"_process":97,"buffer/":93,"querystring/":104,"url/":106}],21:[function(require,module,exports){
var AWS = require('./core');
require('./credentials');
require('./credentials/credential_provider_chain');
var PromisesDependency;

/**
 * The main configuration class used by all service objects to set
 * the region, credentials, and other options for requests.
 *
 * By default, credentials and region settings are left unconfigured.
 * This should be configured by the application before using any
 * AWS service APIs.
 *
 * In order to set global configuration options, properties should
 * be assigned to the global {AWS.config} object.
 *
 * @see AWS.config
 *
 * @!group General Configuration Options
 *
 * @!attribute credentials
 *   @return [AWS.Credentials] the AWS credentials to sign requests with.
 *
 * @!attribute region
 *   @example Set the global region setting to us-west-2
 *     AWS.config.update({region: 'us-west-2'});
 *   @return [AWS.Credentials] The region to send service requests to.
 *   @see http://docs.amazonwebservices.com/general/latest/gr/rande.html
 *     A list of available endpoints for each AWS service
 *
 * @!attribute maxRetries
 *   @return [Integer] the maximum amount of retries to perform for a
 *     service request. By default this value is calculated by the specific
 *     service object that the request is being made to.
 *
 * @!attribute maxRedirects
 *   @return [Integer] the maximum amount of redirects to follow for a
 *     service request. Defaults to 10.
 *
 * @!attribute paramValidation
 *   @return [Boolean|map] whether input parameters should be validated against
 *     the operation description before sending the request. Defaults to true.
 *     Pass a map to enable any of the following specific validation features:
 *
 *     * **min** [Boolean] &mdash; Validates that a value meets the min
 *       constraint. This is enabled by default when paramValidation is set
 *       to `true`.
 *     * **max** [Boolean] &mdash; Validates that a value meets the max
 *       constraint.
 *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
 *       regular expression.
 *     * **enum** [Boolean] &mdash; Validates that a string value matches one
 *       of the allowable enum values.
 *
 * @!attribute computeChecksums
 *   @return [Boolean] whether to compute checksums for payload bodies when
 *     the service accepts it (currently supported in S3 and SQS only).
 *
 * @!attribute convertResponseTypes
 *   @return [Boolean] whether types are converted when parsing response data.
 *     Currently only supported for JSON based services. Turning this off may
 *     improve performance on large response payloads. Defaults to `true`.
 *
 * @!attribute correctClockSkew
 *   @return [Boolean] whether to apply a clock skew correction and retry
 *     requests that fail because of an skewed client clock. Defaults to
 *     `false`.
 *
 * @!attribute sslEnabled
 *   @return [Boolean] whether SSL is enabled for requests
 *
 * @!attribute s3ForcePathStyle
 *   @return [Boolean] whether to force path style URLs for S3 objects
 *
 * @!attribute s3BucketEndpoint
 *   @note Setting this configuration option requires an `endpoint` to be
 *     provided explicitly to the service constructor.
 *   @return [Boolean] whether the provided endpoint addresses an individual
 *     bucket (false if it addresses the root API endpoint).
 *
 * @!attribute s3DisableBodySigning
 *   @return [Boolean] whether to disable S3 body signing when using signature version `v4`.
 *     Body signing can only be disabled when using https. Defaults to `true`.
 *
 * @!attribute s3UsEast1RegionalEndpoint
 *   @return ['legacy'|'regional'] when region is set to 'us-east-1', whether to send s3
 *     request to global endpoints or 'us-east-1' regional endpoints. This config is only
 *     applicable to S3 client;
 *     Defaults to 'legacy'
 * @!attribute s3UseArnRegion
 *   @return [Boolean] whether to override the request region with the region inferred
 *     from requested resource's ARN. Only available for S3 buckets
 *     Defaults to `true`
 *
 * @!attribute useAccelerateEndpoint
 *   @note This configuration option is only compatible with S3 while accessing
 *     dns-compatible buckets.
 *   @return [Boolean] Whether to use the Accelerate endpoint with the S3 service.
 *     Defaults to `false`.
 *
 * @!attribute retryDelayOptions
 *   @example Set the base retry delay for all services to 300 ms
 *     AWS.config.update({retryDelayOptions: {base: 300}});
 *     // Delays with maxRetries = 3: 300, 600, 1200
 *   @example Set a custom backoff function to provide delay values on retries
 *     AWS.config.update({retryDelayOptions: {customBackoff: function(retryCount, err) {
 *       // returns delay in ms
 *     }}});
 *   @return [map] A set of options to configure the retry delay on retryable errors.
 *     Currently supported options are:
 *
 *     * **base** [Integer] &mdash; The base number of milliseconds to use in the
 *       exponential backoff for operation retries. Defaults to 100 ms for all services except
 *       DynamoDB, where it defaults to 50ms.
 *
 *     * **customBackoff ** [function] &mdash; A custom function that accepts a
 *       retry count and error and returns the amount of time to delay in
 *       milliseconds. If the result is a non-zero negative value, no further
 *       retry attempts will be made. The `base` option will be ignored if this
 *       option is supplied. The function is only called for retryable errors.
 *
 * @!attribute httpOptions
 *   @return [map] A set of options to pass to the low-level HTTP request.
 *     Currently supported options are:
 *
 *     * **proxy** [String] &mdash; the URL to proxy requests through
 *     * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
 *       HTTP requests with. Used for connection pooling. Note that for
 *       SSL connections, a special Agent object is used in order to enable
 *       peer certificate verification. This feature is only supported in the
 *       Node.js environment.
 *     * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
 *       failing to establish a connection with the server after
 *       `connectTimeout` milliseconds. This timeout has no effect once a socket
 *       connection has been established.
 *     * **timeout** [Integer] &mdash; The number of milliseconds a request can
 *       take before automatically being terminated.
 *       Defaults to two minutes (120000).
 *     * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
 *       HTTP requests. Used in the browser environment only. Set to false to
 *       send requests synchronously. Defaults to true (async on).
 *     * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
 *       property of an XMLHttpRequest object. Used in the browser environment
 *       only. Defaults to false.
 * @!attribute logger
 *   @return [#write,#log] an object that responds to .write() (like a stream)
 *     or .log() (like the console object) in order to log information about
 *     requests
 *
 * @!attribute systemClockOffset
 *   @return [Number] an offset value in milliseconds to apply to all signing
 *     times. Use this to compensate for clock skew when your system may be
 *     out of sync with the service time. Note that this configuration option
 *     can only be applied to the global `AWS.config` object and cannot be
 *     overridden in service-specific configuration. Defaults to 0 milliseconds.
 *
 * @!attribute signatureVersion
 *   @return [String] the signature version to sign requests with (overriding
 *     the API configuration). Possible values are: 'v2', 'v3', 'v4'.
 *
 * @!attribute signatureCache
 *   @return [Boolean] whether the signature to sign requests with (overriding
 *     the API configuration) is cached. Only applies to the signature version 'v4'.
 *     Defaults to `true`.
 *
 * @!attribute endpointDiscoveryEnabled
 *   @return [Boolean|undefined] whether to call operations with endpoints
 *     given by service dynamically. Setting this config to `true` will enable
 *     endpoint discovery for all applicable operations. Setting it to `false`
 *     will explicitly disable endpoint discovery even though operations that
 *     require endpoint discovery will presumably fail. Leaving it to
 *     `undefined` means SDK only do endpoint discovery when it's required.
 *     Defaults to `undefined`
 *
 * @!attribute endpointCacheSize
 *   @return [Number] the size of the global cache storing endpoints from endpoint
 *     discovery operations. Once endpoint cache is created, updating this setting
 *     cannot change existing cache size.
 *     Defaults to 1000
 *
 * @!attribute hostPrefixEnabled
 *   @return [Boolean] whether to marshal request parameters to the prefix of
 *     hostname. Defaults to `true`.
 *
 * @!attribute stsRegionalEndpoints
 *   @return ['legacy'|'regional'] whether to send sts request to global endpoints or
 *     regional endpoints.
 *     Defaults to 'legacy'.
 *
 * @!attribute useFipsEndpoint
 *   @return [Boolean] Enables FIPS compatible endpoints. Defaults to `false`.
 *
 * @!attribute useDualstackEndpoint
 *   @return [Boolean] Enables IPv6 dualstack endpoint. Defaults to `false`.
 */
AWS.Config = AWS.util.inherit({
  /**
   * @!endgroup
   */

  /**
   * Creates a new configuration object. This is the object that passes
   * option data along to service requests, including credentials, security,
   * region information, and some service specific settings.
   *
   * @example Creating a new configuration object with credentials and region
   *   var config = new AWS.Config({
   *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
   *   });
   * @option options accessKeyId [String] your AWS access key ID.
   * @option options secretAccessKey [String] your AWS secret access key.
   * @option options sessionToken [AWS.Credentials] the optional AWS
   *   session token to sign requests with.
   * @option options credentials [AWS.Credentials] the AWS credentials
   *   to sign requests with. You can either specify this object, or
   *   specify the accessKeyId and secretAccessKey options directly.
   * @option options credentialProvider [AWS.CredentialProviderChain] the
   *   provider chain used to resolve credentials if no static `credentials`
   *   property is set.
   * @option options region [String] the region to send service requests to.
   *   See {region} for more information.
   * @option options maxRetries [Integer] the maximum amount of retries to
   *   attempt with a request. See {maxRetries} for more information.
   * @option options maxRedirects [Integer] the maximum amount of redirects to
   *   follow with a request. See {maxRedirects} for more information.
   * @option options sslEnabled [Boolean] whether to enable SSL for
   *   requests.
   * @option options paramValidation [Boolean|map] whether input parameters
   *   should be validated against the operation description before sending
   *   the request. Defaults to true. Pass a map to enable any of the
   *   following specific validation features:
   *
   *   * **min** [Boolean] &mdash; Validates that a value meets the min
   *     constraint. This is enabled by default when paramValidation is set
   *     to `true`.
   *   * **max** [Boolean] &mdash; Validates that a value meets the max
   *     constraint.
   *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *     regular expression.
   *   * **enum** [Boolean] &mdash; Validates that a string value matches one
   *     of the allowable enum values.
   * @option options computeChecksums [Boolean] whether to compute checksums
   *   for payload bodies when the service accepts it (currently supported
   *   in S3 only)
   * @option options convertResponseTypes [Boolean] whether types are converted
   *     when parsing response data. Currently only supported for JSON based
   *     services. Turning this off may improve performance on large response
   *     payloads. Defaults to `true`.
   * @option options correctClockSkew [Boolean] whether to apply a clock skew
   *     correction and retry requests that fail because of an skewed client
   *     clock. Defaults to `false`.
   * @option options s3ForcePathStyle [Boolean] whether to force path
   *   style URLs for S3 objects.
   * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
   *   addresses an individual bucket (false if it addresses the root API
   *   endpoint). Note that setting this configuration option requires an
   *   `endpoint` to be provided explicitly to the service constructor.
   * @option options s3DisableBodySigning [Boolean] whether S3 body signing
   *   should be disabled when using signature version `v4`. Body signing
   *   can only be disabled when using https. Defaults to `true`.
   * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
   *   is set to 'us-east-1', whether to send s3 request to global endpoints or
   *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
   *   Defaults to `legacy`
   * @option options s3UseArnRegion [Boolean] whether to override the request region
   *   with the region inferred from requested resource's ARN. Only available for S3 buckets
   *   Defaults to `true`
   *
   * @option options retryDelayOptions [map] A set of options to configure
   *   the retry delay on retryable errors. Currently supported options are:
   *
   *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
   *     exponential backoff for operation retries. Defaults to 100 ms for all
   *     services except DynamoDB, where it defaults to 50ms.
   *   * **customBackoff ** [function] &mdash; A custom function that accepts a
   *     retry count and error and returns the amount of time to delay in
   *     milliseconds. If the result is a non-zero negative value, no further
   *     retry attempts will be made. The `base` option will be ignored if this
   *     option is supplied. The function is only called for retryable errors.
   * @option options httpOptions [map] A set of options to pass to the low-level
   *   HTTP request. Currently supported options are:
   *
   *   * **proxy** [String] &mdash; the URL to proxy requests through
   *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
   *     HTTP requests with. Used for connection pooling. Defaults to the global
   *     agent (`http.globalAgent`) for non-SSL connections. Note that for
   *     SSL connections, a special Agent object is used in order to enable
   *     peer certificate verification. This feature is only available in the
   *     Node.js environment.
   *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
   *     failing to establish a connection with the server after
   *     `connectTimeout` milliseconds. This timeout has no effect once a socket
   *     connection has been established.
   *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
   *     milliseconds of inactivity on the socket. Defaults to two minutes
   *     (120000).
   *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
   *     HTTP requests. Used in the browser environment only. Set to false to
   *     send requests synchronously. Defaults to true (async on).
   *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
   *     property of an XMLHttpRequest object. Used in the browser environment
   *     only. Defaults to false.
   * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
   *   (or a date) that represents the latest possible API version that can be
   *   used in all services (unless overridden by `apiVersions`). Specify
   *   'latest' to use the latest possible version.
   * @option options apiVersions [map<String, String|Date>] a map of service
   *   identifiers (the lowercase service class name) with the API version to
   *   use when instantiating a service. Specify 'latest' for each individual
   *   that can use the latest available version.
   * @option options logger [#write,#log] an object that responds to .write()
   *   (like a stream) or .log() (like the console object) in order to log
   *   information about requests
   * @option options systemClockOffset [Number] an offset value in milliseconds
   *   to apply to all signing times. Use this to compensate for clock skew
   *   when your system may be out of sync with the service time. Note that
   *   this configuration option can only be applied to the global `AWS.config`
   *   object and cannot be overridden in service-specific configuration.
   *   Defaults to 0 milliseconds.
   * @option options signatureVersion [String] the signature version to sign
   *   requests with (overriding the API configuration). Possible values are:
   *   'v2', 'v3', 'v4'.
   * @option options signatureCache [Boolean] whether the signature to sign
   *   requests with (overriding the API configuration) is cached. Only applies
   *   to the signature version 'v4'. Defaults to `true`.
   * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
   *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
   * @option options useAccelerateEndpoint [Boolean] Whether to use the
   *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
   * @option options clientSideMonitoring [Boolean] whether to collect and
   *   publish this client's performance metrics of all its API requests.
   * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
   *   call operations with endpoints given by service dynamically. Setting this
   * config to `true` will enable endpoint discovery for all applicable operations.
   *   Setting it to `false` will explicitly disable endpoint discovery even though
   *   operations that require endpoint discovery will presumably fail. Leaving it
   *   to `undefined` means SDK will only do endpoint discovery when it's required.
   *   Defaults to `undefined`
   * @option options endpointCacheSize [Number] the size of the global cache storing
   *   endpoints from endpoint discovery operations. Once endpoint cache is created,
   *   updating this setting cannot change existing cache size.
   *   Defaults to 1000
   * @option options hostPrefixEnabled [Boolean] whether to marshal request
   *   parameters to the prefix of hostname.
   *   Defaults to `true`.
   * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
   *   to global endpoints or regional endpoints.
   *   Defaults to 'legacy'.
   * @option options useFipsEndpoint [Boolean] Enables FIPS compatible endpoints.
   *   Defaults to `false`.
   * @option options useDualstackEndpoint [Boolean] Enables IPv6 dualstack endpoint.
   *   Defaults to `false`.
   */
  constructor: function Config(options) {
    if (options === undefined) options = {};
    options = this.extractCredentials(options);

    AWS.util.each.call(this, this.keys, function (key, value) {
      this.set(key, options[key], value);
    });
  },

  /**
   * @!group Managing Credentials
   */

  /**
   * Loads credentials from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Credentials} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your credentials are loaded prior to a request, you can use this method
   * directly to provide accurate credential data stored in the object.
   *
   * @note If you configure the SDK with static or environment credentials,
   *   the credential data should already be present in {credentials} attribute.
   *   This method is primarily necessary to load credentials from asynchronous
   *   sources, or sources that can refresh credentials periodically.
   * @example Getting your access key
   *   AWS.config.getCredentials(function(err) {
   *     if (err) console.log(err.stack); // credentials not loaded
   *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
   *   })
   * @callback callback function(err)
   *   Called when the {credentials} have been properly set on the configuration
   *   object.
   *
   *   @param err [Error] if this is set, credentials were not successfully
   *     loaded and this error provides information why.
   * @see credentials
   * @see Credentials
   */
  getCredentials: function getCredentials(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.credentials);
    }

    function credError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'CredentialsError',
        message: msg,
        name: 'CredentialsError'
      });
    }

    function getAsyncCredentials() {
      self.credentials.get(function(err) {
        if (err) {
          var msg = 'Could not load credentials from ' +
            self.credentials.constructor.name;
          err = credError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticCredentials() {
      var err = null;
      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
        err = credError('Missing credentials');
      }
      finish(err);
    }

    if (self.credentials) {
      if (typeof self.credentials.get === 'function') {
        getAsyncCredentials();
      } else { // static credentials
        getStaticCredentials();
      }
    } else if (self.credentialProvider) {
      self.credentialProvider.resolve(function(err, creds) {
        if (err) {
          err = credError('Could not load credentials from any providers', err);
        }
        self.credentials = creds;
        finish(err);
      });
    } else {
      finish(credError('No credentials to load'));
    }
  },

  /**
   * Loads token from the configuration object. This is used internally
   * by the SDK to ensure that refreshable {Token} objects are properly
   * refreshed and loaded when sending a request. If you want to ensure that
   * your token is loaded prior to a request, you can use this method
   * directly to provide accurate token data stored in the object.
   *
   * @note If you configure the SDK with static token, the token data should
   *   already be present in {token} attribute. This method is primarily necessary
   *   to load token from asynchronous sources, or sources that can refresh
   *   token periodically.
   * @example Getting your access token
   *   AWS.config.getToken(function(err) {
   *     if (err) console.log(err.stack); // token not loaded
   *     else console.log("Token:", AWS.config.token.token);
   *   })
   * @callback callback function(err)
   *   Called when the {token} have been properly set on the configuration object.
   *
   *   @param err [Error] if this is set, token was not successfully loaded and
   *     this error provides information why.
   * @see token
   */
  getToken: function getToken(callback) {
    var self = this;

    function finish(err) {
      callback(err, err ? null : self.token);
    }

    function tokenError(msg, err) {
      return new AWS.util.error(err || new Error(), {
        code: 'TokenError',
        message: msg,
        name: 'TokenError'
      });
    }

    function getAsyncToken() {
      self.token.get(function(err) {
        if (err) {
          var msg = 'Could not load token from ' +
            self.token.constructor.name;
          err = tokenError(msg, err);
        }
        finish(err);
      });
    }

    function getStaticToken() {
      var err = null;
      if (!self.token.token) {
        err = tokenError('Missing token');
      }
      finish(err);
    }

    if (self.token) {
      if (typeof self.token.get === 'function') {
        getAsyncToken();
      } else { // static token
        getStaticToken();
      }
    } else if (self.tokenProvider) {
      self.tokenProvider.resolve(function(err, token) {
        if (err) {
          err = tokenError('Could not load token from any providers', err);
        }
        self.token = token;
        finish(err);
      });
    } else {
      finish(tokenError('No token to load'));
    }
  },

  /**
   * @!group Loading and Setting Configuration Options
   */

  /**
   * @overload update(options, allowUnknownKeys = false)
   *   Updates the current configuration object with new options.
   *
   *   @example Update maxRetries property of a configuration object
   *     config.update({maxRetries: 10});
   *   @param [Object] options a map of option keys and values.
   *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
   *     the configuration object. Defaults to `false`.
   *   @see constructor
   */
  update: function update(options, allowUnknownKeys) {
    allowUnknownKeys = allowUnknownKeys || false;
    options = this.extractCredentials(options);
    AWS.util.each.call(this, options, function (key, value) {
      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||
          AWS.Service.hasService(key)) {
        this.set(key, value);
      }
    });
  },

  /**
   * Loads configuration data from a JSON file into this config object.
   * @note Loading configuration will reset all existing configuration
   *   on the object.
   * @!macro nobrowser
   * @param path [String] the path relative to your process's current
   *    working directory to load configuration from.
   * @return [AWS.Config] the same configuration object
   */
  loadFromPath: function loadFromPath(path) {
    this.clear();

    var options = JSON.parse(AWS.util.readFileSync(path));
    var fileSystemCreds = new AWS.FileSystemCredentials(path);
    var chain = new AWS.CredentialProviderChain();
    chain.providers.unshift(fileSystemCreds);
    chain.resolve(function (err, creds) {
      if (err) throw err;
      else options.credentials = creds;
    });

    this.constructor(options);

    return this;
  },

  /**
   * Clears configuration data on this object
   *
   * @api private
   */
  clear: function clear() {
    /*jshint forin:false */
    AWS.util.each.call(this, this.keys, function (key) {
      delete this[key];
    });

    // reset credential provider
    this.set('credentials', undefined);
    this.set('credentialProvider', undefined);
  },

  /**
   * Sets a property on the configuration object, allowing for a
   * default value
   * @api private
   */
  set: function set(property, value, defaultValue) {
    if (value === undefined) {
      if (defaultValue === undefined) {
        defaultValue = this.keys[property];
      }
      if (typeof defaultValue === 'function') {
        this[property] = defaultValue.call(this);
      } else {
        this[property] = defaultValue;
      }
    } else if (property === 'httpOptions' && this[property]) {
      // deep merge httpOptions
      this[property] = AWS.util.merge(this[property], value);
    } else {
      this[property] = value;
    }
  },

  /**
   * All of the keys with their default values.
   *
   * @constant
   * @api private
   */
  keys: {
    credentials: null,
    credentialProvider: null,
    region: null,
    logger: null,
    apiVersions: {},
    apiVersion: null,
    endpoint: undefined,
    httpOptions: {
      timeout: 120000
    },
    maxRetries: undefined,
    maxRedirects: 10,
    paramValidation: true,
    sslEnabled: true,
    s3ForcePathStyle: false,
    s3BucketEndpoint: false,
    s3DisableBodySigning: true,
    s3UsEast1RegionalEndpoint: 'legacy',
    s3UseArnRegion: undefined,
    computeChecksums: true,
    convertResponseTypes: true,
    correctClockSkew: false,
    customUserAgent: null,
    dynamoDbCrc32: true,
    systemClockOffset: 0,
    signatureVersion: null,
    signatureCache: true,
    retryDelayOptions: {},
    useAccelerateEndpoint: false,
    clientSideMonitoring: false,
    endpointDiscoveryEnabled: undefined,
    endpointCacheSize: 1000,
    hostPrefixEnabled: true,
    stsRegionalEndpoints: 'legacy',
    useFipsEndpoint: false,
    useDualstackEndpoint: false,
    token: null
  },

  /**
   * Extracts accessKeyId, secretAccessKey and sessionToken
   * from a configuration hash.
   *
   * @api private
   */
  extractCredentials: function extractCredentials(options) {
    if (options.accessKeyId && options.secretAccessKey) {
      options = AWS.util.copy(options);
      options.credentials = new AWS.Credentials(options);
    }
    return options;
  },

  /**
   * Sets the promise dependency the SDK will use wherever Promises are returned.
   * Passing `null` will force the SDK to use native Promises if they are available.
   * If native Promises are not available, passing `null` will have no effect.
   * @param [Constructor] dep A reference to a Promise constructor
   */
  setPromisesDependency: function setPromisesDependency(dep) {
    PromisesDependency = dep;
    // if null was passed in, we should try to use native promises
    if (dep === null && typeof Promise === 'function') {
      PromisesDependency = Promise;
    }
    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];
    if (AWS.S3) {
      constructors.push(AWS.S3);
      if (AWS.S3.ManagedUpload) {
        constructors.push(AWS.S3.ManagedUpload);
      }
    }
    AWS.util.addPromises(constructors, PromisesDependency);
  },

  /**
   * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
   */
  getPromisesDependency: function getPromisesDependency() {
    return PromisesDependency;
  }
});

/**
 * @return [AWS.Config] The global configuration object singleton instance
 * @readonly
 * @see AWS.Config
 */
AWS.config = new AWS.Config();

},{"./core":23,"./credentials":24,"./credentials/credential_provider_chain":27}],22:[function(require,module,exports){
(function (process){(function (){
var AWS = require('./core');
/**
 * @api private
 */
function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
  if (typeof configValue !== 'string') return undefined;
  else if (['legacy', 'regional'].indexOf(configValue.toLowerCase()) >= 0) {
    return configValue.toLowerCase();
  } else {
    throw AWS.util.error(new Error(), errorOptions);
  }
}

/**
 * Resolve the configuration value for regional endpoint from difference sources: client
 * config, environmental variable, shared config file. Value can be case-insensitive
 * 'legacy' or 'reginal'.
 * @param originalConfig user-supplied config object to resolve
 * @param options a map of config property names from individual configuration source
 *  - env: name of environmental variable that refers to the config
 *  - sharedConfig: name of shared configuration file property that refers to the config
 *  - clientConfig: name of client configuration property that refers to the config
 *
 * @api private
 */
function resolveRegionalEndpointsFlag(originalConfig, options) {
  originalConfig = originalConfig || {};
  //validate config value
  var resolved;
  if (originalConfig[options.clientConfig]) {
    resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
      code: 'InvalidConfiguration',
      message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy" ' +
      ' or "regional". Got "' + originalConfig[options.clientConfig] + '".'
    });
    if (resolved) return resolved;
  }
  if (!AWS.util.isNode()) return resolved;
  //validate environmental variable
  if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
    var envFlag = process.env[options.env];
    resolved = validateRegionalEndpointsFlagValue(envFlag, {
      code: 'InvalidEnvironmentalVariable',
      message: 'invalid ' + options.env + ' environmental variable. Expect "legacy" ' +
      ' or "regional". Got "' + process.env[options.env] + '".'
    });
    if (resolved) return resolved;
  }
  //validate shared config file
  var profile = {};
  try {
    var profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
    profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
  } catch (e) {};
  if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
    var fileFlag = profile[options.sharedConfig];
    resolved = validateRegionalEndpointsFlagValue(fileFlag, {
      code: 'InvalidConfiguration',
      message: 'invalid ' + options.sharedConfig + ' profile config. Expect "legacy" ' +
      ' or "regional". Got "' + profile[options.sharedConfig] + '".'
    });
    if (resolved) return resolved;
  }
  return resolved;
}

module.exports = resolveRegionalEndpointsFlag;

}).call(this)}).call(this,require('_process'))

},{"./core":23,"_process":97}],23:[function(require,module,exports){
/**
 * The main AWS namespace
 */
var AWS = { util: require('./util') };

/**
 * @api private
 * @!macro [new] nobrowser
 *   @note This feature is not supported in the browser environment of the SDK.
 */
var _hidden = {}; _hidden.toString(); // hack to parse macro

/**
 * @api private
 */
module.exports = AWS;

AWS.util.update(AWS, {

  /**
   * @constant
   */
  VERSION: '2.1220.0',

  /**
   * @api private
   */
  Signers: {},

  /**
   * @api private
   */
  Protocol: {
    Json: require('./protocol/json'),
    Query: require('./protocol/query'),
    Rest: require('./protocol/rest'),
    RestJson: require('./protocol/rest_json'),
    RestXml: require('./protocol/rest_xml')
  },

  /**
   * @api private
   */
  XML: {
    Builder: require('./xml/builder'),
    Parser: null // conditionally set based on environment
  },

  /**
   * @api private
   */
  JSON: {
    Builder: require('./json/builder'),
    Parser: require('./json/parser')
  },

  /**
   * @api private
   */
  Model: {
    Api: require('./model/api'),
    Operation: require('./model/operation'),
    Shape: require('./model/shape'),
    Paginator: require('./model/paginator'),
    ResourceWaiter: require('./model/resource_waiter')
  },

  /**
   * @api private
   */
  apiLoader: require('./api_loader'),

  /**
   * @api private
   */
  EndpointCache: require('../vendor/endpoint-cache').EndpointCache
});
require('./sequential_executor');
require('./service');
require('./config');
require('./http');
require('./event_listeners');
require('./request');
require('./response');
require('./resource_waiter');
require('./signers/request_signer');
require('./param_validator');

/**
 * @readonly
 * @return [AWS.SequentialExecutor] a collection of global event listeners that
 *   are attached to every sent request.
 * @see AWS.Request AWS.Request for a list of events to listen for
 * @example Logging the time taken to send a request
 *   AWS.events.on('send', function startSend(resp) {
 *     resp.startTime = new Date().getTime();
 *   }).on('complete', function calculateTime(resp) {
 *     var time = (new Date().getTime() - resp.startTime) / 1000;
 *     console.log('Request took ' + time + ' seconds');
 *   });
 *
 *   new AWS.S3().listBuckets(); // prints 'Request took 0.285 seconds'
 */
AWS.events = new AWS.SequentialExecutor();

//create endpoint cache lazily
AWS.util.memoizedProperty(AWS, 'endpointCache', function() {
  return new AWS.EndpointCache(AWS.config.endpointCacheSize);
}, true);

},{"../vendor/endpoint-cache":87,"./api_loader":13,"./config":21,"./event_listeners":38,"./http":39,"./json/builder":41,"./json/parser":42,"./model/api":43,"./model/operation":45,"./model/paginator":46,"./model/resource_waiter":47,"./model/shape":48,"./param_validator":49,"./protocol/json":51,"./protocol/query":52,"./protocol/rest":53,"./protocol/rest_json":54,"./protocol/rest_xml":55,"./request":61,"./resource_waiter":62,"./response":63,"./sequential_executor":65,"./service":66,"./signers/request_signer":72,"./util":80,"./xml/builder":82}],24:[function(require,module,exports){
var AWS = require('./core');

/**
 * Represents your AWS security credentials, specifically the
 * {accessKeyId}, {secretAccessKey}, and optional {sessionToken}.
 * Creating a `Credentials` object allows you to pass around your
 * security information to configuration and service objects.
 *
 * Note that this class typically does not need to be constructed manually,
 * as the {AWS.Config} and {AWS.Service} classes both accept simple
 * options hashes with the three keys. These structures will be converted
 * into Credentials objects automatically.
 *
 * ## Expiring and Refreshing Credentials
 *
 * Occasionally credentials can expire in the middle of a long-running
 * application. In this case, the SDK will automatically attempt to
 * refresh the credentials from the storage location if the Credentials
 * class implements the {refresh} method.
 *
 * If you are implementing a credential storage location, you
 * will want to create a subclass of the `Credentials` class and
 * override the {refresh} method. This method allows credentials to be
 * retrieved from the backing store, be it a file system, database, or
 * some network storage. The method should reset the credential attributes
 * on the object.
 *
 * @!attribute expired
 *   @return [Boolean] whether the credentials have been expired and
 *     require a refresh. Used in conjunction with {expireTime}.
 * @!attribute expireTime
 *   @return [Date] a time when credentials should be considered expired. Used
 *     in conjunction with {expired}.
 * @!attribute accessKeyId
 *   @return [String] the AWS access key ID
 * @!attribute secretAccessKey
 *   @return [String] the AWS secret access key
 * @!attribute sessionToken
 *   @return [String] an optional AWS session token
 */
AWS.Credentials = AWS.util.inherit({
  /**
   * A credentials object can be created using positional arguments or an options
   * hash.
   *
   * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
   *   Creates a Credentials object with a given set of credential information
   *   as positional arguments.
   *   @param accessKeyId [String] the AWS access key ID
   *   @param secretAccessKey [String] the AWS secret access key
   *   @param sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials('akid', 'secret', 'session');
   * @overload AWS.Credentials(options)
   *   Creates a Credentials object with a given set of credential information
   *   as an options hash.
   *   @option options accessKeyId [String] the AWS access key ID
   *   @option options secretAccessKey [String] the AWS secret access key
   *   @option options sessionToken [String] the optional AWS session token
   *   @example Create a credentials object with AWS credentials
   *     var creds = new AWS.Credentials({
   *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
   *     });
   */
  constructor: function Credentials() {
    // hide secretAccessKey from being displayed with util.inspect
    AWS.util.hideProperties(this, ['secretAccessKey']);

    this.expired = false;
    this.expireTime = null;
    this.refreshCallbacks = [];
    if (arguments.length === 1 && typeof arguments[0] === 'object') {
      var creds = arguments[0].credentials || arguments[0];
      this.accessKeyId = creds.accessKeyId;
      this.secretAccessKey = creds.secretAccessKey;
      this.sessionToken = creds.sessionToken;
    } else {
      this.accessKeyId = arguments[0];
      this.secretAccessKey = arguments[1];
      this.sessionToken = arguments[2];
    }
  },

  /**
   * @return [Integer] the number of seconds before {expireTime} during which
   *   the credentials will be considered expired.
   */
  expiryWindow: 15,

  /**
   * @return [Boolean] whether the credentials object should call {refresh}
   * @note Subclasses should override this method to provide custom refresh
   *   logic.
   */
  needsRefresh: function needsRefresh() {
    var currentTime = AWS.util.date.getDate().getTime();
    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);

    if (this.expireTime && adjustedTime > this.expireTime) {
      return true;
    } else {
      return this.expired || !this.accessKeyId || !this.secretAccessKey;
    }
  },

  /**
   * Gets the existing credentials, refreshing them if they are not yet loaded
   * or have expired. Users should call this method before using {refresh},
   * as this will not attempt to reload credentials when they are already
   * loaded into the object.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means either credentials
   *   do not need to be refreshed or refreshed credentials information has
   *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
   *   and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   */
  get: function get(callback) {
    var self = this;
    if (this.needsRefresh()) {
      this.refresh(function(err) {
        if (!err) self.expired = false; // reset expired flag
        if (callback) callback(err);
      });
    } else if (callback) {
      callback();
    }
  },

  /**
   * @!method  getPromise()
   *   Returns a 'thenable' promise.
   *   Gets the existing credentials, refreshing them if they are not yet loaded
   *   or have expired. Users should call this method before using {refresh},
   *   as this will not attempt to reload credentials when they are already
   *   loaded into the object.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means either credentials do not need to be refreshed or refreshed
   *     credentials information has been loaded into the object (as the
   *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `get` call.
   *   @example Calling the `getPromise` method.
   *     var promise = credProvider.getPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * @!method  refreshPromise()
   *   Returns a 'thenable' promise.
   *   Refreshes the credentials. Users should call {get} before attempting
   *   to forcibly refresh credentials.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function()
   *     Called if the promise is fulfilled. When this callback is called, it
   *     means refreshed credentials information has been loaded into the object
   *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Calling the `refreshPromise` method.
   *     var promise = credProvider.refreshPromise();
   *     promise.then(function() { ... }, function(err) { ... });
   */

  /**
   * Refreshes the credentials. Users should call {get} before attempting
   * to forcibly refresh credentials.
   *
   * @callback callback function(err)
   *   When this callback is called with no error, it means refreshed
   *   credentials information has been loaded into the object (as the
   *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @note Subclasses should override this class to reset the
   *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
   *   on the credentials object and then call the callback with
   *   any error information.
   * @see get
   */
  refresh: function refresh(callback) {
    this.expired = false;
    callback();
  },

  /**
   * @api private
   * @param callback
   */
  coalesceRefresh: function coalesceRefresh(callback, sync) {
    var self = this;
    if (self.refreshCallbacks.push(callback) === 1) {
      self.load(function onLoad(err) {
        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {
          if (sync) {
            callback(err);
          } else {
            // callback could throw, so defer to ensure all callbacks are notified
            AWS.util.defer(function () {
              callback(err);
            });
          }
        });
        self.refreshCallbacks.length = 0;
      });
    }
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    callback();
  }
});

/**
 * @api private
 */
AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);
  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);
};

/**
 * @api private
 */
AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getPromise;
  delete this.prototype.refreshPromise;
};

AWS.util.addPromises(AWS.Credentials);

},{"./core":23}],25:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * AWS.ChainableTemporaryCredentials differs from AWS.TemporaryCredentials in
 * the way masterCredentials and refreshes are handled.
 * AWS.ChainableTemporaryCredentials refreshes expired credentials using the
 * masterCredentials passed by the user to support chaining of STS credentials.
 * However, AWS.TemporaryCredentials recursively collapses the masterCredentials
 * during instantiation, precluding the ability to refresh credentials which
 * require intermediate, temporary credentials.
 *
 * For example, if the application should use RoleA, which must be assumed from
 * RoleB, and the environment provides credentials which can assume RoleB, then
 * AWS.ChainableTemporaryCredentials must be used to support refreshing the
 * temporary credentials for RoleA:
 *
 * ```javascript
 * var roleACreds = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: 'RoleA'},
 *   masterCredentials: new AWS.ChainableTemporaryCredentials({
 *     params: {RoleArn: 'RoleB'},
 *     masterCredentials: new AWS.EnvironmentCredentials('AWS')
 *   })
 * });
 * ```
 *
 * If AWS.TemporaryCredentials had been used in the previous example,
 * `roleACreds` would fail to refresh because `roleACreds` would
 * use the environment credentials for the AssumeRole request.
 *
 * Another difference is that AWS.ChainableTemporaryCredentials creates the STS
 * service instance during instantiation while AWS.TemporaryCredentials creates
 * the STS service instance during the first refresh. Creating the service
 * instance during instantiation effectively captures the master credentials
 * from the global config, so that subsequent changes to the global config do
 * not affect the master credentials used to refresh the temporary credentials.
 *
 * This allows an instance of AWS.ChainableTemporaryCredentials to be assigned
 * to AWS.config.credentials:
 *
 * ```javascript
 * var envCreds = new AWS.EnvironmentCredentials('AWS');
 * AWS.config.credentials = envCreds;
 * // masterCredentials will be envCreds
 * AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * Similarly, to use the CredentialProviderChain's default providers as the
 * master credentials, simply create a new instance of
 * AWS.ChainableTemporaryCredentials:
 *
 * ```javascript
 * AWS.config.credentials = new ChainableTemporaryCredentials({
 *   params: {RoleArn: '...'}
 * });
 * ```
 *
 * @!attribute service
 *   @return [AWS.STS] the STS service instance used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.ChainableTemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @param options [map] a set of options
   * @option options params [map] ({}) a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
   *   also be passed in or an error will be thrown.
   * @option options masterCredentials [AWS.Credentials] the master credentials
   *   used to get and refresh temporary credentials from AWS STS. By default,
   *   AWS.config.credentials or AWS.config.credentialProvider will be used.
   * @option options tokenCodeFn [Function] (null) Function to provide
   *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
   *   is called with value of `SerialNumber` and `callback`, and should provide
   *   the `TokenCode` or an error to the callback in the format
   *   `callback(err, token)`.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
   *     params: {
   *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
   *     }
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function ChainableTemporaryCredentials(options) {
    AWS.Credentials.call(this);
    options = options || {};
    this.errorCode = 'ChainableTemporaryCredentialsProviderFailure';
    this.expired = true;
    this.tokenCodeFn = null;

    var params = AWS.util.copy(options.params) || {};
    if (params.RoleArn) {
      params.RoleSessionName = params.RoleSessionName || 'temporary-credentials';
    }
    if (params.SerialNumber) {
      if (!options.tokenCodeFn || (typeof options.tokenCodeFn !== 'function')) {
        throw new AWS.util.error(
          new Error('tokenCodeFn must be a function when params.SerialNumber is given'),
          {code: this.errorCode}
        );
      } else {
        this.tokenCodeFn = options.tokenCodeFn;
      }
    }
    var config = AWS.util.merge(
      {
        params: params,
        credentials: options.masterCredentials || AWS.config.credentials
      },
      options.stsConfig || {}
    );
    this.service = new STS(config);
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    var operation = self.service.config.params.RoleArn ? 'assumeRole' : 'getSessionToken';
    this.getTokenCode(function (err, tokenCode) {
      var params = {};
      if (err) {
        callback(err);
        return;
      }
      if (tokenCode) {
        params.TokenCode = tokenCode;
      }
      self.service[operation](params, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  getTokenCode: function getTokenCode(callback) {
    var self = this;
    if (this.tokenCodeFn) {
      this.tokenCodeFn(this.service.config.params.SerialNumber, function (err, token) {
        if (err) {
          var message = err;
          if (err instanceof Error) {
            message = err.message;
          }
          callback(
            AWS.util.error(
              new Error('Error fetching MFA token: ' + message),
              { code: self.errorCode}
            )
          );
          return;
        }
        callback(null, token);
      });
    } else {
      callback(null);
    }
  }
});

},{"../../clients/sts":12,"../core":23}],26:[function(require,module,exports){
var AWS = require('../core');
var CognitoIdentity = require('../../clients/cognitoidentity');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS Web Identity Federation using
 * the Amazon Cognito Identity service.
 *
 * By default this provider gets credentials using the
 * {AWS.CognitoIdentity.getCredentialsForIdentity} service operation, which
 * requires either an `IdentityId` or an `IdentityPoolId` (Amazon Cognito
 * Identity Pool ID), which is used to call {AWS.CognitoIdentity.getId} to
 * obtain an `IdentityId`. If the identity or identity pool is not configured in
 * the Amazon Cognito Console to use IAM roles with the appropriate permissions,
 * then additionally a `RoleArn` is required containing the ARN of the IAM trust
 * policy for the Amazon Cognito role that the user will log into. If a `RoleArn`
 * is provided, then this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation, after first getting an
 * Open ID token from {AWS.CognitoIdentity.getOpenIdToken}.
 *
 * In addition, if this credential provider is used to provide authenticated
 * login, the `Logins` map may be set to the tokens provided by the respective
 * identity providers. See {constructor} for an example on creating a credentials
 * object with proper property values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.Logins['graph.facebook.com'] = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.CognitoIdentity.getId},
 *     {AWS.CognitoIdentity.getOpenIdToken}, and
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.CognitoIdentity.getCredentialsForIdentity}, or
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 * @!attribute identityId
 *   @return [String] the Cognito ID returned by the last call to
 *     {AWS.CognitoIdentity.getOpenIdToken}. This ID represents the actual
 *     final resolved identity ID from Amazon Cognito.
 */
AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * @api private
   */
  localStorageKey: {
    id: 'aws.cognito.identity-id.',
    providers: 'aws.cognito.identity-providers.'
  },

  /**
   * Creates a new credentials object.
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
   *
   *     // either IdentityPoolId or IdentityId is required
   *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
   *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
   *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
   *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
   *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
   *
   *     // optional, only necessary when the identity pool is not configured
   *     // to use IAM roles in the Amazon Cognito Console
   *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
   *
   *     // optional tokens, used for authenticated login
   *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
   *     Logins: {
   *       'graph.facebook.com': 'FBTOKEN',
   *       'www.amazon.com': 'AMAZONTOKEN',
   *       'accounts.google.com': 'GOOGLETOKEN',
   *       'api.twitter.com': 'TWITTERTOKEN',
   *       'www.digits.com': 'DIGITSTOKEN'
   *     },
   *
   *     // optional name, defaults to web-identity
   *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
   *     RoleSessionName: 'web',
   *
   *     // optional, only necessary when application runs in a browser
   *     // and multiple users are signed in at once, used for caching
   *     LoginId: 'example@gmail.com'
   *
   *   }, {
   *      // optionally provide configuration to apply to the underlying service clients
   *      // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *      // region should match the region your identity pool is located in
   *      region: 'us-east-1',
   *
   *      // specify timeout options
   *      httpOptions: {
   *        timeout: 100
   *      }
   *   });
   * @see AWS.CognitoIdentity.getId
   * @see AWS.CognitoIdentity.getCredentialsForIdentity
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.CognitoIdentity.getOpenIdToken
   * @see AWS.Config
   * @note If a region is not provided in the global AWS.config, or
   *   specified in the `clientConfig` to the CognitoIdentityCredentials
   *   constructor, you may encounter a 'Missing credentials in config' error
   *   when calling making a service call.
   */
  constructor: function CognitoIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.data = null;
    this._identityId = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
    this.loadCachedId();
    var self = this;
    Object.defineProperty(this, 'identityId', {
      get: function() {
        self.loadCachedId();
        return self._identityId || self.params.IdentityId;
      },
      set: function(identityId) {
        self._identityId = identityId;
      }
    });
  },

  /**
   * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
   * or {AWS.STS.assumeRoleWithWebIdentity}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see AWS.Credentials.get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   * @param callback
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.data = null;
    self._identityId = null;
    self.getId(function(err) {
      if (!err) {
        if (!self.params.RoleArn) {
          self.getCredentialsForIdentity(callback);
        } else {
          self.getCredentialsFromSTS(callback);
        }
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * Clears the cached Cognito ID associated with the currently configured
   * identity pool ID. Use this to manually invalidate your cache if
   * the identity pool ID was deleted.
   */
  clearCachedId: function clearCache() {
    this._identityId = null;
    delete this.params.IdentityId;

    var poolId = this.params.IdentityPoolId;
    var loginId = this.params.LoginId || '';
    delete this.storage[this.localStorageKey.id + poolId + loginId];
    delete this.storage[this.localStorageKey.providers + poolId + loginId];
  },

  /**
   * @api private
   */
  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
    var self = this;
    if (err.code == 'NotAuthorizedException') {
      self.clearCachedId();
    }
  },

  /**
   * Retrieves a Cognito ID, loading from cache if it was already retrieved
   * on this device.
   *
   * @callback callback function(err, identityId)
   *   @param err [Error, null] an error object if the call failed or null if
   *     it succeeded.
   *   @param identityId [String, null] if successful, the callback will return
   *     the Cognito ID.
   * @note If not loaded explicitly, the Cognito ID is loaded and stored in
   *   localStorage in the browser environment of a device.
   * @api private
   */
  getId: function getId(callback) {
    var self = this;
    if (typeof self.params.IdentityId === 'string') {
      return callback(null, self.params.IdentityId);
    }

    self.cognito.getId(function(err, data) {
      if (!err && data.IdentityId) {
        self.params.IdentityId = data.IdentityId;
        callback(null, data.IdentityId);
      } else {
        callback(err);
      }
    });
  },


  /**
   * @api private
   */
  loadCredentials: function loadCredentials(data, credentials) {
    if (!data || !credentials) return;
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
  },

  /**
   * @api private
   */
  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
    var self = this;
    self.cognito.getCredentialsForIdentity(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.data = data;
        self.loadCredentials(self.data, self);
      } else {
        self.clearIdOnNotAuthorized(err);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
    var self = this;
    self.cognito.getOpenIdToken(function(err, data) {
      if (!err) {
        self.cacheId(data);
        self.params.WebIdentityToken = data.Token;
        self.webIdentityCredentials.refresh(function(webErr) {
          if (!webErr) {
            self.data = self.webIdentityCredentials.data;
            self.sts.credentialsFrom(self.data, self);
          }
          callback(webErr);
        });
      } else {
        self.clearIdOnNotAuthorized(err);
        callback(err);
      }
    });
  },

  /**
   * @api private
   */
  loadCachedId: function loadCachedId() {
    var self = this;

    // in the browser we source default IdentityId from localStorage
    if (AWS.util.isBrowser() && !self.params.IdentityId) {
      var id = self.getStorage('id');
      if (id && self.params.Logins) {
        var actualProviders = Object.keys(self.params.Logins);
        var cachedProviders =
          (self.getStorage('providers') || '').split(',');

        // only load ID if at least one provider used this ID before
        var intersect = cachedProviders.filter(function(n) {
          return actualProviders.indexOf(n) !== -1;
        });
        if (intersect.length !== 0) {
          self.params.IdentityId = id;
        }
      } else if (id) {
        self.params.IdentityId = id;
      }
    }
  },

  /**
   * @api private
   */
  createClients: function() {
    var clientConfig = this._clientConfig;
    this.webIdentityCredentials = this.webIdentityCredentials ||
      new AWS.WebIdentityCredentials(this.params, clientConfig);
    if (!this.cognito) {
      var cognitoConfig = AWS.util.merge({}, clientConfig);
      cognitoConfig.params = this.params;
      this.cognito = new CognitoIdentity(cognitoConfig);
    }
    this.sts = this.sts || new STS(clientConfig);
  },

  /**
   * @api private
   */
  cacheId: function cacheId(data) {
    this._identityId = data.IdentityId;
    this.params.IdentityId = this._identityId;

    // cache this IdentityId in browser localStorage if possible
    if (AWS.util.isBrowser()) {
      this.setStorage('id', data.IdentityId);

      if (this.params.Logins) {
        this.setStorage('providers', Object.keys(this.params.Logins).join(','));
      }
    }
  },

  /**
   * @api private
   */
  getStorage: function getStorage(key) {
    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];
  },

  /**
   * @api private
   */
  setStorage: function setStorage(key, val) {
    try {
      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;
    } catch (_) {}
  },

  /**
   * @api private
   */
  storage: (function() {
    try {
      var storage = AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === 'object' ?
          window.localStorage : {};

      // Test set/remove which would throw an error in Safari's private browsing
      storage['aws.test-storage'] = 'foobar';
      delete storage['aws.test-storage'];

      return storage;
    } catch (_) {
      return {};
    }
  })()
});

},{"../../clients/cognitoidentity":10,"../../clients/sts":12,"../core":23}],27:[function(require,module,exports){
var AWS = require('../core');

/**
 * Creates a credential provider chain that searches for AWS credentials
 * in a list of credential providers specified by the {providers} property.
 *
 * By default, the chain will use the {defaultProviders} to resolve credentials.
 * These providers will look in the environment using the
 * {AWS.EnvironmentCredentials} class with the 'AWS' and 'AMAZON' prefixes.
 *
 * ## Setting Providers
 *
 * Each provider in the {providers} list should be a function that returns
 * a {AWS.Credentials} object, or a hardcoded credentials object. The function
 * form allows for delayed execution of the credential construction.
 *
 * ## Resolving Credentials from a Chain
 *
 * Call {resolve} to return the first valid credential object that can be
 * loaded by the provider chain.
 *
 * For example, to resolve a chain with a custom provider that checks a file
 * on disk after the set of {defaultProviders}:
 *
 * ```javascript
 * var diskProvider = new AWS.FileSystemCredentials('./creds.json');
 * var chain = new AWS.CredentialProviderChain();
 * chain.providers.push(diskProvider);
 * chain.resolve();
 * ```
 *
 * The above code will return the `diskProvider` object if the
 * file contains credentials and the `defaultProviders` do not contain
 * any credential settings.
 *
 * @!attribute providers
 *   @return [Array<AWS.Credentials, Function>]
 *     a list of credentials objects or functions that return credentials
 *     objects. If the provider is a function, the function will be
 *     executed lazily when the provider needs to be checked for valid
 *     credentials. By default, this object will be set to the
 *     {defaultProviders}.
 *   @see defaultProviders
 */
AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {

  /**
   * Creates a new CredentialProviderChain with a default set of providers
   * specified by {defaultProviders}.
   */
  constructor: function CredentialProviderChain(providers) {
    if (providers) {
      this.providers = providers;
    } else {
      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);
    }
    this.resolveCallbacks = [];
  },

  /**
   * @!method  resolvePromise()
   *   Returns a 'thenable' promise.
   *   Resolves the provider chain by searching for the first set of
   *   credentials in {providers}.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(credentials)
   *     Called if the promise is fulfilled and the provider resolves the chain
   *     to a credentials object
   *     @param credentials [AWS.Credentials] the credentials object resolved
   *       by the provider chain.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param err [Error] the error object returned if no credentials are found.
   *   @return [Promise] A promise that represents the state of the `resolve` method call.
   *   @example Calling the `resolvePromise` method.
   *     var promise = chain.resolvePromise();
   *     promise.then(function(credentials) { ... }, function(err) { ... });
   */

  /**
   * Resolves the provider chain by searching for the first set of
   * credentials in {providers}.
   *
   * @callback callback function(err, credentials)
   *   Called when the provider resolves the chain to a credentials object
   *   or null if no credentials can be found.
   *
   *   @param err [Error] the error object returned if no credentials are
   *     found.
   *   @param credentials [AWS.Credentials] the credentials object resolved
   *     by the provider chain.
   * @return [AWS.CredentialProviderChain] the provider, for chaining.
   */
  resolve: function resolve(callback) {
    var self = this;
    if (self.providers.length === 0) {
      callback(new Error('No providers'));
      return self;
    }

    if (self.resolveCallbacks.push(callback) === 1) {
      var index = 0;
      var providers = self.providers.slice(0);

      function resolveNext(err, creds) {
        if ((!err && creds) || index === providers.length) {
          AWS.util.arrayEach(self.resolveCallbacks, function (callback) {
            callback(err, creds);
          });
          self.resolveCallbacks.length = 0;
          return;
        }

        var provider = providers[index++];
        if (typeof provider === 'function') {
          creds = provider.call();
        } else {
          creds = provider;
        }

        if (creds.get) {
          creds.get(function (getErr) {
            resolveNext(getErr, getErr ? null : creds);
          });
        } else {
          resolveNext(null, creds);
        }
      }

      resolveNext();
    }

    return self;
  }
});

/**
 * The default set of providers used by a vanilla CredentialProviderChain.
 *
 * In the browser:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = []
 * ```
 *
 * In Node.js:
 *
 * ```javascript
 * AWS.CredentialProviderChain.defaultProviders = [
 *   function () { return new AWS.EnvironmentCredentials('AWS'); },
 *   function () { return new AWS.EnvironmentCredentials('AMAZON'); },
 *   function () { return new AWS.SsoCredentials(); },
 *   function () { return new AWS.SharedIniFileCredentials(); },
 *   function () { return new AWS.ECSCredentials(); },
 *   function () { return new AWS.ProcessCredentials(); },
 *   function () { return new AWS.TokenFileWebIdentityCredentials(); },
 *   function () { return new AWS.EC2MetadataCredentials() }
 * ]
 * ```
 */
AWS.CredentialProviderChain.defaultProviders = [];

/**
 * @api private
 */
AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);
};

/**
 * @api private
 */
AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.resolvePromise;
};

AWS.util.addPromises(AWS.CredentialProviderChain);

},{"../core":23}],28:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS SAML support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithSAML} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given, as well as a `PrincipalArn`
 * representing the ARN for the SAML identity provider. In addition, the
 * `SAMLAssertion` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn`, `PrincipalArn`, and `SAMLAssertion` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the SAMLAssertion, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.SAMLAssertion = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithSAML}. To update the token, set the
 *     `params.SAMLAssertion` property.
 */
AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithSAML)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.SAMLCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
   *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
   *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
   *   });
   * @see AWS.STS.assumeRoleWithSAML
   */
  constructor: function SAMLCredentials(params) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithSAML(function (err, data) {
      if (!err) {
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":12,"../core":23}],29:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents temporary credentials retrieved from {AWS.STS}. Without any
 * extra parameters, credentials will be fetched from the
 * {AWS.STS.getSessionToken} operation. If an IAM role is provided, the
 * {AWS.STS.assumeRole} operation will be used to fetch credentials for the
 * role instead.
 *
 * @note AWS.TemporaryCredentials is deprecated, but remains available for
 *   backwards compatibility. {AWS.ChainableTemporaryCredentials} is the
 *   preferred class for temporary credentials.
 *
 * To setup temporary credentials, configure a set of master credentials
 * using the standard credentials providers (environment, EC2 instance metadata,
 * or from the filesystem), then set the global credentials to a new
 * temporary credentials object:
 *
 * ```javascript
 * // Note that environment credentials are loaded by default,
 * // the following line is shown for clarity:
 * AWS.config.credentials = new AWS.EnvironmentCredentials('AWS');
 *
 * // Now set temporary credentials seeded from the master credentials
 * AWS.config.credentials = new AWS.TemporaryCredentials();
 *
 * // subsequent requests will now use temporary credentials from AWS STS.
 * new AWS.S3().listBucket(function(err, data) { ... });
 * ```
 *
 * @!attribute masterCredentials
 *   @return [AWS.Credentials] the master (non-temporary) credentials used to
 *     get and refresh temporary credentials from AWS STS.
 * @note (see constructor)
 */
AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new temporary credentials object.
   *
   * @note In order to create temporary credentials, you first need to have
   *   "master" credentials configured in {AWS.Config.credentials}. These
   *   master credentials are necessary to retrieve the temporary credentials,
   *   as well as refresh the credentials when they expire.
   * @param params [map] a map of options that are passed to the
   *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
   *   If a `RoleArn` parameter is passed in, credentials will be based on the
   *   IAM role.
   * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
   *  used to get and refresh temporary credentials from AWS STS.
   * @example Creating a new credentials object for generic temporary credentials
   *   AWS.config.credentials = new AWS.TemporaryCredentials();
   * @example Creating a new credentials object for an IAM role
   *   AWS.config.credentials = new AWS.TemporaryCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
   *   });
   * @see AWS.STS.assumeRole
   * @see AWS.STS.getSessionToken
   */
  constructor: function TemporaryCredentials(params, masterCredentials) {
    AWS.Credentials.call(this);
    this.loadMasterCredentials(masterCredentials);
    this.expired = true;

    this.params = params || {};
    if (this.params.RoleArn) {
      this.params.RoleSessionName =
        this.params.RoleSessionName || 'temporary-credentials';
    }
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRole} or
   * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
   * to the credentials {constructor}.
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh (callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load (callback) {
    var self = this;
    self.createClients();
    self.masterCredentials.get(function () {
      self.service.config.credentials = self.masterCredentials;
      var operation = self.params.RoleArn ?
        self.service.assumeRole : self.service.getSessionToken;
      operation.call(self.service, function (err, data) {
        if (!err) {
          self.service.credentialsFrom(data, self);
        }
        callback(err);
      });
    });
  },

  /**
   * @api private
   */
  loadMasterCredentials: function loadMasterCredentials (masterCredentials) {
    this.masterCredentials = masterCredentials || AWS.config.credentials;
    while (this.masterCredentials.masterCredentials) {
      this.masterCredentials = this.masterCredentials.masterCredentials;
    }

    if (typeof this.masterCredentials.get !== 'function') {
      this.masterCredentials = new AWS.Credentials(this.masterCredentials);
    }
  },

  /**
   * @api private
   */
  createClients: function () {
    this.service = this.service || new STS({params: this.params});
  }

});

},{"../../clients/sts":12,"../core":23}],30:[function(require,module,exports){
var AWS = require('../core');
var STS = require('../../clients/sts');

/**
 * Represents credentials retrieved from STS Web Identity Federation support.
 *
 * By default this provider gets credentials using the
 * {AWS.STS.assumeRoleWithWebIdentity} service operation. This operation
 * requires a `RoleArn` containing the ARN of the IAM trust policy for the
 * application for which credentials will be given. In addition, the
 * `WebIdentityToken` must be set to the token provided by the identity
 * provider. See {constructor} for an example on creating a credentials
 * object with proper `RoleArn` and `WebIdentityToken` values.
 *
 * ## Refreshing Credentials from Identity Service
 *
 * In addition to AWS credentials expiring after a given amount of time, the
 * login token from the identity provider will also expire. Once this token
 * expires, it will not be usable to refresh AWS credentials, and another
 * token will be needed. The SDK does not manage refreshing of the token value,
 * but this can be done through a "refresh token" supported by most identity
 * providers. Consult the documentation for the identity provider for refreshing
 * tokens. Once the refreshed token is acquired, you should make sure to update
 * this new token in the credentials object's {params} property. The following
 * code will update the WebIdentityToken, assuming you have retrieved an updated
 * token from the identity provider:
 *
 * ```javascript
 * AWS.config.credentials.params.WebIdentityToken = updatedToken;
 * ```
 *
 * Future calls to `credentials.refresh()` will now use the new token.
 *
 * @!attribute params
 *   @return [map] the map of params passed to
 *     {AWS.STS.assumeRoleWithWebIdentity}. To update the token, set the
 *     `params.WebIdentityToken` property.
 * @!attribute data
 *   @return [map] the raw data response from the call to
 *     {AWS.STS.assumeRoleWithWebIdentity}. Use this if you want to get
 *     access to other properties from the response.
 */
AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {
  /**
   * Creates a new credentials object.
   * @param (see AWS.STS.assumeRoleWithWebIdentity)
   * @example Creating a new credentials object
   *   AWS.config.credentials = new AWS.WebIdentityCredentials({
   *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
   *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
   *     RoleSessionName: 'web' // optional name, defaults to web-identity
   *   }, {
   *     // optionally provide configuration to apply to the underlying AWS.STS service client
   *     // if configuration is not provided, then configuration will be pulled from AWS.config
   *
   *     // specify timeout options
   *     httpOptions: {
   *       timeout: 100
   *     }
   *   });
   * @see AWS.STS.assumeRoleWithWebIdentity
   * @see AWS.Config
   */
  constructor: function WebIdentityCredentials(params, clientConfig) {
    AWS.Credentials.call(this);
    this.expired = true;
    this.params = params;
    this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';
    this.data = null;
    this._clientConfig = AWS.util.copy(clientConfig || {});
  },

  /**
   * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
   *
   * @callback callback function(err)
   *   Called when the STS service responds (or fails). When
   *   this callback is called with no error, it means that the credentials
   *   information has been loaded into the object (as the `accessKeyId`,
   *   `secretAccessKey`, and `sessionToken` properties).
   *   @param err [Error] if an error occurred, this value will be filled
   * @see get
   */
  refresh: function refresh(callback) {
    this.coalesceRefresh(callback || AWS.util.fn.callback);
  },

  /**
   * @api private
   */
  load: function load(callback) {
    var self = this;
    self.createClients();
    self.service.assumeRoleWithWebIdentity(function (err, data) {
      self.data = null;
      if (!err) {
        self.data = data;
        self.service.credentialsFrom(data, self);
      }
      callback(err);
    });
  },

  /**
   * @api private
   */
  createClients: function() {
    if (!this.service) {
      var stsConfig = AWS.util.merge({}, this._clientConfig);
      stsConfig.params = this.params;
      this.service = new STS(stsConfig);
    }
  }

});

},{"../../clients/sts":12,"../core":23}],31:[function(require,module,exports){
(function (process){(function (){
var AWS = require('./core');
var util = require('./util');
var endpointDiscoveryEnabledEnvs = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'];

/**
 * Generate key (except resources and operation part) to index the endpoints in the cache
 * If input shape has endpointdiscoveryid trait then use
 *   accessKey + operation + resources + region + service as cache key
 * If input shape doesn't have endpointdiscoveryid trait then use
 *   accessKey + region + service as cache key
 * @return [map<String,String>] object with keys to index endpoints.
 * @api private
 */
function getCacheKey(request) {
  var service = request.service;
  var api = service.api || {};
  var operations = api.operations;
  var identifiers = {};
  if (service.config.region) {
    identifiers.region = service.config.region;
  }
  if (api.serviceId) {
    identifiers.serviceId = api.serviceId;
  }
  if (service.config.credentials.accessKeyId) {
    identifiers.accessKeyId = service.config.credentials.accessKeyId;
  }
  return identifiers;
}

/**
 * Recursive helper for marshallCustomIdentifiers().
 * Looks for required string input members that have 'endpointdiscoveryid' trait.
 * @api private
 */
function marshallCustomIdentifiersHelper(result, params, shape) {
  if (!shape || params === undefined || params === null) return;
  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {
    util.arrayEach(shape.required, function(name) {
      var memberShape = shape.members[name];
      if (memberShape.endpointDiscoveryId === true) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        result[locationName] = String(params[name]);
      } else {
        marshallCustomIdentifiersHelper(result, params[name], memberShape);
      }
    });
  }
}

/**
 * Get custom identifiers for cache key.
 * Identifies custom identifiers by checking each shape's `endpointDiscoveryId` trait.
 * @param [object] request object
 * @param [object] input shape of the given operation's api
 * @api private
 */
function marshallCustomIdentifiers(request, shape) {
  var identifiers = {};
  marshallCustomIdentifiersHelper(identifiers, request.params, shape);
  return identifiers;
}

/**
 * Call endpoint discovery operation when it's optional.
 * When endpoint is available in cache then use the cached endpoints. If endpoints
 * are unavailable then use regional endpoints and call endpoint discovery operation
 * asynchronously. This is turned off by default.
 * @param [object] request object
 * @api private
 */
function optionalDiscoverEndpoint(request) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var endpoints = AWS.endpointCache.get(cacheKey);
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //or endpoint operation just failed in 1 minute
    return;
  } else if (endpoints && endpoints.length > 0) {
    //found endpoint record from cache
    request.httpRequest.updateEndpoint(endpoints[0].Address);
  } else {
    //endpoint record not in cache or outdated. make discovery operation
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    addApiVersionHeader(endpointRequest);
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    endpointRequest.removeListener('retry', AWS.EventListeners.Core.RETRY_CHECK);
    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKey, [{
      Address: '',
      CachePeriodInMinutes: 1
    }]);
    endpointRequest.send(function(err, data) {
      if (data && data.Endpoints) {
        AWS.endpointCache.put(cacheKey, data.Endpoints);
      } else if (err) {
        AWS.endpointCache.put(cacheKey, [{
          Address: '',
          CachePeriodInMinutes: 1 //not to make more endpoint operation in next 1 minute
        }]);
      }
    });
  }
}

var requestQueue = {};

/**
 * Call endpoint discovery operation when it's required.
 * When endpoint is available in cache then use cached ones. If endpoints are
 * unavailable then SDK should call endpoint operation then use returned new
 * endpoint for the api call. SDK will automatically attempt to do endpoint
 * discovery. This is turned off by default
 * @param [object] request object
 * @api private
 */
function requiredDiscoverEndpoint(request, done) {
  var service = request.service;
  var api = service.api;
  var operationModel = api.operations ? api.operations[request.operation] : undefined;
  var inputShape = operationModel ? operationModel.input : undefined;

  var identifiers = marshallCustomIdentifiers(request, inputShape);
  var cacheKey = getCacheKey(request);
  if (Object.keys(identifiers).length > 0) {
    cacheKey = util.update(cacheKey, identifiers);
    if (operationModel) cacheKey.operation = operationModel.name;
  }
  var cacheKeyStr = AWS.EndpointCache.getKeyString(cacheKey);
  var endpoints = AWS.endpointCache.get(cacheKeyStr); //endpoint cache also accepts string keys
  if (endpoints && endpoints.length === 1 && endpoints[0].Address === '') {
    //endpoint operation is being made but response not yet received
    //push request object to a pending queue
    if (!requestQueue[cacheKeyStr]) requestQueue[cacheKeyStr] = [];
    requestQueue[cacheKeyStr].push({request: request, callback: done});
    return;
  } else if (endpoints && endpoints.length > 0) {
    request.httpRequest.updateEndpoint(endpoints[0].Address);
    done();
  } else {
    var endpointRequest = service.makeRequest(api.endpointOperation, {
      Operation: operationModel.name,
      Identifiers: identifiers,
    });
    endpointRequest.removeListener('validate', AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    addApiVersionHeader(endpointRequest);

    //put in a placeholder for endpoints already requested, prevent
    //too much in-flight calls
    AWS.endpointCache.put(cacheKeyStr, [{
      Address: '',
      CachePeriodInMinutes: 60 //long-live cache
    }]);
    endpointRequest.send(function(err, data) {
      if (err) {
        request.response.error = util.error(err, { retryable: false });
        AWS.endpointCache.remove(cacheKey);

        //fail all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.response.error = util.error(err, { retryable: false });
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      } else if (data) {
        AWS.endpointCache.put(cacheKeyStr, data.Endpoints);
        request.httpRequest.updateEndpoint(data.Endpoints[0].Address);

        //update the endpoint for all the pending requests in batch
        if (requestQueue[cacheKeyStr]) {
          var pendingRequests = requestQueue[cacheKeyStr];
          util.arrayEach(pendingRequests, function(requestContext) {
            requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            requestContext.callback();
          });
          delete requestQueue[cacheKeyStr];
        }
      }
      done();
    });
  }
}

/**
 * add api version header to endpoint operation
 * @api private
 */
function addApiVersionHeader(endpointRequest) {
  var api = endpointRequest.service.api;
  var apiVersion = api.apiVersion;
  if (apiVersion && !endpointRequest.httpRequest.headers['x-amz-api-version']) {
    endpointRequest.httpRequest.headers['x-amz-api-version'] = apiVersion;
  }
}

/**
 * If api call gets invalid endpoint exception, SDK should attempt to remove the invalid
 * endpoint from cache.
 * @api private
 */
function invalidateCachedEndpoints(response) {
  var error = response.error;
  var httpResponse = response.httpResponse;
  if (error &&
    (error.code === 'InvalidEndpointException' || httpResponse.statusCode === 421)
  ) {
    var request = response.request;
    var operations = request.service.api.operations || {};
    var inputShape = operations[request.operation] ? operations[request.operation].input : undefined;
    var identifiers = marshallCustomIdentifiers(request, inputShape);
    var cacheKey = getCacheKey(request);
    if (Object.keys(identifiers).length > 0) {
      cacheKey = util.update(cacheKey, identifiers);
      if (operations[request.operation]) cacheKey.operation = operations[request.operation].name;
    }
    AWS.endpointCache.remove(cacheKey);
  }
}

/**
 * If endpoint is explicitly configured, SDK should not do endpoint discovery in anytime.
 * @param [object] client Service client object.
 * @api private
 */
function hasCustomEndpoint(client) {
  //if set endpoint is set for specific client, enable endpoint discovery will raise an error.
  if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
    throw util.error(new Error(), {
      code: 'ConfigurationException',
      message: 'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.'
    });
  };
  var svcConfig = AWS.config[client.serviceIdentifier] || {};
  return Boolean(AWS.config.endpoint || svcConfig.endpoint || (client._originalConfig && client._originalConfig.endpoint));
}

/**
 * @api private
 */
function isFalsy(value) {
  return ['false', '0'].indexOf(value) >= 0;
}

/**
 * If endpoint discovery should perform for this request when no operation requires endpoint
 * discovery for the given service.
 * SDK performs config resolution in order like below:
 * 1. If set in client configuration.
 * 2. If set in env AWS_ENABLE_ENDPOINT_DISCOVERY.
 * 3. If set in shared ini config file with key 'endpoint_discovery_enabled'.
 * @param [object] request request object.
 * @returns [boolean|undefined] if endpoint discovery config is not set in any source, this
 *  function returns undefined
 * @api private
 */
function resolveEndpointDiscoveryConfig(request) {
  var service = request.service || {};
  if (service.config.endpointDiscoveryEnabled !== undefined) {
    return service.config.endpointDiscoveryEnabled;
  }

  //shared ini file is only available in Node
  //not to check env in browser
  if (util.isBrowser()) return undefined;

  // If any of recognized endpoint discovery config env is set
  for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
    var env = endpointDiscoveryEnabledEnvs[i];
    if (Object.prototype.hasOwnProperty.call(process.env, env)) {
      if (process.env[env] === '' || process.env[env] === undefined) {
        throw util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'environmental variable ' + env + ' cannot be set to nothing'
        });
      }
      return !isFalsy(process.env[env]);
    }
  }

  var configFile = {};
  try {
    configFile = AWS.util.iniLoader ? AWS.util.iniLoader.loadFrom({
      isConfig: true,
      filename: process.env[AWS.util.sharedConfigFileEnv]
    }) : {};
  } catch (e) {}
  var sharedFileConfig = configFile[
    process.env.AWS_PROFILE || AWS.util.defaultProfile
  ] || {};
  if (Object.prototype.hasOwnProperty.call(sharedFileConfig, 'endpoint_discovery_enabled')) {
    if (sharedFileConfig.endpoint_discovery_enabled === undefined) {
      throw util.error(new Error(), {
        code: 'ConfigurationException',
        message: 'config file entry \'endpoint_discovery_enabled\' cannot be set to nothing'
      });
    }
    return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
  }
  return undefined;
}

/**
 * attach endpoint discovery logic to request object
 * @param [object] request
 * @api private
 */
function discoverEndpoint(request, done) {
  var service = request.service || {};
  if (hasCustomEndpoint(service) || request.isPresigned()) return done();

  var operations = service.api.operations || {};
  var operationModel = operations[request.operation];
  var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : 'NULL';
  var isEnabled = resolveEndpointDiscoveryConfig(request);
  var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
  if (isEnabled || hasRequiredEndpointDiscovery) {
    // Once a customer enables endpoint discovery, the SDK should start appending
    // the string endpoint-discovery to the user-agent on all requests.
    request.httpRequest.appendToUserAgent('endpoint-discovery');
  }
  switch (isEndpointDiscoveryRequired) {
    case 'OPTIONAL':
      if (isEnabled || hasRequiredEndpointDiscovery) {
        // For a given service; if at least one operation requires endpoint discovery then the SDK must enable endpoint discovery
        // by default for all operations of that service, including operations where endpoint discovery is optional.
        optionalDiscoverEndpoint(request);
        request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      }
      done();
      break;
    case 'REQUIRED':
      if (isEnabled === false) {
        // For a given operation; if endpoint discovery is required and it has been disabled on the SDK client,
        // then the SDK must return a clear and actionable exception.
        request.response.error = util.error(new Error(), {
          code: 'ConfigurationException',
          message: 'Endpoint Discovery is disabled but ' + service.api.className + '.' + request.operation +
                    '() requires it. Please check your configurations.'
        });
        done();
        break;
      }
      request.addNamedListener('INVALIDATE_CACHED_ENDPOINTS', 'extractError', invalidateCachedEndpoints);
      requiredDiscoverEndpoint(request, done);
      break;
    case 'NULL':
    default:
      done();
      break;
  }
}

module.exports = {
  discoverEndpoint: discoverEndpoint,
  requiredDiscoverEndpoint: requiredDiscoverEndpoint,
  optionalDiscoverEndpoint: optionalDiscoverEndpoint,
  marshallCustomIdentifiers: marshallCustomIdentifiers,
  getCacheKey: getCacheKey,
  invalidateCachedEndpoint: invalidateCachedEndpoints,
};

}).call(this)}).call(this,require('_process'))

},{"./core":23,"./util":80,"_process":97}],32:[function(require,module,exports){
var eventMessageChunker = require('../event-stream/event-message-chunker').eventMessageChunker;
var parseEvent = require('./parse-event').parseEvent;

function createEventStream(body, parser, model) {
    var eventMessages = eventMessageChunker(body);

    var events = [];

    for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
    }

    return events;
}

/**
 * @api private
 */
module.exports = {
    createEventStream: createEventStream
};

},{"../event-stream/event-message-chunker":33,"./parse-event":35}],33:[function(require,module,exports){
/**
 * Takes in a buffer of event messages and splits them into individual messages.
 * @param {Buffer} buffer
 * @api private
 */
function eventMessageChunker(buffer) {
    /** @type Buffer[] */
    var messages = [];
    var offset = 0;

    while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);

        // create new buffer for individual message (shares memory with original)
        var message = buffer.slice(offset, totalLength + offset);
        // increment offset to it starts at the next message
        offset += totalLength;

        messages.push(message);
    }

    return messages;
}

/**
 * @api private
 */
module.exports = {
    eventMessageChunker: eventMessageChunker
};

},{}],34:[function(require,module,exports){
var util = require('../core').util;
var toBuffer = util.buffer.toBuffer;

/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 * @param {Buffer} bytes
 *
 * @api private
 */
function Int64(bytes) {
    if (bytes.length !== 8) {
        throw new Error('Int64 buffers must be exactly 8 bytes');
    }
    if (!util.Buffer.isBuffer(bytes)) bytes = toBuffer(bytes);

    this.bytes = bytes;
}

/**
 * @param {number} number
 * @returns {Int64}
 *
 * @api private
 */
Int64.fromNumber = function(number) {
    if (number > 9223372036854775807 || number < -9223372036854775808) {
        throw new Error(
            number + ' is too large (or, if negative, too small) to represent as an Int64'
        );
    }

    var bytes = new Uint8Array(8);
    for (
        var i = 7, remaining = Math.abs(Math.round(number));
        i > -1 && remaining > 0;
        i--, remaining /= 256
    ) {
        bytes[i] = remaining;
    }

    if (number < 0) {
        negate(bytes);
    }

    return new Int64(bytes);
};

/**
 * @returns {number}
 *
 * @api private
 */
Int64.prototype.valueOf = function() {
    var bytes = this.bytes.slice(0);
    var negative = bytes[0] & 128;
    if (negative) {
        negate(bytes);
    }

    return parseInt(bytes.toString('hex'), 16) * (negative ? -1 : 1);
};

Int64.prototype.toString = function() {
    return String(this.valueOf());
};

/**
 * @param {Buffer} bytes
 *
 * @api private
 */
function negate(bytes) {
    for (var i = 0; i < 8; i++) {
        bytes[i] ^= 0xFF;
    }
    for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
            break;
        }
    }
}

/**
 * @api private
 */
module.exports = {
    Int64: Int64
};

},{"../core":23}],35:[function(require,module,exports){
var parseMessage = require('./parse-message').parseMessage;

/**
 *
 * @param {*} parser
 * @param {Buffer} message
 * @param {*} shape
 * @api private
 */
function parseEvent(parser, message, shape) {
    var parsedMessage = parseMessage(message);

    // check if message is an event or error
    var messageType = parsedMessage.headers[':message-type'];
    if (messageType) {
        if (messageType.value === 'error') {
            throw parseError(parsedMessage);
        } else if (messageType.value !== 'event') {
            // not sure how to parse non-events/non-errors, ignore for now
            return;
        }
    }

    // determine event type
    var eventType = parsedMessage.headers[':event-type'];
    // check that the event type is modeled
    var eventModel = shape.members[eventType.value];
    if (!eventModel) {
        return;
    }

    var result = {};
    // check if an event payload exists
    var eventPayloadMemberName = eventModel.eventPayloadMemberName;
    if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        // if the shape is binary, return the byte array
        if (payloadShape.type === 'binary') {
            result[eventPayloadMemberName] = parsedMessage.body;
        } else {
            result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
    }

    // read event headers
    var eventHeaderNames = eventModel.eventHeaderMemberNames;
    for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
            // parse the header!
            result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
    }

    var output = {};
    output[eventType.value] = result;
    return output;
}

function parseError(message) {
    var errorCode = message.headers[':error-code'];
    var errorMessage = message.headers[':error-message'];
    var error = new Error(errorMessage.value || errorMessage);
    error.code = error.name = errorCode.value || errorCode;
    return error;
}

/**
 * @api private
 */
module.exports = {
    parseEvent: parseEvent
};

},{"./parse-message":36}],36:[function(require,module,exports){
var Int64 = require('./int64').Int64;

var splitMessage = require('./split-message').splitMessage;

var BOOLEAN_TAG = 'boolean';
var BYTE_TAG = 'byte';
var SHORT_TAG = 'short';
var INT_TAG = 'integer';
var LONG_TAG = 'long';
var BINARY_TAG = 'binary';
var STRING_TAG = 'string';
var TIMESTAMP_TAG = 'timestamp';
var UUID_TAG = 'uuid';

/**
 * @api private
 *
 * @param {Buffer} headers
 */
function parseHeaders(headers) {
    var out = {};
    var position = 0;
    while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
            case 0 /* boolTrue */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: true
                };
                break;
            case 1 /* boolFalse */:
                out[name] = {
                    type: BOOLEAN_TAG,
                    value: false
                };
                break;
            case 2 /* byte */:
                out[name] = {
                    type: BYTE_TAG,
                    value: headers.readInt8(position++)
                };
                break;
            case 3 /* short */:
                out[name] = {
                    type: SHORT_TAG,
                    value: headers.readInt16BE(position)
                };
                position += 2;
                break;
            case 4 /* integer */:
                out[name] = {
                    type: INT_TAG,
                    value: headers.readInt32BE(position)
                };
                position += 4;
                break;
            case 5 /* long */:
                out[name] = {
                    type: LONG_TAG,
                    value: new Int64(headers.slice(position, position + 8))
                };
                position += 8;
                break;
            case 6 /* byteArray */:
                var binaryLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: BINARY_TAG,
                    value: headers.slice(position, position + binaryLength)
                };
                position += binaryLength;
                break;
            case 7 /* string */:
                var stringLength = headers.readUInt16BE(position);
                position += 2;
                out[name] = {
                    type: STRING_TAG,
                    value: headers.slice(
                        position,
                        position + stringLength
                    ).toString()
                };
                position += stringLength;
                break;
            case 8 /* timestamp */:
                out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(
                        new Int64(headers.slice(position, position + 8))
                            .valueOf()
                    )
                };
                position += 8;
                break;
            case 9 /* uuid */:
                var uuidChars = headers.slice(position, position + 16)
                    .toString('hex');
                position += 16;
                out[name] = {
                    type: UUID_TAG,
                    value: uuidChars.substr(0, 8) + '-' +
                        uuidChars.substr(8, 4) + '-' +
                        uuidChars.substr(12, 4) + '-' +
                        uuidChars.substr(16, 4) + '-' +
                        uuidChars.substr(20)
                };
                break;
            default:
                throw new Error('Unrecognized header type tag');
        }
    }
    return out;
}

function parseMessage(message) {
    var parsed = splitMessage(message);
    return { headers: parseHeaders(parsed.headers), body: parsed.body };
}

/**
 * @api private
 */
module.exports = {
    parseMessage: parseMessage
};

},{"./int64":34,"./split-message":37}],37:[function(require,module,exports){
var util = require('../core').util;
var toBuffer = util.buffer.toBuffer;

// All prelude components are unsigned, 32-bit integers
var PRELUDE_MEMBER_LENGTH = 4;
// The prelude consists of two components
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
// Checksums are always CRC32 hashes.
var CHECKSUM_LENGTH = 4;
// Messages must include a full prelude, a prelude checksum, and a message checksum
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;

/**
 * @api private
 *
 * @param {Buffer} message
 */
function splitMessage(message) {
    if (!util.Buffer.isBuffer(message)) message = toBuffer(message);

    if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error('Provided message too short to accommodate event stream message overhead');
    }

    if (message.length !== message.readUInt32BE(0)) {
        throw new Error('Reported message length does not match received message length');
    }

    var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);

    if (
        expectedPreludeChecksum !== util.crypto.crc32(
            message.slice(0, PRELUDE_LENGTH)
        )
    ) {
        throw new Error(
            'The prelude checksum specified in the message (' +
            expectedPreludeChecksum +
            ') does not match the calculated CRC32 checksum.'
        );
    }

    var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);

    if (
        expectedMessageChecksum !== util.crypto.crc32(
            message.slice(0, message.length - CHECKSUM_LENGTH)
        )
    ) {
        throw new Error(
            'The message checksum did not match the expected value of ' +
                expectedMessageChecksum
        );
    }

    var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
    var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);

    return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH),
    };
}

/**
 * @api private
 */
module.exports = {
    splitMessage: splitMessage
};

},{"../core":23}],38:[function(require,module,exports){
(function (process){(function (){
var AWS = require('./core');
var SequentialExecutor = require('./sequential_executor');
var DISCOVER_ENDPOINT = require('./discover_endpoint').discoverEndpoint;
/**
 * The namespace used to register global event listeners for request building
 * and sending.
 */
AWS.EventListeners = {
  /**
   * @!attribute VALIDATE_CREDENTIALS
   *   A request listener that validates whether the request is being
   *   sent with credentials.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating credentials
   *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_REGION
   *   A request listener that validates whether the region is set
   *   for a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating region configuration
   *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
   *     request.removeListener('validate', listener);
   *   @readonly
   *   @return [Function]
   * @!attribute VALIDATE_PARAMETERS
   *   A request listener that validates input parameters in a request.
   *   Handles the {AWS.Request~validate 'validate' Request event}
   *   @example Sending a request without validating parameters
   *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
   *     request.removeListener('validate', listener);
   *   @example Disable parameter validation globally
   *     AWS.EventListeners.Core.removeListener('validate',
   *       AWS.EventListeners.Core.VALIDATE_REGION);
   *   @readonly
   *   @return [Function]
   * @!attribute SEND
   *   A request listener that initiates the HTTP connection for a
   *   request being sent. Handles the {AWS.Request~send 'send' Request event}
   *   @example Replacing the HTTP handler
   *     var listener = AWS.EventListeners.Core.SEND;
   *     request.removeListener('send', listener);
   *     request.on('send', function(response) {
   *       customHandler.send(response);
   *     });
   *   @return [Function]
   *   @readonly
   * @!attribute HTTP_DATA
   *   A request listener that reads data from the HTTP connection in order
   *   to build the response data.
   *   Handles the {AWS.Request~httpData 'httpData' Request event}.
   *   Remove this handler if you are overriding the 'httpData' event and
   *   do not want extra data processing and buffering overhead.
   *   @example Disabling default data processing
   *     var listener = AWS.EventListeners.Core.HTTP_DATA;
   *     request.removeListener('httpData', listener);
   *   @return [Function]
   *   @readonly
   */
  Core: {} /* doc hack */
};

/**
 * @api private
 */
function getOperationAuthtype(req) {
  if (!req.service.api.operations) {
    return '';
  }
  var operation = req.service.api.operations[req.operation];
  return operation ? operation.authtype : '';
}

AWS.EventListeners = {
  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
    addAsync('VALIDATE_CREDENTIALS', 'validate',
        function VALIDATE_CREDENTIALS(req, done) {
      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion) return done(); // none
      req.service.config.getCredentials(function(err) {
        if (err) {
          req.response.error = AWS.util.error(err,
            {code: 'CredentialsError', message: 'Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1'});
        }
        done();
      });
    });

    add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {
      if (!req.service.isGlobalEndpoint) {
        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!req.service.config.region) {
          req.response.error = AWS.util.error(new Error(),
            {code: 'ConfigError', message: 'Missing region in config'});
        } else if (!dnsHostRegex.test(req.service.config.region)) {
          req.response.error = AWS.util.error(new Error(),
            {code: 'ConfigError', message: 'Invalid region in config'});
        }
      }
    });

    add('BUILD_IDEMPOTENCY_TOKENS', 'validate', function BUILD_IDEMPOTENCY_TOKENS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var idempotentMembers = operation.idempotentMembers;
      if (!idempotentMembers.length) {
        return;
      }
      // creates a copy of params so user's param object isn't mutated
      var params = AWS.util.copy(req.params);
      for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
        if (!params[idempotentMembers[i]]) {
          // add the member
          params[idempotentMembers[i]] = AWS.util.uuid.v4();
        }
      }
      req.params = params;
    });

    add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {
      if (!req.service.api.operations) {
        return;
      }
      var rules = req.service.api.operations[req.operation].input;
      var validation = req.service.config.paramValidation;
      new AWS.ParamValidator(validation).validate(rules, req.params);
    });

    add('COMPUTE_CHECKSUM', 'afterBuild', function COMPUTE_CHECKSUM(req) {
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      if (!operation) {
        return;
      }
      var body = req.httpRequest.body;
      var isNonStreamingPayload = body && (AWS.util.Buffer.isBuffer(body) || typeof body === 'string');
      var headers = req.httpRequest.headers;
      if (
        operation.httpChecksumRequired &&
        req.service.config.computeChecksums &&
        isNonStreamingPayload &&
        !headers['Content-MD5']
      ) {
        var md5 = AWS.util.crypto.md5(body, 'base64');
        headers['Content-MD5'] = md5;
      }
    });

    addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {
      req.haltHandlersOnError();
      if (!req.service.api.operations) {
        return;
      }
      var operation = req.service.api.operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion) return done(); // none
      if (req.service.getSignerClass(req) === AWS.Signers.V4) {
        var body = req.httpRequest.body || '';
        if (authtype.indexOf('unsigned-body') >= 0) {
          req.httpRequest.headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
          return done();
        }
        AWS.util.computeSha256(body, function(err, sha) {
          if (err) {
            done(err);
          }
          else {
            req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;
            done();
          }
        });
      } else {
        done();
      }
    });

    add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {
      var authtype = getOperationAuthtype(req);
      var payloadMember = AWS.util.getRequestPayloadShape(req);
      if (req.httpRequest.headers['Content-Length'] === undefined) {
        try {
          var length = AWS.util.string.byteLength(req.httpRequest.body);
          req.httpRequest.headers['Content-Length'] = length;
        } catch (err) {
          if (payloadMember && payloadMember.isStreaming) {
            if (payloadMember.requiresLength) {
              //streaming payload requires length(s3, glacier)
              throw err;
            } else if (authtype.indexOf('unsigned-body') >= 0) {
              //unbounded streaming payload(lex, mediastore)
              req.httpRequest.headers['Transfer-Encoding'] = 'chunked';
              return;
            } else {
              throw err;
            }
          }
          throw err;
        }
      }
    });

    add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {
      req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;
    });

    add('SET_TRACE_ID', 'afterBuild', function SET_TRACE_ID(req) {
      var traceIdHeaderName = 'X-Amzn-Trace-Id';
      if (AWS.util.isNode() && !Object.hasOwnProperty.call(req.httpRequest.headers, traceIdHeaderName)) {
        var ENV_LAMBDA_FUNCTION_NAME = 'AWS_LAMBDA_FUNCTION_NAME';
        var ENV_TRACE_ID = '_X_AMZN_TRACE_ID';
        var functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
        var traceId = process.env[ENV_TRACE_ID];
        if (
          typeof functionName === 'string' &&
          functionName.length > 0 &&
          typeof traceId === 'string' &&
          traceId.length > 0
        ) {
          req.httpRequest.headers[traceIdHeaderName] = traceId;
        }
      }
    });

    add('RESTART', 'restart', function RESTART() {
      var err = this.response.error;
      if (!err || !err.retryable) return;

      this.httpRequest = new AWS.HttpRequest(
        this.service.endpoint,
        this.service.region
      );

      if (this.response.retryCount < this.service.config.maxRetries) {
        this.response.retryCount++;
      } else {
        this.response.error = null;
      }
    });

    var addToHead = true;
    addAsync('DISCOVER_ENDPOINT', 'sign', DISCOVER_ENDPOINT, addToHead);

    addAsync('SIGN', 'sign', function SIGN(req, done) {
      var service = req.service;
      var operations = req.service.api.operations || {};
      var operation = operations[req.operation];
      var authtype = operation ? operation.authtype : '';
      if (!service.api.signatureVersion && !authtype && !service.config.signatureVersion) return done(); // none

      if (authtype === 'bearer' || service.config.signatureVersion === 'bearer') {
        service.config.getToken(function (err, token) {
          if (err) {
            req.response.error = err;
            return done();
          }

          try {
            var SignerClass = service.getSignerClass(req);
            var signer = new SignerClass(req.httpRequest);
            signer.addAuthorization(token);
          } catch (e) {
            req.response.error = e;
          }
          done();
        });
      } else {
        service.config.getCredentials(function (err, credentials) {
          if (err) {
            req.response.error = err;
            return done();
          }

          try {
            var date = service.getSkewCorrectedDate();
            var SignerClass = service.getSignerClass(req);
            var signer = new SignerClass(req.httpRequest,
              service.getSigningName(req),
              {
                signatureCache: service.config.signatureCache,
                operation: operation,
                signatureVersion: service.api.signatureVersion
              });
            signer.setServiceClientId(service._clientId);

            // clear old authorization headers
            delete req.httpRequest.headers['Authorization'];
            delete req.httpRequest.headers['Date'];
            delete req.httpRequest.headers['X-Amz-Date'];

            // add new authorization
            signer.addAuthorization(credentials, date);
            req.signedAt = date;
          } catch (e) {
            req.response.error = e;
          }
          done();
        });

      }
    });

    add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {
      if (this.service.successfulResponse(resp, this)) {
        resp.data = {};
        resp.error = null;
      } else {
        resp.data = null;
        resp.error = AWS.util.error(new Error(),
          {code: 'UnknownError', message: 'An unknown error occurred.'});
      }
    });

    add('ERROR', 'error', function ERROR(err, resp) {
      var errorCodeMapping = resp.request.service.api.errorCodeMapping;
      if (errorCodeMapping && err && err.code) {
        var mapping = errorCodeMapping[err.code];
        if (mapping) {
          resp.error.code = mapping.code;
        }
      }
    }, true);

    addAsync('SEND', 'send', function SEND(resp, done) {
      resp.httpResponse._abortCallback = done;
      resp.error = null;
      resp.data = null;

      function callback(httpResp) {
        resp.httpResponse.stream = httpResp;
        var stream = resp.request.httpRequest.stream;
        var service = resp.request.service;
        var api = service.api;
        var operationName = resp.request.operation;
        var operation = api.operations[operationName] || {};

        httpResp.on('headers', function onHeaders(statusCode, headers, statusMessage) {
          resp.request.emit(
            'httpHeaders',
            [statusCode, headers, resp, statusMessage]
          );

          if (!resp.httpResponse.streaming) {
            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check
              // if we detect event streams, we're going to have to
              // return the stream immediately
              if (operation.hasEventOutput && service.successfulResponse(resp)) {
                // skip reading the IncomingStream
                resp.request.emit('httpDone');
                done();
                return;
              }

              httpResp.on('readable', function onReadable() {
                var data = httpResp.read();
                if (data !== null) {
                  resp.request.emit('httpData', [data, resp]);
                }
              });
            } else { // legacy streams API
              httpResp.on('data', function onData(data) {
                resp.request.emit('httpData', [data, resp]);
              });
            }
          }
        });

        httpResp.on('end', function onEnd() {
          if (!stream || !stream.didCallback) {
            if (AWS.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
              // don't concatenate response chunks when streaming event stream data when response is successful
              return;
            }
            resp.request.emit('httpDone');
            done();
          }
        });
      }

      function progress(httpResp) {
        httpResp.on('sendProgress', function onSendProgress(value) {
          resp.request.emit('httpUploadProgress', [value, resp]);
        });

        httpResp.on('receiveProgress', function onReceiveProgress(value) {
          resp.request.emit('httpDownloadProgress', [value, resp]);
        });
      }

      function error(err) {
        if (err.code !== 'RequestAbortedError') {
          var errCode = err.code === 'TimeoutError' ? err.code : 'NetworkingError';
          err = AWS.util.error(err, {
            code: errCode,
            region: resp.request.httpRequest.region,
            hostname: resp.request.httpRequest.endpoint.hostname,
            retryable: true
          });
        }
        resp.error = err;
        resp.request.emit('httpError', [resp.error, resp], function() {
          done();
        });
      }

      function executeSend() {
        var http = AWS.HttpClient.getInstance();
        var httpOptions = resp.request.service.config.httpOptions || {};
        try {
          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,
                                          callback, error);
          progress(stream);
        } catch (err) {
          error(err);
        }
      }
      var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1000;
      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign
        this.emit('sign', [this], function(err) {
          if (err) done(err);
          else executeSend();
        });
      } else {
        executeSend();
      }
    });

    add('HTTP_HEADERS', 'httpHeaders',
        function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
      resp.httpResponse.statusCode = statusCode;
      resp.httpResponse.statusMessage = statusMessage;
      resp.httpResponse.headers = headers;
      resp.httpResponse.body = AWS.util.buffer.toBuffer('');
      resp.httpResponse.buffers = [];
      resp.httpResponse.numBytes = 0;
      var dateHeader = headers.date || headers.Date;
      var service = resp.request.service;
      if (dateHeader) {
        var serverTime = Date.parse(dateHeader);
        if (service.config.correctClockSkew
            && service.isClockSkewed(serverTime)) {
          service.applyClockOffset(serverTime);
        }
      }
    });

    add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {
      if (chunk) {
        if (AWS.util.isNode()) {
          resp.httpResponse.numBytes += chunk.length;

          var total = resp.httpResponse.headers['content-length'];
          var progress = { loaded: resp.httpResponse.numBytes, total: total };
          resp.request.emit('httpDownloadProgress', [progress, resp]);
        }

        resp.httpResponse.buffers.push(AWS.util.buffer.toBuffer(chunk));
      }
    });

    add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {
      // convert buffers array into single buffer
      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);
        resp.httpResponse.body = body;
      }
      delete resp.httpResponse.numBytes;
      delete resp.httpResponse.buffers;
    });

    add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {
      if (resp.httpResponse.statusCode) {
        resp.error.statusCode = resp.httpResponse.statusCode;
        if (resp.error.retryable === undefined) {
          resp.error.retryable = this.service.retryableError(resp.error, this);
        }
      }
    });

    add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {
      if (!resp.error) return;
      switch (resp.error.code) {
        case 'RequestExpired': // EC2 only
        case 'ExpiredTokenException':
        case 'ExpiredToken':
          resp.error.retryable = true;
          resp.request.service.config.credentials.expired = true;
      }
    });

    add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {
      var err = resp.error;
      if (!err) return;
      if (typeof err.code === 'string' && typeof err.message === 'string') {
        if (err.code.match(/Signature/) && err.message.match(/expired/)) {
          resp.error.retryable = true;
        }
      }
    });

    add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {
      if (!resp.error) return;
      if (this.service.clockSkewError(resp.error)
          && this.service.config.correctClockSkew) {
        resp.error.retryable = true;
      }
    });

    add('REDIRECT', 'retry', function REDIRECT(resp) {
      if (resp.error && resp.error.statusCode >= 300 &&
          resp.error.statusCode < 400 && resp.httpResponse.headers['location']) {
        this.httpRequest.endpoint =
          new AWS.Endpoint(resp.httpResponse.headers['location']);
        this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;
        resp.error.redirect = true;
        resp.error.retryable = true;
      }
    });

    add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {
      if (resp.error) {
        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.error.retryDelay = 0;
        } else if (resp.retryCount < resp.maxRetries) {
          resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
        }
      }
    });

    addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {
      var delay, willRetry = false;

      if (resp.error) {
        delay = resp.error.retryDelay || 0;
        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
          resp.retryCount++;
          willRetry = true;
        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
          resp.redirectCount++;
          willRetry = true;
        }
      }

      // delay < 0 is a signal from customBackoff to skip retries
      if (willRetry && delay >= 0) {
        resp.error = null;
        setTimeout(done, delay);
      } else {
        done();
      }
    });
  }),

  CorePost: new SequentialExecutor().addNamedListeners(function(add) {
    add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);
    add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);

    add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {
      function isDNSError(err) {
        return err.errno === 'ENOTFOUND' ||
          typeof err.errno === 'number' &&
          typeof AWS.util.getSystemErrorName === 'function' &&
          ['EAI_NONAME', 'EAI_NODATA'].indexOf(AWS.util.getSystemErrorName(err.errno) >= 0);
      }
      if (err.code === 'NetworkingError' && isDNSError(err)) {
        var message = 'Inaccessible host: `' + err.hostname + '\' at port `' + err.port +
          '\'. This service may not be available in the `' + err.region +
          '\' region.';
        this.response.error = AWS.util.error(new Error(message), {
          code: 'UnknownEndpoint',
          region: err.region,
          hostname: err.hostname,
          retryable: true,
          originalError: err
        });
      }
    });
  }),

  Logger: new SequentialExecutor().addNamedListeners(function(add) {
    add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {
      var req = resp.request;
      var logger = req.service.config.logger;
      if (!logger) return;
      function filterSensitiveLog(inputShape, shape) {
        if (!shape) {
          return shape;
        }
        if (inputShape.isSensitive) {
          return '***SensitiveInformation***';
        }
        switch (inputShape.type) {
          case 'structure':
            var struct = {};
            AWS.util.each(shape, function(subShapeName, subShape) {
              if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
              } else {
                struct[subShapeName] = subShape;
              }
            });
            return struct;
          case 'list':
            var list = [];
            AWS.util.arrayEach(shape, function(subShape, index) {
              list.push(filterSensitiveLog(inputShape.member, subShape));
            });
            return list;
          case 'map':
            var map = {};
            AWS.util.each(shape, function(key, value) {
              map[key] = filterSensitiveLog(inputShape.value, value);
            });
            return map;
          default:
            return shape;
        }
      }

      function buildMessage() {
        var time = resp.request.service.getSkewCorrectedDate().getTime();
        var delta = (time - req.startTime.getTime()) / 1000;
        var ansi = logger.isTTY ? true : false;
        var status = resp.httpResponse.statusCode;
        var censoredParams = req.params;
        if (
          req.service.api.operations &&
              req.service.api.operations[req.operation] &&
              req.service.api.operations[req.operation].input
        ) {
          var inputShape = req.service.api.operations[req.operation].input;
          censoredParams = filterSensitiveLog(inputShape, req.params);
        }
        var params = require('util').inspect(censoredParams, true, null);
        var message = '';
        if (ansi) message += '\x1B[33m';
        message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;
        message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';
        if (ansi) message += '\x1B[0;1m';
        message += ' ' + AWS.util.string.lowerFirst(req.operation);
        message += '(' + params + ')';
        if (ansi) message += '\x1B[0m';
        return message;
      }

      var line = buildMessage();
      if (typeof logger.log === 'function') {
        logger.log(line);
      } else if (typeof logger.write === 'function') {
        logger.write(line + '\n');
      }
    });
  }),

  Json: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Rest: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestJson: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_json');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  RestXml: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/rest_xml');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  }),

  Query: new SequentialExecutor().addNamedListeners(function(add) {
    var svc = require('./protocol/query');
    add('BUILD', 'build', svc.buildRequest);
    add('EXTRACT_DATA', 'extractData', svc.extractData);
    add('EXTRACT_ERROR', 'extractError', svc.extractError);
  })
};

}).call(this)}).call(this,require('_process'))

},{"./core":23,"./discover_endpoint":31,"./protocol/json":51,"./protocol/query":52,"./protocol/rest":53,"./protocol/rest_json":54,"./protocol/rest_xml":55,"./sequential_executor":65,"_process":97,"util":109}],39:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;

/**
 * The endpoint that a service will talk to, for example,
 * `'https://ec2.ap-southeast-1.amazonaws.com'`. If
 * you need to override an endpoint for a service, you can
 * set the endpoint on a service by passing the endpoint
 * object with the `endpoint` option key:
 *
 * ```javascript
 * var ep = new AWS.Endpoint('awsproxy.example.com');
 * var s3 = new AWS.S3({endpoint: ep});
 * s3.service.endpoint.hostname == 'awsproxy.example.com'
 * ```
 *
 * Note that if you do not specify a protocol, the protocol will
 * be selected based on your current {AWS.config} configuration.
 *
 * @!attribute protocol
 *   @return [String] the protocol (http or https) of the endpoint
 *     URL
 * @!attribute hostname
 *   @return [String] the host portion of the endpoint, e.g.,
 *     example.com
 * @!attribute host
 *   @return [String] the host portion of the endpoint including
 *     the port, e.g., example.com:80
 * @!attribute port
 *   @return [Integer] the port of the endpoint
 * @!attribute href
 *   @return [String] the full URL of the endpoint
 */
AWS.Endpoint = inherit({

  /**
   * @overload Endpoint(endpoint)
   *   Constructs a new endpoint given an endpoint URL. If the
   *   URL omits a protocol (http or https), the default protocol
   *   set in the global {AWS.config} will be used.
   *   @param endpoint [String] the URL to construct an endpoint from
   */
  constructor: function Endpoint(endpoint, config) {
    AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);

    if (typeof endpoint === 'undefined' || endpoint === null) {
      throw new Error('Invalid endpoint: ' + endpoint);
    } else if (typeof endpoint !== 'string') {
      return AWS.util.copy(endpoint);
    }

    if (!endpoint.match(/^http/)) {
      var useSSL = config && config.sslEnabled !== undefined ?
        config.sslEnabled : AWS.config.sslEnabled;
      endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;
    }

    AWS.util.update(this, AWS.util.urlParse(endpoint));

    // Ensure the port property is set as an integer
    if (this.port) {
      this.port = parseInt(this.port, 10);
    } else {
      this.port = this.protocol === 'https:' ? 443 : 80;
    }
  }

});

/**
 * The low level HTTP request object, encapsulating all HTTP header
 * and body data sent by a service request.
 *
 * @!attribute method
 *   @return [String] the HTTP method of the request
 * @!attribute path
 *   @return [String] the path portion of the URI, e.g.,
 *     "/list/?start=5&num=10"
 * @!attribute headers
 *   @return [map<String,String>]
 *     a map of header keys and their respective values
 * @!attribute body
 *   @return [String] the request body payload
 * @!attribute endpoint
 *   @return [AWS.Endpoint] the endpoint for the request
 * @!attribute region
 *   @api private
 *   @return [String] the region, for signing purposes only.
 */
AWS.HttpRequest = inherit({

  /**
   * @api private
   */
  constructor: function HttpRequest(endpoint, region) {
    endpoint = new AWS.Endpoint(endpoint);
    this.method = 'POST';
    this.path = endpoint.path || '/';
    this.headers = {};
    this.body = '';
    this.endpoint = endpoint;
    this.region = region;
    this._userAgent = '';
    this.setUserAgent();
  },

  /**
   * @api private
   */
  setUserAgent: function setUserAgent() {
    this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS.util.userAgent();
  },

  getUserAgentHeaderName: function getUserAgentHeaderName() {
    var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';
    return prefix + 'User-Agent';
  },

  /**
   * @api private
   */
  appendToUserAgent: function appendToUserAgent(agentPartial) {
    if (typeof agentPartial === 'string' && agentPartial) {
      this._userAgent += ' ' + agentPartial;
    }
    this.headers[this.getUserAgentHeaderName()] = this._userAgent;
  },

  /**
   * @api private
   */
  getUserAgent: function getUserAgent() {
    return this._userAgent;
  },

  /**
   * @return [String] the part of the {path} excluding the
   *   query string
   */
  pathname: function pathname() {
    return this.path.split('?', 1)[0];
  },

  /**
   * @return [String] the query string portion of the {path}
   */
  search: function search() {
    var query = this.path.split('?', 2)[1];
    if (query) {
      query = AWS.util.queryStringParse(query);
      return AWS.util.queryParamsToString(query);
    }
    return '';
  },

  /**
   * @api private
   * update httpRequest endpoint with endpoint string
   */
  updateEndpoint: function updateEndpoint(endpointStr) {
    var newEndpoint = new AWS.Endpoint(endpointStr);
    this.endpoint = newEndpoint;
    this.path = newEndpoint.path || '/';
    if (this.headers['Host']) {
      this.headers['Host'] = newEndpoint.host;
    }
  }
});

/**
 * The low level HTTP response object, encapsulating all HTTP header
 * and body data returned from the request.
 *
 * @!attribute statusCode
 *   @return [Integer] the HTTP status code of the response (e.g., 200, 404)
 * @!attribute headers
 *   @return [map<String,String>]
 *      a map of response header keys and their respective values
 * @!attribute body
 *   @return [String] the response body payload
 * @!attribute [r] streaming
 *   @return [Boolean] whether this response is being streamed at a low-level.
 *     Defaults to `false` (buffered reads). Do not modify this manually, use
 *     {createUnbufferedStream} to convert the stream to unbuffered mode
 *     instead.
 */
AWS.HttpResponse = inherit({

  /**
   * @api private
   */
  constructor: function HttpResponse() {
    this.statusCode = undefined;
    this.headers = {};
    this.body = undefined;
    this.streaming = false;
    this.stream = null;
  },

  /**
   * Disables buffering on the HTTP response and returns the stream for reading.
   * @return [Stream, XMLHttpRequest, null] the underlying stream object.
   *   Use this object to directly read data off of the stream.
   * @note This object is only available after the {AWS.Request~httpHeaders}
   *   event has fired. This method must be called prior to
   *   {AWS.Request~httpData}.
   * @example Taking control of a stream
   *   request.on('httpHeaders', function(statusCode, headers) {
   *     if (statusCode < 300) {
   *       if (headers.etag === 'xyz') {
   *         // pipe the stream, disabling buffering
   *         var stream = this.response.httpResponse.createUnbufferedStream();
   *         stream.pipe(process.stdout);
   *       } else { // abort this request and set a better error message
   *         this.abort();
   *         this.response.error = new Error('Invalid ETag');
   *       }
   *     }
   *   }).send(console.log);
   */
  createUnbufferedStream: function createUnbufferedStream() {
    this.streaming = true;
    return this.stream;
  }
});


AWS.HttpClient = inherit({});

/**
 * @api private
 */
AWS.HttpClient.getInstance = function getInstance() {
  if (this.singleton === undefined) {
    this.singleton = new this();
  }
  return this.singleton;
};

},{"./core":23}],40:[function(require,module,exports){
var AWS = require('../core');
var EventEmitter = require('events').EventEmitter;
require('../http');

/**
 * @api private
 */
AWS.XHRClient = AWS.util.inherit({
  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
    var self = this;
    var endpoint = httpRequest.endpoint;
    var emitter = new EventEmitter();
    var href = endpoint.protocol + '//' + endpoint.hostname;
    if (endpoint.port !== 80 && endpoint.port !== 443) {
      href += ':' + endpoint.port;
    }
    href += httpRequest.path;

    var xhr = new XMLHttpRequest(), headersEmitted = false;
    httpRequest.stream = xhr;

    xhr.addEventListener('readystatechange', function() {
      try {
        if (xhr.status === 0) return; // 0 code is invalid
      } catch (e) { return; }

      if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
        emitter.statusCode = xhr.status;
        emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
        emitter.emit(
          'headers',
          emitter.statusCode,
          emitter.headers,
          xhr.statusText
        );
        headersEmitted = true;
      }
      if (this.readyState === this.DONE) {
        self.finishRequest(xhr, emitter);
      }
    }, false);
    xhr.upload.addEventListener('progress', function (evt) {
      emitter.emit('sendProgress', evt);
    });
    xhr.addEventListener('progress', function (evt) {
      emitter.emit('receiveProgress', evt);
    }, false);
    xhr.addEventListener('timeout', function () {
      errCallback(AWS.util.error(new Error('Timeout'), {code: 'TimeoutError'}));
    }, false);
    xhr.addEventListener('error', function () {
      errCallback(AWS.util.error(new Error('Network Failure'), {
        code: 'NetworkingError'
      }));
    }, false);
    xhr.addEventListener('abort', function () {
      errCallback(AWS.util.error(new Error('Request aborted'), {
        code: 'RequestAbortedError'
      }));
    }, false);

    callback(emitter);
    xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
    AWS.util.each(httpRequest.headers, function (key, value) {
      if (key !== 'Content-Length' && key !== 'User-Agent' && key !== 'Host') {
        xhr.setRequestHeader(key, value);
      }
    });

    if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
      xhr.timeout = httpOptions.timeout;
    }

    if (httpOptions.xhrWithCredentials) {
      xhr.withCredentials = true;
    }
    try { xhr.responseType = 'arraybuffer'; } catch (e) {}

    try {
      if (httpRequest.body) {
        xhr.send(httpRequest.body);
      } else {
        xhr.send();
      }
    } catch (err) {
      if (httpRequest.body && typeof httpRequest.body.buffer === 'object') {
        xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly
      } else {
        throw err;
      }
    }

    return emitter;
  },

  parseHeaders: function parseHeaders(rawHeaders) {
    var headers = {};
    AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {
      var key = line.split(':', 1)[0];
      var value = line.substring(key.length + 2);
      if (key.length > 0) headers[key.toLowerCase()] = value;
    });
    return headers;
  },

  finishRequest: function finishRequest(xhr, emitter) {
    var buffer;
    if (xhr.responseType === 'arraybuffer' && xhr.response) {
      var ab = xhr.response;
      buffer = new AWS.util.Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
      }
    }

    try {
      if (!buffer && typeof xhr.responseText === 'string') {
        buffer = new AWS.util.Buffer(xhr.responseText);
      }
    } catch (e) {}

    if (buffer) emitter.emit('data', buffer);
    emitter.emit('end');
  }
});

/**
 * @api private
 */
AWS.HttpClient.prototype = AWS.XHRClient.prototype;

/**
 * @api private
 */
AWS.HttpClient.streamsApiVersion = 1;

},{"../core":23,"../http":39,"events":92}],41:[function(require,module,exports){
var util = require('../util');

function JsonBuilder() { }

JsonBuilder.prototype.build = function(value, shape) {
  return JSON.stringify(translate(value, shape));
};

function translate(value, shape) {
  if (!shape || value === undefined || value === null) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (shape.isDocument) {
    return structure;
  }
  var struct = {};
  util.each(structure, function(name, value) {
    var memberShape = shape.members[name];
    if (memberShape) {
      if (memberShape.location !== 'body') return;
      var locationName = memberShape.isLocationName ? memberShape.name : name;
      var result = translate(value, memberShape);
      if (result !== undefined) struct[locationName] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result !== undefined) out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result !== undefined) out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toWireFormat(value);
}

/**
 * @api private
 */
module.exports = JsonBuilder;

},{"../util":80}],42:[function(require,module,exports){
var util = require('../util');

function JsonParser() { }

JsonParser.prototype.parse = function(value, shape) {
  return translate(JSON.parse(value), shape);
};

function translate(value, shape) {
  if (!shape || value === undefined) return undefined;

  switch (shape.type) {
    case 'structure': return translateStructure(value, shape);
    case 'map': return translateMap(value, shape);
    case 'list': return translateList(value, shape);
    default: return translateScalar(value, shape);
  }
}

function translateStructure(structure, shape) {
  if (structure == null) return undefined;
  if (shape.isDocument) return structure;

  var struct = {};
  var shapeMembers = shape.members;
  util.each(shapeMembers, function(name, memberShape) {
    var locationName = memberShape.isLocationName ? memberShape.name : name;
    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
      var value = structure[locationName];
      var result = translate(value, memberShape);
      if (result !== undefined) struct[name] = result;
    }
  });
  return struct;
}

function translateList(list, shape) {
  if (list == null) return undefined;

  var out = [];
  util.arrayEach(list, function(value) {
    var result = translate(value, shape.member);
    if (result === undefined) out.push(null);
    else out.push(result);
  });
  return out;
}

function translateMap(map, shape) {
  if (map == null) return undefined;

  var out = {};
  util.each(map, function(key, value) {
    var result = translate(value, shape.value);
    if (result === undefined) out[key] = null;
    else out[key] = result;
  });
  return out;
}

function translateScalar(value, shape) {
  return shape.toType(value);
}

/**
 * @api private
 */
module.exports = JsonParser;

},{"../util":80}],43:[function(require,module,exports){
var Collection = require('./collection');
var Operation = require('./operation');
var Shape = require('./shape');
var Paginator = require('./paginator');
var ResourceWaiter = require('./resource_waiter');
var metadata = require('../../apis/metadata.json');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Api(api, options) {
  var self = this;
  api = api || {};
  options = options || {};
  options.api = this;

  api.metadata = api.metadata || {};

  var serviceIdentifier = options.serviceIdentifier;
  delete options.serviceIdentifier;

  property(this, 'isApi', true, false);
  property(this, 'apiVersion', api.metadata.apiVersion);
  property(this, 'endpointPrefix', api.metadata.endpointPrefix);
  property(this, 'signingName', api.metadata.signingName);
  property(this, 'globalEndpoint', api.metadata.globalEndpoint);
  property(this, 'signatureVersion', api.metadata.signatureVersion);
  property(this, 'jsonVersion', api.metadata.jsonVersion);
  property(this, 'targetPrefix', api.metadata.targetPrefix);
  property(this, 'protocol', api.metadata.protocol);
  property(this, 'timestampFormat', api.metadata.timestampFormat);
  property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);
  property(this, 'abbreviation', api.metadata.serviceAbbreviation);
  property(this, 'fullName', api.metadata.serviceFullName);
  property(this, 'serviceId', api.metadata.serviceId);
  if (serviceIdentifier && metadata[serviceIdentifier]) {
      property(this, 'xmlNoDefaultLists', metadata[serviceIdentifier].xmlNoDefaultLists, false);
  }

  memoizedProperty(this, 'className', function() {
    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
    if (!name) return null;

    name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');
    if (name === 'ElasticLoadBalancing') name = 'ELB';
    return name;
  });

  function addEndpointOperation(name, operation) {
    if (operation.endpointoperation === true) {
      property(self, 'endpointOperation', util.string.lowerFirst(name));
    }
    if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
      property(
        self,
        'hasRequiredEndpointDiscovery',
        operation.endpointdiscovery.required === true
      );
    }
  }

  property(this, 'operations', new Collection(api.operations, options, function(name, operation) {
    return new Operation(name, operation, options);
  }, util.string.lowerFirst, addEndpointOperation));

  property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {
    return Shape.create(shape, options);
  }));

  property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {
    return new Paginator(name, paginator, options);
  }));

  property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {
    return new ResourceWaiter(name, waiter, options);
  }, util.string.lowerFirst));

  if (options.documentation) {
    property(this, 'documentation', api.documentation);
    property(this, 'documentationUrl', api.documentationUrl);
  }
  property(this, 'errorCodeMapping', api.awsQueryCompatible);
}

/**
 * @api private
 */
module.exports = Api;

},{"../../apis/metadata.json":3,"../util":80,"./collection":44,"./operation":45,"./paginator":46,"./resource_waiter":47,"./shape":48}],44:[function(require,module,exports){
var memoizedProperty = require('../util').memoizedProperty;

function memoize(name, value, factory, nameTr) {
  memoizedProperty(this, nameTr(name), function() {
    return factory(name, value);
  });
}

function Collection(iterable, options, factory, nameTr, callback) {
  nameTr = nameTr || String;
  var self = this;

  for (var id in iterable) {
    if (Object.prototype.hasOwnProperty.call(iterable, id)) {
      memoize.call(self, id, iterable[id], factory, nameTr);
      if (callback) callback(id, iterable[id]);
    }
  }
}

/**
 * @api private
 */
module.exports = Collection;

},{"../util":80}],45:[function(require,module,exports){
var Shape = require('./shape');

var util = require('../util');
var property = util.property;
var memoizedProperty = util.memoizedProperty;

function Operation(name, operation, options) {
  var self = this;
  options = options || {};

  property(this, 'name', operation.name || name);
  property(this, 'api', options.api, false);

  operation.http = operation.http || {};
  property(this, 'endpoint', operation.endpoint);
  property(this, 'httpMethod', operation.http.method || 'POST');
  property(this, 'httpPath', operation.http.requestUri || '/');
  property(this, 'authtype', operation.authtype || '');
  property(
    this,
    'endpointDiscoveryRequired',
    operation.endpointdiscovery ?
      (operation.endpointdiscovery.required ? 'REQUIRED' : 'OPTIONAL') :
    'NULL'
  );

  // httpChecksum replaces usage of httpChecksumRequired, but some APIs
  // (s3control) still uses old trait.
  var httpChecksumRequired = operation.httpChecksumRequired
    || (operation.httpChecksum && operation.httpChecksum.requestChecksumRequired);
  property(this, 'httpChecksumRequired', httpChecksumRequired, false);

  memoizedProperty(this, 'input', function() {
    if (!operation.input) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.input, options);
  });

  memoizedProperty(this, 'output', function() {
    if (!operation.output) {
      return new Shape.create({type: 'structure'}, options);
    }
    return Shape.create(operation.output, options);
  });

  memoizedProperty(this, 'errors', function() {
    var list = [];
    if (!operation.errors) return null;

    for (var i = 0; i < operation.errors.length; i++) {
      list.push(Shape.create(operation.errors[i], options));
    }

    return list;
  });

  memoizedProperty(this, 'paginator', function() {
    return options.api.paginators[name];
  });

  if (options.documentation) {
    property(this, 'documentation', operation.documentation);
    property(this, 'documentationUrl', operation.documentationUrl);
  }

  // idempotentMembers only tracks top-level input shapes
  memoizedProperty(this, 'idempotentMembers', function() {
    var idempotentMembers = [];
    var input = self.input;
    var members = input.members;
    if (!input.members) {
      return idempotentMembers;
    }
    for (var name in members) {
      if (!members.hasOwnProperty(name)) {
        continue;
      }
      if (members[name].isIdempotent === true) {
        idempotentMembers.push(name);
      }
    }
    return idempotentMembers;
  });

  memoizedProperty(this, 'hasEventOutput', function() {
    var output = self.output;
    return hasEventStream(output);
  });
}

function hasEventStream(topLevelShape) {
  var members = topLevelShape.members;
  var payload = topLevelShape.payload;

  if (!topLevelShape.members) {
    return false;
  }

  if (payload) {
    var payloadMember = members[payload];
    return payloadMember.isEventStream;
  }

  // check if any member is an event stream
  for (var name in members) {
    if (!members.hasOwnProperty(name)) {
      if (members[name].isEventStream === true) {
        return true;
      }
    }
  }
  return false;
}

/**
 * @api private
 */
module.exports = Operation;

},{"../util":80,"./shape":48}],46:[function(require,module,exports){
var property = require('../util').property;

function Paginator(name, paginator) {
  property(this, 'inputToken', paginator.input_token);
  property(this, 'limitKey', paginator.limit_key);
  property(this, 'moreResults', paginator.more_results);
  property(this, 'outputToken', paginator.output_token);
  property(this, 'resultKey', paginator.result_key);
}

/**
 * @api private
 */
module.exports = Paginator;

},{"../util":80}],47:[function(require,module,exports){
var util = require('../util');
var property = util.property;

function ResourceWaiter(name, waiter, options) {
  options = options || {};
  property(this, 'name', name);
  property(this, 'api', options.api, false);

  if (waiter.operation) {
    property(this, 'operation', util.string.lowerFirst(waiter.operation));
  }

  var self = this;
  var keys = [
    'type',
    'description',
    'delay',
    'maxAttempts',
    'acceptors'
  ];

  keys.forEach(function(key) {
    var value = waiter[key];
    if (value) {
      property(self, key, value);
    }
  });
}

/**
 * @api private
 */
module.exports = ResourceWaiter;

},{"../util":80}],48:[function(require,module,exports){
var Collection = require('./collection');

var util = require('../util');

function property(obj, name, value) {
  if (value !== null && value !== undefined) {
    util.property.apply(this, arguments);
  }
}

function memoizedProperty(obj, name) {
  if (!obj.constructor.prototype[name]) {
    util.memoizedProperty.apply(this, arguments);
  }
}

function Shape(shape, options, memberName) {
  options = options || {};

  property(this, 'shape', shape.shape);
  property(this, 'api', options.api, false);
  property(this, 'type', shape.type);
  property(this, 'enum', shape.enum);
  property(this, 'min', shape.min);
  property(this, 'max', shape.max);
  property(this, 'pattern', shape.pattern);
  property(this, 'location', shape.location || this.location || 'body');
  property(this, 'name', this.name || shape.xmlName || shape.queryName ||
    shape.locationName || memberName);
  property(this, 'isStreaming', shape.streaming || this.isStreaming || false);
  property(this, 'requiresLength', shape.requiresLength, false);
  property(this, 'isComposite', shape.isComposite || false);
  property(this, 'isShape', true, false);
  property(this, 'isQueryName', Boolean(shape.queryName), false);
  property(this, 'isLocationName', Boolean(shape.locationName), false);
  property(this, 'isIdempotent', shape.idempotencyToken === true);
  property(this, 'isJsonValue', shape.jsonvalue === true);
  property(this, 'isSensitive', shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
  property(this, 'isEventStream', Boolean(shape.eventstream), false);
  property(this, 'isEvent', Boolean(shape.event), false);
  property(this, 'isEventPayload', Boolean(shape.eventpayload), false);
  property(this, 'isEventHeader', Boolean(shape.eventheader), false);
  property(this, 'isTimestampFormatSet', Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
  property(this, 'endpointDiscoveryId', Boolean(shape.endpointdiscoveryid), false);
  property(this, 'hostLabel', Boolean(shape.hostLabel), false);

  if (options.documentation) {
    property(this, 'documentation', shape.documentation);
    property(this, 'documentationUrl', shape.documentationUrl);
  }

  if (shape.xmlAttribute) {
    property(this, 'isXmlAttribute', shape.xmlAttribute || false);
  }

  // type conversion and parsing
  property(this, 'defaultValue', null);
  this.toWireFormat = function(value) {
    if (value === null || value === undefined) return '';
    return value;
  };
  this.toType = function(value) { return value; };
}

/**
 * @api private
 */
Shape.normalizedTypes = {
  character: 'string',
  double: 'float',
  long: 'integer',
  short: 'integer',
  biginteger: 'integer',
  bigdecimal: 'float',
  blob: 'binary'
};

/**
 * @api private
 */
Shape.types = {
  'structure': StructureShape,
  'list': ListShape,
  'map': MapShape,
  'boolean': BooleanShape,
  'timestamp': TimestampShape,
  'float': FloatShape,
  'integer': IntegerShape,
  'string': StringShape,
  'base64': Base64Shape,
  'binary': BinaryShape
};

Shape.resolve = function resolve(shape, options) {
  if (shape.shape) {
    var refShape = options.api.shapes[shape.shape];
    if (!refShape) {
      throw new Error('Cannot find shape reference: ' + shape.shape);
    }

    return refShape;
  } else {
    return null;
  }
};

Shape.create = function create(shape, options, memberName) {
  if (shape.isShape) return shape;

  var refShape = Shape.resolve(shape, options);
  if (refShape) {
    var filteredKeys = Object.keys(shape);
    if (!options.documentation) {
      filteredKeys = filteredKeys.filter(function(name) {
        return !name.match(/documentation/);
      });
    }

    // create an inline shape with extra members
    var InlineShape = function() {
      refShape.constructor.call(this, shape, options, memberName);
    };
    InlineShape.prototype = refShape;
    return new InlineShape();
  } else {
    // set type if not set
    if (!shape.type) {
      if (shape.members) shape.type = 'structure';
      else if (shape.member) shape.type = 'list';
      else if (shape.key) shape.type = 'map';
      else shape.type = 'string';
    }

    // normalize types
    var origType = shape.type;
    if (Shape.normalizedTypes[shape.type]) {
      shape.type = Shape.normalizedTypes[shape.type];
    }

    if (Shape.types[shape.type]) {
      return new Shape.types[shape.type](shape, options, memberName);
    } else {
      throw new Error('Unrecognized shape type: ' + origType);
    }
  }
};

function CompositeShape(shape) {
  Shape.apply(this, arguments);
  property(this, 'isComposite', true);

  if (shape.flattened) {
    property(this, 'flattened', shape.flattened || false);
  }
}

function StructureShape(shape, options) {
  var self = this;
  var requiredMap = null, firstInit = !this.isShape;

  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'members', {});
    property(this, 'memberNames', []);
    property(this, 'required', []);
    property(this, 'isRequired', function() { return false; });
    property(this, 'isDocument', Boolean(shape.document));
  }

  if (shape.members) {
    property(this, 'members', new Collection(shape.members, options, function(name, member) {
      return Shape.create(member, options, name);
    }));
    memoizedProperty(this, 'memberNames', function() {
      return shape.xmlOrder || Object.keys(shape.members);
    });

    if (shape.event) {
      memoizedProperty(this, 'eventPayloadMemberName', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        // iterate over members to find ones that are event payloads
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventPayload) {
            return memberNames[i];
          }
        }
      });

      memoizedProperty(this, 'eventHeaderMemberNames', function() {
        var members = self.members;
        var memberNames = self.memberNames;
        var eventHeaderMemberNames = [];
        // iterate over members to find ones that are event headers
        for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
          if (members[memberNames[i]].isEventHeader) {
            eventHeaderMemberNames.push(memberNames[i]);
          }
        }
        return eventHeaderMemberNames;
      });
    }
  }

  if (shape.required) {
    property(this, 'required', shape.required);
    property(this, 'isRequired', function(name) {
      if (!requiredMap) {
        requiredMap = {};
        for (var i = 0; i < shape.required.length; i++) {
          requiredMap[shape.required[i]] = true;
        }
      }

      return requiredMap[name];
    }, false, true);
  }

  property(this, 'resultWrapper', shape.resultWrapper || null);

  if (shape.payload) {
    property(this, 'payload', shape.payload);
  }

  if (typeof shape.xmlNamespace === 'string') {
    property(this, 'xmlNamespaceUri', shape.xmlNamespace);
  } else if (typeof shape.xmlNamespace === 'object') {
    property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);
    property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);
  }
}

function ListShape(shape, options) {
  var self = this, firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return []; });
  }

  if (shape.member) {
    memoizedProperty(this, 'member', function() {
      return Shape.create(shape.member, options);
    });
  }

  if (this.flattened) {
    var oldName = this.name;
    memoizedProperty(this, 'name', function() {
      return self.member.name || oldName;
    });
  }
}

function MapShape(shape, options) {
  var firstInit = !this.isShape;
  CompositeShape.apply(this, arguments);

  if (firstInit) {
    property(this, 'defaultValue', function() { return {}; });
    property(this, 'key', Shape.create({type: 'string'}, options));
    property(this, 'value', Shape.create({type: 'string'}, options));
  }

  if (shape.key) {
    memoizedProperty(this, 'key', function() {
      return Shape.create(shape.key, options);
    });
  }
  if (shape.value) {
    memoizedProperty(this, 'value', function() {
      return Shape.create(shape.value, options);
    });
  }
}

function TimestampShape(shape) {
  var self = this;
  Shape.apply(this, arguments);

  if (shape.timestampFormat) {
    property(this, 'timestampFormat', shape.timestampFormat);
  } else if (self.isTimestampFormatSet && this.timestampFormat) {
    property(this, 'timestampFormat', this.timestampFormat);
  } else if (this.location === 'header') {
    property(this, 'timestampFormat', 'rfc822');
  } else if (this.location === 'querystring') {
    property(this, 'timestampFormat', 'iso8601');
  } else if (this.api) {
    switch (this.api.protocol) {
      case 'json':
      case 'rest-json':
        property(this, 'timestampFormat', 'unixTimestamp');
        break;
      case 'rest-xml':
      case 'query':
      case 'ec2':
        property(this, 'timestampFormat', 'iso8601');
        break;
    }
  }

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    if (typeof value.toUTCString === 'function') return value;
    return typeof value === 'string' || typeof value === 'number' ?
           util.date.parseTimestamp(value) : null;
  };

  this.toWireFormat = function(value) {
    return util.date.format(value, self.timestampFormat);
  };
}

function StringShape() {
  Shape.apply(this, arguments);

  var nullLessProtocols = ['rest-xml', 'query', 'ec2'];
  this.toType = function(value) {
    value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ?
      value || '' : value;
    if (this.isJsonValue) {
      return JSON.parse(value);
    }

    return value && typeof value.toString === 'function' ?
      value.toString() : value;
  };

  this.toWireFormat = function(value) {
    return this.isJsonValue ? JSON.stringify(value) : value;
  };
}

function FloatShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseFloat(value);
  };
  this.toWireFormat = this.toType;
}

function IntegerShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (value === null || value === undefined) return null;
    return parseInt(value, 10);
  };
  this.toWireFormat = this.toType;
}

function BinaryShape() {
  Shape.apply(this, arguments);
  this.toType = function(value) {
    var buf = util.base64.decode(value);
    if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === 'function') {
  /* Node.js can create a Buffer that is not isolated.
   * i.e. buf.byteLength !== buf.buffer.byteLength
   * This means that the sensitive data is accessible to anyone with access to buf.buffer.
   * If this is the node shared Buffer, then other code within this process _could_ find this secret.
   * Copy sensitive data to an isolated Buffer and zero the sensitive data.
   * While this is safe to do here, copying this code somewhere else may produce unexpected results.
   */
      var secureBuf = util.Buffer.alloc(buf.length, buf);
      buf.fill(0);
      buf = secureBuf;
    }
    return buf;
  };
  this.toWireFormat = util.base64.encode;
}

function Base64Shape() {
  BinaryShape.apply(this, arguments);
}

function BooleanShape() {
  Shape.apply(this, arguments);

  this.toType = function(value) {
    if (typeof value === 'boolean') return value;
    if (value === null || value === undefined) return null;
    return value === 'true';
  };
}

/**
 * @api private
 */
Shape.shapes = {
  StructureShape: StructureShape,
  ListShape: ListShape,
  MapShape: MapShape,
  StringShape: StringShape,
  BooleanShape: BooleanShape,
  Base64Shape: Base64Shape
};

/**
 * @api private
 */
module.exports = Shape;

},{"../util":80,"./collection":44}],49:[function(require,module,exports){
var AWS = require('./core');

/**
 * @api private
 */
AWS.ParamValidator = AWS.util.inherit({
  /**
   * Create a new validator object.
   *
   * @param validation [Boolean|map] whether input parameters should be
   *     validated against the operation description before sending the
   *     request. Pass a map to enable any of the following specific
   *     validation features:
   *
   *     * **min** [Boolean] &mdash; Validates that a value meets the min
   *       constraint. This is enabled by default when paramValidation is set
   *       to `true`.
   *     * **max** [Boolean] &mdash; Validates that a value meets the max
   *       constraint.
   *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
   *       regular expression.
   *     * **enum** [Boolean] &mdash; Validates that a string value matches one
   *       of the allowable enum values.
   */
  constructor: function ParamValidator(validation) {
    if (validation === true || validation === undefined) {
      validation = {'min': true};
    }
    this.validation = validation;
  },

  validate: function validate(shape, params, context) {
    this.errors = [];
    this.validateMember(shape, params || {}, context || 'params');

    if (this.errors.length > 1) {
      var msg = this.errors.join('\n* ');
      msg = 'There were ' + this.errors.length +
        ' validation errors:\n* ' + msg;
      throw AWS.util.error(new Error(msg),
        {code: 'MultipleValidationErrors', errors: this.errors});
    } else if (this.errors.length === 1) {
      throw this.errors[0];
    } else {
      return true;
    }
  },

  fail: function fail(code, message) {
    this.errors.push(AWS.util.error(new Error(message), {code: code}));
  },

  validateStructure: function validateStructure(shape, params, context) {
    if (shape.isDocument) return true;

    this.validateType(params, context, ['object'], 'structure');
    var paramName;
    for (var i = 0; shape.required && i < shape.required.length; i++) {
      paramName = shape.required[i];
      var value = params[paramName];
      if (value === undefined || value === null) {
        this.fail('MissingRequiredParameter',
          'Missing required key \'' + paramName + '\' in ' + context);
      }
    }

    // validate hash members
    for (paramName in params) {
      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;

      var paramValue = params[paramName],
          memberShape = shape.members[paramName];

      if (memberShape !== undefined) {
        var memberContext = [context, paramName].join('.');
        this.validateMember(memberShape, paramValue, memberContext);
      } else if (paramValue !== undefined && paramValue !== null) {
        this.fail('UnexpectedParameter',
          'Unexpected key \'' + paramName + '\' found in ' + context);
      }
    }

    return true;
  },

  validateMember: function validateMember(shape, param, context) {
    switch (shape.type) {
      case 'structure':
        return this.validateStructure(shape, param, context);
      case 'list':
        return this.validateList(shape, param, context);
      case 'map':
        return this.validateMap(shape, param, context);
      default:
        return this.validateScalar(shape, param, context);
    }
  },

  validateList: function validateList(shape, params, context) {
    if (this.validateType(params, context, [Array])) {
      this.validateRange(shape, params.length, context, 'list member count');
      // validate array members
      for (var i = 0; i < params.length; i++) {
        this.validateMember(shape.member, params[i], context + '[' + i + ']');
      }
    }
  },

  validateMap: function validateMap(shape, params, context) {
    if (this.validateType(params, context, ['object'], 'map')) {
      // Build up a count of map members to validate range traits.
      var mapCount = 0;
      for (var param in params) {
        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;
        // Validate any map key trait constraints
        this.validateMember(shape.key, param,
                            context + '[key=\'' + param + '\']');
        this.validateMember(shape.value, params[param],
                            context + '[\'' + param + '\']');
        mapCount++;
      }
      this.validateRange(shape, mapCount, context, 'map member count');
    }
  },

  validateScalar: function validateScalar(shape, value, context) {
    switch (shape.type) {
      case null:
      case undefined:
      case 'string':
        return this.validateString(shape, value, context);
      case 'base64':
      case 'binary':
        return this.validatePayload(value, context);
      case 'integer':
      case 'float':
        return this.validateNumber(shape, value, context);
      case 'boolean':
        return this.validateType(value, context, ['boolean']);
      case 'timestamp':
        return this.validateType(value, context, [Date,
          /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],
          'Date object, ISO-8601 string, or a UNIX timestamp');
      default:
        return this.fail('UnkownType', 'Unhandled type ' +
                         shape.type + ' for ' + context);
    }
  },

  validateString: function validateString(shape, value, context) {
    var validTypes = ['string'];
    if (shape.isJsonValue) {
      validTypes = validTypes.concat(['number', 'object', 'boolean']);
    }
    if (value !== null && this.validateType(value, context, validTypes)) {
      this.validateEnum(shape, value, context);
      this.validateRange(shape, value.length, context, 'string length');
      this.validatePattern(shape, value, context);
      this.validateUri(shape, value, context);
    }
  },

  validateUri: function validateUri(shape, value, context) {
    if (shape['location'] === 'uri') {
      if (value.length === 0) {
        this.fail('UriParameterError', 'Expected uri parameter to have length >= 1,'
          + ' but found "' + value +'" for ' + context);
      }
    }
  },

  validatePattern: function validatePattern(shape, value, context) {
    if (this.validation['pattern'] && shape['pattern'] !== undefined) {
      if (!(new RegExp(shape['pattern'])).test(value)) {
        this.fail('PatternMatchError', 'Provided value "' + value + '" '
          + 'does not match regex pattern /' + shape['pattern'] + '/ for '
          + context);
      }
    }
  },

  validateRange: function validateRange(shape, value, context, descriptor) {
    if (this.validation['min']) {
      if (shape['min'] !== undefined && value < shape['min']) {
        this.fail('MinRangeError', 'Expected ' + descriptor + ' >= '
          + shape['min'] + ', but found ' + value + ' for ' + context);
      }
    }
    if (this.validation['max']) {
      if (shape['max'] !== undefined && value > shape['max']) {
        this.fail('MaxRangeError', 'Expected ' + descriptor + ' <= '
          + shape['max'] + ', but found ' + value + ' for ' + context);
      }
    }
  },

  validateEnum: function validateRange(shape, value, context) {
    if (this.validation['enum'] && shape['enum'] !== undefined) {
      // Fail if the string value is not present in the enum list
      if (shape['enum'].indexOf(value) === -1) {
        this.fail('EnumError', 'Found string value of ' + value + ', but '
          + 'expected ' + shape['enum'].join('|') + ' for ' + context);
      }
    }
  },

  validateType: function validateType(value, context, acceptedTypes, type) {
    // We will not log an error for null or undefined, but we will return
    // false so that callers know that the expected type was not strictly met.
    if (value === null || value === undefined) return false;

    var foundInvalidType = false;
    for (var i = 0; i < acceptedTypes.length; i++) {
      if (typeof acceptedTypes[i] === 'string') {
        if (typeof value === acceptedTypes[i]) return true;
      } else if (acceptedTypes[i] instanceof RegExp) {
        if ((value || '').toString().match(acceptedTypes[i])) return true;
      } else {
        if (value instanceof acceptedTypes[i]) return true;
        if (AWS.util.isType(value, acceptedTypes[i])) return true;
        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();
        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);
      }
      foundInvalidType = true;
    }

    var acceptedType = type;
    if (!acceptedType) {
      acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');
    }

    var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';
    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +
              vowel + ' ' + acceptedType);
    return false;
  },

  validateNumber: function validateNumber(shape, value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') {
      var castedValue = parseFloat(value);
      if (castedValue.toString() === value) value = castedValue;
    }
    if (this.validateType(value, context, ['number'])) {
      this.validateRange(shape, value, context, 'numeric value');
    }
  },

  validatePayload: function validatePayload(value, context) {
    if (value === null || value === undefined) return;
    if (typeof value === 'string') return;
    if (value && typeof value.byteLength === 'number') return; // typed arrays
    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js
      var Stream = AWS.util.stream.Stream;
      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;
    } else {
      if (typeof Blob !== void 0 && value instanceof Blob) return;
    }

    var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];
    if (value) {
      for (var i = 0; i < types.length; i++) {
        if (AWS.util.isType(value, types[i])) return;
        if (AWS.util.typeName(value.constructor) === types[i]) return;
      }
    }

    this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +
      'string, Buffer, Stream, Blob, or typed array object');
  }
});

},{"./core":23}],50:[function(require,module,exports){
var util =  require('../util');
var AWS = require('../core');

/**
 * Prepend prefix defined by API model to endpoint that's already
 * constructed. This feature does not apply to operations using
 * endpoint discovery and can be disabled.
 * @api private
 */
function populateHostPrefix(request)  {
  var enabled = request.service.config.hostPrefixEnabled;
  if (!enabled) return request;
  var operationModel = request.service.api.operations[request.operation];
  //don't marshal host prefix when operation has endpoint discovery traits
  if (hasEndpointDiscover(request)) return request;
  if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
    var hostPrefixNotation = operationModel.endpoint.hostPrefix;
    var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
    prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
    validateHostname(request.httpRequest.endpoint.hostname);
  }
  return request;
}

/**
 * @api private
 */
function hasEndpointDiscover(request) {
  var api = request.service.api;
  var operationModel = api.operations[request.operation];
  var isEndpointOperation = api.endpointOperation && (api.endpointOperation === util.string.lowerFirst(operationModel.name));
  return (operationModel.endpointDiscoveryRequired !== 'NULL' || isEndpointOperation === true);
}

/**
 * @api private
 */
function expandHostPrefix(hostPrefixNotation, params, shape) {
  util.each(shape.members, function(name, member) {
    if (member.hostLabel === true) {
      if (typeof params[name] !== 'string' || params[name] === '') {
        throw util.error(new Error(), {
          message: 'Parameter ' + name + ' should be a non-empty string.',
          code: 'InvalidParameter'
        });
      }
      var regex = new RegExp('\\{' + name + '\\}', 'g');
      hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
    }
  });
  return hostPrefixNotation;
}

/**
 * @api private
 */
function prependEndpointPrefix(endpoint, prefix) {
  if (endpoint.host) {
    endpoint.host = prefix + endpoint.host;
  }
  if (endpoint.hostname) {
    endpoint.hostname = prefix + endpoint.hostname;
  }
}

/**
 * @api private
 */
function validateHostname(hostname) {
  var labels = hostname.split('.');
  //Reference: https://tools.ietf.org/html/rfc1123#section-2
  var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
  util.arrayEach(labels, function(label) {
    if (!label.length || label.length < 1 || label.length > 63) {
      throw util.error(new Error(), {
        code: 'ValidationError',
        message: 'Hostname label length should be between 1 to 63 characters, inclusive.'
      });
    }
    if (!hostPattern.test(label)) {
      throw AWS.util.error(new Error(),
        {code: 'ValidationError', message: label + ' is not hostname compatible.'});
    }
  });
}

module.exports = {
  populateHostPrefix: populateHostPrefix
};

},{"../core":23,"../util":80}],51:[function(require,module,exports){
var util = require('../util');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function buildRequest(req) {
  var httpRequest = req.httpRequest;
  var api = req.service.api;
  var target = api.targetPrefix + '.' + api.operations[req.operation].name;
  var version = api.jsonVersion || '1.0';
  var input = api.operations[req.operation].input;
  var builder = new JsonBuilder();

  if (version === 1) version = '1.0';
  httpRequest.body = builder.build(req.params || {}, input);
  httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;
  httpRequest.headers['X-Amz-Target'] = target;

  populateHostPrefix(req);
}

function extractError(resp) {
  var error = {};
  var httpResponse = resp.httpResponse;

  error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';
  if (typeof error.code === 'string') {
    error.code = error.code.split(':')[0];
  }

  if (httpResponse.body.length > 0) {
    try {
      var e = JSON.parse(httpResponse.body.toString());
      var code = e.__type || e.code || e.Code;
      if (code) {
        error.code = code.split('#').pop();
      }
      if (error.code === 'RequestEntityTooLarge') {
        error.message = 'Request body must be less than 1 MB';
      } else {
        error.message = (e.message || e.Message || null);
      }
    } catch (e) {
      error.statusCode = httpResponse.statusCode;
      error.message = httpResponse.statusMessage;
    }
  } else {
    error.statusCode = httpResponse.statusCode;
    error.message = httpResponse.statusCode.toString();
  }

  resp.error = util.error(new Error(), error);
}

function extractData(resp) {
  var body = resp.httpResponse.body.toString() || '{}';
  if (resp.request.service.config.convertResponseTypes === false) {
    resp.data = JSON.parse(body);
  } else {
    var operation = resp.request.service.api.operations[resp.request.operation];
    var shape = operation.output || {};
    var parser = new JsonParser();
    resp.data = parser.parse(body, shape);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":41,"../json/parser":42,"../util":80,"./helpers":50}],52:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var QueryParamSerializer = require('../query/query_param_serializer');
var Shape = require('../model/shape');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function buildRequest(req) {
  var operation = req.service.api.operations[req.operation];
  var httpRequest = req.httpRequest;
  httpRequest.headers['Content-Type'] =
    'application/x-www-form-urlencoded; charset=utf-8';
  httpRequest.params = {
    Version: req.service.api.apiVersion,
    Action: operation.name
  };

  // convert the request parameters into a list of query params,
  // e.g. Deeply.NestedParam.0.Name=value
  var builder = new QueryParamSerializer();
  builder.serialize(req.params, operation.input, function(name, value) {
    httpRequest.params[name] = value;
  });
  httpRequest.body = util.queryParamsToString(httpRequest.params);

  populateHostPrefix(req);
}

function extractError(resp) {
  var data, body = resp.httpResponse.body.toString();
  if (body.match('<UnknownOperationException')) {
    data = {
      Code: 'UnknownOperation',
      Message: 'Unknown operation ' + resp.request.operation
    };
  } else {
    try {
      data = new AWS.XML.Parser().parse(body);
    } catch (e) {
      data = {
        Code: resp.httpResponse.statusCode,
        Message: resp.httpResponse.statusMessage
      };
    }
  }

  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;
  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var shape = operation.output || {};
  var origRules = shape;

  if (origRules.resultWrapper) {
    var tmp = Shape.create({type: 'structure'});
    tmp.members[origRules.resultWrapper] = shape;
    tmp.memberNames = [origRules.resultWrapper];
    util.property(shape, 'name', shape.resultWrapper);
    shape = tmp;
  }

  var parser = new AWS.XML.Parser();

  // TODO: Refactor XML Parser to parse RequestId from response.
  if (shape && shape.members && !shape.members._XAMZRequestId) {
    var requestIdShape = Shape.create(
      { type: 'string' },
      { api: { protocol: 'query' } },
      'requestId'
    );
    shape.members._XAMZRequestId = requestIdShape;
  }

  var data = parser.parse(resp.httpResponse.body.toString(), shape);
  resp.requestId = data._XAMZRequestId || data.requestId;

  if (data._XAMZRequestId) delete data._XAMZRequestId;

  if (origRules.resultWrapper) {
    if (data[origRules.resultWrapper]) {
      util.update(data, data[origRules.resultWrapper]);
      delete data[origRules.resultWrapper];
    }
  }

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":23,"../model/shape":48,"../query/query_param_serializer":56,"../util":80,"./helpers":50}],53:[function(require,module,exports){
var util = require('../util');
var populateHostPrefix = require('./helpers').populateHostPrefix;

function populateMethod(req) {
  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
}

function generateURI(endpointPath, operationPath, input, params) {
  var uri = [endpointPath, operationPath].join('/');
  uri = uri.replace(/\/+/g, '/');

  var queryString = {}, queryStringSet = false;
  util.each(input.members, function (name, member) {
    var paramValue = params[name];
    if (paramValue === null || paramValue === undefined) return;
    if (member.location === 'uri') {
      var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');
      uri = uri.replace(regex, function(_, plus) {
        var fn = plus ? util.uriEscapePath : util.uriEscape;
        return fn(String(paramValue));
      });
    } else if (member.location === 'querystring') {
      queryStringSet = true;

      if (member.type === 'list') {
        queryString[member.name] = paramValue.map(function(val) {
          return util.uriEscape(member.member.toWireFormat(val).toString());
        });
      } else if (member.type === 'map') {
        util.each(paramValue, function(key, value) {
          if (Array.isArray(value)) {
            queryString[key] = value.map(function(val) {
              return util.uriEscape(String(val));
            });
          } else {
            queryString[key] = util.uriEscape(String(value));
          }
        });
      } else {
        queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
      }
    }
  });

  if (queryStringSet) {
    uri += (uri.indexOf('?') >= 0 ? '&' : '?');
    var parts = [];
    util.arrayEach(Object.keys(queryString).sort(), function(key) {
      if (!Array.isArray(queryString[key])) {
        queryString[key] = [queryString[key]];
      }
      for (var i = 0; i < queryString[key].length; i++) {
        parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);
      }
    });
    uri += parts.join('&');
  }

  return uri;
}

function populateURI(req) {
  var operation = req.service.api.operations[req.operation];
  var input = operation.input;

  var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
  req.httpRequest.path = uri;
}

function populateHeaders(req) {
  var operation = req.service.api.operations[req.operation];
  util.each(operation.input.members, function (name, member) {
    var value = req.params[name];
    if (value === null || value === undefined) return;

    if (member.location === 'headers' && member.type === 'map') {
      util.each(value, function(key, memberValue) {
        req.httpRequest.headers[member.name + key] = memberValue;
      });
    } else if (member.location === 'header') {
      value = member.toWireFormat(value).toString();
      if (member.isJsonValue) {
        value = util.base64.encode(value);
      }
      req.httpRequest.headers[member.name] = value;
    }
  });
}

function buildRequest(req) {
  populateMethod(req);
  populateURI(req);
  populateHeaders(req);
  populateHostPrefix(req);
}

function extractError() {
}

function extractData(resp) {
  var req = resp.request;
  var data = {};
  var r = resp.httpResponse;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  // normalize headers names to lower-cased keys for matching
  var headers = {};
  util.each(r.headers, function (k, v) {
    headers[k.toLowerCase()] = v;
  });

  util.each(output.members, function(name, member) {
    var header = (member.name || name).toLowerCase();
    if (member.location === 'headers' && member.type === 'map') {
      data[name] = {};
      var location = member.isLocationName ? member.name : '';
      var pattern = new RegExp('^' + location + '(.+)', 'i');
      util.each(r.headers, function (k, v) {
        var result = k.match(pattern);
        if (result !== null) {
          data[name][result[1]] = v;
        }
      });
    } else if (member.location === 'header') {
      if (headers[header] !== undefined) {
        var value = member.isJsonValue ?
          util.base64.decode(headers[header]) :
          headers[header];
        data[name] = member.toType(value);
      }
    } else if (member.location === 'statusCode') {
      data[name] = parseInt(r.statusCode, 10);
    }
  });

  resp.data = data;
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData,
  generateURI: generateURI
};

},{"../util":80,"./helpers":50}],54:[function(require,module,exports){
var util = require('../util');
var Rest = require('./rest');
var Json = require('./json');
var JsonBuilder = require('../json/builder');
var JsonParser = require('../json/parser');

function populateBody(req) {
  var builder = new JsonBuilder();
  var input = req.service.api.operations[req.operation].input;

  if (input.payload) {
    var params = {};
    var payloadShape = input.members[input.payload];
    params = req.params[input.payload];

    if (payloadShape.type === 'structure') {
      req.httpRequest.body = builder.build(params || {}, payloadShape);
      applyContentTypeHeader(req);
    } else if (params !== undefined) {
      // non-JSON payload
      req.httpRequest.body = params;
      if (payloadShape.type === 'binary' || payloadShape.isStreaming) {
        applyContentTypeHeader(req, true);
      }
    }
  } else {
    req.httpRequest.body = builder.build(req.params, input);
    applyContentTypeHeader(req);
  }
}

function applyContentTypeHeader(req, isBinary) {
  if (!req.httpRequest.headers['Content-Type']) {
    var type = isBinary ? 'binary/octet-stream' : 'application/json';
    req.httpRequest.headers['Content-Type'] = type;
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD/DELETE
  if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Json.extractError(resp);
}

function extractData(resp) {
  Rest.extractData(resp);

  var req = resp.request;
  var operation = req.service.api.operations[req.operation];
  var rules = req.service.api.operations[req.operation].output || {};
  var parser;
  var hasEventOutput = operation.hasEventOutput;

  if (rules.payload) {
    var payloadMember = rules.members[rules.payload];
    var body = resp.httpResponse.body;
    if (payloadMember.isEventStream) {
      parser = new JsonParser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {
      var parser = new JsonParser();
      resp.data[rules.payload] = parser.parse(body, payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[rules.payload] = body;
    } else {
      resp.data[rules.payload] = payloadMember.toType(body);
    }
  } else {
    var data = resp.data;
    Json.extractData(resp);
    resp.data = util.merge(data, resp.data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../json/builder":41,"../json/parser":42,"../util":80,"./json":51,"./rest":53}],55:[function(require,module,exports){
var AWS = require('../core');
var util = require('../util');
var Rest = require('./rest');

function populateBody(req) {
  var input = req.service.api.operations[req.operation].input;
  var builder = new AWS.XML.Builder();
  var params = req.params;

  var payload = input.payload;
  if (payload) {
    var payloadMember = input.members[payload];
    params = params[payload];
    if (params === undefined) return;

    if (payloadMember.type === 'structure') {
      var rootElement = payloadMember.name;
      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
    } else { // non-xml payload
      req.httpRequest.body = params;
    }
  } else {
    req.httpRequest.body = builder.toXML(params, input, input.name ||
      input.shape || util.string.upperFirst(req.operation) + 'Request');
  }
}

function buildRequest(req) {
  Rest.buildRequest(req);

  // never send body payload on GET/HEAD
  if (['GET', 'HEAD'].indexOf(req.httpRequest.method) < 0) {
    populateBody(req);
  }
}

function extractError(resp) {
  Rest.extractError(resp);

  var data;
  try {
    data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());
  } catch (e) {
    data = {
      Code: resp.httpResponse.statusCode,
      Message: resp.httpResponse.statusMessage
    };
  }

  if (data.Errors) data = data.Errors;
  if (data.Error) data = data.Error;
  if (data.Code) {
    resp.error = util.error(new Error(), {
      code: data.Code,
      message: data.Message
    });
  } else {
    resp.error = util.error(new Error(), {
      code: resp.httpResponse.statusCode,
      message: null
    });
  }
}

function extractData(resp) {
  Rest.extractData(resp);

  var parser;
  var req = resp.request;
  var body = resp.httpResponse.body;
  var operation = req.service.api.operations[req.operation];
  var output = operation.output;

  var hasEventOutput = operation.hasEventOutput;

  var payload = output.payload;
  if (payload) {
    var payloadMember = output.members[payload];
    if (payloadMember.isEventStream) {
      parser = new AWS.XML.Parser();
      resp.data[payload] = util.createEventStream(
        AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
        parser,
        payloadMember
      );
    } else if (payloadMember.type === 'structure') {
      parser = new AWS.XML.Parser();
      resp.data[payload] = parser.parse(body.toString(), payloadMember);
    } else if (payloadMember.type === 'binary' || payloadMember.isStreaming) {
      resp.data[payload] = body;
    } else {
      resp.data[payload] = payloadMember.toType(body);
    }
  } else if (body.length > 0) {
    parser = new AWS.XML.Parser();
    var data = parser.parse(body.toString(), output);
    util.update(resp.data, data);
  }
}

/**
 * @api private
 */
module.exports = {
  buildRequest: buildRequest,
  extractError: extractError,
  extractData: extractData
};

},{"../core":23,"../util":80,"./rest":53}],56:[function(require,module,exports){
var util = require('../util');

function QueryParamSerializer() {
}

QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
  serializeStructure('', params, shape, fn);
};

function ucfirst(shape) {
  if (shape.isQueryName || shape.api.protocol !== 'ec2') {
    return shape.name;
  } else {
    return shape.name[0].toUpperCase() + shape.name.substr(1);
  }
}

function serializeStructure(prefix, struct, rules, fn) {
  util.each(rules.members, function(name, member) {
    var value = struct[name];
    if (value === null || value === undefined) return;

    var memberName = ucfirst(member);
    memberName = prefix ? prefix + '.' + memberName : memberName;
    serializeMember(memberName, value, member, fn);
  });
}

function serializeMap(name, map, rules, fn) {
  var i = 1;
  util.each(map, function (key, value) {
    var prefix = rules.flattened ? '.' : '.entry.';
    var position = prefix + (i++) + '.';
    var keyName = position + (rules.key.name || 'key');
    var valueName = position + (rules.value.name || 'value');
    serializeMember(name + keyName, key, rules.key, fn);
    serializeMember(name + valueName, value, rules.value, fn);
  });
}

function serializeList(name, list, rules, fn) {
  var memberRules = rules.member || {};

  if (list.length === 0) {
    fn.call(this, name, null);
    return;
  }

  util.arrayEach(list, function (v, n) {
    var suffix = '.' + (n + 1);
    if (rules.api.protocol === 'ec2') {
      // Do nothing for EC2
      suffix = suffix + ''; // make linter happy
    } else if (rules.flattened) {
      if (memberRules.name) {
        var parts = name.split('.');
        parts.pop();
        parts.push(ucfirst(memberRules));
        name = parts.join('.');
      }
    } else {
      suffix = '.' + (memberRules.name ? memberRules.name : 'member') + suffix;
    }
    serializeMember(name + suffix, v, memberRules, fn);
  });
}

function serializeMember(name, value, rules, fn) {
  if (value === null || value === undefined) return;
  if (rules.type === 'structure') {
    serializeStructure(name, value, rules, fn);
  } else if (rules.type === 'list') {
    serializeList(name, value, rules, fn);
  } else if (rules.type === 'map') {
    serializeMap(name, value, rules, fn);
  } else {
    fn(name, rules.toWireFormat(value).toString());
  }
}

/**
 * @api private
 */
module.exports = QueryParamSerializer;

},{"../util":80}],57:[function(require,module,exports){
module.exports = {
  //provide realtime clock for performance measurement
  now: function now() {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
      return performance.now();
    }
    return Date.now();
  }
};

},{}],58:[function(require,module,exports){
function isFipsRegion(region) {
  return typeof region === 'string' && (region.startsWith('fips-') || region.endsWith('-fips'));
}

function isGlobalRegion(region) {
  return typeof region === 'string' && ['aws-global', 'aws-us-gov-global'].includes(region);
}

function getRealRegion(region) {
  return ['fips-aws-global', 'aws-fips', 'aws-global'].includes(region)
      ? 'us-east-1'
      : ['fips-aws-us-gov-global', 'aws-us-gov-global'].includes(region)
      ? 'us-gov-west-1'
      : region.replace(/fips-(dkr-|prod-)?|-fips/, '');
}

module.exports = {
  isFipsRegion: isFipsRegion,
  isGlobalRegion: isGlobalRegion,
  getRealRegion: getRealRegion
};

},{}],59:[function(require,module,exports){
var util = require('./util');
var regionConfig = require('./region_config_data.json');

function generateRegionPrefix(region) {
  if (!region) return null;
  var parts = region.split('-');
  if (parts.length < 3) return null;
  return parts.slice(0, parts.length - 2).join('-') + '-*';
}

function derivedKeys(service) {
  var region = service.config.region;
  var regionPrefix = generateRegionPrefix(region);
  var endpointPrefix = service.api.endpointPrefix;

  return [
    [region, endpointPrefix],
    [regionPrefix, endpointPrefix],
    [region, '*'],
    [regionPrefix, '*'],
    ['*', endpointPrefix],
    ['*', '*']
  ].map(function(item) {
    return item[0] && item[1] ? item.join('/') : null;
  });
}

function applyConfig(service, config) {
  util.each(config, function(key, value) {
    if (key === 'globalEndpoint') return;
    if (service.config[key] === undefined || service.config[key] === null) {
      service.config[key] = value;
    }
  });
}

function configureEndpoint(service) {
  var keys = derivedKeys(service);
  var useFipsEndpoint = service.config.useFipsEndpoint;
  var useDualstackEndpoint = service.config.useDualstackEndpoint;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!key) continue;

    var rules = useFipsEndpoint
      ? useDualstackEndpoint
        ? regionConfig.dualstackFipsRules
        : regionConfig.fipsRules
      : useDualstackEndpoint
      ? regionConfig.dualstackRules
      : regionConfig.rules;

    if (Object.prototype.hasOwnProperty.call(rules, key)) {
      var config = rules[key];
      if (typeof config === 'string') {
        config = regionConfig.patterns[config];
      }

      // set global endpoint
      service.isGlobalEndpoint = !!config.globalEndpoint;
      if (config.signingRegion) {
        service.signingRegion = config.signingRegion;
      }

      // signature version
      if (!config.signatureVersion) config.signatureVersion = 'v4';

      // merge config
      applyConfig(service, config);
      return;
    }
  }
}

function getEndpointSuffix(region) {
  var regionRegexes = {
    '^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^cn\\-\\w+\\-\\d+$': 'amazonaws.com.cn',
    '^us\\-gov\\-\\w+\\-\\d+$': 'amazonaws.com',
    '^us\\-iso\\-\\w+\\-\\d+$': 'c2s.ic.gov',
    '^us\\-isob\\-\\w+\\-\\d+$': 'sc2s.sgov.gov'
  };
  var defaultSuffix = 'amazonaws.com';
  var regexes = Object.keys(regionRegexes);
  for (var i = 0; i < regexes.length; i++) {
    var regionPattern = RegExp(regexes[i]);
    var dnsSuffix = regionRegexes[regexes[i]];
    if (regionPattern.test(region)) return dnsSuffix;
  }
  return defaultSuffix;
}

/**
 * @api private
 */
module.exports = {
  configureEndpoint: configureEndpoint,
  getEndpointSuffix: getEndpointSuffix,
};

},{"./region_config_data.json":60,"./util":80}],60:[function(require,module,exports){
module.exports={
  "rules": {
    "*/*": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "cn-*/*": {
      "endpoint": "{service}.{region}.amazonaws.com.cn"
    },
    "us-iso-*/*": "usIso",
    "us-isob-*/*": "usIsob",
    "*/budgets": "globalSSL",
    "*/cloudfront": "globalSSL",
    "*/sts": "globalSSL",
    "*/importexport": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2",
      "globalEndpoint": true
    },

    "*/route53": "globalSSL",
    "cn-*/route53": {
      "endpoint": "{service}.amazonaws.com.cn",
      "globalEndpoint": true,
      "signingRegion": "cn-northwest-1"
    },
    "us-gov-*/route53": "globalGovCloud",
    "us-iso-*/route53": {
      "endpoint": "{service}.c2s.ic.gov",
      "globalEndpoint": true,
      "signingRegion": "us-iso-east-1"
    },
    "us-isob-*/route53": {
      "endpoint": "{service}.sc2s.sgov.gov",
      "globalEndpoint": true,
      "signingRegion": "us-isob-east-1"
    },

    "*/waf": "globalSSL",

    "*/iam": "globalSSL",
    "cn-*/iam": {
      "endpoint": "{service}.cn-north-1.amazonaws.com.cn",
      "globalEndpoint": true,
      "signingRegion": "cn-north-1"
    },
    "us-gov-*/iam": "globalGovCloud",

    "us-gov-*/sts": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "us-gov-west-1/s3": "s3signature",
    "us-west-1/s3": "s3signature",
    "us-west-2/s3": "s3signature",
    "eu-west-1/s3": "s3signature",
    "ap-southeast-1/s3": "s3signature",
    "ap-southeast-2/s3": "s3signature",
    "ap-northeast-1/s3": "s3signature",
    "sa-east-1/s3": "s3signature",
    "us-east-1/s3": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "s3"
    },
    "us-east-1/sdb": {
      "endpoint": "{service}.amazonaws.com",
      "signatureVersion": "v2"
    },
    "*/sdb": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "v2"
    }
  },

  "fipsRules": {
    "*/*": "fipsStandard",
    "us-gov-*/*": "fipsStandard",
    "us-iso-*/*": {
      "endpoint": "{service}-fips.{region}.c2s.ic.gov"
    },
    "us-iso-*/dms": "usIso",
    "us-isob-*/*": {
      "endpoint": "{service}-fips.{region}.sc2s.sgov.gov"
    },
    "us-isob-*/dms": "usIsob",
    "cn-*/*": {
      "endpoint": "{service}-fips.{region}.amazonaws.com.cn"
    },
    "*/api.ecr": "fips.api.ecr",
    "*/api.sagemaker": "fips.api.sagemaker",
    "*/batch": "fipsDotPrefix",
    "*/eks": "fipsDotPrefix",
    "*/models.lex": "fips.models.lex",
    "*/runtime.lex": "fips.runtime.lex",
    "*/runtime.sagemaker": {
      "endpoint": "runtime-fips.sagemaker.{region}.amazonaws.com"
    },
    "*/iam": "fipsWithoutRegion",
    "*/route53": "fipsWithoutRegion",
    "*/transcribe": "fipsDotPrefix",
    "*/waf": "fipsWithoutRegion",

    "us-gov-*/transcribe": "fipsDotPrefix",
    "us-gov-*/api.ecr": "fips.api.ecr",
    "us-gov-*/api.sagemaker": "fips.api.sagemaker",
    "us-gov-*/models.lex": "fips.models.lex",
    "us-gov-*/runtime.lex": "fips.runtime.lex",
    "us-gov-*/acm-pca": "fipsWithServiceOnly",
    "us-gov-*/batch": "fipsWithServiceOnly",
    "us-gov-*/config": "fipsWithServiceOnly",
    "us-gov-*/eks": "fipsWithServiceOnly",
    "us-gov-*/elasticmapreduce": "fipsWithServiceOnly",
    "us-gov-*/identitystore": "fipsWithServiceOnly",
    "us-gov-*/dynamodb": "fipsWithServiceOnly",
    "us-gov-*/elasticloadbalancing": "fipsWithServiceOnly",
    "us-gov-*/guardduty": "fipsWithServiceOnly",
    "us-gov-*/monitoring": "fipsWithServiceOnly",
    "us-gov-*/resource-groups": "fipsWithServiceOnly",
    "us-gov-*/runtime.sagemaker": "fipsWithServiceOnly",
    "us-gov-*/servicecatalog-appregistry": "fipsWithServiceOnly",
    "us-gov-*/servicequotas": "fipsWithServiceOnly",
    "us-gov-*/ssm": "fipsWithServiceOnly",
    "us-gov-*/sts": "fipsWithServiceOnly",
    "us-gov-*/support": "fipsWithServiceOnly",
    "us-gov-west-1/states": "fipsWithServiceOnly",
    "us-iso-east-1/elasticfilesystem": {
      "endpoint": "elasticfilesystem-fips.{region}.c2s.ic.gov"
    },
    "us-gov-west-1/organizations": "fipsWithServiceOnly",
    "us-gov-west-1/route53": {
      "endpoint": "route53.us-gov.amazonaws.com"
    }
  },

  "dualstackRules": {
    "*/*": {
      "endpoint": "{service}.{region}.api.aws"
    },
    "cn-*/*": {
      "endpoint": "{service}.{region}.api.amazonwebservices.com.cn"
    },

    "*/s3": "dualstackLegacy",
    "cn-*/s3": "dualstackLegacyCn",
    "*/s3-control": "dualstackLegacy",
    "cn-*/s3-control": "dualstackLegacyCn",

    "ap-south-1/ec2": "dualstackLegacyEc2",
    "eu-west-1/ec2": "dualstackLegacyEc2",
    "sa-east-1/ec2": "dualstackLegacyEc2",
    "us-east-1/ec2": "dualstackLegacyEc2",
    "us-east-2/ec2": "dualstackLegacyEc2",
    "us-west-2/ec2": "dualstackLegacyEc2"
  },

  "dualstackFipsRules": {
    "*/*": {
      "endpoint": "{service}-fips.{region}.api.aws"
    },
    "cn-*/*": {
      "endpoint": "{service}-fips.{region}.api.amazonwebservices.com.cn"
    },
    "*/s3": "dualstackFipsLegacy",
    "cn-*/s3": "dualstackFipsLegacyCn",
    "*/s3-control": "dualstackFipsLegacy",
    "cn-*/s3-control": "dualstackFipsLegacyCn"
  },

  "patterns": {
    "globalSSL": {
      "endpoint": "https://{service}.amazonaws.com",
      "globalEndpoint": true,
      "signingRegion": "us-east-1"
    },
    "globalGovCloud": {
      "endpoint": "{service}.us-gov.amazonaws.com",
      "globalEndpoint": true,
      "signingRegion": "us-gov-west-1"
    },
    "s3signature": {
      "endpoint": "{service}.{region}.amazonaws.com",
      "signatureVersion": "s3"
    },
    "usIso": {
      "endpoint": "{service}.{region}.c2s.ic.gov"
    },
    "usIsob": {
      "endpoint": "{service}.{region}.sc2s.sgov.gov"
    },
    "fipsStandard": {
      "endpoint": "{service}-fips.{region}.amazonaws.com"
    },
    "fipsDotPrefix": {
      "endpoint": "fips.{service}.{region}.amazonaws.com"
    },
    "fipsWithoutRegion": {
      "endpoint": "{service}-fips.amazonaws.com"
    },
    "fips.api.ecr": {
      "endpoint": "ecr-fips.{region}.amazonaws.com"
    },
    "fips.api.sagemaker": {
      "endpoint": "api-fips.sagemaker.{region}.amazonaws.com"
    },
    "fips.models.lex": {
      "endpoint": "models-fips.lex.{region}.amazonaws.com"
    },
    "fips.runtime.lex": {
      "endpoint": "runtime-fips.lex.{region}.amazonaws.com"
    },
    "fipsWithServiceOnly": {
      "endpoint": "{service}.{region}.amazonaws.com"
    },
    "dualstackLegacy": {
      "endpoint": "{service}.dualstack.{region}.amazonaws.com"
    },
    "dualstackLegacyCn": {
      "endpoint": "{service}.dualstack.{region}.amazonaws.com.cn"
    },
    "dualstackFipsLegacy": {
      "endpoint": "{service}-fips.dualstack.{region}.amazonaws.com"
    },
    "dualstackFipsLegacyCn": {
      "endpoint": "{service}-fips.dualstack.{region}.amazonaws.com.cn"
    },
    "dualstackLegacyEc2": {
      "endpoint": "api.ec2.{region}.aws"
    }
  }
}

},{}],61:[function(require,module,exports){
(function (process){(function (){
var AWS = require('./core');
var AcceptorStateMachine = require('./state_machine');
var inherit = AWS.util.inherit;
var domain = AWS.util.domain;
var jmespath = require('jmespath');

/**
 * @api private
 */
var hardErrorStates = {success: 1, error: 1, complete: 1};

function isTerminalState(machine) {
  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
}

var fsm = new AcceptorStateMachine();
fsm.setupStates = function() {
  var transition = function(_, done) {
    var self = this;
    self._haltHandlersOnError = false;

    self.emit(self._asm.currentState, function(err) {
      if (err) {
        if (isTerminalState(self)) {
          if (domain && self.domain instanceof domain.Domain) {
            err.domainEmitter = self;
            err.domain = self.domain;
            err.domainThrown = false;
            self.domain.emit('error', err);
          } else {
            throw err;
          }
        } else {
          self.response.error = err;
          done(err);
        }
      } else {
        done(self.response.error);
      }
    });

  };

  this.addState('validate', 'build', 'error', transition);
  this.addState('build', 'afterBuild', 'restart', transition);
  this.addState('afterBuild', 'sign', 'restart', transition);
  this.addState('sign', 'send', 'retry', transition);
  this.addState('retry', 'afterRetry', 'afterRetry', transition);
  this.addState('afterRetry', 'sign', 'error', transition);
  this.addState('send', 'validateResponse', 'retry', transition);
  this.addState('validateResponse', 'extractData', 'extractError', transition);
  this.addState('extractError', 'extractData', 'retry', transition);
  this.addState('extractData', 'success', 'retry', transition);
  this.addState('restart', 'build', 'error', transition);
  this.addState('success', 'complete', 'complete', transition);
  this.addState('error', 'complete', 'complete', transition);
  this.addState('complete', null, null, transition);
};
fsm.setupStates();

/**
 * ## Asynchronous Requests
 *
 * All requests made through the SDK are asynchronous and use a
 * callback interface. Each service method that kicks off a request
 * returns an `AWS.Request` object that you can use to register
 * callbacks.
 *
 * For example, the following service method returns the request
 * object as "request", which can be used to register callbacks:
 *
 * ```javascript
 * // request is an AWS.Request object
 * var request = ec2.describeInstances();
 *
 * // register callbacks on request to retrieve response data
 * request.on('success', function(response) {
 *   console.log(response.data);
 * });
 * ```
 *
 * When a request is ready to be sent, the {send} method should
 * be called:
 *
 * ```javascript
 * request.send();
 * ```
 *
 * Since registered callbacks may or may not be idempotent, requests should only
 * be sent once. To perform the same operation multiple times, you will need to
 * create multiple request objects, each with its own registered callbacks.
 *
 * ## Removing Default Listeners for Events
 *
 * Request objects are built with default listeners for the various events,
 * depending on the service type. In some cases, you may want to remove
 * some built-in listeners to customize behaviour. Doing this requires
 * access to the built-in listener functions, which are exposed through
 * the {AWS.EventListeners.Core} namespace. For instance, you may
 * want to customize the HTTP handler used when sending a request. In this
 * case, you can remove the built-in listener associated with the 'send'
 * event, the {AWS.EventListeners.Core.SEND} listener and add your own.
 *
 * ## Multiple Callbacks and Chaining
 *
 * You can register multiple callbacks on any request object. The
 * callbacks can be registered for different events, or all for the
 * same event. In addition, you can chain callback registration, for
 * example:
 *
 * ```javascript
 * request.
 *   on('success', function(response) {
 *     console.log("Success!");
 *   }).
 *   on('error', function(error, response) {
 *     console.log("Error!");
 *   }).
 *   on('complete', function(response) {
 *     console.log("Always!");
 *   }).
 *   send();
 * ```
 *
 * The above example will print either "Success! Always!", or "Error! Always!",
 * depending on whether the request succeeded or not.
 *
 * @!attribute httpRequest
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpRequest] the raw HTTP request object
 *     containing request headers and body information
 *     sent by the service.
 *
 * @!attribute startTime
 *   @readonly
 *   @!group Operation Properties
 *   @return [Date] the time that the request started
 *
 * @!group Request Building Events
 *
 * @!event validate(request)
 *   Triggered when a request is being validated. Listeners
 *   should throw an error if the request should not be sent.
 *   @param request [Request] the request object being sent
 *   @see AWS.EventListeners.Core.VALIDATE_CREDENTIALS
 *   @see AWS.EventListeners.Core.VALIDATE_REGION
 *   @example Ensuring that a certain parameter is set before sending a request
 *     var req = s3.putObject(params);
 *     req.on('validate', function() {
 *       if (!req.params.Body.match(/^Hello\s/)) {
 *         throw new Error('Body must start with "Hello "');
 *       }
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event build(request)
 *   Triggered when the request payload is being built. Listeners
 *   should fill the necessary information to send the request
 *   over HTTP.
 *   @param (see AWS.Request~validate)
 *   @example Add a custom HTTP header to a request
 *     var req = s3.putObject(params);
 *     req.on('build', function() {
 *       req.httpRequest.headers['Custom-Header'] = 'value';
 *     });
 *     req.send(function(err, data) { ... });
 *
 * @!event sign(request)
 *   Triggered when the request is being signed. Listeners should
 *   add the correct authentication headers and/or adjust the body,
 *   depending on the authentication mechanism being used.
 *   @param (see AWS.Request~validate)
 *
 * @!group Request Sending Events
 *
 * @!event send(response)
 *   Triggered when the request is ready to be sent. Listeners
 *   should call the underlying transport layer to initiate
 *   the sending of the request.
 *   @param response [Response] the response object
 *   @context [Request] the request object that was sent
 *   @see AWS.EventListeners.Core.SEND
 *
 * @!event retry(response)
 *   Triggered when a request failed and might need to be retried or redirected.
 *   If the response is retryable, the listener should set the
 *   `response.error.retryable` property to `true`, and optionally set
 *   `response.error.retryDelay` to the millisecond delay for the next attempt.
 *   In the case of a redirect, `response.error.redirect` should be set to
 *   `true` with `retryDelay` set to an optional delay on the next request.
 *
 *   If a listener decides that a request should not be retried,
 *   it should set both `retryable` and `redirect` to false.
 *
 *   Note that a retryable error will be retried at most
 *   {AWS.Config.maxRetries} times (based on the service object's config).
 *   Similarly, a request that is redirected will only redirect at most
 *   {AWS.Config.maxRedirects} times.
 *
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @example Adding a custom retry for a 404 response
 *     request.on('retry', function(response) {
 *       // this resource is not yet available, wait 10 seconds to get it again
 *       if (response.httpResponse.statusCode === 404 && response.error) {
 *         response.error.retryable = true;   // retry this error
 *         response.error.retryDelay = 10000; // wait 10 seconds
 *       }
 *     });
 *
 * @!group Data Parsing Events
 *
 * @!event extractError(response)
 *   Triggered on all non-2xx requests so that listeners can extract
 *   error details from the response body. Listeners to this event
 *   should set the `response.error` property.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event extractData(response)
 *   Triggered in successful requests to allow listeners to
 *   de-serialize the response body into `response.data`.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group Completion Events
 *
 * @!event success(response)
 *   Triggered when the request completed successfully.
 *   `response.data` will contain the response data and
 *   `response.error` will be null.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event error(error, response)
 *   Triggered when an error occurs at any point during the
 *   request. `response.error` will contain details about the error
 *   that occurred. `response.data` will be null.
 *   @param error [Error] the error object containing details about
 *     the error that occurred.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event complete(response)
 *   Triggered whenever a request cycle completes. `response.error`
 *   should be checked, since the request may have failed.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!group HTTP Events
 *
 * @!event httpHeaders(statusCode, headers, response, statusMessage)
 *   Triggered when headers are sent by the remote server
 *   @param statusCode [Integer] the HTTP response code
 *   @param headers [map<String,String>] the response headers
 *   @param (see AWS.Request~send)
 *   @param statusMessage [String] A status message corresponding to the HTTP
 *                                 response code
 *   @context (see AWS.Request~send)
 *
 * @!event httpData(chunk, response)
 *   Triggered when data is sent by the remote server
 *   @param chunk [Buffer] the buffer data containing the next data chunk
 *     from the server
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @see AWS.EventListeners.Core.HTTP_DATA
 *
 * @!event httpUploadProgress(progress, response)
 *   Triggered when the HTTP request has uploaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpDownloadProgress(progress, response)
 *   Triggered when the HTTP request has downloaded more data
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request.
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *   @note This event will not be emitted in Node.js 0.8.x.
 *
 * @!event httpError(error, response)
 *   Triggered when the HTTP request failed
 *   @param error [Error] the error object that was thrown
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @!event httpDone(response)
 *   Triggered when the server is finished sending data
 *   @param (see AWS.Request~send)
 *   @context (see AWS.Request~send)
 *
 * @see AWS.Response
 */
AWS.Request = inherit({

  /**
   * Creates a request for an operation on a given service with
   * a set of input parameters.
   *
   * @param service [AWS.Service] the service to perform the operation on
   * @param operation [String] the operation to perform on the service
   * @param params [Object] parameters to send to the operation.
   *   See the operation's documentation for the format of the
   *   parameters.
   */
  constructor: function Request(service, operation, params) {
    var endpoint = service.endpoint;
    var region = service.config.region;
    var customUserAgent = service.config.customUserAgent;

    if (service.signingRegion) {
      region = service.signingRegion;
    } else if (service.isGlobalEndpoint) {
      region = 'us-east-1';
    }

    this.domain = domain && domain.active;
    this.service = service;
    this.operation = operation;
    this.params = params || {};
    this.httpRequest = new AWS.HttpRequest(endpoint, region);
    this.httpRequest.appendToUserAgent(customUserAgent);
    this.startTime = service.getSkewCorrectedDate();

    this.response = new AWS.Response(this);
    this._asm = new AcceptorStateMachine(fsm.states, 'validate');
    this._haltHandlersOnError = false;

    AWS.SequentialExecutor.call(this);
    this.emit = this.emitEvent;
  },

  /**
   * @!group Sending a Request
   */

  /**
   * @overload send(callback = null)
   *   Sends the request object.
   *
   *   @callback callback function(err, data)
   *     If a callback is supplied, it is called when a response is returned
   *     from the service.
   *     @context [AWS.Request] the request object being sent.
   *     @param err [Error] the error object returned from the request.
   *       Set to `null` if the request is successful.
   *     @param data [Object] the de-serialized data returned from
   *       the request. Set to `null` if a request error occurs.
   *   @example Sending a request with a callback
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.send(function(err, data) { console.log(err, data); });
   *   @example Sending a request with no callback (using event handlers)
   *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     request.on('complete', function(response) { ... }); // register a callback
   *     request.send();
   */
  send: function send(callback) {
    if (callback) {
      // append to user agent
      this.httpRequest.appendToUserAgent('callback');
      this.on('complete', function (resp) {
        callback.call(resp, resp.error, resp.data);
      });
    }
    this.runTo();

    return this.response;
  },

  /**
   * @!method  promise()
   *   Sends the request and returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [Object] the de-serialized data returned from the request.
   *   @callback rejectedCallback function(error)
   *     Called if the promise is rejected.
   *     @param error [Error] the error object returned from the request.
   *   @return [Promise] A promise that represents the state of the request.
   *   @example Sending a request using promises.
   *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
   *     var result = request.promise();
   *     result.then(function(data) { ... }, function(error) { ... });
   */

  /**
   * @api private
   */
  build: function build(callback) {
    return this.runTo('send', callback);
  },

  /**
   * @api private
   */
  runTo: function runTo(state, done) {
    this._asm.runTo(state, done, this);
    return this;
  },

  /**
   * Aborts a request, emitting the error and complete events.
   *
   * @!macro nobrowser
   * @example Aborting a request after sending
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
   *   };
   *   var request = s3.putObject(params);
   *   request.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(request.abort.bind(request), 1000);
   *
   *   // prints "Error: RequestAbortedError Request aborted by user"
   * @return [AWS.Request] the same request object, for chaining.
   * @since v1.4.0
   */
  abort: function abort() {
    this.removeAllListeners('validateResponse');
    this.removeAllListeners('extractError');
    this.on('validateResponse', function addAbortedError(resp) {
      resp.error = AWS.util.error(new Error('Request aborted by user'), {
         code: 'RequestAbortedError', retryable: false
      });
    });

    if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) { // abort HTTP stream
      this.httpRequest.stream.abort();
      if (this.httpRequest._abortCallback) {
         this.httpRequest._abortCallback();
      } else {
        this.removeAllListeners('send'); // haven't sent yet, so let's not
      }
    }

    return this;
  },

  /**
   * Iterates over each page of results given a pageable request, calling
   * the provided callback with each page of data. After all pages have been
   * retrieved, the callback is called with `null` data.
   *
   * @note This operation can generate multiple requests to a service.
   * @example Iterating over multiple pages of objects in an S3 bucket
   *   var pages = 1;
   *   s3.listObjects().eachPage(function(err, data) {
   *     if (err) return;
   *     console.log("Page", pages++);
   *     console.log(data);
   *   });
   * @example Iterating over multiple pages with an asynchronous callback
   *   s3.listObjects(params).eachPage(function(err, data, done) {
   *     doSomethingAsyncAndOrExpensive(function() {
   *       // The next page of results isn't fetched until done is called
   *       done();
   *     });
   *   });
   * @callback callback function(err, data, [doneCallback])
   *   Called with each page of resulting data from the request. If the
   *   optional `doneCallback` is provided in the function, it must be called
   *   when the callback is complete.
   *
   *   @param err [Error] an error object, if an error occurred.
   *   @param data [Object] a single page of response data. If there is no
   *     more data, this object will be `null`.
   *   @param doneCallback [Function] an optional done callback. If this
   *     argument is defined in the function declaration, it should be called
   *     when the next page is ready to be retrieved. This is useful for
   *     controlling serial pagination across asynchronous operations.
   *   @return [Boolean] if the callback returns `false`, pagination will
   *     stop.
   *
   * @see AWS.Request.eachItem
   * @see AWS.Response.nextPage
   * @since v1.4.0
   */
  eachPage: function eachPage(callback) {
    // Make all callbacks async-ish
    callback = AWS.util.fn.makeAsync(callback, 3);

    function wrappedCallback(response) {
      callback.call(response, response.error, response.data, function (result) {
        if (result === false) return;

        if (response.hasNextPage()) {
          response.nextPage().on('complete', wrappedCallback).send();
        } else {
          callback.call(response, null, null, AWS.util.fn.noop);
        }
      });
    }

    this.on('complete', wrappedCallback).send();
  },

  /**
   * Enumerates over individual items of a request, paging the responses if
   * necessary.
   *
   * @api experimental
   * @since v1.4.0
   */
  eachItem: function eachItem(callback) {
    var self = this;
    function wrappedCallback(err, data) {
      if (err) return callback(err, null);
      if (data === null) return callback(null, null);

      var config = self.service.paginationConfig(self.operation);
      var resultKey = config.resultKey;
      if (Array.isArray(resultKey)) resultKey = resultKey[0];
      var items = jmespath.search(data, resultKey);
      var continueIteration = true;
      AWS.util.arrayEach(items, function(item) {
        continueIteration = callback(null, item);
        if (continueIteration === false) {
          return AWS.util.abort;
        }
      });
      return continueIteration;
    }

    this.eachPage(wrappedCallback);
  },

  /**
   * @return [Boolean] whether the operation can return multiple pages of
   *   response data.
   * @see AWS.Response.eachPage
   * @since v1.4.0
   */
  isPageable: function isPageable() {
    return this.service.paginationConfig(this.operation) ? true : false;
  },

  /**
   * Sends the request and converts the request object into a readable stream
   * that can be read from or piped into a writable stream.
   *
   * @note The data read from a readable stream contains only
   *   the raw HTTP body contents.
   * @example Manually reading from a stream
   *   request.createReadStream().on('data', function(data) {
   *     console.log("Got data:", data.toString());
   *   });
   * @example Piping a request body into a file
   *   var out = fs.createWriteStream('/path/to/outfile.jpg');
   *   s3.service.getObject(params).createReadStream().pipe(out);
   * @return [Stream] the readable stream object that can be piped
   *   or read from (by registering 'data' event listeners).
   * @!macro nobrowser
   */
  createReadStream: function createReadStream() {
    var streams = AWS.util.stream;
    var req = this;
    var stream = null;

    if (AWS.HttpClient.streamsApiVersion === 2) {
      stream = new streams.PassThrough();
      process.nextTick(function() { req.send(); });
    } else {
      stream = new streams.Stream();
      stream.readable = true;

      stream.sent = false;
      stream.on('newListener', function(event) {
        if (!stream.sent && event === 'data') {
          stream.sent = true;
          process.nextTick(function() { req.send(); });
        }
      });
    }

    this.on('error', function(err) {
      stream.emit('error', err);
    });

    this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {
      if (statusCode < 300) {
        req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);
        req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);
        req.on('httpError', function streamHttpError(error) {
          resp.error = error;
          resp.error.retryable = false;
        });

        var shouldCheckContentLength = false;
        var expectedLen;
        if (req.httpRequest.method !== 'HEAD') {
          expectedLen = parseInt(headers['content-length'], 10);
        }
        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {
          shouldCheckContentLength = true;
          var receivedLen = 0;
        }

        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {
          if (shouldCheckContentLength && receivedLen !== expectedLen) {
            stream.emit('error', AWS.util.error(
              new Error('Stream content length mismatch. Received ' +
                receivedLen + ' of ' + expectedLen + ' bytes.'),
              { code: 'StreamContentLengthMismatch' }
            ));
          } else if (AWS.HttpClient.streamsApiVersion === 2) {
            stream.end();
          } else {
            stream.emit('end');
          }
        };

        var httpStream = resp.httpResponse.createUnbufferedStream();

        if (AWS.HttpClient.streamsApiVersion === 2) {
          if (shouldCheckContentLength) {
            var lengthAccumulator = new streams.PassThrough();
            lengthAccumulator._write = function(chunk) {
              if (chunk && chunk.length) {
                receivedLen += chunk.length;
              }
              return streams.PassThrough.prototype._write.apply(this, arguments);
            };

            lengthAccumulator.on('end', checkContentLengthAndEmit);
            stream.on('error', function(err) {
              shouldCheckContentLength = false;
              httpStream.unpipe(lengthAccumulator);
              lengthAccumulator.emit('end');
              lengthAccumulator.end();
            });
            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
          } else {
            httpStream.pipe(stream);
          }
        } else {

          if (shouldCheckContentLength) {
            httpStream.on('data', function(arg) {
              if (arg && arg.length) {
                receivedLen += arg.length;
              }
            });
          }

          httpStream.on('data', function(arg) {
            stream.emit('data', arg);
          });
          httpStream.on('end', checkContentLengthAndEmit);
        }

        httpStream.on('error', function(err) {
          shouldCheckContentLength = false;
          stream.emit('error', err);
        });
      }
    });

    return stream;
  },

  /**
   * @param [Array,Response] args This should be the response object,
   *   or an array of args to send to the event.
   * @api private
   */
  emitEvent: function emit(eventName, args, done) {
    if (typeof args === 'function') { done = args; args = null; }
    if (!done) done = function() { };
    if (!args) args = this.eventParameters(eventName, this.response);

    var origEmit = AWS.SequentialExecutor.prototype.emit;
    origEmit.call(this, eventName, args, function (err) {
      if (err) this.response.error = err;
      done.call(this, err);
    });
  },

  /**
   * @api private
   */
  eventParameters: function eventParameters(eventName) {
    switch (eventName) {
      case 'restart':
      case 'validate':
      case 'sign':
      case 'build':
      case 'afterValidate':
      case 'afterBuild':
        return [this];
      case 'error':
        return [this.response.error, this.response];
      default:
        return [this.response];
    }
  },

  /**
   * @api private
   */
  presign: function presign(expires, callback) {
    if (!callback && typeof expires === 'function') {
      callback = expires;
      expires = null;
    }
    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);
  },

  /**
   * @api private
   */
  isPresigned: function isPresigned() {
    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');
  },

  /**
   * @api private
   */
  toUnauthenticated: function toUnauthenticated() {
    this._unAuthenticated = true;
    this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);
    this.removeListener('sign', AWS.EventListeners.Core.SIGN);
    return this;
  },

  /**
   * @api private
   */
  toGet: function toGet() {
    if (this.service.api.protocol === 'query' ||
        this.service.api.protocol === 'ec2') {
      this.removeListener('build', this.buildAsGet);
      this.addListener('build', this.buildAsGet);
    }
    return this;
  },

  /**
   * @api private
   */
  buildAsGet: function buildAsGet(request) {
    request.httpRequest.method = 'GET';
    request.httpRequest.path = request.service.endpoint.path +
                               '?' + request.httpRequest.body;
    request.httpRequest.body = '';

    // don't need these headers on a GET request
    delete request.httpRequest.headers['Content-Length'];
    delete request.httpRequest.headers['Content-Type'];
  },

  /**
   * @api private
   */
  haltHandlersOnError: function haltHandlersOnError() {
    this._haltHandlersOnError = true;
  }
});

/**
 * @api private
 */
AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = function promise() {
    var self = this;
    // append to user agent
    this.httpRequest.appendToUserAgent('promise');
    return new PromiseDependency(function(resolve, reject) {
      self.on('complete', function(resp) {
        if (resp.error) {
          reject(resp.error);
        } else {
          // define $response property so that it is not enumerable
          // this prevents circular reference errors when stringifying the JSON object
          resolve(Object.defineProperty(
            resp.data || {},
            '$response',
            {value: resp}
          ));
        }
      });
      self.runTo();
    });
  };
};

/**
 * @api private
 */
AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.Request);

AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);

}).call(this)}).call(this,require('_process'))

},{"./core":23,"./state_machine":79,"_process":97,"jmespath":96}],62:[function(require,module,exports){
/**
 * Copyright 2012-2013 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not use this file except in compliance with the License. A copy of
 * the License is located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
 * ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');

/**
 * @api private
 */
function CHECK_ACCEPTORS(resp) {
  var waiter = resp.request._waiter;
  var acceptors = waiter.config.acceptors;
  var acceptorMatched = false;
  var state = 'retry';

  acceptors.forEach(function(acceptor) {
    if (!acceptorMatched) {
      var matcher = waiter.matchers[acceptor.matcher];
      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
        acceptorMatched = true;
        state = acceptor.state;
      }
    }
  });

  if (!acceptorMatched && resp.error) state = 'failure';

  if (state === 'success') {
    waiter.setSuccess(resp);
  } else {
    waiter.setError(resp, state === 'retry');
  }
}

/**
 * @api private
 */
AWS.ResourceWaiter = inherit({
  /**
   * Waits for a given state on a service object
   * @param service [Service] the service object to wait on
   * @param state [String] the state (defined in waiter configuration) to wait
   *   for.
   * @example Create a waiter for running EC2 instances
   *   var ec2 = new AWS.EC2;
   *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
   */
  constructor: function constructor(service, state) {
    this.service = service;
    this.state = state;
    this.loadWaiterConfig(this.state);
  },

  service: null,

  state: null,

  config: null,

  matchers: {
    path: function(resp, expected, argument) {
      try {
        var result = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      return jmespath.strictDeepEqual(result,expected);
    },

    pathAll: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      if (!numResults) return false;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (!jmespath.strictDeepEqual(results[ind], expected)) {
          return false;
        }
      }
      return true;
    },

    pathAny: function(resp, expected, argument) {
      try {
        var results = jmespath.search(resp.data, argument);
      } catch (err) {
        return false;
      }

      if (!Array.isArray(results)) results = [results];
      var numResults = results.length;
      for (var ind = 0 ; ind < numResults; ind++) {
        if (jmespath.strictDeepEqual(results[ind], expected)) {
          return true;
        }
      }
      return false;
    },

    status: function(resp, expected) {
      var statusCode = resp.httpResponse.statusCode;
      return (typeof statusCode === 'number') && (statusCode === expected);
    },

    error: function(resp, expected) {
      if (typeof expected === 'string' && resp.error) {
        return expected === resp.error.code;
      }
      // if expected is not string, can be boolean indicating presence of error
      return expected === !!resp.error;
    }
  },

  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {
    add('RETRY_CHECK', 'retry', function(resp) {
      var waiter = resp.request._waiter;
      if (resp.error && resp.error.code === 'ResourceNotReady') {
        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;
      }
    });

    add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);

    add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);
  }),

  /**
   * @return [AWS.Request]
   */
  wait: function wait(params, callback) {
    if (typeof params === 'function') {
      callback = params; params = undefined;
    }

    if (params && params.$waiter) {
      params = AWS.util.copy(params);
      if (typeof params.$waiter.delay === 'number') {
        this.config.delay = params.$waiter.delay;
      }
      if (typeof params.$waiter.maxAttempts === 'number') {
        this.config.maxAttempts = params.$waiter.maxAttempts;
      }
      delete params.$waiter;
    }

    var request = this.service.makeRequest(this.config.operation, params);
    request._waiter = this;
    request.response.maxRetries = this.config.maxAttempts;
    request.addListeners(this.listeners);

    if (callback) request.send(callback);
    return request;
  },

  setSuccess: function setSuccess(resp) {
    resp.error = null;
    resp.data = resp.data || {};
    resp.request.removeAllListeners('extractData');
  },

  setError: function setError(resp, retryable) {
    resp.data = null;
    resp.error = AWS.util.error(resp.error || new Error(), {
      code: 'ResourceNotReady',
      message: 'Resource is not in the state ' + this.state,
      retryable: retryable
    });
  },

  /**
   * Loads waiter configuration from API configuration
   *
   * @api private
   */
  loadWaiterConfig: function loadWaiterConfig(state) {
    if (!this.service.api.waiters[state]) {
      throw new AWS.util.error(new Error(), {
        code: 'StateNotFoundError',
        message: 'State ' + state + ' not found.'
      });
    }

    this.config = AWS.util.copy(this.service.api.waiters[state]);
  }
});

},{"./core":23,"jmespath":96}],63:[function(require,module,exports){
var AWS = require('./core');
var inherit = AWS.util.inherit;
var jmespath = require('jmespath');

/**
 * This class encapsulates the response information
 * from a service request operation sent through {AWS.Request}.
 * The response object has two main properties for getting information
 * back from a request:
 *
 * ## The `data` property
 *
 * The `response.data` property contains the serialized object data
 * retrieved from the service request. For instance, for an
 * Amazon DynamoDB `listTables` method call, the response data might
 * look like:
 *
 * ```
 * > resp.data
 * { TableNames:
 *    [ 'table1', 'table2', ... ] }
 * ```
 *
 * The `data` property can be null if an error occurs (see below).
 *
 * ## The `error` property
 *
 * In the event of a service error (or transfer error), the
 * `response.error` property will be filled with the given
 * error data in the form:
 *
 * ```
 * { code: 'SHORT_UNIQUE_ERROR_CODE',
 *   message: 'Some human readable error message' }
 * ```
 *
 * In the case of an error, the `data` property will be `null`.
 * Note that if you handle events that can be in a failure state,
 * you should always check whether `response.error` is set
 * before attempting to access the `response.data` property.
 *
 * @!attribute data
 *   @readonly
 *   @!group Data Properties
 *   @note Inside of a {AWS.Request~httpData} event, this
 *     property contains a single raw packet instead of the
 *     full de-serialized service response.
 *   @return [Object] the de-serialized response data
 *     from the service.
 *
 * @!attribute error
 *   An structure containing information about a service
 *   or networking error.
 *   @readonly
 *   @!group Data Properties
 *   @note This attribute is only filled if a service or
 *     networking error occurs.
 *   @return [Error]
 *     * code [String] a unique short code representing the
 *       error that was emitted.
 *     * message [String] a longer human readable error message
 *     * retryable [Boolean] whether the error message is
 *       retryable.
 *     * statusCode [Numeric] in the case of a request that reached the service,
 *       this value contains the response status code.
 *     * time [Date] the date time object when the error occurred.
 *     * hostname [String] set when a networking error occurs to easily
 *       identify the endpoint of the request.
 *     * region [String] set when a networking error occurs to easily
 *       identify the region of the request.
 *
 * @!attribute requestId
 *   @readonly
 *   @!group Data Properties
 *   @return [String] the unique request ID associated with the response.
 *     Log this value when debugging requests for AWS support.
 *
 * @!attribute retryCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of retries that were
 *     attempted before the request was completed.
 *
 * @!attribute redirectCount
 *   @readonly
 *   @!group Operation Properties
 *   @return [Integer] the number of redirects that were
 *     followed before the request was completed.
 *
 * @!attribute httpResponse
 *   @readonly
 *   @!group HTTP Properties
 *   @return [AWS.HttpResponse] the raw HTTP response object
 *     containing the response headers and body information
 *     from the server.
 *
 * @see AWS.Request
 */
AWS.Response = inherit({

  /**
   * @api private
   */
  constructor: function Response(request) {
    this.request = request;
    this.data = null;
    this.error = null;
    this.retryCount = 0;
    this.redirectCount = 0;
    this.httpResponse = new AWS.HttpResponse();
    if (request) {
      this.maxRetries = request.service.numRetries();
      this.maxRedirects = request.service.config.maxRedirects;
    }
  },

  /**
   * Creates a new request for the next page of response data, calling the
   * callback with the page data if a callback is provided.
   *
   * @callback callback function(err, data)
   *   Called when a page of data is returned from the next request.
   *
   *   @param err [Error] an error object, if an error occurred in the request
   *   @param data [Object] the next page of data, or null, if there are no
   *     more pages left.
   * @return [AWS.Request] the request object for the next page of data
   * @return [null] if no callback is provided and there are no pages left
   *   to retrieve.
   * @since v1.4.0
   */
  nextPage: function nextPage(callback) {
    var config;
    var service = this.request.service;
    var operation = this.request.operation;
    try {
      config = service.paginationConfig(operation, true);
    } catch (e) { this.error = e; }

    if (!this.hasNextPage()) {
      if (callback) callback(this.error, null);
      else if (this.error) throw this.error;
      return null;
    }

    var params = AWS.util.copy(this.request.params);
    if (!this.nextPageTokens) {
      return callback ? callback(null, null) : null;
    } else {
      var inputTokens = config.inputToken;
      if (typeof inputTokens === 'string') inputTokens = [inputTokens];
      for (var i = 0; i < inputTokens.length; i++) {
        params[inputTokens[i]] = this.nextPageTokens[i];
      }
      return service.makeRequest(this.request.operation, params, callback);
    }
  },

  /**
   * @return [Boolean] whether more pages of data can be returned by further
   *   requests
   * @since v1.4.0
   */
  hasNextPage: function hasNextPage() {
    this.cacheNextPageTokens();
    if (this.nextPageTokens) return true;
    if (this.nextPageTokens === undefined) return undefined;
    else return false;
  },

  /**
   * @api private
   */
  cacheNextPageTokens: function cacheNextPageTokens() {
    if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;
    this.nextPageTokens = undefined;

    var config = this.request.service.paginationConfig(this.request.operation);
    if (!config) return this.nextPageTokens;

    this.nextPageTokens = null;
    if (config.moreResults) {
      if (!jmespath.search(this.data, config.moreResults)) {
        return this.nextPageTokens;
      }
    }

    var exprs = config.outputToken;
    if (typeof exprs === 'string') exprs = [exprs];
    AWS.util.arrayEach.call(this, exprs, function (expr) {
      var output = jmespath.search(this.data, expr);
      if (output) {
        this.nextPageTokens = this.nextPageTokens || [];
        this.nextPageTokens.push(output);
      }
    });

    return this.nextPageTokens;
  }

});

},{"./core":23,"jmespath":96}],64:[function(require,module,exports){
var AWS = require('../core');
var byteLength = AWS.util.string.byteLength;
var Buffer = AWS.util.Buffer;

/**
 * The managed uploader allows for easy and efficient uploading of buffers,
 * blobs, or streams, using a configurable amount of concurrency to perform
 * multipart uploads where possible. This abstraction also enables uploading
 * streams of unknown size due to the use of multipart uploads.
 *
 * To construct a managed upload object, see the {constructor} function.
 *
 * ## Tracking upload progress
 *
 * The managed upload object can also track progress by attaching an
 * 'httpUploadProgress' listener to the upload manager. This event is similar
 * to {AWS.Request~httpUploadProgress} but groups all concurrent upload progress
 * into a single event. See {AWS.S3.ManagedUpload~httpUploadProgress} for more
 * information.
 *
 * ## Handling Multipart Cleanup
 *
 * By default, this class will automatically clean up any multipart uploads
 * when an individual part upload fails. This behavior can be disabled in order
 * to manually handle failures by setting the `leavePartsOnError` configuration
 * option to `true` when initializing the upload object.
 *
 * @!event httpUploadProgress(progress)
 *   Triggered when the uploader has uploaded more data.
 *   @note The `total` property may not be set if the stream being uploaded has
 *     not yet finished chunking. In this case the `total` will be undefined
 *     until the total stream size is known.
 *   @note This event will not be emitted in Node.js 0.8.x.
 *   @param progress [map] An object containing the `loaded` and `total` bytes
 *     of the request and the `key` of the S3 object. Note that `total` may be undefined until the payload
 *     size is known.
 *   @context (see AWS.Request~send)
 */
AWS.S3.ManagedUpload = AWS.util.inherit({
  /**
   * Creates a managed upload object with a set of configuration options.
   *
   * @note A "Body" parameter is required to be set prior to calling {send}.
   * @note In Node.js, sending "Body" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}
   *   may result in upload hangs. Using buffer stream is preferable.
   * @option options params [map] a map of parameters to pass to the upload
   *   requests. The "Body" parameter is required to be specified either on
   *   the service or in the params option.
   * @note ContentMD5 should not be provided when using the managed upload object.
   *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
   *   by the managed upload object.
   * @option options queueSize [Number] (4) the size of the concurrent queue
   *   manager to upload parts in parallel. Set to 1 for synchronous uploading
   *   of parts. Note that the uploader will buffer at most queueSize * partSize
   *   bytes into memory at any given time.
   * @option options partSize [Number] (5mb) the size in bytes for each
   *   individual part to be uploaded. Adjust the part size to ensure the number
   *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
   *   minimum allowed part size.
   * @option options leavePartsOnError [Boolean] (false) whether to abort the
   *   multipart upload if an error occurs. Set to true if you want to handle
   *   failures manually.
   * @option options service [AWS.S3] an optional S3 service object to use for
   *   requests. This object might have bound parameters used by the uploader.
   * @option options tags [Array<map>] The tags to apply to the uploaded object.
   *   Each tag should have a `Key` and `Value` keys.
   * @example Creating a default uploader for a stream object
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with concurrency of 1 and partSize of 10mb
   *   var upload = new AWS.S3.ManagedUpload({
   *     partSize: 10 * 1024 * 1024, queueSize: 1,
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
   *   });
   * @example Creating an uploader with tags
   *   var upload = new AWS.S3.ManagedUpload({
   *     params: {Bucket: 'bucket', Key: 'key', Body: stream},
   *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]
   *   });
   * @see send
   */
  constructor: function ManagedUpload(options) {
    var self = this;
    AWS.SequentialExecutor.call(self);
    self.body = null;
    self.sliceFn = null;
    self.callback = null;
    self.parts = {};
    self.completeInfo = [];
    self.fillQueue = function() {
      self.callback(new Error('Unsupported body payload ' + typeof self.body));
    };

    self.configure(options);
  },

  /**
   * @api private
   */
  configure: function configure(options) {
    options = options || {};
    this.partSize = this.minPartSize;

    if (options.queueSize) this.queueSize = options.queueSize;
    if (options.partSize) this.partSize = options.partSize;
    if (options.leavePartsOnError) this.leavePartsOnError = true;
    if (options.tags) {
      if (!Array.isArray(options.tags)) {
        throw new Error('Tags must be specified as an array; ' +
          typeof options.tags + ' provided.');
      }
      this.tags = options.tags;
    }

    if (this.partSize < this.minPartSize) {
      throw new Error('partSize must be greater than ' +
                      this.minPartSize);
    }

    this.service = options.service;
    this.bindServiceObject(options.params);
    this.validateBody();
    this.adjustTotalBytes();
  },

  /**
   * @api private
   */
  leavePartsOnError: false,

  /**
   * @api private
   */
  queueSize: 4,

  /**
   * @api private
   */
  partSize: null,

  /**
   * @readonly
   * @return [Number] the minimum number of bytes for an individual part
   *   upload.
   */
  minPartSize: 1024 * 1024 * 5,

  /**
   * @readonly
   * @return [Number] the maximum allowed number of parts in a multipart upload.
   */
  maxTotalParts: 10000,

  /**
   * Initiates the managed upload for the payload.
   *
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *     * `Location` (String) the URL of the uploaded object
   *     * `ETag` (String) the ETag of the uploaded object
   *     * `Bucket` (String) the bucket to which the object was uploaded
   *     * `Key` (String) the key to which the object was uploaded
   * @example Sending a managed upload object
   *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *   var upload = new AWS.S3.ManagedUpload({params: params});
   *   upload.send(function(err, data) {
   *     console.log(err, data);
   *   });
   */
  send: function(callback) {
    var self = this;
    self.failed = false;
    self.callback = callback || function(err) { if (err) throw err; };

    var runFill = true;
    if (self.sliceFn) {
      self.fillQueue = self.fillBuffer;
    } else if (AWS.util.isNode()) {
      var Stream = AWS.util.stream.Stream;
      if (self.body instanceof Stream) {
        runFill = false;
        self.fillQueue = self.fillStream;
        self.partBuffers = [];
        self.body.
          on('error', function(err) { self.cleanup(err); }).
          on('readable', function() { self.fillQueue(); }).
          on('end', function() {
            self.isDoneChunking = true;
            self.numParts = self.totalPartNumbers;
            self.fillQueue.call(self);

            if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {
              self.finishMultiPart();
            }
          });
      }
    }

    if (runFill) self.fillQueue.call(self);
  },

  /**
   * @!method  promise()
   *   Returns a 'thenable' promise.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @callback fulfilledCallback function(data)
   *     Called if the promise is fulfilled.
   *     @param data [map] The response data from the successful upload:
   *       `Location` (String) the URL of the uploaded object
   *       `ETag` (String) the ETag of the uploaded object
   *       `Bucket` (String) the bucket to which the object was uploaded
   *       `Key` (String) the key to which the object was uploaded
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] an error or null if no error occurred.
   *   @return [Promise] A promise that represents the state of the upload request.
   *   @example Sending an upload request using promises.
   *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
   *     var promise = upload.promise();
   *     promise.then(function(data) { ... }, function(err) { ... });
   */

  /**
   * Aborts a managed upload, including all concurrent upload requests.
   * @note By default, calling this function will cleanup a multipart upload
   *   if one was created. To leave the multipart upload around after aborting
   *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
   * @note Calling {abort} in the browser environment will not abort any requests
   *   that are already in flight. If a multipart upload was created, any parts
   *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
   * @example Aborting an upload
   *   var params = {
   *     Bucket: 'bucket', Key: 'key',
   *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload
   *   };
   *   var upload = s3.upload(params);
   *   upload.send(function (err, data) {
   *     if (err) console.log("Error:", err.code, err.message);
   *     else console.log(data);
   *   });
   *
   *   // abort request in 1 second
   *   setTimeout(upload.abort.bind(upload), 1000);
   */
  abort: function() {
    var self = this;
    //abort putObject request
    if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {
      self.singlePart.abort();
    } else {
      self.cleanup(AWS.util.error(new Error('Request aborted by user'), {
        code: 'RequestAbortedError', retryable: false
      }));
    }
  },

  /**
   * @api private
   */
  validateBody: function validateBody() {
    var self = this;
    self.body = self.service.config.params.Body;
    if (typeof self.body === 'string') {
      self.body = AWS.util.buffer.toBuffer(self.body);
    } else if (!self.body) {
      throw new Error('params.Body is required');
    }
    self.sliceFn = AWS.util.arraySliceFn(self.body);
  },

  /**
   * @api private
   */
  bindServiceObject: function bindServiceObject(params) {
    params = params || {};
    var self = this;
    // bind parameters to new service object
    if (!self.service) {
      self.service = new AWS.S3({params: params});
    } else {
      // Create a new S3 client from the supplied client's constructor.
      var service = self.service;
      var config = AWS.util.copy(service.config);
      config.signatureVersion = service.getSignatureVersion();
      self.service = new service.constructor.__super__(config);
      self.service.config.params =
        AWS.util.merge(self.service.config.params || {}, params);
      Object.defineProperty(self.service, '_originalConfig', {
        get: function() { return service._originalConfig; },
        enumerable: false,
        configurable: true
      });
    }
  },

  /**
   * @api private
   */
  adjustTotalBytes: function adjustTotalBytes() {
    var self = this;
    try { // try to get totalBytes
      self.totalBytes = byteLength(self.body);
    } catch (e) { }

    // try to adjust partSize if we know payload length
    if (self.totalBytes) {
      var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
      if (newPartSize > self.partSize) self.partSize = newPartSize;
    } else {
      self.totalBytes = undefined;
    }
  },

  /**
   * @api private
   */
  isDoneChunking: false,

  /**
   * @api private
   */
  partPos: 0,

  /**
   * @api private
   */
  totalChunkedBytes: 0,

  /**
   * @api private
   */
  totalUploadedBytes: 0,

  /**
   * @api private
   */
  totalBytes: undefined,

  /**
   * @api private
   */
  numParts: 0,

  /**
   * @api private
   */
  totalPartNumbers: 0,

  /**
   * @api private
   */
  activeParts: 0,

  /**
   * @api private
   */
  doneParts: 0,

  /**
   * @api private
   */
  parts: null,

  /**
   * @api private
   */
  completeInfo: null,

  /**
   * @api private
   */
  failed: false,

  /**
   * @api private
   */
  multipartReq: null,

  /**
   * @api private
   */
  partBuffers: null,

  /**
   * @api private
   */
  partBufferLength: 0,

  /**
   * @api private
   */
  fillBuffer: function fillBuffer() {
    var self = this;
    var bodyLen = byteLength(self.body);

    if (bodyLen === 0) {
      self.isDoneChunking = true;
      self.numParts = 1;
      self.nextChunk(self.body);
      return;
    }

    while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
      var endPos = Math.min(self.partPos + self.partSize, bodyLen);
      var buf = self.sliceFn.call(self.body, self.partPos, endPos);
      self.partPos += self.partSize;

      if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
        self.isDoneChunking = true;
        self.numParts = self.totalPartNumbers + 1;
      }
      self.nextChunk(buf);
    }
  },

  /**
   * @api private
   */
  fillStream: function fillStream() {
    var self = this;
    if (self.activeParts >= self.queueSize) return;

    var buf = self.body.read(self.partSize - self.partBufferLength) ||
              self.body.read();
    if (buf) {
      self.partBuffers.push(buf);
      self.partBufferLength += buf.length;
      self.totalChunkedBytes += buf.length;
    }

    if (self.partBufferLength >= self.partSize) {
      // if we have single buffer we avoid copyfull concat
      var pbuf = self.partBuffers.length === 1 ?
        self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;

      // if we have more than partSize, push the rest back on the queue
      if (pbuf.length > self.partSize) {
        var rest = pbuf.slice(self.partSize);
        self.partBuffers.push(rest);
        self.partBufferLength += rest.length;
        pbuf = pbuf.slice(0, self.partSize);
      }

      self.nextChunk(pbuf);
    }

    if (self.isDoneChunking && !self.isDoneSending) {
      // if we have single buffer we avoid copyfull concat
      pbuf = self.partBuffers.length === 1 ?
          self.partBuffers[0] : Buffer.concat(self.partBuffers);
      self.partBuffers = [];
      self.partBufferLength = 0;
      self.totalBytes = self.totalChunkedBytes;
      self.isDoneSending = true;

      if (self.numParts === 0 || pbuf.length > 0) {
        self.numParts++;
        self.nextChunk(pbuf);
      }
    }

    self.body.read(0);
  },

  /**
   * @api private
   */
  nextChunk: function nextChunk(chunk) {
    var self = this;
    if (self.failed) return null;

    var partNumber = ++self.totalPartNumbers;
    if (self.isDoneChunking && partNumber === 1) {
      var params = {Body: chunk};
      if (this.tags) {
        params.Tagging = this.getTaggingHeader();
      }
      var req = self.service.putObject(params);
      req._managedUpload = self;
      req.on('httpUploadProgress', self.progress).send(self.finishSinglePart);
      self.singlePart = req; //save the single part request
      return null;
    } else if (self.service.config.params.ContentMD5) {
      var err = AWS.util.error(new Error('The Content-MD5 you specified is invalid for multi-part uploads.'), {
        code: 'InvalidDigest', retryable: false
      });

      self.cleanup(err);
      return null;
    }

    if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
      return null; // Already uploaded this part.
    }

    self.activeParts++;
    if (!self.service.config.params.UploadId) {

      if (!self.multipartReq) { // create multipart
        self.multipartReq = self.service.createMultipartUpload();
        self.multipartReq.on('success', function(resp) {
          self.service.config.params.UploadId = resp.data.UploadId;
          self.multipartReq = null;
        });
        self.queueChunks(chunk, partNumber);
        self.multipartReq.on('error', function(err) {
          self.cleanup(err);
        });
        self.multipartReq.send();
      } else {
        self.queueChunks(chunk, partNumber);
      }
    } else { // multipart is created, just send
      self.uploadPart(chunk, partNumber);
    }
  },

  /**
   * @api private
   */
  getTaggingHeader: function getTaggingHeader() {
    var kvPairStrings = [];
    for (var i = 0; i < this.tags.length; i++) {
      kvPairStrings.push(AWS.util.uriEscape(this.tags[i].Key) + '=' +
        AWS.util.uriEscape(this.tags[i].Value));
    }

    return kvPairStrings.join('&');
  },

  /**
   * @api private
   */
  uploadPart: function uploadPart(chunk, partNumber) {
    var self = this;

    var partParams = {
      Body: chunk,
      ContentLength: AWS.util.string.byteLength(chunk),
      PartNumber: partNumber
    };

    var partInfo = {ETag: null, PartNumber: partNumber};
    self.completeInfo[partNumber] = partInfo;

    var req = self.service.uploadPart(partParams);
    self.parts[partNumber] = req;
    req._lastUploadedBytes = 0;
    req._managedUpload = self;
    req.on('httpUploadProgress', self.progress);
    req.send(function(err, data) {
      delete self.parts[partParams.PartNumber];
      self.activeParts--;

      if (!err && (!data || !data.ETag)) {
        var message = 'No access to ETag property on response.';
        if (AWS.util.isBrowser()) {
          message += ' Check CORS configuration to expose ETag header.';
        }

        err = AWS.util.error(new Error(message), {
          code: 'ETagMissing', retryable: false
        });
      }
      if (err) return self.cleanup(err);
      //prevent sending part being returned twice (https://github.com/aws/aws-sdk-js/issues/2304)
      if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) return null;
      partInfo.ETag = data.ETag;
      self.doneParts++;
      if (self.isDoneChunking && self.doneParts === self.totalPartNumbers) {
        self.finishMultiPart();
      } else {
        self.fillQueue.call(self);
      }
    });
  },

  /**
   * @api private
   */
  queueChunks: function queueChunks(chunk, partNumber) {
    var self = this;
    self.multipartReq.on('success', function() {
      self.uploadPart(chunk, partNumber);
    });
  },

  /**
   * @api private
   */
  cleanup: function cleanup(err) {
    var self = this;
    if (self.failed) return;

    // clean up stream
    if (typeof self.body.removeAllListeners === 'function' &&
        typeof self.body.resume === 'function') {
      self.body.removeAllListeners('readable');
      self.body.removeAllListeners('end');
      self.body.resume();
    }

    // cleanup multipartReq listeners
    if (self.multipartReq) {
      self.multipartReq.removeAllListeners('success');
      self.multipartReq.removeAllListeners('error');
      self.multipartReq.removeAllListeners('complete');
      delete self.multipartReq;
    }

    if (self.service.config.params.UploadId && !self.leavePartsOnError) {
      self.service.abortMultipartUpload().send();
    } else if (self.leavePartsOnError) {
      self.isDoneChunking = false;
    }

    AWS.util.each(self.parts, function(partNumber, part) {
      part.removeAllListeners('complete');
      part.abort();
    });

    self.activeParts = 0;
    self.partPos = 0;
    self.numParts = 0;
    self.totalPartNumbers = 0;
    self.parts = {};
    self.failed = true;
    self.callback(err);
  },

  /**
   * @api private
   */
  finishMultiPart: function finishMultiPart() {
    var self = this;
    var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };
    self.service.completeMultipartUpload(completeParams, function(err, data) {
      if (err) {
        return self.cleanup(err);
      }

      if (data && typeof data.Location === 'string') {
        data.Location = data.Location.replace(/%2F/g, '/');
      }

      if (Array.isArray(self.tags)) {
        for (var i = 0; i < self.tags.length; i++) {
          self.tags[i].Value = String(self.tags[i].Value);
        }
        self.service.putObjectTagging(
          {Tagging: {TagSet: self.tags}},
          function(e, d) {
            if (e) {
              self.callback(e);
            } else {
              self.callback(e, data);
            }
          }
        );
      } else {
        self.callback(err, data);
      }
    });
  },

  /**
   * @api private
   */
  finishSinglePart: function finishSinglePart(err, data) {
    var upload = this.request._managedUpload;
    var httpReq = this.request.httpRequest;
    var endpoint = httpReq.endpoint;
    if (err) return upload.callback(err);
    data.Location =
      [endpoint.protocol, '//', endpoint.host, httpReq.path].join('');
    data.key = this.request.params.Key; // will stay undocumented
    data.Key = this.request.params.Key;
    data.Bucket = this.request.params.Bucket;
    upload.callback(err, data);
  },

  /**
   * @api private
   */
  progress: function progress(info) {
    var upload = this._managedUpload;
    if (this.operation === 'putObject') {
      info.part = 1;
      info.key = this.params.Key;
    } else {
      upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
      this._lastUploadedBytes = info.loaded;
      info = {
        loaded: upload.totalUploadedBytes,
        total: upload.totalBytes,
        part: this.params.PartNumber,
        key: this.params.Key
      };
    }
    upload.emit('httpUploadProgress', [info]);
  }
});

AWS.util.mixin(AWS.S3.ManagedUpload, AWS.SequentialExecutor);

/**
 * @api private
 */
AWS.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.promise = AWS.util.promisifyMethod('send', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.promise;
};

AWS.util.addPromises(AWS.S3.ManagedUpload);

/**
 * @api private
 */
module.exports = AWS.S3.ManagedUpload;

},{"../core":23}],65:[function(require,module,exports){
var AWS = require('./core');

/**
 * @api private
 * @!method on(eventName, callback)
 *   Registers an event listener callback for the event given by `eventName`.
 *   Parameters passed to the callback function depend on the individual event
 *   being triggered. See the event documentation for those parameters.
 *
 *   @param eventName [String] the event name to register the listener for
 *   @param callback [Function] the listener callback function
 *   @param toHead [Boolean] attach the listener callback to the head of callback array if set to true.
 *     Default to be false.
 *   @return [AWS.SequentialExecutor] the same object for chaining
 */
AWS.SequentialExecutor = AWS.util.inherit({

  constructor: function SequentialExecutor() {
    this._events = {};
  },

  /**
   * @api private
   */
  listeners: function listeners(eventName) {
    return this._events[eventName] ? this._events[eventName].slice(0) : [];
  },

  on: function on(eventName, listener, toHead) {
    if (this._events[eventName]) {
      toHead ?
        this._events[eventName].unshift(listener) :
        this._events[eventName].push(listener);
    } else {
      this._events[eventName] = [listener];
    }
    return this;
  },

  onAsync: function onAsync(eventName, listener, toHead) {
    listener._isAsync = true;
    return this.on(eventName, listener, toHead);
  },

  removeListener: function removeListener(eventName, listener) {
    var listeners = this._events[eventName];
    if (listeners) {
      var length = listeners.length;
      var position = -1;
      for (var i = 0; i < length; ++i) {
        if (listeners[i] === listener) {
          position = i;
        }
      }
      if (position > -1) {
        listeners.splice(position, 1);
      }
    }
    return this;
  },

  removeAllListeners: function removeAllListeners(eventName) {
    if (eventName) {
      delete this._events[eventName];
    } else {
      this._events = {};
    }
    return this;
  },

  /**
   * @api private
   */
  emit: function emit(eventName, eventArgs, doneCallback) {
    if (!doneCallback) doneCallback = function() { };
    var listeners = this.listeners(eventName);
    var count = listeners.length;
    this.callListeners(listeners, eventArgs, doneCallback);
    return count > 0;
  },

  /**
   * @api private
   */
  callListeners: function callListeners(listeners, args, doneCallback, prevError) {
    var self = this;
    var error = prevError || null;

    function callNextListener(err) {
      if (err) {
        error = AWS.util.error(error || new Error(), err);
        if (self._haltHandlersOnError) {
          return doneCallback.call(self, error);
        }
      }
      self.callListeners(listeners, args, doneCallback, error);
    }

    while (listeners.length > 0) {
      var listener = listeners.shift();
      if (listener._isAsync) { // asynchronous listener
        listener.apply(self, args.concat([callNextListener]));
        return; // stop here, callNextListener will continue
      } else { // synchronous listener
        try {
          listener.apply(self, args);
        } catch (err) {
          error = AWS.util.error(error || new Error(), err);
        }
        if (error && self._haltHandlersOnError) {
          doneCallback.call(self, error);
          return;
        }
      }
    }
    doneCallback.call(self, error);
  },

  /**
   * Adds or copies a set of listeners from another list of
   * listeners or SequentialExecutor object.
   *
   * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
   *   a list of events and callbacks, or an event emitter object
   *   containing listeners to add to this emitter object.
   * @return [AWS.SequentialExecutor] the emitter object, for chaining.
   * @example Adding listeners from a map of listeners
   *   emitter.addListeners({
   *     event1: [function() { ... }, function() { ... }],
   *     event2: [function() { ... }]
   *   });
   *   emitter.emit('event1'); // emitter has event1
   *   emitter.emit('event2'); // emitter has event2
   * @example Adding listeners from another emitter object
   *   var emitter1 = new AWS.SequentialExecutor();
   *   emitter1.on('event1', function() { ... });
   *   emitter1.on('event2', function() { ... });
   *   var emitter2 = new AWS.SequentialExecutor();
   *   emitter2.addListeners(emitter1);
   *   emitter2.emit('event1'); // emitter2 has event1
   *   emitter2.emit('event2'); // emitter2 has event2
   */
  addListeners: function addListeners(listeners) {
    var self = this;

    // extract listeners if parameter is an SequentialExecutor object
    if (listeners._events) listeners = listeners._events;

    AWS.util.each(listeners, function(event, callbacks) {
      if (typeof callbacks === 'function') callbacks = [callbacks];
      AWS.util.arrayEach(callbacks, function(callback) {
        self.on(event, callback);
      });
    });

    return self;
  },

  /**
   * Registers an event with {on} and saves the callback handle function
   * as a property on the emitter object using a given `name`.
   *
   * @param name [String] the property name to set on this object containing
   *   the callback function handle so that the listener can be removed in
   *   the future.
   * @param (see on)
   * @return (see on)
   * @example Adding a named listener DATA_CALLBACK
   *   var listener = function() { doSomething(); };
   *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
   *
   *   // the following prints: true
   *   console.log(emitter.DATA_CALLBACK == listener);
   */
  addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
    this[name] = callback;
    this.addListener(eventName, callback, toHead);
    return this;
  },

  /**
   * @api private
   */
  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
    callback._isAsync = true;
    return this.addNamedListener(name, eventName, callback, toHead);
  },

  /**
   * Helper method to add a set of named listeners using
   * {addNamedListener}. The callback contains a parameter
   * with a handle to the `addNamedListener` method.
   *
   * @callback callback function(add)
   *   The callback function is called immediately in order to provide
   *   the `add` function to the block. This simplifies the addition of
   *   a large group of named listeners.
   *   @param add [Function] the {addNamedListener} function to call
   *     when registering listeners.
   * @example Adding a set of named listeners
   *   emitter.addNamedListeners(function(add) {
   *     add('DATA_CALLBACK', 'data', function() { ... });
   *     add('OTHER', 'otherEvent', function() { ... });
   *     add('LAST', 'lastEvent', function() { ... });
   *   });
   *
   *   // these properties are now set:
   *   emitter.DATA_CALLBACK;
   *   emitter.OTHER;
   *   emitter.LAST;
   */
  addNamedListeners: function addNamedListeners(callback) {
    var self = this;
    callback(
      function() {
        self.addNamedListener.apply(self, arguments);
      },
      function() {
        self.addNamedAsyncListener.apply(self, arguments);
      }
    );
    return this;
  }
});

/**
 * {on} is the prefered method.
 * @api private
 */
AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;

/**
 * @api private
 */
module.exports = AWS.SequentialExecutor;

},{"./core":23}],66:[function(require,module,exports){
(function (process){(function (){
var AWS = require('./core');
var Api = require('./model/api');
var regionConfig = require('./region_config');

var inherit = AWS.util.inherit;
var clientCount = 0;
var region_utils = require('./region/utils');

/**
 * The service class representing an AWS service.
 *
 * @class_abstract This class is an abstract class.
 *
 * @!attribute apiVersions
 *   @return [Array<String>] the list of API versions supported by this service.
 *   @readonly
 */
AWS.Service = inherit({
  /**
   * Create a new service object with a configuration object
   *
   * @param config [map] a map of configuration options
   */
  constructor: function Service(config) {
    if (!this.loadServiceClass) {
      throw AWS.util.error(new Error(),
        'Service must be constructed with `new\' operator');
    }

    if (config) {
      if (config.region) {
        var region = config.region;
        if (region_utils.isFipsRegion(region)) {
          config.region = region_utils.getRealRegion(region);
          config.useFipsEndpoint = true;
        }
        if (region_utils.isGlobalRegion(region)) {
          config.region = region_utils.getRealRegion(region);
        }
      }
      if (typeof config.useDualstack === 'boolean'
        && typeof config.useDualstackEndpoint !== 'boolean') {
        config.useDualstackEndpoint = config.useDualstack;
      }
    }

    var ServiceClass = this.loadServiceClass(config || {});
    if (ServiceClass) {
      var originalConfig = AWS.util.copy(config);
      var svc = new ServiceClass(config);
      Object.defineProperty(svc, '_originalConfig', {
        get: function() { return originalConfig; },
        enumerable: false,
        configurable: true
      });
      svc._clientId = ++clientCount;
      return svc;
    }
    this.initialize(config);
  },

  /**
   * @api private
   */
  initialize: function initialize(config) {
    var svcConfig = AWS.config[this.serviceIdentifier];
    this.config = new AWS.Config(AWS.config);
    if (svcConfig) this.config.update(svcConfig, true);
    if (config) this.config.update(config, true);

    this.validateService();
    if (!this.config.endpoint) regionConfig.configureEndpoint(this);

    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
    this.setEndpoint(this.config.endpoint);
    //enable attaching listeners to service client
    AWS.SequentialExecutor.call(this);
    AWS.Service.addDefaultMonitoringListeners(this);
    if ((this.config.clientSideMonitoring || AWS.Service._clientSideMonitoring) && this.publisher) {
      var publisher = this.publisher;
      this.addNamedListener('PUBLISH_API_CALL', 'apiCall', function PUBLISH_API_CALL(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
      this.addNamedListener('PUBLISH_API_ATTEMPT', 'apiCallAttempt', function PUBLISH_API_ATTEMPT(event) {
        process.nextTick(function() {publisher.eventHandler(event);});
      });
    }
  },

  /**
   * @api private
   */
  validateService: function validateService() {
  },

  /**
   * @api private
   */
  loadServiceClass: function loadServiceClass(serviceConfig) {
    var config = serviceConfig;
    if (!AWS.util.isEmpty(this.api)) {
      return null;
    } else if (config.apiConfig) {
      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);
    } else if (!this.constructor.services) {
      return null;
    } else {
      config = new AWS.Config(AWS.config);
      config.update(serviceConfig, true);
      var version = config.apiVersions[this.constructor.serviceIdentifier];
      version = version || config.apiVersion;
      return this.getLatestServiceClass(version);
    }
  },

  /**
   * @api private
   */
  getLatestServiceClass: function getLatestServiceClass(version) {
    version = this.getLatestServiceVersion(version);
    if (this.constructor.services[version] === null) {
      AWS.Service.defineServiceApi(this.constructor, version);
    }

    return this.constructor.services[version];
  },

  /**
   * @api private
   */
  getLatestServiceVersion: function getLatestServiceVersion(version) {
    if (!this.constructor.services || this.constructor.services.length === 0) {
      throw new Error('No services defined on ' +
                      this.constructor.serviceIdentifier);
    }

    if (!version) {
      version = 'latest';
    } else if (AWS.util.isType(version, Date)) {
      version = AWS.util.date.iso8601(version).split('T')[0];
    }

    if (Object.hasOwnProperty(this.constructor.services, version)) {
      return version;
    }

    var keys = Object.keys(this.constructor.services).sort();
    var selectedVersion = null;
    for (var i = keys.length - 1; i >= 0; i--) {
      // versions that end in "*" are not available on disk and can be
      // skipped, so do not choose these as selectedVersions
      if (keys[i][keys[i].length - 1] !== '*') {
        selectedVersion = keys[i];
      }
      if (keys[i].substr(0, 10) <= version) {
        return selectedVersion;
      }
    }

    throw new Error('Could not find ' + this.constructor.serviceIdentifier +
                    ' API to satisfy version constraint `' + version + '\'');
  },

  /**
   * @api private
   */
  api: {},

  /**
   * @api private
   */
  defaultRetryCount: 3,

  /**
   * @api private
   */
  customizeRequests: function customizeRequests(callback) {
    if (!callback) {
      this.customRequestHandler = null;
    } else if (typeof callback === 'function') {
      this.customRequestHandler = callback;
    } else {
      throw new Error('Invalid callback type \'' + typeof callback + '\' provided in customizeRequests');
    }
  },

  /**
   * Calls an operation on a service with the given input parameters.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeRequest: function makeRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = null;
    }

    params = params || {};
    if (this.config.params) { // copy only toplevel bound params
      var rules = this.api.operations[operation];
      if (rules) {
        params = AWS.util.copy(params);
        AWS.util.each(this.config.params, function(key, value) {
          if (rules.input.members[key]) {
            if (params[key] === undefined || params[key] === null) {
              params[key] = value;
            }
          }
        });
      }
    }

    var request = new AWS.Request(this, operation, params);
    this.addAllRequestListeners(request);
    this.attachMonitoringEmitter(request);
    if (callback) request.send(callback);
    return request;
  },

  /**
   * Calls an operation on a service with the given input parameters, without
   * any authentication data. This method is useful for "public" API operations.
   *
   * @param operation [String] the name of the operation to call on the service.
   * @param params [map] a map of input options for the operation
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
    if (typeof params === 'function') {
      callback = params;
      params = {};
    }

    var request = this.makeRequest(operation, params).toUnauthenticated();
    return callback ? request.send(callback) : request;
  },

  /**
   * Waits for a given state
   *
   * @param state [String] the state on the service to wait for
   * @param params [map] a map of parameters to pass with each request
   * @option params $waiter [map] a map of configuration options for the waiter
   * @option params $waiter.delay [Number] The number of seconds to wait between
   *                                       requests
   * @option params $waiter.maxAttempts [Number] The maximum number of requests
   *                                             to send while waiting
   * @callback callback function(err, data)
   *   If a callback is supplied, it is called when a response is returned
   *   from the service.
   *   @param err [Error] the error object returned from the request.
   *     Set to `null` if the request is successful.
   *   @param data [Object] the de-serialized data returned from
   *     the request. Set to `null` if a request error occurs.
   */
  waitFor: function waitFor(state, params, callback) {
    var waiter = new AWS.ResourceWaiter(this, state);
    return waiter.wait(params, callback);
  },

  /**
   * @api private
   */
  addAllRequestListeners: function addAllRequestListeners(request) {
    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),
                AWS.EventListeners.CorePost];
    for (var i = 0; i < list.length; i++) {
      if (list[i]) request.addListeners(list[i]);
    }

    // disable parameter validation
    if (!this.config.paramValidation) {
      request.removeListener('validate',
        AWS.EventListeners.Core.VALIDATE_PARAMETERS);
    }

    if (this.config.logger) { // add logging events
      request.addListeners(AWS.EventListeners.Logger);
    }

    this.setupRequestListeners(request);
    // call prototype's customRequestHandler
    if (typeof this.constructor.prototype.customRequestHandler === 'function') {
      this.constructor.prototype.customRequestHandler(request);
    }
    // call instance's customRequestHandler
    if (Object.prototype.hasOwnProperty.call(this, 'customRequestHandler') && typeof this.customRequestHandler === 'function') {
      this.customRequestHandler(request);
    }
  },

  /**
   * Event recording metrics for a whole API call.
   * @returns {object} a subset of api call metrics
   * @api private
   */
  apiCallEvent: function apiCallEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCall',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Region: request.httpRequest.region,
      MaxRetriesExceeded: 0,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
    }
    if (response.error) {
      var error = response.error;
      var statusCode = response.httpResponse.statusCode;
      if (statusCode > 299) {
        if (error.code) monitoringEvent.FinalAwsException = error.code;
        if (error.message) monitoringEvent.FinalAwsExceptionMessage = error.message;
      } else {
        if (error.code || error.name) monitoringEvent.FinalSdkException = error.code || error.name;
        if (error.message) monitoringEvent.FinalSdkExceptionMessage = error.message;
      }
    }
    return monitoringEvent;
  },

  /**
   * Event recording metrics for an API call attempt.
   * @returns {object} a subset of api call attempt metrics
   * @api private
   */
  apiAttemptEvent: function apiAttemptEvent(request) {
    var api = request.service.api.operations[request.operation];
    var monitoringEvent = {
      Type: 'ApiCallAttempt',
      Api: api ? api.name : request.operation,
      Version: 1,
      Service: request.service.api.serviceId || request.service.api.endpointPrefix,
      Fqdn: request.httpRequest.endpoint.hostname,
      UserAgent: request.httpRequest.getUserAgent(),
    };
    var response = request.response;
    if (response.httpResponse.statusCode) {
      monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
    }
    if (
      !request._unAuthenticated &&
      request.service.config.credentials &&
      request.service.config.credentials.accessKeyId
    ) {
      monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
    }
    if (!response.httpResponse.headers) return monitoringEvent;
    if (request.httpRequest.headers['x-amz-security-token']) {
      monitoringEvent.SessionToken = request.httpRequest.headers['x-amz-security-token'];
    }
    if (response.httpResponse.headers['x-amzn-requestid']) {
      monitoringEvent.XAmznRequestId = response.httpResponse.headers['x-amzn-requestid'];
    }
    if (response.httpResponse.headers['x-amz-request-id']) {
      monitoringEvent.XAmzRequestId = response.httpResponse.headers['x-amz-request-id'];
    }
    if (response.httpResponse.headers['x-amz-id-2']) {
      monitoringEvent.XAmzId2 = response.httpResponse.headers['x-amz-id-2'];
    }
    return monitoringEvent;
  },

  /**
   * Add metrics of failed request.
   * @api private
   */
  attemptFailEvent: function attemptFailEvent(request) {
    var monitoringEvent = this.apiAttemptEvent(request);
    var response = request.response;
    var error = response.error;
    if (response.httpResponse.statusCode > 299 ) {
      if (error.code) monitoringEvent.AwsException = error.code;
      if (error.message) monitoringEvent.AwsExceptionMessage = error.message;
    } else {
      if (error.code || error.name) monitoringEvent.SdkException = error.code || error.name;
      if (error.message) monitoringEvent.SdkExceptionMessage = error.message;
    }
    return monitoringEvent;
  },

  /**
   * Attach listeners to request object to fetch metrics of each request
   * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
   * @api private
   */
  attachMonitoringEmitter: function attachMonitoringEmitter(request) {
    var attemptTimestamp; //timestamp marking the beginning of a request attempt
    var attemptStartRealTime; //Start time of request attempt. Used to calculating attemptLatency
    var attemptLatency; //latency from request sent out to http response reaching SDK
    var callStartRealTime; //Start time of API call. Used to calculating API call latency
    var attemptCount = 0; //request.retryCount is not reliable here
    var region; //region cache region for each attempt since it can be updated in plase (e.g. s3)
    var callTimestamp; //timestamp when the request is created
    var self = this;
    var addToHead = true;

    request.on('validate', function () {
      callStartRealTime = AWS.util.realClock.now();
      callTimestamp = Date.now();
    }, addToHead);
    request.on('sign', function () {
      attemptStartRealTime = AWS.util.realClock.now();
      attemptTimestamp = Date.now();
      region = request.httpRequest.region;
      attemptCount++;
    }, addToHead);
    request.on('validateResponse', function() {
      attemptLatency = Math.round(AWS.util.realClock.now() - attemptStartRealTime);
    });
    request.addNamedListener('API_CALL_ATTEMPT', 'success', function API_CALL_ATTEMPT() {
      var apiAttemptEvent = self.apiAttemptEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL_ATTEMPT_RETRY', 'retry', function API_CALL_ATTEMPT_RETRY() {
      var apiAttemptEvent = self.attemptFailEvent(request);
      apiAttemptEvent.Timestamp = attemptTimestamp;
      //attemptLatency may not be available if fail before response
      attemptLatency = attemptLatency ||
        Math.round(AWS.util.realClock.now() - attemptStartRealTime);
      apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
      apiAttemptEvent.Region = region;
      self.emit('apiCallAttempt', [apiAttemptEvent]);
    });
    request.addNamedListener('API_CALL', 'complete', function API_CALL() {
      var apiCallEvent = self.apiCallEvent(request);
      apiCallEvent.AttemptCount = attemptCount;
      if (apiCallEvent.AttemptCount <= 0) return;
      apiCallEvent.Timestamp = callTimestamp;
      var latency = Math.round(AWS.util.realClock.now() - callStartRealTime);
      apiCallEvent.Latency = latency >= 0 ? latency : 0;
      var response = request.response;
      if (
        response.error &&
        response.error.retryable &&
        typeof response.retryCount === 'number' &&
        typeof response.maxRetries === 'number' &&
        (response.retryCount >= response.maxRetries)
      ) {
        apiCallEvent.MaxRetriesExceeded = 1;
      }
      self.emit('apiCall', [apiCallEvent]);
    });
  },

  /**
   * Override this method to setup any custom request listeners for each
   * new request to the service.
   *
   * @method_abstract This is an abstract method.
   */
  setupRequestListeners: function setupRequestListeners(request) {
  },

  /**
   * Gets the signing name for a given request
   * @api private
   */
  getSigningName: function getSigningName() {
    return this.api.signingName || this.api.endpointPrefix;
  },

  /**
   * Gets the signer class for a given request
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var version;
    // get operation authtype if present
    var operation = null;
    var authtype = '';
    if (request) {
      var operations = request.service.api.operations || {};
      operation = operations[request.operation] || null;
      authtype = operation ? operation.authtype : '';
    }
    if (this.config.signatureVersion) {
      version = this.config.signatureVersion;
    } else if (authtype === 'v4' || authtype === 'v4-unsigned-body') {
      version = 'v4';
    } else if (authtype === 'bearer') {
      version = 'bearer';
    } else {
      version = this.api.signatureVersion;
    }
    return AWS.Signers.RequestSigner.getVersion(version);
  },

  /**
   * @api private
   */
  serviceInterface: function serviceInterface() {
    switch (this.api.protocol) {
      case 'ec2': return AWS.EventListeners.Query;
      case 'query': return AWS.EventListeners.Query;
      case 'json': return AWS.EventListeners.Json;
      case 'rest-json': return AWS.EventListeners.RestJson;
      case 'rest-xml': return AWS.EventListeners.RestXml;
    }
    if (this.api.protocol) {
      throw new Error('Invalid service `protocol\' ' +
        this.api.protocol + ' in API config');
    }
  },

  /**
   * @api private
   */
  successfulResponse: function successfulResponse(resp) {
    return resp.httpResponse.statusCode < 300;
  },

  /**
   * How many times a failed request should be retried before giving up.
   * the defaultRetryCount can be overriden by service classes.
   *
   * @api private
   */
  numRetries: function numRetries() {
    if (this.config.maxRetries !== undefined) {
      return this.config.maxRetries;
    } else {
      return this.defaultRetryCount;
    }
  },

  /**
   * @api private
   */
  retryDelays: function retryDelays(retryCount, err) {
    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
  },

  /**
   * @api private
   */
  retryableError: function retryableError(error) {
    if (this.timeoutError(error)) return true;
    if (this.networkingError(error)) return true;
    if (this.expiredCredentialsError(error)) return true;
    if (this.throttledError(error)) return true;
    if (error.statusCode >= 500) return true;
    return false;
  },

  /**
   * @api private
   */
  networkingError: function networkingError(error) {
    return error.code === 'NetworkingError';
  },

  /**
   * @api private
   */
  timeoutError: function timeoutError(error) {
    return error.code === 'TimeoutError';
  },

  /**
   * @api private
   */
  expiredCredentialsError: function expiredCredentialsError(error) {
    // TODO : this only handles *one* of the expired credential codes
    return (error.code === 'ExpiredTokenException');
  },

  /**
   * @api private
   */
  clockSkewError: function clockSkewError(error) {
    switch (error.code) {
      case 'RequestTimeTooSkewed':
      case 'RequestExpired':
      case 'InvalidSignatureException':
      case 'SignatureDoesNotMatch':
      case 'AuthFailure':
      case 'RequestInTheFuture':
        return true;
      default: return false;
    }
  },

  /**
   * @api private
   */
  getSkewCorrectedDate: function getSkewCorrectedDate() {
    return new Date(Date.now() + this.config.systemClockOffset);
  },

  /**
   * @api private
   */
  applyClockOffset: function applyClockOffset(newServerTime) {
    if (newServerTime) {
      this.config.systemClockOffset = newServerTime - Date.now();
    }
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(newServerTime) {
    if (newServerTime) {
      return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 300000;
    }
  },

  /**
   * @api private
   */
  throttledError: function throttledError(error) {
    // this logic varies between services
    if (error.statusCode === 429) return true;
    switch (error.code) {
      case 'ProvisionedThroughputExceededException':
      case 'Throttling':
      case 'ThrottlingException':
      case 'RequestLimitExceeded':
      case 'RequestThrottled':
      case 'RequestThrottledException':
      case 'TooManyRequestsException':
      case 'TransactionInProgressException': //dynamodb
      case 'EC2ThrottledException':
        return true;
      default:
        return false;
    }
  },

  /**
   * @api private
   */
  endpointFromTemplate: function endpointFromTemplate(endpoint) {
    if (typeof endpoint !== 'string') return endpoint;

    var e = endpoint;
    e = e.replace(/\{service\}/g, this.api.endpointPrefix);
    e = e.replace(/\{region\}/g, this.config.region);
    e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');
    return e;
  },

  /**
   * @api private
   */
  setEndpoint: function setEndpoint(endpoint) {
    this.endpoint = new AWS.Endpoint(endpoint, this.config);
  },

  /**
   * @api private
   */
  paginationConfig: function paginationConfig(operation, throwException) {
    var paginator = this.api.operations[operation].paginator;
    if (!paginator) {
      if (throwException) {
        var e = new Error();
        throw AWS.util.error(e, 'No pagination configuration for ' + operation);
      }
      return null;
    }

    return paginator;
  }
});

AWS.util.update(AWS.Service, {

  /**
   * Adds one method for each operation described in the api configuration
   *
   * @api private
   */
  defineMethods: function defineMethods(svc) {
    AWS.util.each(svc.prototype.api.operations, function iterator(method) {
      if (svc.prototype[method]) return;
      var operation = svc.prototype.api.operations[method];
      if (operation.authtype === 'none') {
        svc.prototype[method] = function (params, callback) {
          return this.makeUnauthenticatedRequest(method, params, callback);
        };
      } else {
        svc.prototype[method] = function (params, callback) {
          return this.makeRequest(method, params, callback);
        };
      }
    });
  },

  /**
   * Defines a new Service class using a service identifier and list of versions
   * including an optional set of features (functions) to apply to the class
   * prototype.
   *
   * @param serviceIdentifier [String] the identifier for the service
   * @param versions [Array<String>] a list of versions that work with this
   *   service
   * @param features [Object] an object to attach to the prototype
   * @return [Class<Service>] the service class defined by this function.
   */
  defineService: function defineService(serviceIdentifier, versions, features) {
    AWS.Service._serviceMap[serviceIdentifier] = true;
    if (!Array.isArray(versions)) {
      features = versions;
      versions = [];
    }

    var svc = inherit(AWS.Service, features || {});

    if (typeof serviceIdentifier === 'string') {
      AWS.Service.addVersions(svc, versions);

      var identifier = svc.serviceIdentifier || serviceIdentifier;
      svc.serviceIdentifier = identifier;
    } else { // defineService called with an API
      svc.prototype.api = serviceIdentifier;
      AWS.Service.defineMethods(svc);
    }
    AWS.SequentialExecutor.call(this.prototype);
    //util.clientSideMonitoring is only available in node
    if (!this.prototype.publisher && AWS.util.clientSideMonitoring) {
      var Publisher = AWS.util.clientSideMonitoring.Publisher;
      var configProvider = AWS.util.clientSideMonitoring.configProvider;
      var publisherConfig = configProvider();
      this.prototype.publisher = new Publisher(publisherConfig);
      if (publisherConfig.enabled) {
        //if csm is enabled in environment, SDK should send all metrics
        AWS.Service._clientSideMonitoring = true;
      }
    }
    AWS.SequentialExecutor.call(svc.prototype);
    AWS.Service.addDefaultMonitoringListeners(svc.prototype);
    return svc;
  },

  /**
   * @api private
   */
  addVersions: function addVersions(svc, versions) {
    if (!Array.isArray(versions)) versions = [versions];

    svc.services = svc.services || {};
    for (var i = 0; i < versions.length; i++) {
      if (svc.services[versions[i]] === undefined) {
        svc.services[versions[i]] = null;
      }
    }

    svc.apiVersions = Object.keys(svc.services).sort();
  },

  /**
   * @api private
   */
  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
    var svc = inherit(superclass, {
      serviceIdentifier: superclass.serviceIdentifier
    });

    function setApi(api) {
      if (api.isApi) {
        svc.prototype.api = api;
      } else {
        svc.prototype.api = new Api(api, {
          serviceIdentifier: superclass.serviceIdentifier
        });
      }
    }

    if (typeof version === 'string') {
      if (apiConfig) {
        setApi(apiConfig);
      } else {
        try {
          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));
        } catch (err) {
          throw AWS.util.error(err, {
            message: 'Could not find API configuration ' +
              superclass.serviceIdentifier + '-' + version
          });
        }
      }
      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
        superclass.apiVersions = superclass.apiVersions.concat(version).sort();
      }
      superclass.services[version] = svc;
    } else {
      setApi(version);
    }

    AWS.Service.defineMethods(svc);
    return svc;
  },

  /**
   * @api private
   */
  hasService: function(identifier) {
    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);
  },

  /**
   * @param attachOn attach default monitoring listeners to object
   *
   * Each monitoring event should be emitted from service client to service constructor prototype and then
   * to global service prototype like bubbling up. These default monitoring events listener will transfer
   * the monitoring events to the upper layer.
   * @api private
   */
  addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
    attachOn.addNamedListener('MONITOR_EVENTS_BUBBLE', 'apiCallAttempt', function EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCallAttempt', [event]);
    });
    attachOn.addNamedListener('CALL_EVENTS_BUBBLE', 'apiCall', function CALL_EVENTS_BUBBLE(event) {
      var baseClass = Object.getPrototypeOf(attachOn);
      if (baseClass._events) baseClass.emit('apiCall', [event]);
    });
  },

  /**
   * @api private
   */
  _serviceMap: {}
});

AWS.util.mixin(AWS.Service, AWS.SequentialExecutor);

/**
 * @api private
 */
module.exports = AWS.Service;

}).call(this)}).call(this,require('_process'))

},{"./core":23,"./model/api":43,"./region/utils":58,"./region_config":59,"_process":97}],67:[function(require,module,exports){
var AWS = require('../core');
var v4Credentials = require('../signers/v4_credentials');
var resolveRegionalEndpointsFlag = require('../config_regional_endpoint');
var s3util = require('./s3util');
var regionUtil = require('../region_config');

// Pull in managed upload extension
require('../s3/managed_upload');

/**
 * @api private
 */
var operationsWith200StatusCodeError = {
  'completeMultipartUpload': true,
  'copyObject': true,
  'uploadPartCopy': true
};

/**
 * @api private
 */
 var regionRedirectErrorCodes = [
  'AuthorizationHeaderMalformed', // non-head operations on virtual-hosted global bucket endpoints
  'BadRequest', // head operations on virtual-hosted global bucket endpoints
  'PermanentRedirect', // non-head operations on path-style or regional endpoints
  301 // head operations on path-style or regional endpoints
 ];

var OBJECT_LAMBDA_SERVICE = 's3-object-lambda';

AWS.util.update(AWS.S3.prototype, {
  /**
   * @api private
   */
  getSignatureVersion: function getSignatureVersion(request) {
    var defaultApiVersion = this.api.signatureVersion;
    var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
    var regionDefinedVersion = this.config.signatureVersion;
    var isPresigned = request ? request.isPresigned() : false;
    /*
      1) User defined version specified:
        a) always return user defined version
      2) No user defined version specified:
        a) If not using presigned urls, default to V4
        b) If using presigned urls, default to lowest version the region supports
    */
    if (userDefinedVersion) {
      userDefinedVersion = userDefinedVersion === 'v2' ? 's3' : userDefinedVersion;
      return userDefinedVersion;
    }
    if (isPresigned !== true) {
      defaultApiVersion = 'v4';
    } else if (regionDefinedVersion) {
      defaultApiVersion = regionDefinedVersion;
    }
    return defaultApiVersion;
  },

  /**
   * @api private
   */
  getSigningName: function getSigningName(req) {
    if (req && req.operation === 'writeGetObjectResponse') {
      return OBJECT_LAMBDA_SERVICE;
    }

    var _super = AWS.Service.prototype.getSigningName;
    return (req && req._parsedArn && req._parsedArn.service)
      ? req._parsedArn.service
      : _super.call(this);
  },

  /**
   * @api private
   */
  getSignerClass: function getSignerClass(request) {
    var signatureVersion = this.getSignatureVersion(request);
    return AWS.Signers.RequestSigner.getVersion(signatureVersion);
  },

  /**
   * @api private
   */
  validateService: function validateService() {
    var msg;
    var messages = [];

    // default to us-east-1 when no region is provided
    if (!this.config.region) this.config.region = 'us-east-1';

    if (!this.config.endpoint && this.config.s3BucketEndpoint) {
      messages.push('An endpoint must be provided when configuring ' +
                    '`s3BucketEndpoint` to true.');
    }
    if (messages.length === 1) {
      msg = messages[0];
    } else if (messages.length > 1) {
      msg = 'Multiple configuration errors:\n' + messages.join('\n');
    }
    if (msg) {
      throw AWS.util.error(new Error(),
        {name: 'InvalidEndpoint', message: msg});
    }
  },

  /**
   * @api private
   */
  shouldDisableBodySigning: function shouldDisableBodySigning(request) {
    var signerClass = this.getSignerClass();
    if (this.config.s3DisableBodySigning === true && signerClass === AWS.Signers.V4
        && request.httpRequest.endpoint.protocol === 'https:') {
      return true;
    }
    return false;
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    var prependListener = true;
    request.addListener('validate', this.validateScheme);
    request.addListener('validate', this.validateBucketName, prependListener);
    request.addListener('validate', this.optInUsEast1RegionalEndpoint, prependListener);

    request.removeListener('validate',
      AWS.EventListeners.Core.VALIDATE_REGION);
    request.addListener('build', this.addContentType);
    request.addListener('build', this.computeContentMd5);
    request.addListener('build', this.computeSseCustomerKeyMd5);
    request.addListener('build', this.populateURI);
    request.addListener('afterBuild', this.addExpect100Continue);
    request.addListener('extractError', this.extractError);
    request.addListener('extractData', AWS.util.hoistPayloadMember);
    request.addListener('extractData', this.extractData);
    request.addListener('extractData', this.extractErrorFrom200Response);
    request.addListener('beforePresign', this.prepareSignedUrl);
    if (this.shouldDisableBodySigning(request))  {
      request.removeListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
      request.addListener('afterBuild', this.disableBodySigning);
    }
    //deal with ARNs supplied to Bucket
    if (request.operation !== 'createBucket' && s3util.isArnInParam(request, 'Bucket')) {
      // avoid duplicate parsing in the future
      request._parsedArn = AWS.util.ARN.parse(request.params.Bucket);

      request.removeListener('validate', this.validateBucketName);
      request.removeListener('build', this.populateURI);
      if (request._parsedArn.service === 's3') {
        request.addListener('validate', s3util.validateS3AccessPointArn);
        request.addListener('validate', this.validateArnResourceType);
        request.addListener('validate', this.validateArnRegion);
      } else if (request._parsedArn.service === 's3-outposts') {
        request.addListener('validate', s3util.validateOutpostsAccessPointArn);
        request.addListener('validate', s3util.validateOutpostsArn);
        request.addListener('validate', s3util.validateArnRegion);
      }
      request.addListener('validate', s3util.validateArnAccount);
      request.addListener('validate', s3util.validateArnService);
      request.addListener('build', this.populateUriFromAccessPointArn);
      request.addListener('build', s3util.validatePopulateUriFromArn);
      return;
    }
    //listeners regarding region inference
    request.addListener('validate', this.validateBucketEndpoint);
    request.addListener('validate', this.correctBucketRegionFromCache);
    request.onAsync('extractError', this.requestBucketRegion);
    if (AWS.util.isBrowser()) {
      request.onAsync('retry', this.reqRegionForNetworkingError);
    }
  },

  /**
   * @api private
   */
  validateScheme: function(req) {
    var params = req.params,
        scheme = req.httpRequest.endpoint.protocol,
        sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
    if (sensitive && scheme !== 'https:') {
      var msg = 'Cannot send SSE keys over HTTP. Set \'sslEnabled\'' +
        'to \'true\' in your configuration';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
  validateBucketEndpoint: function(req) {
    if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
      var msg = 'Cannot send requests to root API with `s3BucketEndpoint` set.';
      throw AWS.util.error(new Error(),
        { code: 'ConfigError', message: msg });
    }
  },

  /**
   * @api private
   */
   validateArnRegion: function validateArnRegion(req) {
    s3util.validateArnRegion(req, { allowFipsEndpoint: true });
  },

  /**
   * Validate resource-type supplied in S3 ARN
   */
  validateArnResourceType: function validateArnResourceType(req) {
    var resource = req._parsedArn.resource;

    if (
      resource.indexOf('accesspoint:') !== 0 &&
      resource.indexOf('accesspoint/') !== 0
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'ARN resource should begin with \'accesspoint/\''
      });
    }
  },

  /**
   * @api private
   */
  validateBucketName: function validateBucketName(req) {
    var service = req.service;
    var signatureVersion = service.getSignatureVersion(req);
    var bucket = req.params && req.params.Bucket;
    var key = req.params && req.params.Key;
    var slashIndex = bucket && bucket.indexOf('/');
    if (bucket && slashIndex >= 0) {
      if (typeof key === 'string' && slashIndex > 0) {
        req.params = AWS.util.copy(req.params);
        // Need to include trailing slash to match sigv2 behavior
        var prefix = bucket.substr(slashIndex + 1) || '';
        req.params.Key = prefix + '/' + key;
        req.params.Bucket = bucket.substr(0, slashIndex);
      } else if (signatureVersion === 'v4') {
        var msg = 'Bucket names cannot contain forward slashes. Bucket: ' + bucket;
        throw AWS.util.error(new Error(),
          { code: 'InvalidBucket', message: msg });
      }
    }
  },

  /**
   * @api private
   */
  isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
    var invalidOperations = [
      'createBucket',
      'deleteBucket',
      'listBuckets'
    ];
    return invalidOperations.indexOf(operation) === -1;
  },

  /**
   * When us-east-1 region endpoint configuration is set, in stead of sending request to
   * global endpoint(e.g. 's3.amazonaws.com'), we will send request to
   * 's3.us-east-1.amazonaws.com'.
   * @api private
   */
  optInUsEast1RegionalEndpoint: function optInUsEast1RegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.s3UsEast1RegionalEndpoint = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: 'AWS_S3_US_EAST_1_REGIONAL_ENDPOINT',
      sharedConfig: 's3_us_east_1_regional_endpoint',
      clientConfig: 's3UsEast1RegionalEndpoint'
    });
    if (
      !(service._originalConfig || {}).endpoint &&
      req.httpRequest.region === 'us-east-1' &&
      config.s3UsEast1RegionalEndpoint === 'regional' &&
      req.httpRequest.endpoint.hostname.indexOf('s3.amazonaws.com') >= 0
    ) {
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.us-east-1' + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
    }
  },

  /**
   * S3 prefers dns-compatible bucket names to be moved from the uri path
   * to the hostname as a sub-domain.  This is not possible, even for dns-compat
   * buckets when using SSL and the bucket name contains a dot ('.').  The
   * ssl wildcard certificate is only 1-level deep.
   *
   * @api private
   */
  populateURI: function populateURI(req) {
    var httpRequest = req.httpRequest;
    var b = req.params.Bucket;
    var service = req.service;
    var endpoint = httpRequest.endpoint;
    if (b) {
      if (!service.pathStyleBucketName(b)) {
        if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
          if (service.config.useDualstackEndpoint) {
            endpoint.hostname = b + '.s3-accelerate.dualstack.amazonaws.com';
          } else {
            endpoint.hostname = b + '.s3-accelerate.amazonaws.com';
          }
        } else if (!service.config.s3BucketEndpoint) {
          endpoint.hostname =
            b + '.' + endpoint.hostname;
        }

        var port = endpoint.port;
        if (port !== 80 && port !== 443) {
          endpoint.host = endpoint.hostname + ':' +
            endpoint.port;
        } else {
          endpoint.host = endpoint.hostname;
        }

        httpRequest.virtualHostedBucket = b; // needed for signing the request
        service.removeVirtualHostedBucketFromPath(req);
      }
    }
  },

  /**
   * Takes the bucket name out of the path if bucket is virtual-hosted
   *
   * @api private
   */
  removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
    var httpRequest = req.httpRequest;
    var bucket = httpRequest.virtualHostedBucket;
    if (bucket && httpRequest.path) {
      if (req.params && req.params.Key) {
        var encodedS3Key = '/' + AWS.util.uriEscapePath(req.params.Key);
        if (httpRequest.path.indexOf(encodedS3Key) === 0 && (httpRequest.path.length === encodedS3Key.length || httpRequest.path[encodedS3Key.length] === '?')) {
          //path only contains key or path contains only key and querystring
          return;
        }
      }
      httpRequest.path = httpRequest.path.replace(new RegExp('/' + bucket), '');
      if (httpRequest.path[0] !== '/') {
        httpRequest.path = '/' + httpRequest.path;
      }
    }
  },

  /**
   * When user supply an access point ARN in the Bucket parameter, we need to
   * populate the URI according to the ARN.
   */
  populateUriFromAccessPointArn: function populateUriFromAccessPointArn(req) {
    var accessPointArn = req._parsedArn;

    var isOutpostArn = accessPointArn.service === 's3-outposts';
    var isObjectLambdaArn = accessPointArn.service === 's3-object-lambda';

    var outpostsSuffix = isOutpostArn ? '.' + accessPointArn.outpostId: '';
    var serviceName = isOutpostArn ? 's3-outposts': 's3-accesspoint';
    var fipsSuffix = !isOutpostArn && req.service.config.useFipsEndpoint ? '-fips': '';
    var dualStackSuffix = !isOutpostArn &&
      req.service.config.useDualstackEndpoint ? '.dualstack' : '';

    var endpoint = req.httpRequest.endpoint;
    var dnsSuffix = regionUtil.getEndpointSuffix(accessPointArn.region);
    var useArnRegion = req.service.config.s3UseArnRegion;

    endpoint.hostname = [
      accessPointArn.accessPoint + '-' + accessPointArn.accountId + outpostsSuffix,
      serviceName + fipsSuffix + dualStackSuffix,
      useArnRegion ? accessPointArn.region : req.service.config.region,
      dnsSuffix
    ].join('.');

    if (isObjectLambdaArn) {
      // should be in the format: "accesspoint/${accesspointName}"
      var serviceName = 's3-object-lambda';
      var accesspointName = accessPointArn.resource.split('/')[1];
      var fipsSuffix = req.service.config.useFipsEndpoint ? '-fips': '';
      endpoint.hostname = [
        accesspointName + '-' + accessPointArn.accountId,
        serviceName + fipsSuffix,
        useArnRegion ? accessPointArn.region : req.service.config.region,
        dnsSuffix
      ].join('.');
    }
    endpoint.host = endpoint.hostname;
    var encodedArn = AWS.util.uriEscape(req.params.Bucket);
    var path = req.httpRequest.path;
    //remove the Bucket value from path
    req.httpRequest.path = path.replace(new RegExp('/' + encodedArn), '');
    if (req.httpRequest.path[0] !== '/') {
      req.httpRequest.path = '/' + req.httpRequest.path;
    }
    req.httpRequest.region = accessPointArn.region; //region used to sign
  },

  /**
   * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
   * @api private
   */
  addExpect100Continue: function addExpect100Continue(req) {
    var len = req.httpRequest.headers['Content-Length'];
    if (AWS.util.isNode() && (len >= 1024 * 1024 || req.params.Body instanceof AWS.util.stream.Stream)) {
      req.httpRequest.headers['Expect'] = '100-continue';
    }
  },

  /**
   * Adds a default content type if none is supplied.
   *
   * @api private
   */
  addContentType: function addContentType(req) {
    var httpRequest = req.httpRequest;
    if (httpRequest.method === 'GET' || httpRequest.method === 'HEAD') {
      // Content-Type is not set in GET/HEAD requests
      delete httpRequest.headers['Content-Type'];
      return;
    }

    if (!httpRequest.headers['Content-Type']) { // always have a Content-Type
      httpRequest.headers['Content-Type'] = 'application/octet-stream';
    }

    var contentType = httpRequest.headers['Content-Type'];
    if (AWS.util.isBrowser()) {
      if (typeof httpRequest.body === 'string' && !contentType.match(/;\s*charset=/)) {
        var charset = '; charset=UTF-8';
        httpRequest.headers['Content-Type'] += charset;
      } else {
        var replaceFn = function(_, prefix, charsetName) {
          return prefix + charsetName.toUpperCase();
        };

        httpRequest.headers['Content-Type'] =
          contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
      }
    }
  },

  /**
   * Checks whether checksums should be computed for the request if it's not
   * already set by {AWS.EventListeners.Core.COMPUTE_CHECKSUM}. It depends on
   * whether {AWS.Config.computeChecksums} is set.
   *
   * @param req [AWS.Request] the request to check against
   * @return [Boolean] whether to compute checksums for a request.
   * @api private
   */
  willComputeChecksums: function willComputeChecksums(req) {
    var rules = req.service.api.operations[req.operation].input.members;
    var body = req.httpRequest.body;
    var needsContentMD5 = req.service.config.computeChecksums &&
      rules.ContentMD5 &&
      !req.params.ContentMD5 &&
      body &&
      (AWS.util.Buffer.isBuffer(req.httpRequest.body) || typeof req.httpRequest.body === 'string');

    // Sha256 signing disabled, and not a presigned url
    if (needsContentMD5 && req.service.shouldDisableBodySigning(req) && !req.isPresigned()) {
      return true;
    }

    // SigV2 and presign, for backwards compatibility purpose.
    if (needsContentMD5 && this.getSignatureVersion(req) === 's3' && req.isPresigned()) {
      return true;
    }

    return false;
  },

  /**
   * A listener that computes the Content-MD5 and sets it in the header.
   * This listener is to support S3-specific features like
   * s3DisableBodySigning and SigV2 presign. Content MD5 logic for SigV4 is
   * handled in AWS.EventListeners.Core.COMPUTE_CHECKSUM
   *
   * @api private
   */
  computeContentMd5: function computeContentMd5(req) {
    if (req.service.willComputeChecksums(req)) {
      var md5 = AWS.util.crypto.md5(req.httpRequest.body, 'base64');
      req.httpRequest.headers['Content-MD5'] = md5;
    }
  },

  /**
   * @api private
   */
  computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
    var keys = {
      SSECustomerKey: 'x-amz-server-side-encryption-customer-key-MD5',
      CopySourceSSECustomerKey: 'x-amz-copy-source-server-side-encryption-customer-key-MD5'
    };
    AWS.util.each(keys, function(key, header) {
      if (req.params[key]) {
        var value = AWS.util.crypto.md5(req.params[key], 'base64');
        req.httpRequest.headers[header] = value;
      }
    });
  },

  /**
   * Returns true if the bucket name should be left in the URI path for
   * a request to S3.  This function takes into account the current
   * endpoint protocol (e.g. http or https).
   *
   * @api private
   */
  pathStyleBucketName: function pathStyleBucketName(bucketName) {
    // user can force path style requests via the configuration
    if (this.config.s3ForcePathStyle) return true;
    if (this.config.s3BucketEndpoint) return false;

    if (s3util.dnsCompatibleBucketName(bucketName)) {
      return (this.config.sslEnabled && bucketName.match(/\./)) ? true : false;
    } else {
      return true; // not dns compatible names must always use path style
    }
  },

  /**
   * For COPY operations, some can be error even with status code 200.
   * SDK treats the response as exception when response body indicates
   * an exception or body is empty.
   *
   * @api private
   */
  extractErrorFrom200Response: function extractErrorFrom200Response(resp) {
    if (!operationsWith200StatusCodeError[resp.request.operation]) return;
    var httpResponse = resp.httpResponse;
    if (httpResponse.body && httpResponse.body.toString().match('<Error>')) {
      // Response body with '<Error>...</Error>' indicates an exception.
      // Get S3 client object. In ManagedUpload, this.service refers to
      // S3 client object.
      resp.data = null;
      var service = this.service ? this.service : this;
      service.extractError(resp);
      throw resp.error;
    } else if (!httpResponse.body || !httpResponse.body.toString().match(/<[\w_]/)) {
      // When body is empty or incomplete, S3 might stop the request on detecting client
      // side aborting the request.
      resp.data = null;
      throw AWS.util.error(new Error(), {
        code: 'InternalError',
        message: 'S3 aborted request'
      });
    }
  },

  /**
   * @return [Boolean] whether the error can be retried
   * @api private
   */
  retryableError: function retryableError(error, request) {
    if (operationsWith200StatusCodeError[request.operation] &&
        error.statusCode === 200) {
      return true;
    } else if (request._requestRegionForBucket &&
        request.service.bucketRegionCache[request._requestRegionForBucket]) {
      return false;
    } else if (error && error.code === 'RequestTimeout') {
      return true;
    } else if (error &&
        regionRedirectErrorCodes.indexOf(error.code) != -1 &&
        error.region && error.region != request.httpRequest.region) {
      request.httpRequest.region = error.region;
      if (error.statusCode === 301) {
        request.service.updateReqBucketRegion(request);
      }
      return true;
    } else {
      var _super = AWS.Service.prototype.retryableError;
      return _super.call(this, error, request);
    }
  },

  /**
   * Updates httpRequest with region. If region is not provided, then
   * the httpRequest will be updated based on httpRequest.region
   *
   * @api private
   */
  updateReqBucketRegion: function updateReqBucketRegion(request, region) {
    var httpRequest = request.httpRequest;
    if (typeof region === 'string' && region.length) {
      httpRequest.region = region;
    }
    if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
      return;
    }
    var service = request.service;
    var s3Config = service.config;
    var s3BucketEndpoint = s3Config.s3BucketEndpoint;
    if (s3BucketEndpoint) {
      delete s3Config.s3BucketEndpoint;
    }
    var newConfig = AWS.util.copy(s3Config);
    delete newConfig.endpoint;
    newConfig.region = httpRequest.region;

    httpRequest.endpoint = (new AWS.S3(newConfig)).endpoint;
    service.populateURI(request);
    s3Config.s3BucketEndpoint = s3BucketEndpoint;
    httpRequest.headers.Host = httpRequest.endpoint.host;

    if (request._asm.currentState === 'validate') {
      request.removeListener('build', service.populateURI);
      request.addListener('build', service.removeVirtualHostedBucketFromPath);
    }
  },

  /**
   * Provides a specialized parser for getBucketLocation -- all other
   * operations are parsed by the super class.
   *
   * @api private
   */
  extractData: function extractData(resp) {
    var req = resp.request;
    if (req.operation === 'getBucketLocation') {
      var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
      delete resp.data['_'];
      if (match) {
        resp.data.LocationConstraint = match[1];
      } else {
        resp.data.LocationConstraint = '';
      }
    }
    var bucket = req.params.Bucket || null;
    if (req.operation === 'deleteBucket' && typeof bucket === 'string' && !resp.error) {
      req.service.clearBucketRegionCache(bucket);
    } else {
      var headers = resp.httpResponse.headers || {};
      var region = headers['x-amz-bucket-region'] || null;
      if (!region && req.operation === 'createBucket' && !resp.error) {
        var createBucketConfiguration = req.params.CreateBucketConfiguration;
        if (!createBucketConfiguration) {
          region = 'us-east-1';
        } else if (createBucketConfiguration.LocationConstraint === 'EU') {
          region = 'eu-west-1';
        } else {
          region = createBucketConfiguration.LocationConstraint;
        }
      }
      if (region) {
          if (bucket && region !== req.service.bucketRegionCache[bucket]) {
            req.service.bucketRegionCache[bucket] = region;
          }
      }
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * Extracts an error object from the http response.
   *
   * @api private
   */
  extractError: function extractError(resp) {
    var codes = {
      304: 'NotModified',
      403: 'Forbidden',
      400: 'BadRequest',
      404: 'NotFound'
    };

    var req = resp.request;
    var code = resp.httpResponse.statusCode;
    var body = resp.httpResponse.body || '';

    var headers = resp.httpResponse.headers || {};
    var region = headers['x-amz-bucket-region'] || null;
    var bucket = req.params.Bucket || null;
    var bucketRegionCache = req.service.bucketRegionCache;
    if (region && bucket && region !== bucketRegionCache[bucket]) {
      bucketRegionCache[bucket] = region;
    }

    var cachedRegion;
    if (codes[code] && body.length === 0) {
      if (bucket && !region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }
      resp.error = AWS.util.error(new Error(), {
        code: codes[code],
        message: null,
        region: region
      });
    } else {
      var data = new AWS.XML.Parser().parse(body.toString());

      if (data.Region && !region) {
        region = data.Region;
        if (bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }
      } else if (bucket && !region && !data.Region) {
        cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion !== req.httpRequest.region) {
          region = cachedRegion;
        }
      }

      resp.error = AWS.util.error(new Error(), {
        code: data.Code || code,
        message: data.Message || null,
        region: region
      });
    }
    req.service.extractRequestIds(resp);
  },

  /**
   * If region was not obtained synchronously, then send async request
   * to get bucket region for errors resulting from wrong region.
   *
   * @api private
   */
  requestBucketRegion: function requestBucketRegion(resp, done) {
    var error = resp.error;
    var req = resp.request;
    var bucket = req.params.Bucket || null;

    if (!error || !bucket || error.region || req.operation === 'listObjects' ||
        (AWS.util.isNode() && req.operation === 'headBucket') ||
        (error.statusCode === 400 && req.operation !== 'headObject') ||
        regionRedirectErrorCodes.indexOf(error.code) === -1) {
      return done();
    }
    var reqOperation = AWS.util.isNode() ? 'headBucket' : 'listObjects';
    var reqParams = {Bucket: bucket};
    if (reqOperation === 'listObjects') reqParams.MaxKeys = 0;
    var regionReq = req.service[reqOperation](reqParams);
    regionReq._requestRegionForBucket = bucket;
    regionReq.send(function() {
      var region = req.service.bucketRegionCache[bucket] || null;
      error.region = region;
      done();
    });
  },

   /**
   * For browser only. If NetworkingError received, will attempt to obtain
   * the bucket region.
   *
   * @api private
   */
   reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
    if (!AWS.util.isBrowser()) {
      return done();
    }
    var error = resp.error;
    var request = resp.request;
    var bucket = request.params.Bucket;
    if (!error || error.code !== 'NetworkingError' || !bucket ||
        request.httpRequest.region === 'us-east-1') {
      return done();
    }
    var service = request.service;
    var bucketRegionCache = service.bucketRegionCache;
    var cachedRegion = bucketRegionCache[bucket] || null;

    if (cachedRegion && cachedRegion !== request.httpRequest.region) {
      service.updateReqBucketRegion(request, cachedRegion);
      done();
    } else if (!s3util.dnsCompatibleBucketName(bucket)) {
      service.updateReqBucketRegion(request, 'us-east-1');
      if (bucketRegionCache[bucket] !== 'us-east-1') {
        bucketRegionCache[bucket] = 'us-east-1';
      }
      done();
    } else if (request.httpRequest.virtualHostedBucket) {
      var getRegionReq = service.listObjects({Bucket: bucket, MaxKeys: 0});
      service.updateReqBucketRegion(getRegionReq, 'us-east-1');
      getRegionReq._requestRegionForBucket = bucket;

      getRegionReq.send(function() {
        var region = service.bucketRegionCache[bucket] || null;
        if (region && region !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, region);
        }
        done();
      });
    } else {
      // DNS-compatible path-style
      // (s3ForcePathStyle or bucket name with dot over https)
      // Cannot obtain region information for this case
      done();
    }
   },

  /**
   * Cache for bucket region.
   *
   * @api private
   */
   bucketRegionCache: {},

  /**
   * Clears bucket region cache.
   *
   * @api private
   */
   clearBucketRegionCache: function(buckets) {
    var bucketRegionCache = this.bucketRegionCache;
    if (!buckets) {
      buckets = Object.keys(bucketRegionCache);
    } else if (typeof buckets === 'string') {
      buckets = [buckets];
    }
    for (var i = 0; i < buckets.length; i++) {
      delete bucketRegionCache[buckets[i]];
    }
    return bucketRegionCache;
   },

   /**
    * Corrects request region if bucket's cached region is different
    *
    * @api private
    */
  correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
    var bucket = req.params.Bucket || null;
    if (bucket) {
      var service = req.service;
      var requestRegion = req.httpRequest.region;
      var cachedRegion = service.bucketRegionCache[bucket];
      if (cachedRegion && cachedRegion !== requestRegion) {
        service.updateReqBucketRegion(req, cachedRegion);
      }
    }
  },

  /**
   * Extracts S3 specific request ids from the http response.
   *
   * @api private
   */
  extractRequestIds: function extractRequestIds(resp) {
    var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-id-2'] : null;
    var cfId = resp.httpResponse.headers ? resp.httpResponse.headers['x-amz-cf-id'] : null;
    resp.extendedRequestId = extendedRequestId;
    resp.cfId = cfId;

    if (resp.error) {
      resp.error.requestId = resp.requestId || null;
      resp.error.extendedRequestId = extendedRequestId;
      resp.error.cfId = cfId;
    }
  },

  /**
   * Get a pre-signed URL for a given operation name.
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   * @note Not all operation parameters are supported when using pre-signed
   *   URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *   `ContentLength`, or `Tagging` must be provided as headers when sending a
   *   request. If you are using pre-signed URLs to upload from a browser and
   *   need to use these fields, see {createPresignedPost}.
   * @note The default signer allows altering the request by adding corresponding
   *   headers to set some parameters (e.g. Range) and these added parameters
   *   won't be signed. You must use signatureVersion v4 to to include these
   *   parameters in the signed portion of the URL and enforce exact matching
   *   between headers and signed params in the URL.
   * @note This operation cannot be used with a promise. See note above regarding
   *   asynchronous credentials and use with a callback.
   * @param operation [String] the name of the operation to call
   * @param params [map] parameters to pass to the operation. See the given
   *   operation for the expected operation parameters. In addition, you can
   *   also pass the "Expires" parameter to inform S3 how long the URL should
   *   work for.
   * @option params Expires [Integer] (900) the number of seconds to expire
   *   the pre-signed URL operation in. Defaults to 15 minutes.
   * @param callback [Function] if a callback is provided, this function will
   *   pass the URL as the second parameter (after the error parameter) to
   *   the callback function.
   * @return [String] if called synchronously (with no callback), returns the
   *   signed URL.
   * @return [null] nothing is returned if a callback is provided.
   * @example Pre-signing a getObject operation (synchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url);
   * @example Pre-signing a putObject (asynchronously)
   *   var params = {Bucket: 'bucket', Key: 'key'};
   *   s3.getSignedUrl('putObject', params, function (err, url) {
   *     console.log('The URL is', url);
   *   });
   * @example Pre-signing a putObject operation with a specific payload
   *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *   var url = s3.getSignedUrl('putObject', params);
   *   console.log('The URL is', url);
   * @example Passing in a 1-minute expiry time for a pre-signed URL
   *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *   var url = s3.getSignedUrl('getObject', params);
   *   console.log('The URL is', url); // expires in 60 seconds
   */
  getSignedUrl: function getSignedUrl(operation, params, callback) {
    params = AWS.util.copy(params || {});
    var expires = params.Expires || 900;

    if (typeof expires !== 'number') {
      throw AWS.util.error(new Error(),
        { code: 'InvalidParameterException', message: 'The expiration must be a number, received ' + typeof expires });
    }

    delete params.Expires; // we can't validate this
    var request = this.makeRequest(operation, params);

    if (callback) {
      AWS.util.defer(function() {
        request.presign(expires, callback);
      });
    } else {
      return request.presign(expires, callback);
    }
  },

  /**
   * @!method  getSignedUrlPromise()
   *   Returns a 'thenable' promise that will be resolved with a pre-signed URL
   *   for a given operation name.
   *
   *   Two callbacks can be provided to the `then` method on the returned promise.
   *   The first callback will be called if the promise is fulfilled, and the second
   *   callback will be called if the promise is rejected.
   *   @note Not all operation parameters are supported when using pre-signed
   *      URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
   *      `ContentLength`, or `Tagging` must be provided as headers when sending a
   *      request. If you are using pre-signed URLs to upload from a browser and
   *      need to use these fields, see {createPresignedPost}.
   *   @param operation [String] the name of the operation to call
   *   @param params [map] parameters to pass to the operation. See the given
   *      operation for the expected operation parameters. In addition, you can
   *      also pass the "Expires" parameter to inform S3 how long the URL should
   *      work for.
   *   @option params Expires [Integer] (900) the number of seconds to expire
   *      the pre-signed URL operation in. Defaults to 15 minutes.
   *   @callback fulfilledCallback function(url)
   *     Called if the promise is fulfilled.
   *     @param url [String] the signed url
   *   @callback rejectedCallback function(err)
   *     Called if the promise is rejected.
   *     @param err [Error] if an error occurred, this value will be filled
   *   @return [Promise] A promise that represents the state of the `refresh` call.
   *   @example Pre-signing a getObject operation
   *      var params = {Bucket: 'bucket', Key: 'key'};
   *      var promise = s3.getSignedUrlPromise('getObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   *   @example Pre-signing a putObject operation with a specific payload
   *      var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
   *      var promise = s3.getSignedUrlPromise('putObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   *   @example Passing in a 1-minute expiry time for a pre-signed URL
   *      var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
   *      var promise = s3.getSignedUrlPromise('getObject', params);
   *      promise.then(function(url) {
   *        console.log('The URL is', url);
   *      }, function(err) { ... });
   */

  /**
   * Get a pre-signed POST policy to support uploading to S3 directly from an
   * HTML form.
   *
   * @param params [map]
   * @option params Bucket [String]     The bucket to which the post should be
   *                                    uploaded
   * @option params Expires [Integer]   (3600) The number of seconds for which
   *                                    the presigned policy should be valid.
   * @option params Conditions [Array]  An array of conditions that must be met
   *                                    for the presigned policy to allow the
   *                                    upload. This can include required tags,
   *                                    the accepted range for content lengths,
   *                                    etc.
   * @see http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
   * @option params Fields [map]        Fields to include in the form. All
   *                                    values passed in as fields will be
   *                                    signed as exact match conditions.
   * @param callback [Function]
   *
   * @note All fields passed in when creating presigned post data will be signed
   *   as exact match conditions. Any fields that will be interpolated by S3
   *   must be added to the fields hash after signing, and an appropriate
   *   condition for such fields must be explicitly added to the Conditions
   *   array passed to this function before signing.
   *
   * @example Presiging post data with a known key
   *   var params = {
   *     Bucket: 'bucket',
   *     Fields: {
   *       key: 'key'
   *     }
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @example Presigning post data with an interpolated key
   *   var params = {
   *     Bucket: 'bucket',
   *     Conditions: [
   *       ['starts-with', '$key', 'path/to/uploads/']
   *     ]
   *   };
   *   s3.createPresignedPost(params, function(err, data) {
   *     if (err) {
   *       console.error('Presigning post data encountered an error', err);
   *     } else {
   *       data.Fields.key = 'path/to/uploads/${filename}';
   *       console.log('The post data is', data);
   *     }
   *   });
   *
   * @note You must ensure that you have static or previously resolved
   *   credentials if you call this method synchronously (with no callback),
   *   otherwise it may not properly sign the request. If you cannot guarantee
   *   this (you are using an asynchronous credential provider, i.e., EC2
   *   IAM roles), you should always call this method with an asynchronous
   *   callback.
   *
   * @return [map]  If called synchronously (with no callback), returns a hash
   *                with the url to set as the form action and a hash of fields
   *                to include in the form.
   * @return [null] Nothing is returned if a callback is provided.
   *
   * @callback callback function (err, data)
   *  @param err [Error] the error object returned from the policy signer
   *  @param data [map] The data necessary to construct an HTML form
   *  @param data.url [String] The URL to use as the action of the form
   *  @param data.fields [map] A hash of fields that must be included in the
   *                           form for the upload to succeed. This hash will
   *                           include the signed POST policy, your access key
   *                           ID and security token (if present), etc. These
   *                           may be safely included as input elements of type
   *                           'hidden.'
   */
  createPresignedPost: function createPresignedPost(params, callback) {
    if (typeof params === 'function' && callback === undefined) {
      callback = params;
      params = null;
    }

    params = AWS.util.copy(params || {});
    var boundParams = this.config.params || {};
    var bucket = params.Bucket || boundParams.Bucket,
      self = this,
      config = this.config,
      endpoint = AWS.util.copy(this.endpoint);
    if (!config.s3BucketEndpoint) {
      endpoint.pathname = '/' + bucket;
    }

    function finalizePost() {
      return {
        url: AWS.util.urlFormat(endpoint),
        fields: self.preparePostFields(
          config.credentials,
          config.region,
          bucket,
          params.Fields,
          params.Conditions,
          params.Expires
        )
      };
    }

    if (callback) {
      config.getCredentials(function (err) {
        if (err) {
          callback(err);
        } else {
          try {
            callback(null, finalizePost());
          } catch (err) {
            callback(err);
          }
        }
      });
    } else {
      return finalizePost();
    }
  },

  /**
   * @api private
   */
  preparePostFields: function preparePostFields(
    credentials,
    region,
    bucket,
    fields,
    conditions,
    expiresInSeconds
  ) {
    var now = this.getSkewCorrectedDate();
    if (!credentials || !region || !bucket) {
      throw new Error('Unable to create a POST object policy without a bucket,'
        + ' region, and credentials');
    }
    fields = AWS.util.copy(fields || {});
    conditions = (conditions || []).slice(0);
    expiresInSeconds = expiresInSeconds || 3600;

    var signingDate = AWS.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, '');
    var shortDate = signingDate.substr(0, 8);
    var scope = v4Credentials.createScope(shortDate, region, 's3');
    var credential = credentials.accessKeyId + '/' + scope;

    fields['bucket'] = bucket;
    fields['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
    fields['X-Amz-Credential'] = credential;
    fields['X-Amz-Date'] = signingDate;
    if (credentials.sessionToken) {
      fields['X-Amz-Security-Token'] = credentials.sessionToken;
    }
    for (var field in fields) {
      if (fields.hasOwnProperty(field)) {
        var condition = {};
        condition[field] = fields[field];
        conditions.push(condition);
      }
    }

    fields.Policy = this.preparePostPolicy(
      new Date(now.valueOf() + expiresInSeconds * 1000),
      conditions
    );
    fields['X-Amz-Signature'] = AWS.util.crypto.hmac(
      v4Credentials.getSigningKey(credentials, shortDate, region, 's3', true),
      fields.Policy,
      'hex'
    );

    return fields;
  },

  /**
   * @api private
   */
  preparePostPolicy: function preparePostPolicy(expiration, conditions) {
    return AWS.util.base64.encode(JSON.stringify({
      expiration: AWS.util.date.iso8601(expiration),
      conditions: conditions
    }));
  },

  /**
   * @api private
   */
  prepareSignedUrl: function prepareSignedUrl(request) {
    request.addListener('validate', request.service.noPresignedContentLength);
    request.removeListener('build', request.service.addContentType);
    if (!request.params.Body) {
      // no Content-MD5/SHA-256 if body is not provided
      request.removeListener('build', request.service.computeContentMd5);
    } else {
      request.addListener('afterBuild', AWS.EventListeners.Core.COMPUTE_SHA256);
    }
  },

  /**
   * @api private
   * @param request
   */
  disableBodySigning: function disableBodySigning(request) {
    var headers = request.httpRequest.headers;
    // Add the header to anything that isn't a presigned url, unless that presigned url had a body defined
    if (!Object.prototype.hasOwnProperty.call(headers, 'presigned-expires')) {
      headers['X-Amz-Content-Sha256'] = 'UNSIGNED-PAYLOAD';
    }
  },

  /**
   * @api private
   */
  noPresignedContentLength: function noPresignedContentLength(request) {
    if (request.params.ContentLength !== undefined) {
      throw AWS.util.error(new Error(), {code: 'UnexpectedParameter',
        message: 'ContentLength is not supported in pre-signed URLs.'});
    }
  },

  createBucket: function createBucket(params, callback) {
    // When creating a bucket *outside* the classic region, the location
    // constraint must be set for the bucket and it must match the endpoint.
    // This chunk of code will set the location constraint param based
    // on the region (when possible), but it will not override a passed-in
    // location constraint.
    if (typeof params === 'function' || !params) {
      callback = callback || params;
      params = {};
    }
    var hostname = this.endpoint.hostname;
    // copy params so that appending keys does not unintentioinallly
    // mutate params object argument passed in by user
    var copiedParams = AWS.util.copy(params);

    if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
      copiedParams.CreateBucketConfiguration = { LocationConstraint: this.config.region };
    }
    return this.makeRequest('createBucket', copiedParams, callback);
  },

  writeGetObjectResponse: function writeGetObjectResponse(params, callback) {

    var request = this.makeRequest('writeGetObjectResponse', AWS.util.copy(params), callback);
    var hostname = this.endpoint.hostname;
    if (hostname.indexOf(this.config.region) !== -1) {
      // hostname specifies a region already
      hostname = hostname.replace('s3.', OBJECT_LAMBDA_SERVICE + '.');
    } else {
      // Hostname doesn't have a region.
      // Object Lambda requires an explicit region.
      hostname = hostname.replace('s3.', OBJECT_LAMBDA_SERVICE + '.' + this.config.region + '.');
    }

    request.httpRequest.endpoint = new AWS.Endpoint(hostname, this.config);
    return request;
  },

  /**
   * @see AWS.S3.ManagedUpload
   * @overload upload(params = {}, [options], [callback])
   *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
   *   concurrent handling of parts if the payload is large enough. You can
   *   configure the concurrent queue size by setting `options`. Note that this
   *   is the only operation for which the SDK can retry requests with stream
   *   bodies.
   *
   *   @param (see AWS.S3.putObject)
   *   @option (see AWS.S3.ManagedUpload.constructor)
   *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
   *     `send()` or track progress.
   *   @example Uploading a stream object
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     s3.upload(params, function(err, data) {
   *       console.log(err, data);
   *     });
   *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
   *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
   *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
   *     s3.upload(params, options, function(err, data) {
   *       console.log(err, data);
   *     });
   * @callback callback function(err, data)
   *   @param err [Error] an error or null if no error occurred.
   *   @param data [map] The response data from the successful upload:
   *   @param data.Location [String] the URL of the uploaded object
   *   @param data.ETag [String] the ETag of the uploaded object
   *   @param data.Bucket [String]  the bucket to which the object was uploaded
   *   @param data.Key [String] the key to which the object was uploaded
   */
  upload: function upload(params, options, callback) {
    if (typeof options === 'function' && callback === undefined) {
      callback = options;
      options = null;
    }

    options = options || {};
    options = AWS.util.merge(options || {}, {service: this, params: params});

    var uploader = new AWS.S3.ManagedUpload(options);
    if (typeof callback === 'function') uploader.send(callback);
    return uploader;
  }
});

/**
 * @api private
 */
AWS.S3.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
  this.prototype.getSignedUrlPromise = AWS.util.promisifyMethod('getSignedUrl', PromiseDependency);
};

/**
 * @api private
 */
AWS.S3.deletePromisesFromClass = function deletePromisesFromClass() {
  delete this.prototype.getSignedUrlPromise;
};

AWS.util.addPromises(AWS.S3);

},{"../config_regional_endpoint":22,"../core":23,"../region_config":59,"../s3/managed_upload":64,"../signers/v4_credentials":78,"./s3util":68}],68:[function(require,module,exports){
(function (process){(function (){
var AWS = require('../core');
var regionUtil = require('../region_config');

var s3util = {
  /**
   * @api private
   */
  isArnInParam: function isArnInParam(req, paramName) {
    var inputShape = (req.service.api.operations[req.operation] || {}).input || {};
    var inputMembers = inputShape.members || {};
    if (!req.params[paramName] || !inputMembers[paramName]) return false;
    return AWS.util.ARN.validate(req.params[paramName]);
  },

  /**
   * Validate service component from ARN supplied in Bucket parameter
   */
  validateArnService: function validateArnService(req) {
    var parsedArn = req._parsedArn;

    if (parsedArn.service !== 's3'
      && parsedArn.service !== 's3-outposts'
      && parsedArn.service !== 's3-object-lambda') {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'expect \'s3\' or \'s3-outposts\' or \'s3-object-lambda\' in ARN service component'
      });
    }
  },

  /**
   * Validate account ID from ARN supplied in Bucket parameter is a valid account
   */
  validateArnAccount: function validateArnAccount(req) {
    var parsedArn = req._parsedArn;

    if (!/[0-9]{12}/.exec(parsedArn.accountId)) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'ARN accountID does not match regex "[0-9]{12}"'
      });
    }
  },

  /**
   * Validate ARN supplied in Bucket parameter is a valid access point ARN
   */
  validateS3AccessPointArn: function validateS3AccessPointArn(req) {
    var parsedArn = req._parsedArn;

    //can be ':' or '/'
    var delimiter = parsedArn.resource['accesspoint'.length];

    if (parsedArn.resource.split(delimiter).length !== 2) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'Access Point ARN should have one resource accesspoint/{accesspointName}'
      });
    }

    var accessPoint = parsedArn.resource.split(delimiter)[1];
    var accessPointPrefix = accessPoint + '-' + parsedArn.accountId;
    if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'Access point resource in ARN is not DNS compatible. Got ' + accessPoint
      });
    }

    //set parsed valid access point
    req._parsedArn.accessPoint = accessPoint;
  },

  /**
   * Validate Outposts ARN supplied in Bucket parameter is a valid outposts ARN
   */
  validateOutpostsArn: function validateOutpostsArn(req) {
    var parsedArn = req._parsedArn;

    if (
      parsedArn.resource.indexOf('outpost:') !== 0 &&
      parsedArn.resource.indexOf('outpost/') !== 0
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'ARN resource should begin with \'outpost/\''
      });
    }

    //can be ':' or '/'
    var delimiter = parsedArn.resource['outpost'.length];
    var outpostId = parsedArn.resource.split(delimiter)[1];
    var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(outpostId)) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'Outpost resource in ARN is not DNS compatible. Got ' + outpostId
      });
    }
    req._parsedArn.outpostId = outpostId;
  },

  /**
   * Validate Outposts ARN supplied in Bucket parameter is a valid outposts ARN
   */
  validateOutpostsAccessPointArn: function validateOutpostsAccessPointArn(req) {
    var parsedArn = req._parsedArn;

    //can be ':' or '/'
    var delimiter = parsedArn.resource['outpost'.length];

    if (parsedArn.resource.split(delimiter).length !== 4) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'Outposts ARN should have two resources outpost/{outpostId}/accesspoint/{accesspointName}'
      });
    }

    var accessPoint = parsedArn.resource.split(delimiter)[3];
    var accessPointPrefix = accessPoint + '-' + parsedArn.accountId;
    if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: 'Access point resource in ARN is not DNS compatible. Got ' + accessPoint
      });
    }

    //set parsed valid access point
    req._parsedArn.accessPoint = accessPoint;
  },

  /**
   * Validate region field in ARN supplied in Bucket parameter is a valid region
   */
  validateArnRegion: function validateArnRegion(req, options) {
    if (options === undefined) {
      options = {};
    }

    var useArnRegion = s3util.loadUseArnRegionConfig(req);
    var regionFromArn = req._parsedArn.region;
    var clientRegion = req.service.config.region;
    var useFipsEndpoint = req.service.config.useFipsEndpoint;
    var allowFipsEndpoint = options.allowFipsEndpoint || false;

    if (!regionFromArn) {
      var message = 'ARN region is empty';
      if (req._parsedArn.service === 's3') {
        message = message + '\nYou may want to use multi-regional ARN. The feature is not supported in current SDK. ' +
        'You should consider switching to V3(https://github.com/aws/aws-sdk-js-v3).';
      }
      throw AWS.util.error(new Error(), {
        code: 'InvalidARN',
        message: message
      });
    }

    if (useFipsEndpoint && !allowFipsEndpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'ARN endpoint is not compatible with FIPS region'
      });
    }

    if (regionFromArn.indexOf('fips') >= 0) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'FIPS region not allowed in ARN'
      });
    }

    if (!useArnRegion && regionFromArn !== clientRegion) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Configured region conflicts with access point region'
      });
    } else if (
      useArnRegion &&
      regionUtil.getEndpointSuffix(regionFromArn) !== regionUtil.getEndpointSuffix(clientRegion)
    ) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Configured region and access point region not in same partition'
      });
    }

    if (req.service.config.useAccelerateEndpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'useAccelerateEndpoint config is not supported with access point ARN'
      });
    }

    if (req._parsedArn.service === 's3-outposts' && req.service.config.useDualstackEndpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Dualstack is not supported with outposts access point ARN'
      });
    }
  },

  loadUseArnRegionConfig: function loadUseArnRegionConfig(req) {
    var envName = 'AWS_S3_USE_ARN_REGION';
    var configName = 's3_use_arn_region';
    var useArnRegion = true;
    var originalConfig = req.service._originalConfig || {};
    if (req.service.config.s3UseArnRegion !== undefined) {
      return req.service.config.s3UseArnRegion;
    } else if (originalConfig.s3UseArnRegion !== undefined) {
      useArnRegion = originalConfig.s3UseArnRegion === true;
    } else if (AWS.util.isNode()) {
      //load from environmental variable AWS_USE_ARN_REGION
      if (process.env[envName]) {
        var value = process.env[envName].trim().toLowerCase();
        if (['false', 'true'].indexOf(value) < 0) {
          throw AWS.util.error(new Error(), {
            code: 'InvalidConfiguration',
            message: envName + ' only accepts true or false. Got ' + process.env[envName],
            retryable: false
          });
        }
        useArnRegion = value === 'true';
      } else {  //load from shared config property use_arn_region
        var profiles = {};
        var profile = {};
        try {
          profiles = AWS.util.getProfilesFromSharedConfig(AWS.util.iniLoader);
          profile = profiles[process.env.AWS_PROFILE || AWS.util.defaultProfile];
        } catch (e) {}
        if (profile[configName]) {
          if (['false', 'true'].indexOf(profile[configName].trim().toLowerCase()) < 0) {
            throw AWS.util.error(new Error(), {
              code: 'InvalidConfiguration',
              message: configName + ' only accepts true or false. Got ' + profile[configName],
              retryable: false
            });
          }
          useArnRegion = profile[configName].trim().toLowerCase() === 'true';
        }
      }
    }
    req.service.config.s3UseArnRegion = useArnRegion;
    return useArnRegion;
  },

  /**
   * Validations before URI can be populated
   */
  validatePopulateUriFromArn: function validatePopulateUriFromArn(req) {
    if (req.service._originalConfig && req.service._originalConfig.endpoint) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Custom endpoint is not compatible with access point ARN'
      });
    }

    if (req.service.config.s3ForcePathStyle) {
      throw AWS.util.error(new Error(), {
        code: 'InvalidConfiguration',
        message: 'Cannot construct path-style endpoint with access point'
      });
    }
  },

  /**
   * Returns true if the bucket name is DNS compatible.  Buckets created
   * outside of the classic region MUST be DNS compatible.
   *
   * @api private
   */
  dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {
    var b = bucketName;
    var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
    var ipAddress = new RegExp(/(\d+\.){3}\d+/);
    var dots = new RegExp(/\.\./);
    return (b.match(domain) && !b.match(ipAddress) && !b.match(dots)) ? true : false;
  },
};

/**
 * @api private
 */
module.exports = s3util;

}).call(this)}).call(this,require('_process'))

},{"../core":23,"../region_config":59,"_process":97}],69:[function(require,module,exports){
var AWS = require('../core');
var resolveRegionalEndpointsFlag = require('../config_regional_endpoint');
var ENV_REGIONAL_ENDPOINT_ENABLED = 'AWS_STS_REGIONAL_ENDPOINTS';
var CONFIG_REGIONAL_ENDPOINT_ENABLED = 'sts_regional_endpoints';

AWS.util.update(AWS.STS.prototype, {
  /**
   * @overload credentialsFrom(data, credentials = null)
   *   Creates a credentials object from STS response data containing
   *   credentials information. Useful for quickly setting AWS credentials.
   *
   *   @note This is a low-level utility function. If you want to load temporary
   *     credentials into your process for subsequent requests to AWS resources,
   *     you should use {AWS.TemporaryCredentials} instead.
   *   @param data [map] data retrieved from a call to {getFederatedToken},
   *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
   *   @param credentials [AWS.Credentials] an optional credentials object to
   *     fill instead of creating a new object. Useful when modifying an
   *     existing credentials object from a refresh call.
   *   @return [AWS.TemporaryCredentials] the set of temporary credentials
   *     loaded from a raw STS operation response.
   *   @example Using credentialsFrom to load global AWS credentials
   *     var sts = new AWS.STS();
   *     sts.getSessionToken(function (err, data) {
   *       if (err) console.log("Error getting credentials");
   *       else {
   *         AWS.config.credentials = sts.credentialsFrom(data);
   *       }
   *     });
   *   @see AWS.TemporaryCredentials
   */
  credentialsFrom: function credentialsFrom(data, credentials) {
    if (!data) return null;
    if (!credentials) credentials = new AWS.TemporaryCredentials();
    credentials.expired = false;
    credentials.accessKeyId = data.Credentials.AccessKeyId;
    credentials.secretAccessKey = data.Credentials.SecretAccessKey;
    credentials.sessionToken = data.Credentials.SessionToken;
    credentials.expireTime = data.Credentials.Expiration;
    return credentials;
  },

  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);
  },

  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
    return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);
  },

  /**
   * @api private
   */
  setupRequestListeners: function setupRequestListeners(request) {
    request.addListener('validate', this.optInRegionalEndpoint, true);
  },

  /**
   * @api private
   */
  optInRegionalEndpoint: function optInRegionalEndpoint(req) {
    var service = req.service;
    var config = service.config;
    config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
      env: ENV_REGIONAL_ENDPOINT_ENABLED,
      sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
      clientConfig: 'stsRegionalEndpoints'
    });
    if (
      config.stsRegionalEndpoints === 'regional' &&
      service.isGlobalEndpoint
    ) {
      //client will throw if region is not supplied; request will be signed with specified region
      if (!config.region) {
        throw AWS.util.error(new Error(),
          {code: 'ConfigError', message: 'Missing region in config'});
      }
      var insertPoint = config.endpoint.indexOf('.amazonaws.com');
      var regionalEndpoint = config.endpoint.substring(0, insertPoint) +
        '.' + config.region + config.endpoint.substring(insertPoint);
      req.httpRequest.updateEndpoint(regionalEndpoint);
      req.httpRequest.region = config.region;
    }
  }

});

},{"../config_regional_endpoint":22,"../core":23}],70:[function(require,module,exports){
var AWS = require('../core');

/**
 * @api private
 */
AWS.Signers.Bearer = AWS.util.inherit(AWS.Signers.RequestSigner, {
  constructor: function Bearer(request) {
    AWS.Signers.RequestSigner.call(this, request);
  },

  addAuthorization: function addAuthorization(token) {
    this.request.httpRequest.headers['Authorization'] = 'Bearer ' + token.token;
  }
});

},{"../core":23}],71:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
function signedUrlBuilder(request) {
  var expires = request.httpRequest.headers[expiresHeader];
  var signerClass = request.service.getSignerClass(request);

  delete request.httpRequest.headers['User-Agent'];
  delete request.httpRequest.headers['X-Amz-User-Agent'];

  if (signerClass === AWS.Signers.V4) {
    if (expires > 604800) { // one week expiry is invalid
      var message = 'Presigning does not support expiry time greater ' +
                    'than a week with SigV4 signing.';
      throw AWS.util.error(new Error(), {
        code: 'InvalidExpiryTime', message: message, retryable: false
      });
    }
    request.httpRequest.headers[expiresHeader] = expires;
  } else if (signerClass === AWS.Signers.S3) {
    var now = request.service ? request.service.getSkewCorrectedDate() : AWS.util.date.getDate();
    request.httpRequest.headers[expiresHeader] = parseInt(
      AWS.util.date.unixTimestamp(now) + expires, 10).toString();
  } else {
    throw AWS.util.error(new Error(), {
      message: 'Presigning only supports S3 or SigV4 signing.',
      code: 'UnsupportedSigner', retryable: false
    });
  }
}

/**
 * @api private
 */
function signedUrlSigner(request) {
  var endpoint = request.httpRequest.endpoint;
  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);
  var queryParams = {};

  if (parsedUrl.search) {
    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));
  }

  var auth = request.httpRequest.headers['Authorization'].split(' ');
  if (auth[0] === 'AWS') {
    auth = auth[1].split(':');
    queryParams['Signature'] = auth.pop();
    queryParams['AWSAccessKeyId'] = auth.join(':');

    AWS.util.each(request.httpRequest.headers, function (key, value) {
      if (key === expiresHeader) key = 'Expires';
      if (key.indexOf('x-amz-meta-') === 0) {
        // Delete existing, potentially not normalized key
        delete queryParams[key];
        key = key.toLowerCase();
      }
      queryParams[key] = value;
    });
    delete request.httpRequest.headers[expiresHeader];
    delete queryParams['Authorization'];
    delete queryParams['Host'];
  } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing
    auth.shift();
    var rest = auth.join(' ');
    var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
    queryParams['X-Amz-Signature'] = signature;
    delete queryParams['Expires'];
  }

  // build URL
  endpoint.pathname = parsedUrl.pathname;
  endpoint.search = AWS.util.queryParamsToString(queryParams);
}

/**
 * @api private
 */
AWS.Signers.Presign = inherit({
  /**
   * @api private
   */
  sign: function sign(request, expireTime, callback) {
    request.httpRequest.headers[expiresHeader] = expireTime || 3600;
    request.on('build', signedUrlBuilder);
    request.on('sign', signedUrlSigner);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.SET_CONTENT_LENGTH);
    request.removeListener('afterBuild',
      AWS.EventListeners.Core.COMPUTE_SHA256);

    request.emit('beforePresign', [request]);

    if (callback) {
      request.build(function() {
        if (this.response.error) callback(this.response.error);
        else {
          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));
        }
      });
    } else {
      request.build();
      if (request.response.error) throw request.response.error;
      return AWS.util.urlFormat(request.httpRequest.endpoint);
    }
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.Presign;

},{"../core":23}],72:[function(require,module,exports){
var AWS = require('../core');

var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.RequestSigner = inherit({
  constructor: function RequestSigner(request) {
    this.request = request;
  },

  setServiceClientId: function setServiceClientId(id) {
    this.serviceClientId = id;
  },

  getServiceClientId: function getServiceClientId() {
    return this.serviceClientId;
  }
});

AWS.Signers.RequestSigner.getVersion = function getVersion(version) {
  switch (version) {
    case 'v2': return AWS.Signers.V2;
    case 'v3': return AWS.Signers.V3;
    case 's3v4': return AWS.Signers.V4;
    case 'v4': return AWS.Signers.V4;
    case 's3': return AWS.Signers.S3;
    case 'v3https': return AWS.Signers.V3Https;
    case 'bearer': return AWS.Signers.Bearer;
  }
  throw new Error('Unknown signing version ' + version);
};

require('./v2');
require('./v3');
require('./v3https');
require('./v4');
require('./s3');
require('./presign');
require('./bearer');

},{"../core":23,"./bearer":70,"./presign":71,"./s3":73,"./v2":74,"./v3":75,"./v3https":76,"./v4":77}],73:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {
  /**
   * When building the stringToSign, these sub resource params should be
   * part of the canonical resource string with their NON-decoded values
   */
  subResources: {
    'acl': 1,
    'accelerate': 1,
    'analytics': 1,
    'cors': 1,
    'lifecycle': 1,
    'delete': 1,
    'inventory': 1,
    'location': 1,
    'logging': 1,
    'metrics': 1,
    'notification': 1,
    'partNumber': 1,
    'policy': 1,
    'requestPayment': 1,
    'replication': 1,
    'restore': 1,
    'tagging': 1,
    'torrent': 1,
    'uploadId': 1,
    'uploads': 1,
    'versionId': 1,
    'versioning': 1,
    'versions': 1,
    'website': 1
  },

  // when building the stringToSign, these querystring params should be
  // part of the canonical resource string with their NON-encoded values
  responseHeaders: {
    'response-content-type': 1,
    'response-content-language': 1,
    'response-expires': 1,
    'response-cache-control': 1,
    'response-content-disposition': 1,
    'response-content-encoding': 1
  },

  addAuthorization: function addAuthorization(credentials, date) {
    if (!this.request.headers['presigned-expires']) {
      this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);
    }

    if (credentials.sessionToken) {
      // presigned URLs require this header to be lowercased
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
    var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;

    this.request.headers['Authorization'] = auth;
  },

  stringToSign: function stringToSign() {
    var r = this.request;

    var parts = [];
    parts.push(r.method);
    parts.push(r.headers['Content-MD5'] || '');
    parts.push(r.headers['Content-Type'] || '');

    // This is the "Date" header, but we use X-Amz-Date.
    // The S3 signing mechanism requires us to pass an empty
    // string for this Date header regardless.
    parts.push(r.headers['presigned-expires'] || '');

    var headers = this.canonicalizedAmzHeaders();
    if (headers) parts.push(headers);
    parts.push(this.canonicalizedResource());

    return parts.join('\n');

  },

  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {

    var amzHeaders = [];

    AWS.util.each(this.request.headers, function (name) {
      if (name.match(/^x-amz-/i))
        amzHeaders.push(name);
    });

    amzHeaders.sort(function (a, b) {
      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
    });

    var parts = [];
    AWS.util.arrayEach.call(this, amzHeaders, function (name) {
      parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));
    });

    return parts.join('\n');

  },

  canonicalizedResource: function canonicalizedResource() {

    var r = this.request;

    var parts = r.path.split('?');
    var path = parts[0];
    var querystring = parts[1];

    var resource = '';

    if (r.virtualHostedBucket)
      resource += '/' + r.virtualHostedBucket;

    resource += path;

    if (querystring) {

      // collect a list of sub resources and query params that need to be signed
      var resources = [];

      AWS.util.arrayEach.call(this, querystring.split('&'), function (param) {
        var name = param.split('=')[0];
        var value = param.split('=')[1];
        if (this.subResources[name] || this.responseHeaders[name]) {
          var subresource = { name: name };
          if (value !== undefined) {
            if (this.subResources[name]) {
              subresource.value = value;
            } else {
              subresource.value = decodeURIComponent(value);
            }
          }
          resources.push(subresource);
        }
      });

      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });

      if (resources.length) {

        querystring = [];
        AWS.util.arrayEach(resources, function (res) {
          if (res.value === undefined) {
            querystring.push(res.name);
          } else {
            querystring.push(res.name + '=' + res.value);
          }
        });

        resource += '?' + querystring.join('&');
      }

    }

    return resource;

  },

  sign: function sign(secret, string) {
    return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.S3;

},{"../core":23}],74:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    if (!date) date = AWS.util.date.getDate();

    var r = this.request;

    r.params.Timestamp = AWS.util.date.iso8601(date);
    r.params.SignatureVersion = '2';
    r.params.SignatureMethod = 'HmacSHA256';
    r.params.AWSAccessKeyId = credentials.accessKeyId;

    if (credentials.sessionToken) {
      r.params.SecurityToken = credentials.sessionToken;
    }

    delete r.params.Signature; // delete old Signature for re-signing
    r.params.Signature = this.signature(credentials);

    r.body = AWS.util.queryParamsToString(r.params);
    r.headers['Content-Length'] = r.body.length;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push(this.request.endpoint.host.toLowerCase());
    parts.push(this.request.pathname());
    parts.push(AWS.util.queryParamsToString(this.request.params));
    return parts.join('\n');
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V2;

},{"../core":23}],75:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {
  addAuthorization: function addAuthorization(credentials, date) {

    var datetime = AWS.util.date.rfc822(date);

    this.request.headers['X-Amz-Date'] = datetime;

    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }

    this.request.headers['X-Amzn-Authorization'] =
      this.authorization(credentials, datetime);

  },

  authorization: function authorization(credentials) {
    return 'AWS3 ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'SignedHeaders=' + this.signedHeaders() + ',' +
      'Signature=' + this.signature(credentials);
  },

  signedHeaders: function signedHeaders() {
    var headers = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      headers.push(h.toLowerCase());
    });
    return headers.sort().join(';');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = this.request.headers;
    var parts = [];
    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {
      parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());
    });
    return parts.sort().join('\n') + '\n';
  },

  headersToSign: function headersToSign() {
    var headers = [];
    AWS.util.each(this.request.headers, function iterator(k) {
      if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {
        headers.push(k);
      }
    });
    return headers;
  },

  signature: function signature(credentials) {
    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');
  },

  stringToSign: function stringToSign() {
    var parts = [];
    parts.push(this.request.method);
    parts.push('/');
    parts.push('');
    parts.push(this.canonicalHeaders());
    parts.push(this.request.body);
    return AWS.util.crypto.sha256(parts.join('\n'));
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V3;

},{"../core":23}],76:[function(require,module,exports){
var AWS = require('../core');
var inherit = AWS.util.inherit;

require('./v3');

/**
 * @api private
 */
AWS.Signers.V3Https = inherit(AWS.Signers.V3, {
  authorization: function authorization(credentials) {
    return 'AWS3-HTTPS ' +
      'AWSAccessKeyId=' + credentials.accessKeyId + ',' +
      'Algorithm=HmacSHA256,' +
      'Signature=' + this.signature(credentials);
  },

  stringToSign: function stringToSign() {
    return this.request.headers['X-Amz-Date'];
  }
});

/**
 * @api private
 */
module.exports = AWS.Signers.V3Https;

},{"../core":23,"./v3":75}],77:[function(require,module,exports){
var AWS = require('../core');
var v4Credentials = require('./v4_credentials');
var inherit = AWS.util.inherit;

/**
 * @api private
 */
var expiresHeader = 'presigned-expires';

/**
 * @api private
 */
AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {
  constructor: function V4(request, serviceName, options) {
    AWS.Signers.RequestSigner.call(this, request);
    this.serviceName = serviceName;
    options = options || {};
    this.signatureCache = typeof options.signatureCache === 'boolean' ? options.signatureCache : true;
    this.operation = options.operation;
    this.signatureVersion = options.signatureVersion;
  },

  algorithm: 'AWS4-HMAC-SHA256',

  addAuthorization: function addAuthorization(credentials, date) {
    var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');

    if (this.isPresigned()) {
      this.updateForPresigned(credentials, datetime);
    } else {
      this.addHeaders(credentials, datetime);
    }

    this.request.headers['Authorization'] =
      this.authorization(credentials, datetime);
  },

  addHeaders: function addHeaders(credentials, datetime) {
    this.request.headers['X-Amz-Date'] = datetime;
    if (credentials.sessionToken) {
      this.request.headers['x-amz-security-token'] = credentials.sessionToken;
    }
  },

  updateForPresigned: function updateForPresigned(credentials, datetime) {
    var credString = this.credentialString(datetime);
    var qs = {
      'X-Amz-Date': datetime,
      'X-Amz-Algorithm': this.algorithm,
      'X-Amz-Credential': credentials.accessKeyId + '/' + credString,
      'X-Amz-Expires': this.request.headers[expiresHeader],
      'X-Amz-SignedHeaders': this.signedHeaders()
    };

    if (credentials.sessionToken) {
      qs['X-Amz-Security-Token'] = credentials.sessionToken;
    }

    if (this.request.headers['Content-Type']) {
      qs['Content-Type'] = this.request.headers['Content-Type'];
    }
    if (this.request.headers['Content-MD5']) {
      qs['Content-MD5'] = this.request.headers['Content-MD5'];
    }
    if (this.request.headers['Cache-Control']) {
      qs['Cache-Control'] = this.request.headers['Cache-Control'];
    }

    // need to pull in any other X-Amz-* headers
    AWS.util.each.call(this, this.request.headers, function(key, value) {
      if (key === expiresHeader) return;
      if (this.isSignableHeader(key)) {
        var lowerKey = key.toLowerCase();
        // Metadata should be normalized
        if (lowerKey.indexOf('x-amz-meta-') === 0) {
          qs[lowerKey] = value;
        } else if (lowerKey.indexOf('x-amz-') === 0) {
          qs[key] = value;
        }
      }
    });

    var sep = this.request.path.indexOf('?') >= 0 ? '&' : '?';
    this.request.path += sep + AWS.util.queryParamsToString(qs);
  },

  authorization: function authorization(credentials, datetime) {
    var parts = [];
    var credString = this.credentialString(datetime);
    parts.push(this.algorithm + ' Credential=' +
      credentials.accessKeyId + '/' + credString);
    parts.push('SignedHeaders=' + this.signedHeaders());
    parts.push('Signature=' + this.signature(credentials, datetime));
    return parts.join(', ');
  },

  signature: function signature(credentials, datetime) {
    var signingKey = v4Credentials.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName,
      this.signatureCache
    );
    return AWS.util.crypto.hmac(signingKey, this.stringToSign(datetime), 'hex');
  },

  stringToSign: function stringToSign(datetime) {
    var parts = [];
    parts.push('AWS4-HMAC-SHA256');
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    parts.push(this.hexEncodedHash(this.canonicalString()));
    return parts.join('\n');
  },

  canonicalString: function canonicalString() {
    var parts = [], pathname = this.request.pathname();
    if (this.serviceName !== 's3' && this.signatureVersion !== 's3v4') pathname = AWS.util.uriEscapePath(pathname);

    parts.push(this.request.method);
    parts.push(pathname);
    parts.push(this.request.search());
    parts.push(this.canonicalHeaders() + '\n');
    parts.push(this.signedHeaders());
    parts.push(this.hexEncodedBodyHash());
    return parts.join('\n');
  },

  canonicalHeaders: function canonicalHeaders() {
    var headers = [];
    AWS.util.each.call(this, this.request.headers, function (key, item) {
      headers.push([key, item]);
    });
    headers.sort(function (a, b) {
      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
    });
    var parts = [];
    AWS.util.arrayEach.call(this, headers, function (item) {
      var key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        var value = item[1];
        if (typeof value === 'undefined' || value === null || typeof value.toString !== 'function') {
          throw AWS.util.error(new Error('Header ' + key + ' contains invalid value'), {
            code: 'InvalidHeader'
          });
        }
        parts.push(key + ':' +
          this.canonicalHeaderValues(value.toString()));
      }
    });
    return parts.join('\n');
  },

  canonicalHeaderValues: function canonicalHeaderValues(values) {
    return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');
  },

  signedHeaders: function signedHeaders() {
    var keys = [];
    AWS.util.each.call(this, this.request.headers, function (key) {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) keys.push(key);
    });
    return keys.sort().join(';');
  },

  credentialString: function credentialString(datetime) {
    return v4Credentials.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  },

  hexEncodedHash: function hash(string) {
    return AWS.util.crypto.sha256(string, 'hex');
  },

  hexEncodedBodyHash: function hexEncodedBodyHash() {
    var request = this.request;
    if (this.isPresigned() && (['s3', 's3-object-lambda'].indexOf(this.serviceName) > -1) && !request.body) {
      return 'UNSIGNED-PAYLOAD';
    } else if (request.headers['X-Amz-Content-Sha256']) {
      return request.headers['X-Amz-Content-Sha256'];
    } else {
      return this.hexEncodedHash(this.request.body || '');
    }
  },

  unsignableHeaders: [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    expiresHeader,
    'expect',
    'x-amzn-trace-id'
  ],

  isSignableHeader: function isSignableHeader(key) {
    if (key.toLowerCase().indexOf('x-amz-') === 0) return true;
    return this.unsignableHeaders.indexOf(key) < 0;
  },

  isPresigned: function isPresigned() {
    return this.request.headers[expiresHeader] ? true : false;
  }

});

/**
 * @api private
 */
module.exports = AWS.Signers.V4;

},{"../core":23,"./v4_credentials":78}],78:[function(require,module,exports){
var AWS = require('../core');

/**
 * @api private
 */
var cachedSecret = {};

/**
 * @api private
 */
var cacheQueue = [];

/**
 * @api private
 */
var maxCacheEntries = 50;

/**
 * @api private
 */
var v4Identifier = 'aws4_request';

/**
 * @api private
 */
module.exports = {
  /**
   * @api private
   *
   * @param date [String]
   * @param region [String]
   * @param serviceName [String]
   * @return [String]
   */
  createScope: function createScope(date, region, serviceName) {
    return [
      date.substr(0, 8),
      region,
      serviceName,
      v4Identifier
    ].join('/');
  },

  /**
   * @api private
   *
   * @param credentials [Credentials]
   * @param date [String]
   * @param region [String]
   * @param service [String]
   * @param shouldCache [Boolean]
   * @return [String]
   */
  getSigningKey: function getSigningKey(
    credentials,
    date,
    region,
    service,
    shouldCache
  ) {
    var credsIdentifier = AWS.util.crypto
      .hmac(credentials.secretAccessKey, credentials.accessKeyId, 'base64');
    var cacheKey = [credsIdentifier, date, region, service].join('_');
    shouldCache = shouldCache !== false;
    if (shouldCache && (cacheKey in cachedSecret)) {
      return cachedSecret[cacheKey];
    }

    var kDate = AWS.util.crypto.hmac(
      'AWS4' + credentials.secretAccessKey,
      date,
      'buffer'
    );
    var kRegion = AWS.util.crypto.hmac(kDate, region, 'buffer');
    var kService = AWS.util.crypto.hmac(kRegion, service, 'buffer');

    var signingKey = AWS.util.crypto.hmac(kService, v4Identifier, 'buffer');
    if (shouldCache) {
      cachedSecret[cacheKey] = signingKey;
      cacheQueue.push(cacheKey);
      if (cacheQueue.length > maxCacheEntries) {
        // remove the oldest entry (not the least recently used)
        delete cachedSecret[cacheQueue.shift()];
      }
    }

    return signingKey;
  },

  /**
   * @api private
   *
   * Empties the derived signing key cache. Made available for testing purposes
   * only.
   */
  emptyCache: function emptyCache() {
    cachedSecret = {};
    cacheQueue = [];
  }
};

},{"../core":23}],79:[function(require,module,exports){
function AcceptorStateMachine(states, state) {
  this.currentState = state || null;
  this.states = states || {};
}

AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
  if (typeof finalState === 'function') {
    inputError = bindObject; bindObject = done;
    done = finalState; finalState = null;
  }

  var self = this;
  var state = self.states[self.currentState];
  state.fn.call(bindObject || self, inputError, function(err) {
    if (err) {
      if (state.fail) self.currentState = state.fail;
      else return done ? done.call(bindObject, err) : null;
    } else {
      if (state.accept) self.currentState = state.accept;
      else return done ? done.call(bindObject) : null;
    }
    if (self.currentState === finalState) {
      return done ? done.call(bindObject, err) : null;
    }

    self.runTo(finalState, done, bindObject, err);
  });
};

AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
  if (typeof acceptState === 'function') {
    fn = acceptState; acceptState = null; failState = null;
  } else if (typeof failState === 'function') {
    fn = failState; failState = null;
  }

  if (!this.currentState) this.currentState = name;
  this.states[name] = { accept: acceptState, fail: failState, fn: fn };
  return this;
};

/**
 * @api private
 */
module.exports = AcceptorStateMachine;

},{}],80:[function(require,module,exports){
(function (process,setImmediate){(function (){
/* eslint guard-for-in:0 */
var AWS;

/**
 * A set of utility methods for use with the AWS SDK.
 *
 * @!attribute abort
 *   Return this value from an iterator function {each} or {arrayEach}
 *   to break out of the iteration.
 *   @example Breaking out of an iterator function
 *     AWS.util.each({a: 1, b: 2, c: 3}, function(key, value) {
 *       if (key == 'b') return AWS.util.abort;
 *     });
 *   @see each
 *   @see arrayEach
 * @api private
 */
var util = {
  environment: 'nodejs',
  engine: function engine() {
    if (util.isBrowser() && typeof navigator !== 'undefined') {
      return navigator.userAgent;
    } else {
      var engine = process.platform + '/' + process.version;
      if (process.env.AWS_EXECUTION_ENV) {
        engine += ' exec-env/' + process.env.AWS_EXECUTION_ENV;
      }
      return engine;
    }
  },

  userAgent: function userAgent() {
    var name = util.environment;
    var agent = 'aws-sdk-' + name + '/' + require('./core').VERSION;
    if (name === 'nodejs') agent += ' ' + util.engine();
    return agent;
  },

  uriEscape: function uriEscape(string) {
    var output = encodeURIComponent(string);
    output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);

    // AWS percent-encodes some extra non-standard characters in a URI
    output = output.replace(/[*]/g, function(ch) {
      return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    });

    return output;
  },

  uriEscapePath: function uriEscapePath(string) {
    var parts = [];
    util.arrayEach(string.split('/'), function (part) {
      parts.push(util.uriEscape(part));
    });
    return parts.join('/');
  },

  urlParse: function urlParse(url) {
    return util.url.parse(url);
  },

  urlFormat: function urlFormat(url) {
    return util.url.format(url);
  },

  queryStringParse: function queryStringParse(qs) {
    return util.querystring.parse(qs);
  },

  queryParamsToString: function queryParamsToString(params) {
    var items = [];
    var escape = util.uriEscape;
    var sortedKeys = Object.keys(params).sort();

    util.arrayEach(sortedKeys, function(name) {
      var value = params[name];
      var ename = escape(name);
      var result = ename + '=';
      if (Array.isArray(value)) {
        var vals = [];
        util.arrayEach(value, function(item) { vals.push(escape(item)); });
        result = ename + '=' + vals.sort().join('&' + ename + '=');
      } else if (value !== undefined && value !== null) {
        result = ename + '=' + escape(value);
      }
      items.push(result);
    });

    return items.join('&');
  },

  readFileSync: function readFileSync(path) {
    if (util.isBrowser()) return null;
    return require('fs').readFileSync(path, 'utf-8');
  },

  base64: {
    encode: function encode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 encode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      var buf = util.buffer.toBuffer(string);
      return buf.toString('base64');
    },

    decode: function decode64(string) {
      if (typeof string === 'number') {
        throw util.error(new Error('Cannot base64 decode number ' + string));
      }
      if (string === null || typeof string === 'undefined') {
        return string;
      }
      return util.buffer.toBuffer(string, 'base64');
    }

  },

  buffer: {
    /**
     * Buffer constructor for Node buffer and buffer pollyfill
     */
    toBuffer: function(data, encoding) {
      return (typeof util.Buffer.from === 'function' && util.Buffer.from !== Uint8Array.from) ?
        util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
    },

    alloc: function(size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new Error('size passed to alloc must be a number.');
      }
      if (typeof util.Buffer.alloc === 'function') {
        return util.Buffer.alloc(size, fill, encoding);
      } else {
        var buf = new util.Buffer(size);
        if (fill !== undefined && typeof buf.fill === 'function') {
          buf.fill(fill, undefined, undefined, encoding);
        }
        return buf;
      }
    },

    toStream: function toStream(buffer) {
      if (!util.Buffer.isBuffer(buffer)) buffer =  util.buffer.toBuffer(buffer);

      var readable = new (util.stream.Readable)();
      var pos = 0;
      readable._read = function(size) {
        if (pos >= buffer.length) return readable.push(null);

        var end = pos + size;
        if (end > buffer.length) end = buffer.length;
        readable.push(buffer.slice(pos, end));
        pos = end;
      };

      return readable;
    },

    /**
     * Concatenates a list of Buffer objects.
     */
    concat: function(buffers) {
      var length = 0,
          offset = 0,
          buffer = null, i;

      for (i = 0; i < buffers.length; i++) {
        length += buffers[i].length;
      }

      buffer = util.buffer.alloc(length);

      for (i = 0; i < buffers.length; i++) {
        buffers[i].copy(buffer, offset);
        offset += buffers[i].length;
      }

      return buffer;
    }
  },

  string: {
    byteLength: function byteLength(string) {
      if (string === null || string === undefined) return 0;
      if (typeof string === 'string') string = util.buffer.toBuffer(string);

      if (typeof string.byteLength === 'number') {
        return string.byteLength;
      } else if (typeof string.length === 'number') {
        return string.length;
      } else if (typeof string.size === 'number') {
        return string.size;
      } else if (typeof string.path === 'string') {
        return require('fs').lstatSync(string.path).size;
      } else {
        throw util.error(new Error('Cannot determine length of ' + string),
          { object: string });
      }
    },

    upperFirst: function upperFirst(string) {
      return string[0].toUpperCase() + string.substr(1);
    },

    lowerFirst: function lowerFirst(string) {
      return string[0].toLowerCase() + string.substr(1);
    }
  },

  ini: {
    parse: function string(ini) {
      var currentSection, map = {};
      util.arrayEach(ini.split(/\r?\n/), function(line) {
        line = line.split(/(^|\s)[;#]/)[0].trim(); // remove comments and trim
        var isSection = line[0] === '[' && line[line.length - 1] === ']';
        if (isSection) {
          currentSection = line.substring(1, line.length - 1);
          if (currentSection === '__proto__' || currentSection.split(/\s/)[1] === '__proto__') {
            throw util.error(
              new Error('Cannot load profile name \'' + currentSection + '\' from shared ini file.')
            );
          }
        } else if (currentSection) {
          var indexOfEqualsSign = line.indexOf('=');
          var start = 0;
          var end = line.length - 1;
          var isAssignment =
            indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;

          if (isAssignment) {
            var name = line.substring(0, indexOfEqualsSign).trim();
            var value = line.substring(indexOfEqualsSign + 1).trim();

            map[currentSection] = map[currentSection] || {};
            map[currentSection][name] = value;
          }
        }
      });

      return map;
    }
  },

  fn: {
    noop: function() {},
    callback: function (err) { if (err) throw err; },

    /**
     * Turn a synchronous function into as "async" function by making it call
     * a callback. The underlying function is called with all but the last argument,
     * which is treated as the callback. The callback is passed passed a first argument
     * of null on success to mimick standard node callbacks.
     */
    makeAsync: function makeAsync(fn, expectedArgs) {
      if (expectedArgs && expectedArgs <= fn.length) {
        return fn;
      }

      return function() {
        var args = Array.prototype.slice.call(arguments, 0);
        var callback = args.pop();
        var result = fn.apply(null, args);
        callback(result);
      };
    }
  },

  /**
   * Date and time utility functions.
   */
  date: {

    /**
     * @return [Date] the current JavaScript date object. Since all
     *   AWS services rely on this date object, you can override
     *   this function to provide a special time value to AWS service
     *   requests.
     */
    getDate: function getDate() {
      if (!AWS) AWS = require('./core');
      if (AWS.config.systemClockOffset) { // use offset when non-zero
        return new Date(new Date().getTime() + AWS.config.systemClockOffset);
      } else {
        return new Date();
      }
    },

    /**
     * @return [String] the date in ISO-8601 format
     */
    iso8601: function iso8601(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toISOString().replace(/\.\d{3}Z$/, 'Z');
    },

    /**
     * @return [String] the date in RFC 822 format
     */
    rfc822: function rfc822(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.toUTCString();
    },

    /**
     * @return [Integer] the UNIX timestamp value for the current time
     */
    unixTimestamp: function unixTimestamp(date) {
      if (date === undefined) { date = util.date.getDate(); }
      return date.getTime() / 1000;
    },

    /**
     * @param [String,number,Date] date
     * @return [Date]
     */
    from: function format(date) {
      if (typeof date === 'number') {
        return new Date(date * 1000); // unix timestamp
      } else {
        return new Date(date);
      }
    },

    /**
     * Given a Date or date-like value, this function formats the
     * date into a string of the requested value.
     * @param [String,number,Date] date
     * @param [String] formatter Valid formats are:
     #   * 'iso8601'
     #   * 'rfc822'
     #   * 'unixTimestamp'
     * @return [String]
     */
    format: function format(date, formatter) {
      if (!formatter) formatter = 'iso8601';
      return util.date[formatter](util.date.from(date));
    },

    parseTimestamp: function parseTimestamp(value) {
      if (typeof value === 'number') { // unix timestamp (number)
        return new Date(value * 1000);
      } else if (value.match(/^\d+$/)) { // unix timestamp
        return new Date(value * 1000);
      } else if (value.match(/^\d{4}/)) { // iso8601
        return new Date(value);
      } else if (value.match(/^\w{3},/)) { // rfc822
        return new Date(value);
      } else {
        throw util.error(
          new Error('unhandled timestamp format: ' + value),
          {code: 'TimestampParserError'});
      }
    }

  },

  crypto: {
    crc32Table: [
     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,
     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,
     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,
     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,
     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,
     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,
     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,
     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,
     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,
     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,
     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,
     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,
     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,
     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,
     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,
     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,
     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,
     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,
     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,
     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,
     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,
     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,
     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,
     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,
     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,
     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,
     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,
     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,
     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,
     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,
     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,
     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,
     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,
     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,
     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,
     0x2D02EF8D],

    crc32: function crc32(data) {
      var tbl = util.crypto.crc32Table;
      var crc = 0 ^ -1;

      if (typeof data === 'string') {
        data = util.buffer.toBuffer(data);
      }

      for (var i = 0; i < data.length; i++) {
        var code = data.readUInt8(i);
        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];
      }
      return (crc ^ -1) >>> 0;
    },

    hmac: function hmac(key, string, digest, fn) {
      if (!digest) digest = 'binary';
      if (digest === 'buffer') { digest = undefined; }
      if (!fn) fn = 'sha256';
      if (typeof string === 'string') string = util.buffer.toBuffer(string);
      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
    },

    md5: function md5(data, digest, callback) {
      return util.crypto.hash('md5', data, digest, callback);
    },

    sha256: function sha256(data, digest, callback) {
      return util.crypto.hash('sha256', data, digest, callback);
    },

    hash: function(algorithm, data, digest, callback) {
      var hash = util.crypto.createHash(algorithm);
      if (!digest) { digest = 'binary'; }
      if (digest === 'buffer') { digest = undefined; }
      if (typeof data === 'string') data = util.buffer.toBuffer(data);
      var sliceFn = util.arraySliceFn(data);
      var isBuffer = util.Buffer.isBuffer(data);
      //Identifying objects with an ArrayBuffer as buffers
      if (util.isBrowser() && typeof ArrayBuffer !== 'undefined' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;

      if (callback && typeof data === 'object' &&
          typeof data.on === 'function' && !isBuffer) {
        data.on('data', function(chunk) { hash.update(chunk); });
        data.on('error', function(err) { callback(err); });
        data.on('end', function() { callback(null, hash.digest(digest)); });
      } else if (callback && sliceFn && !isBuffer &&
                 typeof FileReader !== 'undefined') {
        // this might be a File/Blob
        var index = 0, size = 1024 * 512;
        var reader = new FileReader();
        reader.onerror = function() {
          callback(new Error('Failed to read data.'));
        };
        reader.onload = function() {
          var buf = new util.Buffer(new Uint8Array(reader.result));
          hash.update(buf);
          index += buf.length;
          reader._continueReading();
        };
        reader._continueReading = function() {
          if (index >= data.size) {
            callback(null, hash.digest(digest));
            return;
          }

          var back = index + size;
          if (back > data.size) back = data.size;
          reader.readAsArrayBuffer(sliceFn.call(data, index, back));
        };

        reader._continueReading();
      } else {
        if (util.isBrowser() && typeof data === 'object' && !isBuffer) {
          data = new util.Buffer(new Uint8Array(data));
        }
        var out = hash.update(data).digest(digest);
        if (callback) callback(null, out);
        return out;
      }
    },

    toHex: function toHex(data) {
      var out = [];
      for (var i = 0; i < data.length; i++) {
        out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));
      }
      return out.join('');
    },

    createHash: function createHash(algorithm) {
      return util.crypto.lib.createHash(algorithm);
    }

  },

  /** @!ignore */

  /* Abort constant */
  abort: {},

  each: function each(object, iterFunction) {
    for (var key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        var ret = iterFunction.call(this, key, object[key]);
        if (ret === util.abort) break;
      }
    }
  },

  arrayEach: function arrayEach(array, iterFunction) {
    for (var idx in array) {
      if (Object.prototype.hasOwnProperty.call(array, idx)) {
        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
        if (ret === util.abort) break;
      }
    }
  },

  update: function update(obj1, obj2) {
    util.each(obj2, function iterator(key, item) {
      obj1[key] = item;
    });
    return obj1;
  },

  merge: function merge(obj1, obj2) {
    return util.update(util.copy(obj1), obj2);
  },

  copy: function copy(object) {
    if (object === null || object === undefined) return object;
    var dupe = {};
    // jshint forin:false
    for (var key in object) {
      dupe[key] = object[key];
    }
    return dupe;
  },

  isEmpty: function isEmpty(obj) {
    for (var prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        return false;
      }
    }
    return true;
  },

  arraySliceFn: function arraySliceFn(obj) {
    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
    return typeof fn === 'function' ? fn : null;
  },

  isType: function isType(obj, type) {
    // handle cross-"frame" objects
    if (typeof type === 'function') type = util.typeName(type);
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  },

  typeName: function typeName(type) {
    if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;
    var str = type.toString();
    var match = str.match(/^\s*function (.+)\(/);
    return match ? match[1] : str;
  },

  error: function error(err, options) {
    var originalError = null;
    if (typeof err.message === 'string' && err.message !== '') {
      if (typeof options === 'string' || (options && options.message)) {
        originalError = util.copy(err);
        originalError.message = err.message;
      }
    }
    err.message = err.message || null;

    if (typeof options === 'string') {
      err.message = options;
    } else if (typeof options === 'object' && options !== null) {
      util.update(err, options);
      if (options.message)
        err.message = options.message;
      if (options.code || options.name)
        err.code = options.code || options.name;
      if (options.stack)
        err.stack = options.stack;
    }

    if (typeof Object.defineProperty === 'function') {
      Object.defineProperty(err, 'name', {writable: true, enumerable: false});
      Object.defineProperty(err, 'message', {enumerable: true});
    }

    err.name = String(options && options.name || err.name || err.code || 'Error');
    err.time = new Date();

    if (originalError) err.originalError = originalError;

    return err;
  },

  /**
   * @api private
   */
  inherit: function inherit(klass, features) {
    var newObject = null;
    if (features === undefined) {
      features = klass;
      klass = Object;
      newObject = {};
    } else {
      var ctor = function ConstructorWrapper() {};
      ctor.prototype = klass.prototype;
      newObject = new ctor();
    }

    // constructor not supplied, create pass-through ctor
    if (features.constructor === Object) {
      features.constructor = function() {
        if (klass !== Object) {
          return klass.apply(this, arguments);
        }
      };
    }

    features.constructor.prototype = newObject;
    util.update(features.constructor.prototype, features);
    features.constructor.__super__ = klass;
    return features.constructor;
  },

  /**
   * @api private
   */
  mixin: function mixin() {
    var klass = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      // jshint forin:false
      for (var prop in arguments[i].prototype) {
        var fn = arguments[i].prototype[prop];
        if (prop !== 'constructor') {
          klass.prototype[prop] = fn;
        }
      }
    }
    return klass;
  },

  /**
   * @api private
   */
  hideProperties: function hideProperties(obj, props) {
    if (typeof Object.defineProperty !== 'function') return;

    util.arrayEach(props, function (key) {
      Object.defineProperty(obj, key, {
        enumerable: false, writable: true, configurable: true });
    });
  },

  /**
   * @api private
   */
  property: function property(obj, name, value, enumerable, isValue) {
    var opts = {
      configurable: true,
      enumerable: enumerable !== undefined ? enumerable : true
    };
    if (typeof value === 'function' && !isValue) {
      opts.get = value;
    }
    else {
      opts.value = value; opts.writable = true;
    }

    Object.defineProperty(obj, name, opts);
  },

  /**
   * @api private
   */
  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
    var cachedValue = null;

    // build enumerable attribute for each value with lazy accessor.
    util.property(obj, name, function() {
      if (cachedValue === null) {
        cachedValue = get();
      }
      return cachedValue;
    }, enumerable);
  },

  /**
   * TODO Remove in major version revision
   * This backfill populates response data without the
   * top-level payload name.
   *
   * @api private
   */
  hoistPayloadMember: function hoistPayloadMember(resp) {
    var req = resp.request;
    var operationName = req.operation;
    var operation = req.service.api.operations[operationName];
    var output = operation.output;
    if (output.payload && !operation.hasEventOutput) {
      var payloadMember = output.members[output.payload];
      var responsePayload = resp.data[output.payload];
      if (payloadMember.type === 'structure') {
        util.each(responsePayload, function(key, value) {
          util.property(resp.data, key, value, false);
        });
      }
    }
  },

  /**
   * Compute SHA-256 checksums of streams
   *
   * @api private
   */
  computeSha256: function computeSha256(body, done) {
    if (util.isNode()) {
      var Stream = util.stream.Stream;
      var fs = require('fs');
      if (typeof Stream === 'function' && body instanceof Stream) {
        if (typeof body.path === 'string') { // assume file object
          var settings = {};
          if (typeof body.start === 'number') {
            settings.start = body.start;
          }
          if (typeof body.end === 'number') {
            settings.end = body.end;
          }
          body = fs.createReadStream(body.path, settings);
        } else { // TODO support other stream types
          return done(new Error('Non-file stream objects are ' +
                                'not supported with SigV4'));
        }
      }
    }

    util.crypto.sha256(body, 'hex', function(err, sha) {
      if (err) done(err);
      else done(null, sha);
    });
  },

  /**
   * @api private
   */
  isClockSkewed: function isClockSkewed(serverTime) {
    if (serverTime) {
      util.property(AWS.config, 'isClockSkewed',
        Math.abs(new Date().getTime() - serverTime) >= 300000, false);
      return AWS.config.isClockSkewed;
    }
  },

  applyClockOffset: function applyClockOffset(serverTime) {
    if (serverTime)
      AWS.config.systemClockOffset = serverTime - new Date().getTime();
  },

  /**
   * @api private
   */
  extractRequestId: function extractRequestId(resp) {
    var requestId = resp.httpResponse.headers['x-amz-request-id'] ||
                     resp.httpResponse.headers['x-amzn-requestid'];

    if (!requestId && resp.data && resp.data.ResponseMetadata) {
      requestId = resp.data.ResponseMetadata.RequestId;
    }

    if (requestId) {
      resp.requestId = requestId;
    }

    if (resp.error) {
      resp.error.requestId = requestId;
    }
  },

  /**
   * @api private
   */
  addPromises: function addPromises(constructors, PromiseDependency) {
    var deletePromises = false;
    if (PromiseDependency === undefined && AWS && AWS.config) {
      PromiseDependency = AWS.config.getPromisesDependency();
    }
    if (PromiseDependency === undefined && typeof Promise !== 'undefined') {
      PromiseDependency = Promise;
    }
    if (typeof PromiseDependency !== 'function') deletePromises = true;
    if (!Array.isArray(constructors)) constructors = [constructors];

    for (var ind = 0; ind < constructors.length; ind++) {
      var constructor = constructors[ind];
      if (deletePromises) {
        if (constructor.deletePromisesFromClass) {
          constructor.deletePromisesFromClass();
        }
      } else if (constructor.addPromisesToClass) {
        constructor.addPromisesToClass(PromiseDependency);
      }
    }
  },

  /**
   * @api private
   * Return a function that will return a promise whose fate is decided by the
   * callback behavior of the given method with `methodName`. The method to be
   * promisified should conform to node.js convention of accepting a callback as
   * last argument and calling that callback with error as the first argument
   * and success value on the second argument.
   */
  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
    return function promise() {
      var self = this;
      var args = Array.prototype.slice.call(arguments);
      return new PromiseDependency(function(resolve, reject) {
        args.push(function(err, data) {
          if (err) {
            reject(err);
          } else {
            resolve(data);
          }
        });
        self[methodName].apply(self, args);
      });
    };
  },

  /**
   * @api private
   */
  isDualstackAvailable: function isDualstackAvailable(service) {
    if (!service) return false;
    var metadata = require('../apis/metadata.json');
    if (typeof service !== 'string') service = service.serviceIdentifier;
    if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;
    return !!metadata[service].dualstackAvailable;
  },

  /**
   * @api private
   */
  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
    if (!retryDelayOptions) retryDelayOptions = {};
    var customBackoff = retryDelayOptions.customBackoff || null;
    if (typeof customBackoff === 'function') {
      return customBackoff(retryCount, err);
    }
    var base = typeof retryDelayOptions.base === 'number' ? retryDelayOptions.base : 100;
    var delay = Math.random() * (Math.pow(2, retryCount) * base);
    return delay;
  },

  /**
   * @api private
   */
  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
    if (!options) options = {};
    var http = AWS.HttpClient.getInstance();
    var httpOptions = options.httpOptions || {};
    var retryCount = 0;

    var errCallback = function(err) {
      var maxRetries = options.maxRetries || 0;
      if (err && err.code === 'TimeoutError') err.retryable = true;

      // Call `calculateRetryDelay()` only when relevant, see #3401
      if (err && err.retryable && retryCount < maxRetries) {
        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
        if (delay >= 0) {
          retryCount++;
          setTimeout(sendRequest, delay + (err.retryAfter || 0));
          return;
        }
      }
      cb(err);
    };

    var sendRequest = function() {
      var data = '';
      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
        httpResponse.on('data', function(chunk) { data += chunk.toString(); });
        httpResponse.on('end', function() {
          var statusCode = httpResponse.statusCode;
          if (statusCode < 300) {
            cb(null, data);
          } else {
            var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;
            var err = util.error(new Error(),
              {
                statusCode: statusCode,
                retryable: statusCode >= 500 || statusCode === 429
              }
            );
            if (retryAfter && err.retryable) err.retryAfter = retryAfter;
            errCallback(err);
          }
        });
      }, errCallback);
    };

    AWS.util.defer(sendRequest);
  },

  /**
   * @api private
   */
  uuid: {
    v4: function uuidV4() {
      return require('uuid').v4();
    }
  },

  /**
   * @api private
   */
  convertPayloadToString: function convertPayloadToString(resp) {
    var req = resp.request;
    var operation = req.operation;
    var rules = req.service.api.operations[operation].output || {};
    if (rules.payload && resp.data[rules.payload]) {
      resp.data[rules.payload] = resp.data[rules.payload].toString();
    }
  },

  /**
   * @api private
   */
  defer: function defer(callback) {
    if (typeof process === 'object' && typeof process.nextTick === 'function') {
      process.nextTick(callback);
    } else if (typeof setImmediate === 'function') {
      setImmediate(callback);
    } else {
      setTimeout(callback, 0);
    }
  },

  /**
   * @api private
   */
  getRequestPayloadShape: function getRequestPayloadShape(req) {
    var operations = req.service.api.operations;
    if (!operations) return undefined;
    var operation = (operations || {})[req.operation];
    if (!operation || !operation.input || !operation.input.payload) return undefined;
    return operation.input.members[operation.input.payload];
  },

  getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
    var profiles = {};
    var profilesFromConfig = {};
    if (process.env[util.configOptInEnv]) {
      var profilesFromConfig = iniLoader.loadFrom({
        isConfig: true,
        filename: process.env[util.sharedConfigFileEnv]
      });
    }
    var profilesFromCreds= {};
    try {
      var profilesFromCreds = iniLoader.loadFrom({
        filename: filename ||
          (process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv])
      });
    } catch (error) {
      // if using config, assume it is fully descriptive without a credentials file:
      if (!process.env[util.configOptInEnv]) throw error;
    }
    for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
    }
    for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
      profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
    }
    return profiles;

    /**
     * Roughly the semantics of `Object.assign(target, source)`
     */
    function objectAssign(target, source) {
      for (var i = 0, keys = Object.keys(source); i < keys.length; i++) {
        target[keys[i]] = source[keys[i]];
      }
      return target;
    }
  },

  /**
   * @api private
   */
  ARN: {
    validate: function validateARN(str) {
      return str && str.indexOf('arn:') === 0 && str.split(':').length >= 6;
    },
    parse: function parseARN(arn) {
      var matched = arn.split(':');
      return {
        partition: matched[1],
        service: matched[2],
        region: matched[3],
        accountId: matched[4],
        resource: matched.slice(5).join(':')
      };
    },
    build: function buildARN(arnObject) {
      if (
        arnObject.service === undefined ||
        arnObject.region === undefined ||
        arnObject.accountId === undefined ||
        arnObject.resource === undefined
      ) throw util.error(new Error('Input ARN object is invalid'));
      return 'arn:'+ (arnObject.partition || 'aws') + ':' + arnObject.service +
        ':' + arnObject.region + ':' + arnObject.accountId + ':' + arnObject.resource;
    }
  },

  /**
   * @api private
   */
  defaultProfile: 'default',

  /**
   * @api private
   */
  configOptInEnv: 'AWS_SDK_LOAD_CONFIG',

  /**
   * @api private
   */
  sharedCredentialsFileEnv: 'AWS_SHARED_CREDENTIALS_FILE',

  /**
   * @api private
   */
  sharedConfigFileEnv: 'AWS_CONFIG_FILE',

  /**
   * @api private
   */
  imdsDisabledEnv: 'AWS_EC2_METADATA_DISABLED'
};

/**
 * @api private
 */
module.exports = util;

}).call(this)}).call(this,require('_process'),require("timers").setImmediate)

},{"../apis/metadata.json":3,"./core":23,"_process":97,"fs":90,"timers":105,"uuid":111}],81:[function(require,module,exports){
var util = require('../util');
var Shape = require('../model/shape');

function DomXmlParser() { }

DomXmlParser.prototype.parse = function(xml, shape) {
  if (xml.replace(/^\s+/, '') === '') return {};

  var result, error;
  try {
    if (window.DOMParser) {
      try {
        var parser = new DOMParser();
        result = parser.parseFromString(xml, 'text/xml');
      } catch (syntaxError) {
        throw util.error(new Error('Parse error in document'),
          {
            originalError: syntaxError,
            code: 'XMLParserError',
            retryable: true
          });
      }

      if (result.documentElement === null) {
        throw util.error(new Error('Cannot parse empty document.'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }

      var isError = result.getElementsByTagName('parsererror')[0];
      if (isError && (isError.parentNode === result ||
          isError.parentNode.nodeName === 'body' ||
          isError.parentNode.parentNode === result ||
          isError.parentNode.parentNode.nodeName === 'body')) {
        var errorElement = isError.getElementsByTagName('div')[0] || isError;
        throw util.error(new Error(errorElement.textContent || 'Parser error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else if (window.ActiveXObject) {
      result = new window.ActiveXObject('Microsoft.XMLDOM');
      result.async = false;

      if (!result.loadXML(xml)) {
        throw util.error(new Error('Parse error in document'),
          {
            code: 'XMLParserError',
            retryable: true
          });
      }
    } else {
      throw new Error('Cannot load XML parser');
    }
  } catch (e) {
    error = e;
  }

  if (result && result.documentElement && !error) {
    var data = parseXml(result.documentElement, shape);
    var metadata = getElementByTagName(result.documentElement, 'ResponseMetadata');
    if (metadata) {
      data.ResponseMetadata = parseXml(metadata, {});
    }
    return data;
  } else if (error) {
    throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});
  } else { // empty xml document
    return {};
  }
};

function getElementByTagName(xml, tag) {
  var elements = xml.getElementsByTagName(tag);
  for (var i = 0, iLen = elements.length; i < iLen; i++) {
    if (elements[i].parentNode === xml) {
      return elements[i];
    }
  }
}

function parseXml(xml, shape) {
  if (!shape) shape = {};
  switch (shape.type) {
    case 'structure': return parseStructure(xml, shape);
    case 'map': return parseMap(xml, shape);
    case 'list': return parseList(xml, shape);
    case undefined: case null: return parseUnknown(xml);
    default: return parseScalar(xml, shape);
  }
}

function parseStructure(xml, shape) {
  var data = {};
  if (xml === null) return data;

  util.each(shape.members, function(memberName, memberShape) {
    if (memberShape.isXmlAttribute) {
      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
        var value = xml.attributes[memberShape.name].value;
        data[memberName] = parseXml({textContent: value}, memberShape);
      }
    } else {
      var xmlChild = memberShape.flattened ? xml :
        getElementByTagName(xml, memberShape.name);
      if (xmlChild) {
        data[memberName] = parseXml(xmlChild, memberShape);
      } else if (
        !memberShape.flattened &&
        memberShape.type === 'list' &&
        !shape.api.xmlNoDefaultLists) {
        data[memberName] = memberShape.defaultValue;
      }
    }
  });

  return data;
}

function parseMap(xml, shape) {
  var data = {};
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';
  var tagName = shape.flattened ? shape.name : 'entry';

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      var key = getElementByTagName(child, xmlKey).textContent;
      var value = getElementByTagName(child, xmlValue);
      data[key] = parseXml(value, shape.value);
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseList(xml, shape) {
  var data = [];
  var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');

  var child = xml.firstElementChild;
  while (child) {
    if (child.nodeName === tagName) {
      data.push(parseXml(child, shape.member));
    }
    child = child.nextElementSibling;
  }
  return data;
}

function parseScalar(xml, shape) {
  if (xml.getAttribute) {
    var encoding = xml.getAttribute('encoding');
    if (encoding === 'base64') {
      shape = new Shape.create({type: encoding});
    }
  }

  var text = xml.textContent;
  if (text === '') text = null;
  if (typeof shape.toType === 'function') {
    return shape.toType(text);
  } else {
    return text;
  }
}

function parseUnknown(xml) {
  if (xml === undefined || xml === null) return '';

  // empty object
  if (!xml.firstElementChild) {
    if (xml.parentNode.parentNode === null) return {};
    if (xml.childNodes.length === 0) return '';
    else return xml.textContent;
  }

  // object, parse as structure
  var shape = {type: 'structure', members: {}};
  var child = xml.firstElementChild;
  while (child) {
    var tag = child.nodeName;
    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
      // multiple tags of the same name makes it a list
      shape.members[tag].type = 'list';
    } else {
      shape.members[tag] = {name: tag};
    }
    child = child.nextElementSibling;
  }
  return parseStructure(xml, shape);
}

/**
 * @api private
 */
module.exports = DomXmlParser;

},{"../model/shape":48,"../util":80}],82:[function(require,module,exports){
var util = require('../util');
var XmlNode = require('./xml-node').XmlNode;
var XmlText = require('./xml-text').XmlText;

function XmlBuilder() { }

XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
  var xml = new XmlNode(rootElement);
  applyNamespaces(xml, shape, true);
  serialize(xml, params, shape);
  return xml.children.length > 0 || noEmpty ? xml.toString() : '';
};

function serialize(xml, value, shape) {
  switch (shape.type) {
    case 'structure': return serializeStructure(xml, value, shape);
    case 'map': return serializeMap(xml, value, shape);
    case 'list': return serializeList(xml, value, shape);
    default: return serializeScalar(xml, value, shape);
  }
}

function serializeStructure(xml, params, shape) {
  util.arrayEach(shape.memberNames, function(memberName) {
    var memberShape = shape.members[memberName];
    if (memberShape.location !== 'body') return;

    var value = params[memberName];
    var name = memberShape.name;
    if (value !== undefined && value !== null) {
      if (memberShape.isXmlAttribute) {
        xml.addAttribute(name, value);
      } else if (memberShape.flattened) {
        serialize(xml, value, memberShape);
      } else {
        var element = new XmlNode(name);
        xml.addChildNode(element);
        applyNamespaces(element, memberShape);
        serialize(element, value, memberShape);
      }
    }
  });
}

function serializeMap(xml, map, shape) {
  var xmlKey = shape.key.name || 'key';
  var xmlValue = shape.value.name || 'value';

  util.each(map, function(key, value) {
    var entry = new XmlNode(shape.flattened ? shape.name : 'entry');
    xml.addChildNode(entry);

    var entryKey = new XmlNode(xmlKey);
    var entryValue = new XmlNode(xmlValue);
    entry.addChildNode(entryKey);
    entry.addChildNode(entryValue);

    serialize(entryKey, key, shape.key);
    serialize(entryValue, value, shape.value);
  });
}

function serializeList(xml, list, shape) {
  if (shape.flattened) {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || shape.name;
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  } else {
    util.arrayEach(list, function(value) {
      var name = shape.member.name || 'member';
      var element = new XmlNode(name);
      xml.addChildNode(element);
      serialize(element, value, shape.member);
    });
  }
}

function serializeScalar(xml, value, shape) {
  xml.addChildNode(
    new XmlText(shape.toWireFormat(value))
  );
}

function applyNamespaces(xml, shape, isRoot) {
  var uri, prefix = 'xmlns';
  if (shape.xmlNamespaceUri) {
    uri = shape.xmlNamespaceUri;
    if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;
  } else if (isRoot && shape.api.xmlNamespaceUri) {
    uri = shape.api.xmlNamespaceUri;
  }

  if (uri) xml.addAttribute(prefix, uri);
}

/**
 * @api private
 */
module.exports = XmlBuilder;

},{"../util":80,"./xml-node":85,"./xml-text":86}],83:[function(require,module,exports){
/**
 * Escapes characters that can not be in an XML attribute.
 */
function escapeAttribute(value) {
    return value.replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/**
 * @api private
 */
module.exports = {
    escapeAttribute: escapeAttribute
};

},{}],84:[function(require,module,exports){
/**
 * Escapes characters that can not be in an XML element.
 */
function escapeElement(value) {
    return value.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\r/g, '&#x0D;')
                .replace(/\n/g, '&#x0A;')
                .replace(/\u0085/g, '&#x85;')
                .replace(/\u2028/, '&#x2028;');
}

/**
 * @api private
 */
module.exports = {
    escapeElement: escapeElement
};

},{}],85:[function(require,module,exports){
var escapeAttribute = require('./escape-attribute').escapeAttribute;

/**
 * Represents an XML node.
 * @api private
 */
function XmlNode(name, children) {
    if (children === void 0) { children = []; }
    this.name = name;
    this.children = children;
    this.attributes = {};
}
XmlNode.prototype.addAttribute = function (name, value) {
    this.attributes[name] = value;
    return this;
};
XmlNode.prototype.addChildNode = function (child) {
    this.children.push(child);
    return this;
};
XmlNode.prototype.removeAttribute = function (name) {
    delete this.attributes[name];
    return this;
};
XmlNode.prototype.toString = function () {
    var hasChildren = Boolean(this.children.length);
    var xmlText = '<' + this.name;
    // add attributes
    var attributes = this.attributes;
    for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== 'undefined' && attribute !== null) {
            xmlText += ' ' + attributeName + '=\"' + escapeAttribute('' + attribute) + '\"';
        }
    }
    return xmlText += !hasChildren ? '/>' : '>' + this.children.map(function (c) { return c.toString(); }).join('') + '</' + this.name + '>';
};

/**
 * @api private
 */
module.exports = {
    XmlNode: XmlNode
};

},{"./escape-attribute":83}],86:[function(require,module,exports){
var escapeElement = require('./escape-element').escapeElement;

/**
 * Represents an XML text value.
 * @api private
 */
function XmlText(value) {
    this.value = value;
}

XmlText.prototype.toString = function () {
    return escapeElement('' + this.value);
};

/**
 * @api private
 */
module.exports = {
    XmlText: XmlText
};

},{"./escape-element":84}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRU_1 = require("./utils/LRU");
var CACHE_SIZE = 1000;
/**
 * Inspired node-lru-cache[https://github.com/isaacs/node-lru-cache]
 */
var EndpointCache = /** @class */ (function () {
    function EndpointCache(maxSize) {
        if (maxSize === void 0) { maxSize = CACHE_SIZE; }
        this.maxSize = maxSize;
        this.cache = new LRU_1.LRUCache(maxSize);
    }
    ;
    Object.defineProperty(EndpointCache.prototype, "size", {
        get: function () {
            return this.cache.length;
        },
        enumerable: true,
        configurable: true
    });
    EndpointCache.prototype.put = function (key, value) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var endpointRecord = this.populateValue(value);
        this.cache.put(keyString, endpointRecord);
    };
    EndpointCache.prototype.get = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        var now = Date.now();
        var records = this.cache.get(keyString);
        if (records) {
            for (var i = records.length-1; i >= 0; i--) {
                var record = records[i];
                if (record.Expire < now) {
                    records.splice(i, 1);
                }
            }
            if (records.length === 0) {
                this.cache.remove(keyString);
                return undefined;
            }
        }
        return records;
    };
    EndpointCache.getKeyString = function (key) {
        var identifiers = [];
        var identifierNames = Object.keys(key).sort();
        for (var i = 0; i < identifierNames.length; i++) {
            var identifierName = identifierNames[i];
            if (key[identifierName] === undefined)
                continue;
            identifiers.push(key[identifierName]);
        }
        return identifiers.join(' ');
    };
    EndpointCache.prototype.populateValue = function (endpoints) {
        var now = Date.now();
        return endpoints.map(function (endpoint) { return ({
            Address: endpoint.Address || '',
            Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1000
        }); });
    };
    EndpointCache.prototype.empty = function () {
        this.cache.empty();
    };
    EndpointCache.prototype.remove = function (key) {
      var keyString = typeof key !== 'string' ? EndpointCache.getKeyString(key) : key;
        this.cache.remove(keyString);
    };
    return EndpointCache;
}());
exports.EndpointCache = EndpointCache;
},{"./utils/LRU":88}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LinkedListNode = /** @class */ (function () {
    function LinkedListNode(key, value) {
        this.key = key;
        this.value = value;
    }
    return LinkedListNode;
}());
var LRUCache = /** @class */ (function () {
    function LRUCache(size) {
        this.nodeMap = {};
        this.size = 0;
        if (typeof size !== 'number' || size < 1) {
            throw new Error('Cache size can only be positive number');
        }
        this.sizeLimit = size;
    }
    Object.defineProperty(LRUCache.prototype, "length", {
        get: function () {
            return this.size;
        },
        enumerable: true,
        configurable: true
    });
    LRUCache.prototype.prependToList = function (node) {
        if (!this.headerNode) {
            this.tailNode = node;
        }
        else {
            this.headerNode.prev = node;
            node.next = this.headerNode;
        }
        this.headerNode = node;
        this.size++;
    };
    LRUCache.prototype.removeFromTail = function () {
        if (!this.tailNode) {
            return undefined;
        }
        var node = this.tailNode;
        var prevNode = node.prev;
        if (prevNode) {
            prevNode.next = undefined;
        }
        node.prev = undefined;
        this.tailNode = prevNode;
        this.size--;
        return node;
    };
    LRUCache.prototype.detachFromList = function (node) {
        if (this.headerNode === node) {
            this.headerNode = node.next;
        }
        if (this.tailNode === node) {
            this.tailNode = node.prev;
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        node.next = undefined;
        node.prev = undefined;
        this.size--;
    };
    LRUCache.prototype.get = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            this.prependToList(node);
            return node.value;
        }
    };
    LRUCache.prototype.remove = function (key) {
        if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    LRUCache.prototype.put = function (key, value) {
        if (this.nodeMap[key]) {
            this.remove(key);
        }
        else if (this.size === this.sizeLimit) {
            var tailNode = this.removeFromTail();
            var key_1 = tailNode.key;
            delete this.nodeMap[key_1];
        }
        var newNode = new LinkedListNode(key, value);
        this.nodeMap[key] = newNode;
        this.prependToList(newNode);
    };
    LRUCache.prototype.empty = function () {
        var keys = Object.keys(this.nodeMap);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
        }
    };
    return LRUCache;
}());
exports.LRUCache = LRUCache;
},{}],89:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],90:[function(require,module,exports){

},{}],91:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":89,"buffer":91,"ieee754":94}],92:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],93:[function(require,module,exports){
(function (global,Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":89,"buffer":91,"ieee754":94,"isarray":95}],94:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],95:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],96:[function(require,module,exports){
(function(exports) {
  "use strict";

  function isArray(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    } else {
      return false;
    }
  }

  function isObject(obj) {
    if (obj !== null) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    } else {
      return false;
    }
  }

  function strictDeepEqual(first, second) {
    // Check the scalar case first.
    if (first === second) {
      return true;
    }

    // Check if they are the same type.
    var firstType = Object.prototype.toString.call(first);
    if (firstType !== Object.prototype.toString.call(second)) {
      return false;
    }
    // We know that first and second have the same type so we can just check the
    // first type from now on.
    if (isArray(first) === true) {
      // Short circuit if they're not the same length;
      if (first.length !== second.length) {
        return false;
      }
      for (var i = 0; i < first.length; i++) {
        if (strictDeepEqual(first[i], second[i]) === false) {
          return false;
        }
      }
      return true;
    }
    if (isObject(first) === true) {
      // An object is equal if it has the same key/value pairs.
      var keysSeen = {};
      for (var key in first) {
        if (hasOwnProperty.call(first, key)) {
          if (strictDeepEqual(first[key], second[key]) === false) {
            return false;
          }
          keysSeen[key] = true;
        }
      }
      // Now check that there aren't any keys in second that weren't
      // in first.
      for (var key2 in second) {
        if (hasOwnProperty.call(second, key2)) {
          if (keysSeen[key2] !== true) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  function isFalse(obj) {
    // From the spec:
    // A false value corresponds to the following values:
    // Empty list
    // Empty object
    // Empty string
    // False boolean
    // null value

    // First check the scalar values.
    if (obj === "" || obj === false || obj === null) {
        return true;
    } else if (isArray(obj) && obj.length === 0) {
        // Check for an empty array.
        return true;
    } else if (isObject(obj)) {
        // Check for an empty object.
        for (var key in obj) {
            // If there are any keys, then
            // the object is not empty so the object
            // is not false.
            if (obj.hasOwnProperty(key)) {
              return false;
            }
        }
        return true;
    } else {
        return false;
    }
  }

  function objValues(obj) {
    var keys = Object.keys(obj);
    var values = [];
    for (var i = 0; i < keys.length; i++) {
      values.push(obj[keys[i]]);
    }
    return values;
  }

  function merge(a, b) {
      var merged = {};
      for (var key in a) {
          merged[key] = a[key];
      }
      for (var key2 in b) {
          merged[key2] = b[key2];
      }
      return merged;
  }

  var trimLeft;
  if (typeof String.prototype.trimLeft === "function") {
    trimLeft = function(str) {
      return str.trimLeft();
    };
  } else {
    trimLeft = function(str) {
      return str.match(/^\s*(.*)/)[1];
    };
  }

  // Type constants used to define functions.
  var TYPE_NUMBER = 0;
  var TYPE_ANY = 1;
  var TYPE_STRING = 2;
  var TYPE_ARRAY = 3;
  var TYPE_OBJECT = 4;
  var TYPE_BOOLEAN = 5;
  var TYPE_EXPREF = 6;
  var TYPE_NULL = 7;
  var TYPE_ARRAY_NUMBER = 8;
  var TYPE_ARRAY_STRING = 9;
  var TYPE_NAME_TABLE = {
    0: 'number',
    1: 'any',
    2: 'string',
    3: 'array',
    4: 'object',
    5: 'boolean',
    6: 'expression',
    7: 'null',
    8: 'Array<number>',
    9: 'Array<string>'
  };

  var TOK_EOF = "EOF";
  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
  var TOK_RBRACKET = "Rbracket";
  var TOK_RPAREN = "Rparen";
  var TOK_COMMA = "Comma";
  var TOK_COLON = "Colon";
  var TOK_RBRACE = "Rbrace";
  var TOK_NUMBER = "Number";
  var TOK_CURRENT = "Current";
  var TOK_EXPREF = "Expref";
  var TOK_PIPE = "Pipe";
  var TOK_OR = "Or";
  var TOK_AND = "And";
  var TOK_EQ = "EQ";
  var TOK_GT = "GT";
  var TOK_LT = "LT";
  var TOK_GTE = "GTE";
  var TOK_LTE = "LTE";
  var TOK_NE = "NE";
  var TOK_FLATTEN = "Flatten";
  var TOK_STAR = "Star";
  var TOK_FILTER = "Filter";
  var TOK_DOT = "Dot";
  var TOK_NOT = "Not";
  var TOK_LBRACE = "Lbrace";
  var TOK_LBRACKET = "Lbracket";
  var TOK_LPAREN= "Lparen";
  var TOK_LITERAL= "Literal";

  // The "&", "[", "<", ">" tokens
  // are not in basicToken because
  // there are two token variants
  // ("&&", "[?", "<=", ">=").  This is specially handled
  // below.

  var basicTokens = {
    ".": TOK_DOT,
    "*": TOK_STAR,
    ",": TOK_COMMA,
    ":": TOK_COLON,
    "{": TOK_LBRACE,
    "}": TOK_RBRACE,
    "]": TOK_RBRACKET,
    "(": TOK_LPAREN,
    ")": TOK_RPAREN,
    "@": TOK_CURRENT
  };

  var operatorStartToken = {
      "<": true,
      ">": true,
      "=": true,
      "!": true
  };

  var skipChars = {
      " ": true,
      "\t": true,
      "\n": true
  };


  function isAlpha(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             ch === "_";
  }

  function isNum(ch) {
      return (ch >= "0" && ch <= "9") ||
             ch === "-";
  }
  function isAlphaNum(ch) {
      return (ch >= "a" && ch <= "z") ||
             (ch >= "A" && ch <= "Z") ||
             (ch >= "0" && ch <= "9") ||
             ch === "_";
  }

  function Lexer() {
  }
  Lexer.prototype = {
      tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
              if (isAlpha(stream[this._current])) {
                  start = this._current;
                  identifier = this._consumeUnquotedIdentifier(stream);
                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (basicTokens[stream[this._current]] !== undefined) {
                  tokens.push({type: basicTokens[stream[this._current]],
                              value: stream[this._current],
                              start: this._current});
                  this._current++;
              } else if (isNum(stream[this._current])) {
                  token = this._consumeNumber(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "[") {
                  // No need to increment this._current.  This happens
                  // in _consumeLBracket
                  token = this._consumeLBracket(stream);
                  tokens.push(token);
              } else if (stream[this._current] === "\"") {
                  start = this._current;
                  identifier = this._consumeQuotedIdentifier(stream);
                  tokens.push({type: TOK_QUOTEDIDENTIFIER,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "'") {
                  start = this._current;
                  identifier = this._consumeRawStringLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: identifier,
                               start: start});
              } else if (stream[this._current] === "`") {
                  start = this._current;
                  var literal = this._consumeLiteral(stream);
                  tokens.push({type: TOK_LITERAL,
                               value: literal,
                               start: start});
              } else if (operatorStartToken[stream[this._current]] !== undefined) {
                  tokens.push(this._consumeOperator(stream));
              } else if (skipChars[stream[this._current]] !== undefined) {
                  // Ignore whitespace.
                  this._current++;
              } else if (stream[this._current] === "&") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({type: TOK_AND, value: "&&", start: start});
                  } else {
                      tokens.push({type: TOK_EXPREF, value: "&", start: start});
                  }
              } else if (stream[this._current] === "|") {
                  start = this._current;
                  this._current++;
                  if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({type: TOK_OR, value: "||", start: start});
                  } else {
                      tokens.push({type: TOK_PIPE, value: "|", start: start});
                  }
              } else {
                  var error = new Error("Unknown character:" + stream[this._current]);
                  error.name = "LexerError";
                  throw error;
              }
          }
          return tokens;
      },

      _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
              this._current++;
          }
          return stream.slice(start, this._current);
      },

      _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "\"" && this._current < maxLength) {
              // You can escape a double quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "\"")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
      },

      _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
              // You can escape a single quote and you can escape an escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "'")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
      },

      _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
              this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return {type: TOK_NUMBER, value: value, start: start};
      },

      _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
              this._current++;
              return {type: TOK_FILTER, value: "[?", start: start};
          } else if (stream[this._current] === "]") {
              this._current++;
              return {type: TOK_FLATTEN, value: "[]", start: start};
          } else {
              return {type: TOK_LBRACKET, value: "[", start: start};
          }
      },

      _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_NE, value: "!=", start: start};
              } else {
                return {type: TOK_NOT, value: "!", start: start};
              }
          } else if (startingChar === "<") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_LTE, value: "<=", start: start};
              } else {
                  return {type: TOK_LT, value: "<", start: start};
              }
          } else if (startingChar === ">") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_GTE, value: ">=", start: start};
              } else {
                  return {type: TOK_GT, value: ">", start: start};
              }
          } else if (startingChar === "=") {
              if (stream[this._current] === "=") {
                  this._current++;
                  return {type: TOK_EQ, value: "==", start: start};
              }
          }
      },

      _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while(stream[this._current] !== "`" && this._current < maxLength) {
              // You can escape a literal char or you can escape the escape.
              var current = this._current;
              if (stream[current] === "\\" && (stream[current + 1] === "\\" ||
                                               stream[current + 1] === "`")) {
                  current += 2;
              } else {
                  current++;
              }
              this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
              literal = JSON.parse(literalString);
          } else {
              // Try to JSON parse it as "<literal>"
              literal = JSON.parse("\"" + literalString + "\"");
          }
          // +1 gets us to the ending "`", +1 to move on to the next char.
          this._current++;
          return literal;
      },

      _looksLikeJSON: function(literalString) {
          var startingChars = "[{\"";
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";

          if (literalString === "") {
              return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
              return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
              return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
              try {
                  JSON.parse(literalString);
                  return true;
              } catch (ex) {
                  return false;
              }
          } else {
              return false;
          }
      }
  };

      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;

  function Parser() {
  }

  Parser.prototype = {
      parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
              var t = this._lookaheadToken(0);
              var error = new Error(
                  "Unexpected token type: " + t.type + ", value: " + t.value);
              error.name = "ParserError";
              throw error;
          }
          return ast;
      },

      _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({type: TOK_EOF, value: "", start: expression.length});
          this.tokens = tokens;
      },

      expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
              this._advance();
              left = this.led(currentToken, left);
              currentToken = this._lookahead(0);
          }
          return left;
      },

      _lookahead: function(number) {
          return this.tokens[this.index + number].type;
      },

      _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
      },

      _advance: function() {
          this.index++;
      },

      nud: function(token) {
        var left;
        var right;
        var expression;
        switch (token.type) {
          case TOK_LITERAL:
            return {type: "Literal", value: token.value};
          case TOK_UNQUOTEDIDENTIFIER:
            return {type: "Field", name: token.value};
          case TOK_QUOTEDIDENTIFIER:
            var node = {type: "Field", name: token.value};
            if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
            }
            return node;
          case TOK_NOT:
            right = this.expression(bindingPower.Not);
            return {type: "NotExpression", children: [right]};
          case TOK_STAR:
            left = {type: "Identity"};
            right = null;
            if (this._lookahead(0) === TOK_RBRACKET) {
                // This can happen in a multiselect,
                // [a, b, *]
                right = {type: "Identity"};
            } else {
                right = this._parseProjectionRHS(bindingPower.Star);
            }
            return {type: "ValueProjection", children: [left, right]};
          case TOK_FILTER:
            return this.led(token.type, {type: "Identity"});
          case TOK_LBRACE:
            return this._parseMultiselectHash();
          case TOK_FLATTEN:
            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};
            right = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [left, right]};
          case TOK_LBRACKET:
            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({type: "Identity"}, right);
            } else if (this._lookahead(0) === TOK_STAR &&
                       this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {type: "Projection",
                        children: [{type: "Identity"}, right]};
            }
            return this._parseMultiselectList();
          case TOK_CURRENT:
            return {type: TOK_CURRENT};
          case TOK_EXPREF:
            expression = this.expression(bindingPower.Expref);
            return {type: "ExpressionReference", children: [expression]};
          case TOK_LPAREN:
            var args = [];
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            return args[0];
          default:
            this._errorToken(token);
        }
      },

      led: function(tokenName, left) {
        var right;
        switch(tokenName) {
          case TOK_DOT:
            var rbp = bindingPower.Dot;
            if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return {type: "Subexpression", children: [left, right]};
            }
            // Creating a projection.
            this._advance();
            right = this._parseProjectionRHS(rbp);
            return {type: "ValueProjection", children: [left, right]};
          case TOK_PIPE:
            right = this.expression(bindingPower.Pipe);
            return {type: TOK_PIPE, children: [left, right]};
          case TOK_OR:
            right = this.expression(bindingPower.Or);
            return {type: "OrExpression", children: [left, right]};
          case TOK_AND:
            right = this.expression(bindingPower.And);
            return {type: "AndExpression", children: [left, right]};
          case TOK_LPAREN:
            var name = left.name;
            var args = [];
            var expression, node;
            while (this._lookahead(0) !== TOK_RPAREN) {
              if (this._lookahead(0) === TOK_CURRENT) {
                expression = {type: TOK_CURRENT};
                this._advance();
              } else {
                expression = this.expression(0);
              }
              if (this._lookahead(0) === TOK_COMMA) {
                this._match(TOK_COMMA);
              }
              args.push(expression);
            }
            this._match(TOK_RPAREN);
            node = {type: "Function", name: name, children: args};
            return node;
          case TOK_FILTER:
            var condition = this.expression(0);
            this._match(TOK_RBRACKET);
            if (this._lookahead(0) === TOK_FLATTEN) {
              right = {type: "Identity"};
            } else {
              right = this._parseProjectionRHS(bindingPower.Filter);
            }
            return {type: "FilterProjection", children: [left, right, condition]};
          case TOK_FLATTEN:
            var leftNode = {type: TOK_FLATTEN, children: [left]};
            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
            return {type: "Projection", children: [leftNode, rightNode]};
          case TOK_EQ:
          case TOK_NE:
          case TOK_GT:
          case TOK_GTE:
          case TOK_LT:
          case TOK_LTE:
            return this._parseComparator(left, tokenName);
          case TOK_LBRACKET:
            var token = this._lookaheadToken(0);
            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
            }
            this._match(TOK_STAR);
            this._match(TOK_RBRACKET);
            right = this._parseProjectionRHS(bindingPower.Star);
            return {type: "Projection", children: [left, right]};
          default:
            this._errorToken(this._lookaheadToken(0));
        }
      },

      _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
              this._advance();
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Expected " + tokenType + ", got: " + t.type);
              error.name = "ParserError";
              throw error;
          }
      },

      _errorToken: function(token) {
          var error = new Error("Invalid token (" +
                                token.type + "): \"" +
                                token.value + "\"");
          error.name = "ParserError";
          throw error;
      },


      _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
              return this._parseSliceExpression();
          } else {
              var node = {
                  type: "Index",
                  value: this._lookaheadToken(0).value};
              this._advance();
              this._match(TOK_RBRACKET);
              return node;
          }
      },

      _projectIfSlice: function(left, right) {
          var indexExpr = {type: "IndexExpression", children: [left, right]};
          if (right.type === "Slice") {
              return {
                  type: "Projection",
                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
              };
          } else {
              return indexExpr;
          }
      },

      _parseSliceExpression: function() {
          // [start:end:step] where each part is optional, as well as the last
          // colon.
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
              if (currentToken === TOK_COLON) {
                  index++;
                  this._advance();
              } else if (currentToken === TOK_NUMBER) {
                  parts[index] = this._lookaheadToken(0).value;
                  this._advance();
              } else {
                  var t = this._lookahead(0);
                  var error = new Error("Syntax error, unexpected token: " +
                                        t.value + "(" + t.type + ")");
                  error.name = "Parsererror";
                  throw error;
              }
              currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
              type: "Slice",
              children: parts
          };
      },

      _parseComparator: function(left, comparator) {
        var right = this.expression(bindingPower[comparator]);
        return {type: "Comparator", name: comparator, children: [left, right]};
      },

      _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
              return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
              this._match(TOK_LBRACKET);
              return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
              this._match(TOK_LBRACE);
              return this._parseMultiselectHash();
          }
      },

      _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
              right = {type: "Identity"};
          } else if (this._lookahead(0) === TOK_LBRACKET) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
              right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
              this._match(TOK_DOT);
              right = this._parseDotRHS(rbp);
          } else {
              var t = this._lookaheadToken(0);
              var error = new Error("Sytanx error, unexpected token: " +
                                    t.value + "(" + t.type + ")");
              error.name = "ParserError";
              throw error;
          }
          return right;
      },

      _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
              var expression = this.expression(0);
              expressions.push(expression);
              if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                  if (this._lookahead(0) === TOK_RBRACKET) {
                    throw new Error("Unexpected token Rbracket");
                  }
              }
          }
          this._match(TOK_RBRACKET);
          return {type: "MultiSelectList", children: expressions};
      },

      _parseMultiselectHash: function() {
        var pairs = [];
        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
        var keyToken, keyName, value, node;
        for (;;) {
          keyToken = this._lookaheadToken(0);
          if (identifierTypes.indexOf(keyToken.type) < 0) {
            throw new Error("Expecting an identifier token, got: " +
                            keyToken.type);
          }
          keyName = keyToken.value;
          this._advance();
          this._match(TOK_COLON);
          value = this.expression(0);
          node = {type: "KeyValuePair", name: keyName, value: value};
          pairs.push(node);
          if (this._lookahead(0) === TOK_COMMA) {
            this._match(TOK_COMMA);
          } else if (this._lookahead(0) === TOK_RBRACE) {
            this._match(TOK_RBRACE);
            break;
          }
        }
        return {type: "MultiSelectHash", children: pairs};
      }
  };


  function TreeInterpreter(runtime) {
    this.runtime = runtime;
  }

  TreeInterpreter.prototype = {
      search: function(node, value) {
          return this.visit(node, value);
      },

      visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject(value)) {
                  field = value[node.name];
                  if (field === undefined) {
                      return null;
                  } else {
                      return field;
                  }
              }
              return null;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                  result = this.visit(node.children[1], result);
                  if (result === null) {
                      return null;
                  }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === undefined) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                  for (i = start; i < stop; i += step) {
                      result.push(value[i]);
                  }
              } else {
                  for (i = start; i > stop; i += step) {
                      result.push(value[i]);
                  }
              }
              return result;
            case "Projection":
              // Evaluate left child.
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              // Evaluate left child.
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch(node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                  collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                  matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);

              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                  resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              // Tag the node with a specific attribute so the type
              // checker verify the type.
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
      },

      computeSliceParams: function(arrayLength, sliceParams) {
        var start = sliceParams[0];
        var stop = sliceParams[1];
        var step = sliceParams[2];
        var computed = [null, null, null];
        if (step === null) {
          step = 1;
        } else if (step === 0) {
          var error = new Error("Invalid slice, step cannot be 0");
          error.name = "RuntimeError";
          throw error;
        }
        var stepValueNegative = step < 0 ? true : false;

        if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
        } else {
            start = this.capSliceRange(arrayLength, start, step);
        }

        if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
        } else {
            stop = this.capSliceRange(arrayLength, stop, step);
        }
        computed[0] = start;
        computed[1] = stop;
        computed[2] = step;
        return computed;
      },

      capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
              actualValue += arrayLength;
              if (actualValue < 0) {
                  actualValue = step < 0 ? -1 : 0;
              }
          } else if (actualValue >= arrayLength) {
              actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
      }

  };

  function Runtime(interpreter) {
    this._interpreter = interpreter;
    this.functionTable = {
        // name: [function, <signature>]
        // The <signature> can be:
        //
        // {
        //   args: [[type1, type2], [type1, type2]],
        //   variadic: true|false
        // }
        //
        // Each arg in the arg list is a list of valid types
        // (if the function is overloaded and supports multiple
        // types.  If the type is "any" then no type checking
        // occurs on the argument.  Variadic is optional
        // and if not provided is assumed to be false.
        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},
        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},
        contains: {
            _func: this._functionContains,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},
                        {types: [TYPE_ANY]}]},
        "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},
        length: {
            _func: this._functionLength,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},
        map: {
            _func: this._functionMap,
            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},
        max: {
            _func: this._functionMax,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "merge": {
            _func: this._functionMerge,
            _signature: [{types: [TYPE_OBJECT], variadic: true}]
        },
        "max_by": {
          _func: this._functionMaxBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},
        "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},
        min: {
            _func: this._functionMin,
            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},
        "min_by": {
          _func: this._functionMinBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},
        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},
        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},
        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},
        "sort_by": {
          _func: this._functionSortBy,
          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]
        },
        join: {
            _func: this._functionJoin,
            _signature: [
                {types: [TYPE_STRING]},
                {types: [TYPE_ARRAY_STRING]}
            ]
        },
        reverse: {
            _func: this._functionReverse,
            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},
        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},
        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},
        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},
        "not_null": {
            _func: this._functionNotNull,
            _signature: [{types: [TYPE_ANY], variadic: true}]
        }
    };
  }

  Runtime.prototype = {
    callFunction: function(name, resolvedArgs) {
      var functionEntry = this.functionTable[name];
      if (functionEntry === undefined) {
          throw new Error("Unknown function: " + name + "()");
      }
      this._validateArgs(name, resolvedArgs, functionEntry._signature);
      return functionEntry._func.call(this, resolvedArgs);
    },

    _validateArgs: function(name, args, signature) {
        // Validating the args requires validating
        // the correct arity and the correct type of each arg.
        // If the last argument is declared as variadic, then we need
        // a minimum number of args to be required.  Otherwise it has to
        // be an exact amount.
        var pluralized;
        if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
                pluralized = signature.length === 1 ? " argument" : " arguments";
                throw new Error("ArgumentError: " + name + "() " +
                                "takes at least" + signature.length + pluralized +
                                " but received " + args.length);
            }
        } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() " +
                            "takes " + signature.length + pluralized +
                            " but received " + args.length);
        }
        var currentSpec;
        var actualType;
        var typeMatched;
        for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
                if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                    typeMatched = true;
                    break;
                }
            }
            if (!typeMatched) {
                var expected = currentSpec
                    .map(function(typeIdentifier) {
                        return TYPE_NAME_TABLE[typeIdentifier];
                    })
                    .join(',');
                throw new Error("TypeError: " + name + "() " +
                                "expected argument " + (i + 1) +
                                " to be type " + expected +
                                " but received type " +
                                TYPE_NAME_TABLE[actualType] + " instead.");
            }
        }
    },

    _typeMatches: function(actual, expected, argValue) {
        if (expected === TYPE_ANY) {
            return true;
        }
        if (expected === TYPE_ARRAY_STRING ||
            expected === TYPE_ARRAY_NUMBER ||
            expected === TYPE_ARRAY) {
            // The expected type can either just be array,
            // or it can require a specific subtype (array of numbers).
            //
            // The simplest case is if "array" with no subtype is specified.
            if (expected === TYPE_ARRAY) {
                return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
                // Otherwise we need to check subtypes.
                // I think this has potential to be improved.
                var subtype;
                if (expected === TYPE_ARRAY_NUMBER) {
                  subtype = TYPE_NUMBER;
                } else if (expected === TYPE_ARRAY_STRING) {
                  subtype = TYPE_STRING;
                }
                for (var i = 0; i < argValue.length; i++) {
                    if (!this._typeMatches(
                            this._getTypeName(argValue[i]), subtype,
                                             argValue[i])) {
                        return false;
                    }
                }
                return true;
            }
        } else {
            return actual === expected;
        }
    },
    _getTypeName: function(obj) {
        switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              // Check if it's an expref.  If it has, it's been
              // tagged with a jmespathType attr of 'Expref';
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
        }
    },

    _functionStartsWith: function(resolvedArgs) {
        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
    },

    _functionEndsWith: function(resolvedArgs) {
        var searchStr = resolvedArgs[0];
        var suffix = resolvedArgs[1];
        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
    },

    _functionReverse: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        if (typeName === TYPE_STRING) {
          var originalStr = resolvedArgs[0];
          var reversedStr = "";
          for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
          }
          return reversedStr;
        } else {
          var reversedArray = resolvedArgs[0].slice(0);
          reversedArray.reverse();
          return reversedArray;
        }
    },

    _functionAbs: function(resolvedArgs) {
      return Math.abs(resolvedArgs[0]);
    },

    _functionCeil: function(resolvedArgs) {
        return Math.ceil(resolvedArgs[0]);
    },

    _functionAvg: function(resolvedArgs) {
        var sum = 0;
        var inputArray = resolvedArgs[0];
        for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
        }
        return sum / inputArray.length;
    },

    _functionContains: function(resolvedArgs) {
        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
    },

    _functionFloor: function(resolvedArgs) {
        return Math.floor(resolvedArgs[0]);
    },

    _functionLength: function(resolvedArgs) {
       if (!isObject(resolvedArgs[0])) {
         return resolvedArgs[0].length;
       } else {
         // As far as I can tell, there's no way to get the length
         // of an object without O(n) iteration through the object.
         return Object.keys(resolvedArgs[0]).length;
       }
    },

    _functionMap: function(resolvedArgs) {
      var mapped = [];
      var interpreter = this._interpreter;
      var exprefNode = resolvedArgs[0];
      var elements = resolvedArgs[1];
      for (var i = 0; i < elements.length; i++) {
          mapped.push(interpreter.visit(exprefNode, elements[i]));
      }
      return mapped;
    },

    _functionMerge: function(resolvedArgs) {
      var merged = {};
      for (var i = 0; i < resolvedArgs.length; i++) {
        var current = resolvedArgs[i];
        for (var key in current) {
          merged[key] = current[key];
        }
      }
      return merged;
    },

    _functionMax: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.max.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var maxElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
              }
          }
          return maxElement;
        }
      } else {
          return null;
      }
    },

    _functionMin: function(resolvedArgs) {
      if (resolvedArgs[0].length > 0) {
        var typeName = this._getTypeName(resolvedArgs[0][0]);
        if (typeName === TYPE_NUMBER) {
          return Math.min.apply(Math, resolvedArgs[0]);
        } else {
          var elements = resolvedArgs[0];
          var minElement = elements[0];
          for (var i = 1; i < elements.length; i++) {
              if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
              }
          }
          return minElement;
        }
      } else {
        return null;
      }
    },

    _functionSum: function(resolvedArgs) {
      var sum = 0;
      var listToSum = resolvedArgs[0];
      for (var i = 0; i < listToSum.length; i++) {
        sum += listToSum[i];
      }
      return sum;
    },

    _functionType: function(resolvedArgs) {
        switch (this._getTypeName(resolvedArgs[0])) {
          case TYPE_NUMBER:
            return "number";
          case TYPE_STRING:
            return "string";
          case TYPE_ARRAY:
            return "array";
          case TYPE_OBJECT:
            return "object";
          case TYPE_BOOLEAN:
            return "boolean";
          case TYPE_EXPREF:
            return "expref";
          case TYPE_NULL:
            return "null";
        }
    },

    _functionKeys: function(resolvedArgs) {
        return Object.keys(resolvedArgs[0]);
    },

    _functionValues: function(resolvedArgs) {
        var obj = resolvedArgs[0];
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
        }
        return values;
    },

    _functionJoin: function(resolvedArgs) {
        var joinChar = resolvedArgs[0];
        var listJoin = resolvedArgs[1];
        return listJoin.join(joinChar);
    },

    _functionToArray: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
        } else {
            return [resolvedArgs[0]];
        }
    },

    _functionToString: function(resolvedArgs) {
        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
        } else {
            return JSON.stringify(resolvedArgs[0]);
        }
    },

    _functionToNumber: function(resolvedArgs) {
        var typeName = this._getTypeName(resolvedArgs[0]);
        var convertedValue;
        if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
        } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
                return convertedValue;
            }
        }
        return null;
    },

    _functionNotNull: function(resolvedArgs) {
        for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                return resolvedArgs[i];
            }
        }
        return null;
    },

    _functionSort: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        sortedArray.sort();
        return sortedArray;
    },

    _functionSortBy: function(resolvedArgs) {
        var sortedArray = resolvedArgs[0].slice(0);
        if (sortedArray.length === 0) {
            return sortedArray;
        }
        var interpreter = this._interpreter;
        var exprefNode = resolvedArgs[1];
        var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0]));
        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
        }
        var that = this;
        // In order to get a stable sort out of an unstable
        // sort algorithm, we decorate/sort/undecorate (DSU)
        // by creating a new list of [index, element] pairs.
        // In the cmp function, if the evaluated elements are
        // equal, then the index will be used as the tiebreaker.
        // After the decorated list has been sorted, it will be
        // undecorated to extract the original elements.
        var decorated = [];
        for (var i = 0; i < sortedArray.length; i++) {
          decorated.push([i, sortedArray[i]]);
        }
        decorated.sort(function(a, b) {
          var exprA = interpreter.visit(exprefNode, a[1]);
          var exprB = interpreter.visit(exprefNode, b[1]);
          if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprA));
          } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                  "TypeError: expected " + requiredType + ", received " +
                  that._getTypeName(exprB));
          }
          if (exprA > exprB) {
            return 1;
          } else if (exprA < exprB) {
            return -1;
          } else {
            // If they're equal compare the items by their
            // order to maintain relative order of equal keys
            // (i.e. to get a stable sort).
            return a[0] - b[0];
          }
        });
        // Undecorate: extract out the original list elements.
        for (var j = 0; j < decorated.length; j++) {
          sortedArray[j] = decorated[j][1];
        }
        return sortedArray;
    },

    _functionMaxBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var maxNumber = -Infinity;
      var maxRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current > maxNumber) {
          maxNumber = current;
          maxRecord = resolvedArray[i];
        }
      }
      return maxRecord;
    },

    _functionMinBy: function(resolvedArgs) {
      var exprefNode = resolvedArgs[1];
      var resolvedArray = resolvedArgs[0];
      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
      var minNumber = Infinity;
      var minRecord;
      var current;
      for (var i = 0; i < resolvedArray.length; i++) {
        current = keyFunction(resolvedArray[i]);
        if (current < minNumber) {
          minNumber = current;
          minRecord = resolvedArray[i];
        }
      }
      return minRecord;
    },

    createKeyFunction: function(exprefNode, allowedTypes) {
      var that = this;
      var interpreter = this._interpreter;
      var keyFunc = function(x) {
        var current = interpreter.visit(exprefNode, x);
        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
          var msg = "TypeError: expected one of " + allowedTypes +
                    ", received " + that._getTypeName(current);
          throw new Error(msg);
        }
        return current;
      };
      return keyFunc;
    }

  };

  function compile(stream) {
    var parser = new Parser();
    var ast = parser.parse(stream);
    return ast;
  }

  function tokenize(stream) {
      var lexer = new Lexer();
      return lexer.tokenize(stream);
  }

  function search(data, expression) {
      var parser = new Parser();
      // This needs to be improved.  Both the interpreter and runtime depend on
      // each other.  The runtime needs the interpreter to support exprefs.
      // There's likely a clean way to avoid the cyclic dependency.
      var runtime = new Runtime();
      var interpreter = new TreeInterpreter(runtime);
      runtime._interpreter = interpreter;
      var node = parser.parse(expression);
      return interpreter.search(node, data);
  }

  exports.tokenize = tokenize;
  exports.compile = compile;
  exports.search = search;
  exports.strictDeepEqual = strictDeepEqual;
})(typeof exports === "undefined" ? this.jmespath = {} : exports);

},{}],97:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],98:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],99:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],100:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],101:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":99,"./encode":100}],102:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

},{}],103:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

},{}],104:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"./decode":102,"./encode":103,"dup":101}],105:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":97,"timers":105}],106:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":98,"querystring":101}],107:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],108:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],109:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":108,"_process":97,"inherits":107}],110:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
}

var _default = bytesToUuid;
exports.default = _default;
},{}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./v1.js":115,"./v3.js":116,"./v4.js":118,"./v5.js":119}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes == 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Array(msg.length);

    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var i;
  var x;
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';
  var hex;

  for (i = 0; i < length32; i += 8) {
    x = input[i >> 5] >>> i % 32 & 0xff;
    hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;
  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = undefined;

  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }

  var length8 = input.length * 8;

  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);
var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

function rng() {
  if (!getRandomValues) {
    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
  }

  return getRandomValues(rnds8);
}
},{}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes == 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Array(msg.length);

    for (var i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var i = 0; i < N; i++) {
    M[i] = new Array(16);

    for (var j = 0; j < 16; j++) {
      M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var i = 0; i < N; i++) {
    var W = new Array(80);

    for (var t = 0; t < 16; t++) W[t] = M[i][t];

    for (var t = 16; t < 80; t++) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var t = 0; t < 80; t++) {
      var s = Math.floor(t / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : (0, _bytesToUuid.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./bytesToUuid.js":110,"./rng.js":113}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":112,"./v35.js":117}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function uuidToBytes(uuid) {
  // Note: We assume we're being passed a valid uuid string
  var bytes = [];
  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {
    bytes.push(parseInt(hex, 16));
  });
  return bytes;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = new Array(str.length);

  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  var generateUUID = function (value, namespace, buf, offset) {
    var off = buf && offset || 0;
    if (typeof value == 'string') value = stringToBytes(value);
    if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
    if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
    if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values'); // Per 4.3

    var bytes = hashfunc(namespace.concat(value));
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      for (var idx = 0; idx < 16; ++idx) {
        buf[off + idx] = bytes[idx];
      }
    }

    return buf || (0, _bytesToUuid.default)(bytes);
  }; // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name;
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./bytesToUuid.js":110}],118:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _bytesToUuid = _interopRequireDefault(require("./bytesToUuid.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof options == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }

  options = options || {};

  var rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || (0, _bytesToUuid.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./bytesToUuid.js":110,"./rng.js":113}],119:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":114,"./v35.js":117}],120:[function(require,module,exports){
"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var AWS = __importStar(require("aws-sdk/global"));
var console_wrapper_1 = require("./../utils/console_wrapper");
console_wrapper_1.log('cognito loaded.', 2 /* BASIC */);
var CredentialsProvider = /** @class */ (function () {
    function CredentialsProvider(identityPoolId, region) {
        this.region = region;
        AWS.config.region = region;
        this.creds = new AWS.CognitoIdentityCredentials({
            IdentityPoolId: identityPoolId,
        });
        this.creds.get(function (error) {
            error
                ? console_wrapper_1.log(error.message, 3 /* DETAILED */)
                : console_wrapper_1.log('No error was reported.', 3 /* DETAILED */);
        });
        AWS.config.credentials = this.creds;
    }
    CredentialsProvider.get = function (identityPoolId, region) {
        if (identityPoolId === void 0) { identityPoolId = CredentialsProvider.ipID; }
        if (region === void 0) { region = CredentialsProvider.region; }
        return new CredentialsProvider(identityPoolId, region);
    };
    Object.defineProperty(CredentialsProvider.prototype, "credentials", {
        get: function () {
            return this.creds;
        },
        enumerable: true,
        configurable: true
    });
    CredentialsProvider.ipID = 'us-east-2:94f763ec-3864-4e89-810d-6d2ba70172ba';
    CredentialsProvider.region = 'us-east-2';
    return CredentialsProvider;
}());
exports.CredentialsProvider = CredentialsProvider;

},{"./../utils/console_wrapper":137,"aws-sdk/global":9}],121:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var cognito_1 = require("./cognito");
var s3_1 = require("./s3");
console_wrapper_1.log('mturk loaded.', 2 /* BASIC */);
var MturkClient = /** @class */ (function () {
    function MturkClient() {
    }
    MturkClient.init = function (bucketName, keyPrefix) {
        MturkClient.s3 = s3_1.S3Client.get(bucketName, keyPrefix);
        Object.assign(window, {
            s3: MturkClient.s3,
            cog: MturkClient.cognito,
            sub: MturkClient.submit,
        });
    };
    MturkClient.submit = function (name, data) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, console_wrapper_1.error(function () { return __awaiter(_this, void 0, void 0, function () {
                        var strData, ret;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    strData = JSON.stringify(data);
                                    console.log(strData);
                                    return [4 /*yield*/, MturkClient.s3.upload(name, strData)];
                                case 1:
                                    ret = _a.sent();
                                    ret = ret;
                                    return [2 /*return*/];
                            }
                        });
                    }); })];
            });
        });
    };
    MturkClient.keyGen = function (hitID, assignmentID) {
        return hitID + "_" + assignmentID + "_log.json";
    };
    MturkClient.updateCognito = function (cp) {
        MturkClient.cognito = cp;
    };
    MturkClient.updateS3 = function (s3) {
        MturkClient.s3 = s3;
    };
    // TODO: Change these back to private after debugging.
    MturkClient.cognito = cognito_1.CredentialsProvider.get();
    return MturkClient;
}());
exports.MturkClient = MturkClient;

},{"../utils/console_wrapper":137,"./cognito":120,"./s3":122}],122:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var s3_1 = __importDefault(require("aws-sdk/clients/s3"));
var console_wrapper_1 = require("../utils/console_wrapper");
console_wrapper_1.log('s3 loaded.', 2 /* BASIC */);
var S3Client = /** @class */ (function () {
    function S3Client(bucketName, keyPrefix) {
        this.bucketName = bucketName;
        this.keyPrefix = keyPrefix;
        this.s3 = new s3_1.default({
            apiVersion: S3Client.apiVersion,
        });
    }
    S3Client.get = function (bucket, keyPrefix) {
        if (bucket === void 0) { bucket = S3Client.bucketName; }
        return new S3Client(bucket, keyPrefix);
    };
    Object.defineProperty(S3Client.prototype, "bucket", {
        get: function () {
            return this.bucketName;
        },
        enumerable: true,
        configurable: true
    });
    S3Client.prototype.upload = function (name, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.s3.putObject({
                Key: _this.keyPrefix + '/' + name,
                Body: data,
                Bucket: _this.bucket,
            }, function (err, success) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(success);
                }
            });
        });
    };
    S3Client.bucketName = '';
    S3Client.apiVersion = '2006-03-01';
    S3Client.keyPrefix = '';
    return S3Client;
}());
exports.S3Client = S3Client;

},{"../utils/console_wrapper":137,"aws-sdk/clients/s3":11}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
console.log('data loaded.');
var urlParams = new URLSearchParams(window.location.hash.split('?')[1]);
exports.urlData = {
    raw: urlParams.toString(),
    assignmentID: urlParams.get('assignmentId'),
    hitID: urlParams.get('hitId'),
    workerID: urlParams.get('workerId'),
    submitTo: urlParams.get('turkSubmitTo'),
};
var Data = /** @class */ (function () {
    function Data(rawMturkURLData) {
        this.logs = {};
        this.data = {};
        this.errors = [];
        this.urlData = rawMturkURLData;
    }
    Data.prototype.serialize = function () {
        return JSON.stringify(this);
    };
    return Data;
}());
exports.Data = Data;
exports.data = new Data(exports.urlData);
Object.assign(window, { data: exports.data });

},{}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("../utils/funcs");
console_wrapper_1.log("event loaded.", 2 /* BASIC */);
function objectToTrackerEvent(obj, action) {
    obj.action = action;
    obj.time = funcs_1.now();
}
exports.objectToTrackerEvent = objectToTrackerEvent;
function isTrackerEvent(obj) {
    return obj.action !== undefined && obj.time !== undefined;
}
exports.isTrackerEvent = isTrackerEvent;
var BaseTrackerEvent = /** @class */ (function () {
    function BaseTrackerEvent(action, eventInitDict) {
        this.custEv = new CustomEvent(action, eventInitDict);
        this.action = action;
        this.time = funcs_1.now();
    }
    Object.defineProperty(BaseTrackerEvent.prototype, "detail", {
        get: function () {
            return this.custEv.detail;
        },
        enumerable: true,
        configurable: true
    });
    return BaseTrackerEvent;
}());
exports.BaseTrackerEvent = BaseTrackerEvent;
// tslint:disable-next-line: max-classes-per-file
var ClickEvent = /** @class */ (function (_super) {
    __extends(ClickEvent, _super);
    function ClickEvent(x, y, id, eventInitDict) {
        var _this = _super.call(this, "click" /* CLICK */, eventInitDict) || this;
        _this.detail.x = x;
        _this.detail.y = y;
        _this.detail.id = id;
        return _this;
    }
    return ClickEvent;
}(BaseTrackerEvent));
exports.ClickEvent = ClickEvent;
// tslint:disable-next-line: max-classes-per-file
var ButtonEvent = /** @class */ (function (_super) {
    __extends(ButtonEvent, _super);
    function ButtonEvent(key, id, eventInitDict) {
        var _this = _super.call(this, "click" /* CLICK */, eventInitDict) || this;
        _this.detail.key = key;
        _this.detail.id = id;
        return _this;
    }
    return ButtonEvent;
}(BaseTrackerEvent));
exports.ButtonEvent = ButtonEvent;
// tslint:disable-next-line: max-classes-per-file
var HistoryEvent = /** @class */ (function (_super) {
    __extends(HistoryEvent, _super);
    function HistoryEvent(url, extra, eventInitDict) {
        var _this = _super.call(this, "history" /* HISTORY */, eventInitDict) || this;
        _this.detail.url = url;
        _this.detail.extra = extra;
        return _this;
    }
    return HistoryEvent;
}(BaseTrackerEvent));
exports.HistoryEvent = HistoryEvent;

},{"../utils/console_wrapper":137,"../utils/funcs":138}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var event_1 = require("./event");
console_wrapper_1.log("receiver loaded.", 2 /* BASIC */);
var EventReceiver = /** @class */ (function () {
    function EventReceiver() {
        this.map = new Map();
        this.emitter = new EventTarget();
    }
    EventReceiver.prototype.register = function (eventType, callback) {
        this.emitter.addEventListener(eventType, function (event) {
            var trackEv = event
                .detail;
            if (event_1.isTrackerEvent(trackEv) && callback) {
                callback(trackEv);
            }
        });
        if (callback) {
            this.map.set(eventType, callback);
        }
    };
    EventReceiver.prototype.doEvent = function (event) {
        var callback = this.map.get("" + event.action);
        if (callback) {
            callback(event);
        }
    };
    return EventReceiver;
}());
exports.EventReceiver = EventReceiver;

},{"../utils/console_wrapper":137,"./event":124}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var router_1 = require("../router/router");
var console_wrapper_1 = require("../utils/console_wrapper");
var history_1 = require("./../router/history");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log("banner loaded.", 2 /* BASIC */);
var TopBanner = /** @class */ (function () {
    function TopBanner() {
    }
    TopBanner.show = function () {
        TopBanner.showing = true;
        document_1.D.display(elements_1.Elements.ddUp, true);
        document_1.D.display(elements_1.Elements.ddDown, false);
        document_1.D.display(elements_1.Elements.ddContent, true);
    };
    TopBanner.hide = function () {
        TopBanner.showing = false;
        document_1.D.display(elements_1.Elements.ddDown, true);
        document_1.D.display(elements_1.Elements.ddUp, false);
        document_1.D.display(elements_1.Elements.ddContent, false);
    };
    TopBanner.doDisplayChange = function () {
        TopBanner.showing ? TopBanner.hide() : TopBanner.show();
    };
    TopBanner.setup = function () {
        document_1.D.addEventListener(elements_1.Elements.ddArrow, "click", TopBanner.doDisplayChange);
    };
    TopBanner.showing = true;
    return TopBanner;
}());
exports.TopBanner = TopBanner;
document_1.D.addEventListener("mturk-top-banner-back", "click", function (e) {
    if (history_1.History.canBackward()) {
        router_1.Router.loadWithPathPrefix(history_1.History.backward());
    }
    else {
        alert("There is no page history to go back for at this time!");
    }
});

},{"../router/router":135,"../utils/console_wrapper":137,"./../router/history":134,"./document":127,"./elements":128}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./../utils/console_wrapper");
console_wrapper_1.log("document loaded.", 2 /* BASIC */);
var D = /** @class */ (function () {
    function D() {
    }
    D.elem = function (elem) {
        if (typeof elem === "string") {
            return D.id(elem);
        }
        else {
            return elem;
        }
    };
    D.display = function (elem, show) {
        elem = D.elem(elem);
        if (show) {
            elem.classList.remove("none");
            elem.classList.add("display");
        }
        else {
            elem.classList.remove("display");
            elem.classList.add("none");
        }
    };
    D.id = function (id) {
        var element = D.doc.getElementById(id);
        if (element === null) {
            throw new Error("Element was not found, id: <" + id + ">.");
        }
        else {
            return element;
        }
    };
    D.claz = function (claz) {
        return D.doc.getElementsByClassName(claz);
    };
    D.tag = function (tag) {
        return D.doc.getElementsByTagName(tag);
    };
    D.image = function (id, url) {
        console_wrapper_1.error(function () { return D.id(id).setAttribute("src", url); });
    };
    D.addEventListener = function (elem, type, listener) {
        elem = this.elem(elem);
        var wrapperFunc = function (e) {
            try {
                listener(e);
            }
            catch (err) {
                console.error(err);
            }
        };
        elem.addEventListener(type, wrapperFunc);
        return wrapperFunc;
    };
    D.each = function (elem, apply) {
        elem = this.elem(elem);
        var children = elem.children;
        for (var i = 0; i < children.length; i++) {
            apply(children[i]);
        }
    };
    D.eachRecur = function (elem, apply) {
        elem = this.elem(elem);
        var children = elem.children;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            apply(child);
            D.eachRecur(child, apply);
        }
    };
    D.create = function (tagName, options) {
        return document.createElement(tagName, options);
    };
    D.doc = document;
    return D;
}());
exports.D = D;

},{"./../utils/console_wrapper":137}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var document_1 = require("./document");
console_wrapper_1.log('element loaded.', 2 /* BASIC */);
/**
 * These are elements that are in every single project. Even if they are not used they should
 * be place in the project and display should be set to none. This simplifies configuration
 * and some common functions and allows less null checks to be performed overall. If the
 * element does not exist at run time an empty div with that id is created and its display
 * is set to none then appended to the body.
 */
/**
 * Attempts to get an element, if unsuccessful, creates div with id and appends to body.
 *
 * @param id - the id of the element to retrieve.
 */
function makeElemIfNotExist(id) {
    var elem;
    try {
        elem = document_1.D.id(id);
    }
    catch (err) {
        elem = document_1.D.create('div');
        elem.id = id;
        elem.style.display = 'none';
        document.body.append(elem);
    }
    return elem;
}
/**
 * Commonly accessed elements, allows for clearer dom manip on these elements.
 */
exports.Elements = {
    document: document_1.D.doc.documentElement,
    wrapper: makeElemIfNotExist('wrapper'),
    htmlLoc: makeElemIfNotExist('html-loc'),
    innerBody: makeElemIfNotExist('inner-body'),
    ddDown: makeElemIfNotExist('mturk-top-banner-drop-down-button'),
    ddUp: makeElemIfNotExist('mturk-top-banner-collapse-button'),
    ddContent: makeElemIfNotExist('mturk-top-banner-drop-down-content'),
    backButton: makeElemIfNotExist('mturk-top-banner-back'),
    ddArrow: makeElemIfNotExist('mturk-top-banner-arrow'),
    mtTopBannerText: makeElemIfNotExist('mturk-top-banner-text'),
    mtScenarioContext: makeElemIfNotExist('scenario_context'),
    mtScenarioQuestion: makeElemIfNotExist('scenario_question'),
    logFileInput: makeElemIfNotExist('mturk-top-banner-drop-down-content-log-file-input'),
    submitForm: makeElemIfNotExist('mturk-submit-form'),
    modal: makeElemIfNotExist('modal'),
};

},{"../utils/console_wrapper":137,"./document":127}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var elements_1 = require("./../dom/elements");
console_wrapper_1.log('html loc loaded.', 2 /* BASIC */);
var AppEnum;
(function (AppEnum) {
    AppEnum["INFORMATION_FORAGING"] = "information-foraging";
    AppEnum["COGNITIVE_LOAD"] = "cognitive-load";
    AppEnum["GENDER_MAG"] = "gender-mag";
    AppEnum["ERROR"] = "error";
})(AppEnum = exports.AppEnum || (exports.AppEnum = {}));
var ModeEnum;
(function (ModeEnum) {
    ModeEnum["REAL"] = "real";
    ModeEnum["SANDBOX"] = "sandbox";
    ModeEnum["TEST"] = "test";
    ModeEnum["ERROR"] = "error";
})(ModeEnum = exports.ModeEnum || (exports.ModeEnum = {}));
var HTMLLoc = /** @class */ (function () {
    function HTMLLoc() {
    }
    HTMLLoc.setup = function () {
        HTMLLoc.app = HTMLLoc.elem.dataset.app || AppEnum.ERROR;
        HTMLLoc.mode =
            HTMLLoc.elem.dataset.mode || ModeEnum.ERROR;
        HTMLLoc.scenario = HTMLLoc.elem.dataset.scenario || 'error';
    };
    HTMLLoc.elem = elements_1.Elements.htmlLoc;
    return HTMLLoc;
}());
exports.HTMLLoc = HTMLLoc;

},{"../utils/console_wrapper":137,"./../dom/elements":128}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./../utils/console_wrapper");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log('modal loaded.', 2 /* BASIC */);
var Modal = /** @class */ (function () {
    function Modal() {
    }
    Modal.display = function (src) {
        Modal.elem.setAttribute('style', "left: " + Math.round(window.pageXOffset) + "px; top: " + Math.round(window.pageYOffset) + "px;");
        Modal.elem.classList.replace('hide-modal', 'show-modal');
        document_1.D.each(Modal.elem, function (node) {
            node.src = src;
        });
        document.body.classList.add('noscroll');
    };
    Modal.hide = function () {
        Modal.elem.classList.replace('show-modal', 'hide-modal');
        document_1.D.each(Modal.elem, function (node) {
            node.src = '';
        });
        document.body.classList.remove('noscroll');
    };
    Modal.elem = elements_1.Elements.modal;
    return Modal;
}());
exports.Modal = Modal;
document_1.D.addEventListener(Modal.elem, 'click', function (e) {
    Modal.hide();
});
document_1.D.each(Modal.elem, function (node) {
    document_1.D.addEventListener(node, 'click', function (e) {
        e.preventDefault();
    });
});

},{"./../utils/console_wrapper":137,"./document":127,"./elements":128}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("./../utils/funcs");
console_wrapper_1.log("scroll loaded.", 2 /* BASIC */);
/**
 * Linear implementation of scrolling.
 * Follows the singleton pattern, call do to start a scroll operation.
 *
 * If a scroll is called when another scroll has already begun an
 * error will be thrown, but the first scroll will continue until completion.
 */
var Scroll = /** @class */ (function () {
    function Scroll(endPos, duration, complete) {
        this.endPos = endPos;
        this.duration = duration;
        this.complete = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            document.dispatchEvent(new CustomEvent("scroll"));
            complete(args);
        };
    }
    Scroll.callback = function (endPos, duration, complete) {
        if (duration === void 0) { duration = 200; }
        if (complete === void 0) { complete = funcs_1.noop; }
        if (Scroll.running) {
            throw new Error("Cannot make multiple calls to scroll at the same time.");
        }
        Scroll.running = true;
        var oldComplete = complete;
        complete = function () {
            Scroll.running = false;
            console_wrapper_1.error(oldComplete);
        };
        this.instance.update(endPos, duration, complete).attemptScroll();
    };
    Scroll.promise = function (endPos, duration) {
        var _this = this;
        if (duration === void 0) { duration = 200; }
        if (Scroll.running) {
            throw new Error("Cannot make multiple calls to scroll at the same time.");
        }
        Scroll.running = true;
        return new Promise(function (resolve, reject) {
            try {
                var runResolver = function () {
                    Scroll.running = false;
                    resolve();
                };
                _this.instance.update(endPos, duration, runResolver).attemptScroll();
            }
            catch (err) {
                Scroll.running = false;
                reject(err);
            }
        });
    };
    Object.defineProperty(Scroll, "isRunning", {
        get: function () {
            return Scroll.running;
        },
        enumerable: true,
        configurable: true
    });
    Scroll.prototype.update = function (endPos, duration, complete) {
        this.endPos = endPos;
        this.duration = duration;
        this.complete = complete;
        return this;
    };
    Scroll.prototype.calcScrollAmount = function () {
        var curTime = funcs_1.now();
        var steps = Math.max(1, (this.duration - curTime) / Scroll.STEP_IN_MS);
        var curPos = window.pageYOffset;
        return Math.ceil((this.endPos - curPos) / steps);
    };
    Scroll.prototype.scroll = function () {
        window.scroll(0, this.calcScrollAmount());
        if (window.pageYOffset === this.endPos) {
            this.complete();
        }
        else {
            requestAnimationFrame(this.scroll);
        }
    };
    Scroll.prototype.attemptScroll = function () {
        if ("requestAnimationFrame" in window === false) {
            window.scroll(0, this.endPos);
        }
        this.scroll();
    };
    Scroll.STEP_IN_MS = 17;
    Scroll.running = false;
    Scroll.instance = new Scroll(0, 0, funcs_1.noop);
    return Scroll;
}());
exports.Scroll = Scroll;

},{"../utils/console_wrapper":137,"./../utils/funcs":138}],132:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var funcs_1 = require("../utils/funcs");
var mturk_1 = require("./../aws/mturk");
var data_1 = require("./../data-log/data");
var console_wrapper_1 = require("./../utils/console_wrapper");
var document_1 = require("./document");
var elements_1 = require("./elements");
console_wrapper_1.log('submit form loaded.', 2 /* BASIC */);
var AllowSubmissionDefault = {
    allow: function () { return null; },
    preSubmit: funcs_1.noop,
};
var SubmitForm = /** @class */ (function () {
    function SubmitForm() {
    }
    SubmitForm.setup = function (allowSubmission) {
        var _this = this;
        if (allowSubmission === void 0) { allowSubmission = AllowSubmissionDefault; }
        if (data_1.data.urlData.assignmentID !== null) {
            document_1.D.id('assignment-id').value =
                data_1.data.urlData.assignmentID;
        }
        if (data_1.data.urlData.hitID !== null) {
            document_1.D.id('hit-id').value = data_1.data.urlData.hitID;
        }
        SubmitForm.submitFunc = function (event) { return __awaiter(_this, void 0, void 0, function () {
            var allowed, hitID, assignmnetID;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        event.preventDefault();
                        allowed = allowSubmission.allow();
                        if (!(allowed === null)) return [3 /*break*/, 2];
                        allowSubmission.preSubmit();
                        hitID = data_1.data.urlData.hitID;
                        if (hitID === null) {
                            hitID = 'hitid' + Math.round(Math.random() * 100000);
                        }
                        assignmnetID = data_1.data.urlData.assignmentID;
                        if (assignmnetID === null) {
                            assignmnetID =
                                'assignmnetid' + Math.round(Math.random() * 100000);
                        }
                        return [4 /*yield*/, mturk_1.MturkClient.submit(mturk_1.MturkClient.keyGen(hitID, assignmnetID), data_1.data)];
                    case 1:
                        _a.sent();
                        console.log('hello');
                        SubmitForm.elem.removeEventListener('submit', SubmitForm.submitFunc);
                        SubmitForm.elem.submit();
                        return [3 /*break*/, 3];
                    case 2:
                        alert(allowed);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        }); };
        SubmitForm.elem.addEventListener('submit', SubmitForm.submitFunc);
    };
    SubmitForm.elem = elements_1.Elements.submitForm;
    SubmitForm.allowSubmitDefault = { allow: function () { return true; }, preSubmit: funcs_1.noop };
    return SubmitForm;
}());
exports.SubmitForm = SubmitForm;

},{"../utils/funcs":138,"./../aws/mturk":121,"./../data-log/data":123,"./../utils/console_wrapper":137,"./document":127,"./elements":128}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var banner_1 = require("./banner");
var html_loc_1 = require("./html_loc");
var TrackerElements = /** @class */ (function () {
    function TrackerElements() {
    }
    TrackerElements.setupTrackerElements = function () {
        // setup dom elements
        banner_1.TopBanner.setup();
        html_loc_1.HTMLLoc.setup();
    };
    return TrackerElements;
}());
exports.TrackerElements = TrackerElements;

},{"./banner":126,"./html_loc":129}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tracker_1 = require("./../tracker/tracker");
function newHistoryEntry(currURL, hasPrevURL, prevEntry, extra) {
    tracker_1.Tracker.getEventDispatchFunc('history')({ url: currURL, extra: extra });
    return {
        currURL: currURL,
        hasPrevURL: hasPrevURL,
        prevEntry: prevEntry,
        extra: extra,
        nextEntries: [],
    };
}
var History = /** @class */ (function () {
    function History() {
    }
    History.forward = function (url, extra) {
        var histEnt = newHistoryEntry(url, true, History.currhistory, extra);
        History.currhistory.nextEntries.push(histEnt);
        History.currhistory = histEnt;
        return url;
    };
    History.canBackward = function () {
        var _a, _b;
        return (History.currhistory.hasPrevURL &&
            !((_b = (_a = History.currhistory.prevEntry) === null || _a === void 0 ? void 0 : _a.extra) === null || _b === void 0 ? void 0 : _b.wrapper));
    };
    History.backward = function () {
        if (!History.canBackward()) {
            throw new Error('Cannot go back any further.');
        }
        console.log(History.currhistory.prevEntry);
        var prevEntry = History.currhistory.prevEntry;
        var nextURL = prevEntry.currURL;
        var histEnt = newHistoryEntry(nextURL, prevEntry.hasPrevURL, prevEntry.prevEntry, { back: true });
        History.currhistory = histEnt;
        return nextURL;
    };
    History.setup = function (url, extra) {
        History.firstHistory = newHistoryEntry(url, false, undefined, extra);
        History.currhistory = History.firstHistory;
    };
    return History;
}());
exports.History = History;
window.h = History;

},{"./../tracker/tracker":136}],135:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("../dom/document");
var elements_1 = require("../dom/elements");
var modal_1 = require("../dom/modal");
var console_wrapper_1 = require("../utils/console_wrapper");
var funcs_1 = require("../utils/funcs");
var html_loader_1 = require("../utils/html_loader");
var history_1 = require("./history");
console_wrapper_1.log('router loaded.', 2 /* BASIC */);
function testOn(elem, config) {
    return (elem.tagName === config.module &&
        (config.mode === 1 /* ON */ ||
            config.mode === 2 /* STANDARD_ALLOWANCES */));
}
function testAllowance(config) {
    return config.mode === 2 /* STANDARD_ALLOWANCES */;
}
var Router = /** @class */ (function () {
    function Router() {
    }
    Router.configure = function (configs, pathPrefix) {
        configs.forEach(function (config) {
            Router.configs.set(config.module, Router.upgradeConfig(config));
        });
        Router.pathPrefix = pathPrefix;
    };
    Router.setup = function (elem) {
        document_1.D.eachRecur(elem, function (node) {
            var e_1, _a;
            try {
                for (var _b = __values(Router.configs.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var config = _c.value;
                    if (testOn(node, config)) {
                        config.setup(config, node);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
    Router.STANDARD_LINK_LISTENER = function (e) {
        return console_wrapper_1.error(function () {
            e.preventDefault();
            var target = e.target;
            var url = target.href;
            history_1.History.forward(Router.getPathName(url));
            var ret = html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc);
            window.dispatchEvent(new CustomEvent('newPageLoad'));
            return ret;
        });
    };
    Router.ON_COMPLETE_SLL = function (post) {
        var _this = this;
        return function (e) {
            console_wrapper_1.error(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, Router.STANDARD_LINK_LISTENER(e)];
                        case 1:
                            _a.sent();
                            post(e);
                            return [2 /*return*/];
                    }
                });
            }); });
        };
    };
    Router.IMAGE_LINK_LISTENER = function (e) {
        return console_wrapper_1.error(function () {
            // TODO: Load modal or load nothing at all, fix this
            e.preventDefault();
            var target = e.target;
            var url = target.src;
            history_1.History.forward(Router.getPathName(url));
            return html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc);
        });
    };
    Router.FORM_OFF_LISTENER = function (e) {
        e.preventDefault();
        console.error('All forms except for the one in the top header are inactive.');
    };
    Router.defaultAllowancesOn = function () {
        Router.registerAllowance({ regex: Router.EMPTY, func: Router.EMPTY_RESPONDER }, { regex: Router.HASH_TAGS, func: Router.HASH_TAG_RESPONDER }, { regex: Router.AT_SYMBOL, func: Router.AT_SYMBOL_RESPONDER });
    };
    Router.defaultAllowancesOff = function () {
        Router.unregisterAllowance(Router.EMPTY, Router.HASH_TAGS, Router.AT_SYMBOL);
    };
    Router.registerAllowance = function () {
        var regexs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            regexs[_i] = arguments[_i];
        }
        regexs.forEach(function (regex) {
            return Router.linkAllowances.set(regex.regex, regex.func);
        });
    };
    Router.unregisterAllowance = function () {
        var regexs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            regexs[_i] = arguments[_i];
        }
        regexs.forEach(function (regex) { return Router.linkAllowances.delete(regex); });
    };
    Router.clearAllowances = function () {
        Router.linkAllowances.clear();
    };
    Router.load = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            var ret;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        history_1.History.forward(Router.getPathName(url));
                        return [4 /*yield*/, html_loader_1.HTMLLoader.loadURL(url, elements_1.Elements.htmlLoc)];
                    case 1:
                        ret = _a.sent();
                        window.dispatchEvent(new CustomEvent('newPageLoad'));
                        return [2 /*return*/, ret];
                }
            });
        });
    };
    Router.loadWithPathPrefix = function (page) {
        return __awaiter(this, void 0, void 0, function () {
            var ret;
            return __generator(this, function (_a) {
                ret = html_loader_1.HTMLLoader.loadURL(Router.pathPrefix + page, elements_1.Elements.htmlLoc);
                window.dispatchEvent(new CustomEvent('newPageLoad'));
                return [2 /*return*/, ret];
            });
        });
    };
    Router.upgradeConfig = function (config) {
        return {
            module: config.module,
            mode: config.mode,
            setup: Router.SetupFunctions[config.module],
        };
    };
    Router.getPathName = function (url) {
        var ret = Router.pathRegex.exec(url);
        return ret === null ? url : ret.length > 1 ? ret[1] : url;
    };
    Router.HASH_TAGS = new RegExp('#');
    Router.EMPTY = new RegExp('^$');
    Router.AT_SYMBOL = new RegExp('@');
    Router.HASH_TAG_RESPONDER = funcs_1.noop;
    Router.EMPTY_RESPONDER = function (event) { return event.preventDefault(); };
    Router.AT_SYMBOL_RESPONDER = function (event) {
        return event.preventDefault();
    };
    Router.pathPrefix = '';
    Router.SetupFunctions = {
        A: function (config, elem) {
            var aNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_1 = true;
                var href_1 = aNode.href;
                Router.linkAllowances.forEach(function (func, regex) {
                    var test = regex.test(href_1);
                    passesRegexTest_1 = passesRegexTest_1 && !test;
                    if (test) {
                        document_1.D.addEventListener(elem, 'click', func);
                    }
                });
                if (passesRegexTest_1) {
                    if (href_1.substr(href_1.length - 3) === 'pdf') {
                        document_1.D.addEventListener(elem, 'click', function (e) {
                            e.preventDefault();
                            modal_1.Modal.display(href_1);
                        });
                    }
                    else {
                        document_1.D.addEventListener(elem, 'click', function (e) {
                            return Router.STANDARD_LINK_LISTENER(e);
                        });
                    }
                }
            }
            else {
                document_1.D.addEventListener(elem, 'click', function (e) {
                    return Router.STANDARD_LINK_LISTENER(e);
                });
            }
        },
        IMG: function (config, elem) {
            var imgNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_2 = true;
                Router.linkAllowances.forEach(function (func, regex) {
                    var test = !regex.test(imgNode.src);
                    passesRegexTest_2 = passesRegexTest_2 && test;
                    if (test) {
                        document_1.D.addEventListener(elem, 'click', func);
                    }
                });
                if (passesRegexTest_2) {
                    document_1.D.addEventListener(elem, 'click', function (e) {
                        return Router.STANDARD_LINK_LISTENER(e);
                    });
                }
            }
            else {
                document_1.D.addEventListener(elem, 'click', function (e) {
                    return Router.STANDARD_LINK_LISTENER(e);
                });
            }
        },
        FORM: function (config, elem) {
            var formNode = elem;
            if (testAllowance(config)) {
                var passesRegexTest_3 = true;
                Router.linkAllowances.forEach(function (func, regex) {
                    var test = !regex.test(formNode.src);
                    passesRegexTest_3 = passesRegexTest_3 && test;
                    if (test) {
                        document_1.D.addEventListener(elem, 'click', func);
                    }
                });
                if (passesRegexTest_3) {
                    document_1.D.addEventListener(elem, 'submit', Router.FORM_OFF_LISTENER);
                }
            }
            else {
                document_1.D.addEventListener(elem, 'submit', Router.FORM_OFF_LISTENER);
            }
        },
    };
    Router.configs = new Map();
    Router.linkAllowances = new Map();
    Router.pathRegex = /\/([\w]+.html)/;
    return Router;
}());
exports.Router = Router;

},{"../dom/document":127,"../dom/elements":128,"../dom/modal":130,"../utils/console_wrapper":137,"../utils/funcs":138,"../utils/html_loader":139,"./history":134}],136:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var event_1 = require("../data-log/event");
var receiver_1 = require("../data-log/receiver");
var elements_1 = require("../dom/elements");
var tracker_elems_1 = require("../dom/tracker_elems");
var console_wrapper_1 = require("../utils/console_wrapper");
var mturk_1 = require("./../aws/mturk");
var data_1 = require("./../data-log/data");
var submit_form_1 = require("./../dom/submit_form");
console_wrapper_1.log('tracker loaded.', 2 /* BASIC */);
var Tracker = /** @class */ (function () {
    function Tracker() {
    }
    Tracker.loadScenario = function (scen) {
        var sub = scen.scenario;
        if (sub.length > 50) {
            sub = sub.substring(0, 50);
            var inds = [
                sub.lastIndexOf(' '),
                sub.lastIndexOf('.'),
                sub.lastIndexOf(','),
                sub.lastIndexOf('?'),
                sub.lastIndexOf('!'),
            ];
            var ind = Math.max.apply(Math, __spread(inds));
            sub = sub.substring(0, ind) + '...';
        }
        elements_1.Elements.mtTopBannerText.innerText = sub;
        elements_1.Elements.mtScenarioContext.innerText = scen.scenario;
        elements_1.Elements.mtScenarioQuestion.innerText = scen.question;
        elements_1.Elements.htmlLoc.dataset.task = scen.tag;
    };
    Tracker.start = function (config) {
        console_wrapper_1.setDebugLevel(config.debugLevel);
        // configure tracker specific elements
        tracker_elems_1.TrackerElements.setupTrackerElements();
        submit_form_1.SubmitForm.setup(config.allowSubmission);
        mturk_1.MturkClient.init(config.bucketName, config.keyPrefix);
        data_1.data.data.task = elements_1.Elements.htmlLoc.dataset.task;
        config.setup();
    };
    Tracker.registerEvent = function (eventType) {
        data_1.data.logs[eventType] = [];
        this.receiver.register(eventType, function (event) {
            data_1.data.logs[eventType].push(event);
        });
        return this.getEventDispatchFunc(eventType);
    };
    Tracker.getEventDispatchFunc = function (eventType) {
        var _this = this;
        return function (evData) {
            if (typeof evData === 'object') {
                if (!event_1.isTrackerEvent(evData)) {
                    event_1.objectToTrackerEvent(evData, eventType);
                }
                _this.receiver.doEvent(evData);
            }
        };
    };
    Tracker.attachData = function (key, attribute) {
        data_1.data.data[key] = attribute;
    };
    Tracker.computeAttribute = function (name, compute) {
        data_1.data.data[name] = compute(data_1.data.data[name]);
    };
    Tracker.lastPos = { x: 0, y: 0, time: 0 };
    Tracker.receiver = new receiver_1.EventReceiver();
    return Tracker;
}());
exports.Tracker = Tracker;

},{"../data-log/event":124,"../data-log/receiver":125,"../dom/elements":128,"../dom/tracker_elems":133,"../utils/console_wrapper":137,"./../aws/mturk":121,"./../data-log/data":123,"./../dom/submit_form":132}],137:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("./../data-log/data");
log("console wrapper loaded.", 2 /* BASIC */);
function error(func) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, errorHO(func)()];
        });
    });
}
exports.error = error;
function errorHO(func) {
    var _this = this;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                try {
                    return [2 /*return*/, func(args)];
                }
                catch (error) {
                    data_1.data.errors.push(error);
                    console.error(error);
                }
                return [2 /*return*/];
            });
        });
    };
}
exports.errorHO = errorHO;
var debugLevel = 2 /* BASIC */;
function setDebugLevel(level) {
    debugLevel = level;
}
exports.setDebugLevel = setDebugLevel;
function log(message, importance) {
    if (debugLevel >= importance) {
        console.log(message);
    }
}
exports.log = log;

},{"./../data-log/data":123}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log("funcs loaded.", 2 /* BASIC */);
// tslint:disable-next-line: no-empty
function noop() { }
exports.noop = noop;
function now() {
    return new Date().getTime();
}
exports.now = now;

},{"./console_wrapper":137}],139:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("../dom/document");
var console_wrapper_1 = require("./console_wrapper");
var funcs_1 = require("./funcs");
console_wrapper_1.log('html loader loaded.', 2 /* BASIC */);
var HTMLLoader = /** @class */ (function () {
    function HTMLLoader() {
    }
    HTMLLoader.finish = function () {
        HTMLLoader.finished = true;
        HTMLLoader.flattenTSLoadTags();
    };
    HTMLLoader.isFinished = function () {
        return HTMLLoader.finished;
    };
    HTMLLoader.cacheHTML = function (name, content) {
        if (HTMLLoader.finished) {
            throw new Error('Cannot cache new HTML entities after the application has been started.');
        }
        var tsl = document.createElement('ts-load');
        tsl.dataset.name = name;
        tsl.innerHTML = content;
        this.CACHE[name] = tsl;
    };
    HTMLLoader.registerPostLoadFunc = function (func) {
        console_wrapper_1.log('regsiter post load function', 3 /* DETAILED */);
        HTMLLoader.postLoadFunc = func;
    };
    HTMLLoader.load = function (html, elem) {
        return new Promise(function (resolve, reject) {
            try {
                console_wrapper_1.log('begin load', 3 /* DETAILED */);
                var context = document_1.D.elem(elem);
                var range = document.createRange();
                range.selectNodeContents(context);
                var frag = range.createContextualFragment(html);
                HTMLLoader.removeTagsFromDocumentFragment(frag, 'script');
                HTMLLoader.loadAllCachedElements(frag);
                context.innerHTML = '';
                context.appendChild(frag);
                console_wrapper_1.log('end load', 3 /* DETAILED */);
                HTMLLoader.postLoadFunc();
                resolve(true);
            }
            catch (err) {
                reject(err);
            }
        });
    };
    HTMLLoader.loadURL = function (url, elem) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _b = (_a = HTMLLoader).load;
                        return [4 /*yield*/, HTMLLoader.getHTML(url)];
                    case 1: return [2 /*return*/, _b.apply(_a, [_c.sent(), elem])];
                }
            });
        });
    };
    HTMLLoader.getHTML = function (url) {
        return new Promise(function (resolve, reject) {
            try {
                console_wrapper_1.log('begin request', 3 /* DETAILED */);
                var request_1 = new XMLHttpRequest();
                request_1.open('GET', url, true);
                request_1.send(null);
                request_1.onreadystatechange = function () {
                    if (request_1.readyState === 4) {
                        console_wrapper_1.log('resolve request', 3 /* DETAILED */);
                        resolve(request_1.responseText);
                    }
                };
            }
            catch (err) {
                reject(err);
            }
        });
    };
    HTMLLoader.removeTagsFromDocumentFragment = function (frag, tagName) {
        frag.querySelectorAll(tagName).forEach(function (tag) { return frag.removeChild(tag); });
    };
    HTMLLoader.flattenTSLoadTags = function () {
        console_wrapper_1.log('Flattening', 3 /* DETAILED */);
        var s = new Set();
        Object.keys(HTMLLoader.CACHE).forEach(function (name) {
            return (HTMLLoader.CACHE[name] = HTMLLoader.flattenTSLoadTag(HTMLLoader.getCachedContent(name), s, 0));
        });
    };
    HTMLLoader.multipleTabs = function (n) {
        var ret = '';
        for (var i = 0; i < n; i++) {
            ret += '\t';
        }
        return ret;
    };
    HTMLLoader.flattenTSLoadTag = function (elem, flattened, count) {
        var tabs = HTMLLoader.multipleTabs(count);
        if (count > 100) {
            alert('Check the console, an error has occurred.');
            throw new Error('It seems like you might have infinitely recursively nested tags.' +
                '\nHere are all of the tags that have been flattened so far: ' +
                flattened +
                '\nHere is the name of the current element: ' +
                elem.getAttribute('data-name'));
        }
        var name = elem.getAttribute('data-name');
        if (name === null) {
            return null;
        }
        var content = HTMLLoader.getCachedContent(name);
        if (content === null) {
            return null;
        }
        if (flattened.has(name)) {
            return content;
        }
        content.querySelectorAll('script').forEach(function (e) { return e.remove(); });
        content.querySelectorAll('ts-load').forEach(function (e) {
            var child = HTMLLoader.flattenTSLoadTag(e, flattened, count + 1);
            if (child !== null) {
                e.replaceWith(child);
            }
        });
        flattened.add(name);
        return content;
    };
    HTMLLoader.getCachedContent = function (name) {
        if (name === undefined || name === null) {
            return null;
        }
        var content = HTMLLoader.CACHE[name];
        if (content === undefined || content === null) {
            return null;
        }
        return content.cloneNode(true);
    };
    HTMLLoader.loadAllCachedElements = function (frag) {
        frag.querySelectorAll('ts-load').forEach(function (elem) {
            var name = elem.getAttribute('data-name');
            var content = HTMLLoader.getCachedContent(name);
            if (content != null) {
                elem.replaceWith(content);
            }
        });
    };
    HTMLLoader.CACHE = {};
    HTMLLoader.finished = false;
    HTMLLoader.postLoadFunc = funcs_1.noop;
    return HTMLLoader;
}());
exports.HTMLLoader = HTMLLoader;

},{"../dom/document":127,"./console_wrapper":137,"./funcs":138}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var elements_1 = require("../dom/elements");
var document_1 = require("./../dom/document");
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log("id generator loaded", 2 /* BASIC */);
var IDGenerator = /** @class */ (function () {
    function IDGenerator() {
    }
    IDGenerator.reset = function () {
        IDGenerator.idCount = 0;
    };
    Object.defineProperty(IDGenerator, "next", {
        get: function () {
            IDGenerator.idCount += 1;
            return IDGenerator.prefix + IDGenerator.idCount;
        },
        enumerable: true,
        configurable: true
    });
    IDGenerator.applyID = function (elem) {
        elem.id = elem.id ? elem.id : IDGenerator.next;
    };
    /**
     * Recursively adds ids to all elements that are below the given
     * element in the heirarchy.
     *
     * @param elem - the element to start applying ids to its children.
     *                  Will not apply an id to this element.
     */
    IDGenerator.applyRecur = function (elem) {
        document_1.D.eachRecur(elem, this.applyID);
    };
    /**
     * Attaches ids to all html elements in the target location in the DOM that do not have ids.
     */
    IDGenerator.attachIdsToAllElements = function () {
        IDGenerator.applyRecur(elements_1.Elements.htmlLoc);
    };
    IDGenerator.idCount = 0;
    IDGenerator.prefix = "auto_gen_id_unq_";
    return IDGenerator;
}());
exports.IDGenerator = IDGenerator;

},{"../dom/elements":128,"./../dom/document":127,"./console_wrapper":137}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var console_wrapper_1 = require("./console_wrapper");
console_wrapper_1.log("ready loaded", 2 /* BASIC */);
var ready = false;
var resolveFunc;
var rejectFunc;
var readyPromise = new Promise(function (resolve, reject) {
    resolveFunc = resolve;
    rejectFunc = reject;
});
document.addEventListener("DOMContentLoaded", function () {
    console_wrapper_1.log("document is ready", 3 /* DETAILED */);
    ready = true;
    resolveFunc(true);
});
function isReady() {
    return ready;
}
exports.isReady = isReady;
function waitUntilReady() {
    return ready ? Promise.resolve(true) : readyPromise;
}
exports.waitUntilReady = waitUntilReady;

},{"./console_wrapper":137}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../core/dom/document");
var Accordion = /** @class */ (function () {
    function Accordion(outer) {
        var _this = this;
        this.outer = outer;
        document_1.D.addEventListener(outer, "click", function () {
            /* Toggle between adding and removing the "active" class,
                      to highlight the button that controls the panel */
            _this.outer.classList.toggle("active");
            /* Toggle between hiding and showing the active panel */
            var panel = _this.outer.nextElementSibling;
            if (panel.style.display === "block") {
                panel.style.display = "none";
            }
            else {
                panel.style.display = "block";
            }
        });
    }
    Accordion.setupAll = function () {
        Accordion.discardAll();
        var accordions = document_1.D.claz("accordion");
        for (var accIndex = 0; accIndex < accordions.length; ++accIndex) {
            var elem = accordions.item(accIndex);
            if (elem == null) {
                continue;
            }
            Accordion.accordions.push(new Accordion(elem));
        }
    };
    Accordion.discardAll = function () {
        Accordion.accordions = [];
    };
    Accordion.accordions = [];
    return Accordion;
}());
exports.Accordion = Accordion;

},{"./../core/dom/document":127}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function doSomething() {
    console.log("Put some code in here!");
}
exports.doSomething = doSomething;

},{}],144:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var html_loader_1 = require("../core/utils/html_loader");
var accordion_1 = require("./accordion");
var do_something_1 = require("./do-something");
var html_imports_1 = require("./html-imports");
var slideshow_1 = require("./slideshow");
// Put all function calls that need to be made on every page load inside the setupAll function body.
function PutStudentPageLoadOperationsInsideThisStudentBody() {
    // TODO: Put all operations that you want to happen on ever page load in this function.
    // For example you could write: Sticky.setup()
    do_something_1.doSomething();
}
exports.PutStudentPageLoadOperationsInsideThisStudentBody = PutStudentPageLoadOperationsInsideThisStudentBody;
function setupAll() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, new Promise(function (r) { return setTimeout(r, 100); })];
                case 1:
                    _a.sent();
                    console.log('reloading');
                    slideshow_1.Slideshow.setupAll();
                    accordion_1.Accordion.setupAll();
                    PutStudentPageLoadOperationsInsideThisStudentBody();
                    console.log('reloaded');
                    return [2 /*return*/];
            }
        });
    });
}
exports.setupAll = setupAll;
html_imports_1.itemsToCache.forEach(function (item) {
    html_loader_1.HTMLLoader.cacheHTML(item.name, item.content);
});
window.HTMLLoader = html_loader_1.HTMLLoader;
console.log('dynamic-dom loaded');
// Do not touch this line, needed to reinitialize code in the dynamic-dom.ts setupAll function
window.addEventListener('newPageLoad', function () { return setupAll(); });

},{"../core/utils/html_loader":139,"./accordion":142,"./do-something":143,"./html-imports":145,"./slideshow":149}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// An HTMLContent object should look like the following:
// {
//     name: 'footer',
//     content: require('./html/footer.html'),
// }
// Then you can reference that content in your html using the following tag with the corresponding name attribute.
// <ts-load data-name="header"></ts-load>
// You can specify as many as you want inside of the array and they will all be bundled up with your website.
// Make sure to make a corresponding html file in the html file folder for each element you specify.
exports.itemsToCache = [
    // Feel free to change the content inside any of the html files in the html file folder to suit your needs.
    {
        name: 'header',
        content: require('./html/header.html'),
    },
    {
        name: 'footer',
        content: require('./html/footer.html'),
    },
    {
        name: 'nested',
        content: require('./html/nested.html'),
    },
];

},{"./html/footer.html":146,"./html/header.html":147,"./html/nested.html":148}],146:[function(require,module,exports){
module.exports = "<footer id=\"colophon\" class=\"footer\" role=\"contentinfo\">\n  <div class=\"container\">\n    <div class=\"footer-widgets\">\n      <aside class=\"widget site-contact\">\n        <h2 class=\"footer-widget-title\">Nursery School</h2>\n        <p>6926 Forest Park Parkway</p>\n        <p>St. Louis, MO 63130</p>\n        <p class=\"phone\">314-935-6689 <span>|</span> Fax: 314-935-7249</p>\n        <p>\n          <a href=\"files/mailto:nursery@wustl.edu\">nursery@wustl.edu</a>\n        </p>\n      </aside>\n\n      <div class=\"widget-wrapper\">\n        <aside id=\"text-4\" class=\"widget widget_text widget-count-2\">\n          <h2 class=\"footer-widget-title\">Hours of Operation</h2>\n          <div class=\"textwidget\">\n            <p>\n              Classes meet Mon. through Fri.<br />\n              Morning: 9-11:45 a.m.<br />\n              Afternoon: 12:30-3:15 p.m.<br />\n              Full day: 9 a.m.-3:15 p.m.\n            </p>\n          </div>\n        </aside>\n        <aside id=\"text-3\" class=\"widget widget_text widget-count-2\">\n          <h2 class=\"footer-widget-title\">Apply for the Nursery School</h2>\n          <div class=\"textwidget\">\n            <p>\n              Experience the innovative approach and dynamic teaching\n              environment of the Washington University Nursery School.\n            </p>\n            <a href=\"files/apply.html\">Register Now</a>\n          </div>\n        </aside>\n      </div>\n    </div>\n    <div class=\"site-info\">\n      <p class=\"footer-copyright\">©2019 Washington University in St. Louis</p>\n    </div>\n  </div>\n</footer>";

},{}],147:[function(require,module,exports){
module.exports = "<div id=\"wustl-branding\">\n  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"321\" height=\"28\" viewBox=\"0 0 321 28\" class=\"washu-logo\"\n    aria-labelledby=\"title\">\n    <title id=\"title\">Washington University in St. Louis</title>\n    <path fill=\"#FFF\"\n      d=\"M10.46 1.76c-.09 0-4.41.04-10.46-1.21V18c0 .27.01.47.01.47v.02c.04.81.28 1.45.77 2 .32.34.76.7 1.38 1.05.17.1.35.18.55.28.15.07.31.14.47.2.14.06.55.24.69.29l6.59 2.5 6.59-2.5c.15-.05.56-.24.69-.29.16-.07.32-.14.47-.2.19-.1.38-.18.55-.28.62-.35 1.06-.7 1.38-1.05.48-.55.73-1.19.77-2v-.02s0-.19.01-.47V.55C14.86 1.8 10.55 1.76 10.46 1.76z\">\n    </path>\n    <path fill=\"#007360\"\n      d=\"M10.46 2.8c-.09 0-4.03.04-9.56-1.1v15.95c0 .25.01.43.01.44v.02c.04.74.25 1.33.7 1.83.29.31.7.64 1.26.95.15.09.32.17.5.26.14.07.28.13.44.19.12.05.5.22.63.27l6.03 2.29 6.03-2.29c.13-.05.51-.22.63-.27.15-.06.3-.13.44-.19.18-.09.35-.17.5-.26.56-.31.97-.64 1.26-.95.44-.5.66-1.09.7-1.83v-.02s0-.18.01-.44V1.7c-5.55 1.14-9.5 1.1-9.58 1.1z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M10.46 3.75c-.08 0-3.68.04-8.74-1.02v4.08c5.05 1.05 8.67 1.02 8.74 1.02s3.68.04 8.74-1.02V2.73c-5.06 1.05-8.66 1.02-8.74 1.02z\">\n    </path>\n    <path fill=\"#A51417\"\n      d=\"M10.46 7.83c-.08 0-3.68.04-8.74-1.02v9.05c5.05 1.05 8.67 1.02 8.74 1.02s3.68.04 8.74-1.02V6.82c-5.06 1.04-8.66 1.01-8.74 1.01z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M1.72 17.72c.03.69.23 1.23.64 1.68.26.28.64.58 1.15.87.15.08.29.15.46.23.13.06.26.12.4.17.11.05.46.2.58.24L10.46 23l5.51-2.09c.12-.04.46-.2.58-.24.14-.06.27-.12.4-.17.16-.08.32-.15.46-.23.51-.29.88-.58 1.15-.87.41-.46.6-1 .64-1.68v-.02s0-.16.01-.4v-1.44c-5.05 1.05-8.67 1.02-8.74 1.02s-3.68.04-8.74-1.02v1.45c-.02.25-.01.41-.01.41z\">\n    </path>\n    <path fill=\"#007360\"\n      d=\"M4.8 3.69l.41 1.23 1.29.01-1.04.77.39 1.24-1.05-.76-1.05.76.39-1.24-1.04-.77 1.29-.01.41-1.23zm11.31 0l.42 1.23 1.29.01-1.04.77.39 1.24-1.06-.76-1.05.76.39-1.24-1.04-.77 1.29-.01.41-1.23zm-5.65.48l.42 1.23 1.29.01-1.04.77.39 1.24-1.06-.76-1.06.75.39-1.24-1.04-.77 1.3-.01.41-1.22zM10.46 17.21l-.46.45v1.22l.23.65v1.09h.45v-1.09l.23-.65v-1.22l-.45-.45zm.22 4.41v-.65h-.45v.65l-.23.42.46.56.46-.56-.24-.42zm.33-.65v.5l.29.31.51-.41v-.41h-.8zm.54-2.04l-.54.6v1.09h.44v-.65l.43-.46.55.36.35-.36v-.58h-1.23zm-1.64 2.04v.5l-.29.31-.52-.41v-.41h.81zm-.55-2.04l.54.6v1.09h-.43v-.65l-.43-.46-.55.36-.35-.36v-.58h1.22z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M14.62 9.27v5.19h-3.49l-.25.21-.43.37-.43-.37-.25-.21H6.29V9.27l-.74.54v5.38h4.12l.37.31.43.38.43-.38.37-.31h4.12V9.81l-.77-.54z\">\n    </path>\n    <path fill=\"#E1C4AC\"\n      d=\"M11.02 8.83l-.14.11-.43.38-.43-.38-.12-.11H7.03v4.89h2.88l.2.17.35.31.36-.31.19-.17h2.88V8.83h-2.87zM16.11 10.35v3.31c.95-.14 1.98-.31 3.08-.54V9.81a50.5 50.5 0 0 1-3.08.54zm-11.31 0c-.95-.14-1.98-.31-3.08-.54v3.31c1.1.23 2.14.41 3.08.54v-3.31z\">\n    </path>\n    <path fill=\"#007360\"\n      d=\"M16.11 16.76l-.31.32v.86l.15.46v.77h.31v-.77l.16-.46v-.86l-.31-.32zm.16 3.09v-.45h-.31v.46l-.15.3.31.4.32-.4-.17-.31zm.23-.45v.35l.2.22.36-.28v-.29h-.56zm.38-1.43l-.38.43v.77h.31v-.46l.3-.33.38.25.24-.25v-.41h-.85zm-1.14 1.43v.35l-.21.22-.35-.28v-.29h.56zm-.39-1.43l.39.43v.77h-.31v-.46l-.3-.33-.39.25-.24-.25v-.41h.85zM4.8 16.76l-.32.32v.86l.16.46v.77h.31v-.77l.15-.46v-.86l-.3-.32zm.16 3.09v-.45h-.31v.46l-.16.3.32.4.31-.4-.16-.31zm.22-.45v.35l.21.22.35-.28v-.29h-.56zm.39-1.43l-.39.43v.77h.31v-.46l.3-.33.39.25.24-.25v-.41h-.85zM4.42 19.4v.35l-.2.22-.36-.28v-.29h.56zm-.38-1.43l.38.43v.77h-.31v-.46l-.3-.33-.38.25-.24-.25v-.41h.85z\">\n    </path>\n    <g fill=\"#FFF\" class=\"washu-logo-text\">\n      <path\n        d=\"M232.47 8.16c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.76 1.57 1.07 1.57zm13.82 12.03v-5.08c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-1.04 1.01-3.06 1.62-.13.03-.5.04-.51.27 0 .65 2.03-.84 1.99 1.68v7.64c0 1.43-.7 1.55-1.21 1.68-.03 0-.06-.01-.1 0-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04-.84-.01-.63.1-.63.36.03.31.53.33 1.37.34.29 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.31 0 1.15-.13 2.53-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06V13.1c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c-.03 2.27-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c1.27 0 1.82.12 2.16.12.26 0 .73-.2.45-.44-.68-.5-1.97.3-1.95-2.04zM48.91 2.4c.37-.05.55-.19.55-.19 0-.24-.05-.3-.39-.3-.65 0-1.05.11-1.69.11-.71 0-1.25-.08-1.85-.08-.34 0-.31.11-.31.3 0 .21.65.08 1.02.89.21.44.13 1.36-.08 1.9l-5.01 13.74-2.14-6.1-.83-2.23s-.13.06.46-1.79l1.17-3.52c.57-1.73 1.14-2.64 1.88-2.65.92-.02.92-.57.21-.57s-1.13.06-1.75.06c-.65 0-.99-.06-1.69-.06-.26 0-.55.08-.52.3.03.21.42.14.71.3.47.24.78 1.25.45 2.3l-1.38 4.42-1.58-4.13c-.31-.78-.73-2.52.03-2.67.73-.15.63-.52.18-.52-.86 0-1.32.11-2.15.11-.91 0-1.59-.11-2.45-.11-.18 0-.52.03-.42.38.05.21.49.14.76.3 1.05.68 1.25 1.55 1.62 2.52l2.3 6.48c.42 1.16.45.74.11 1.73l-2 5.5-4.95-14.11c-.39-1.06-.6-1.79.26-2.2.37-.19.47-.22.52-.3.05-.07.1-.32-.45-.3-.89.03-1.43.11-2.32.11-.94 0-1.59-.11-2.45-.11-.29 0-.34.14-.34.35 0 .33.71.11 1.31.81.34.38.99 1.66 1.14 2.12L32.8 22.3c.11.25.14.76.48.76.27 0 .33-.57.42-.79l3.13-8.59 3.05 8.16c.13.33.31 1.22.63 1.22.26 0 .36-.43.49-.83l5.9-16.87c.5-1.36 1.07-2.79 2.01-2.96zm65.46 6.71c-3.26 0-5.77 3.28-5.77 7.13 0 1.96.52 3.51 1.42 4.63-.31.21-.92.7-2.15.7-1.07 0-1.68-.64-1.74-2V11.2l3.38-.01c.22 0 .65-1.44.67-1.52.04-.18.1-.33.12-.46.04-.28-.17-.3-.37-.01-.15.15-.32.55-.99.55h-2.81c0-2.41.03-3.51-.35-3.51-.36 0-.3.1-.63 1.17-.44 1.44-1.79 2.23-2.63 2.68-.38.09-.81.12-1.29.01-.74-.16-1.6-1.06-3.83-1.06-2.38 0-4.46 1.95-4.46 4.55 0 1.4.62 2.76 1.71 3.48-.2.12-1.53 1.24-1.37 2.56 0 0-.03 1.37 1.05 1.82-.33.14-.67.36-.96.63-.7-.26-1.72-.06-1.72-1.91V15.1c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-.73.99-2.91 1.55-.13.03-.43.1-.44.34 0 .65 1.75-.71 1.76 1.68v7.64c0 1.65-1.31 1.65-1.54 1.67-.1 0-.19 0-.31.01-.55-.05-1.51-.3-1.51-1.34V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.78-.86 2.01-1.43 2.03-.69-.09-1.22-.37-1.22-1.41v-5.14c0-2.65-1.01-6.07-4.33-6.07-1.47 0-2.75.81-3.73 1.92V2.41c0-.31-.15-.48-.31-.49-.4-.03-1.07 1.19-2.96 1.63-.13.03-.62.07-.62.25 0 .65 1.97-.31 1.99 1.69V20.6c0 1.51-1.3 1.31-1.53 1.79-.04.21.08.31.26.31.42 0 1.55-.12 2.35-.12s2.1.12 2.64.12c.31 0 .44-.06.44-.44-.27-.52-2.28.28-2.28-2.37v-6.5c0-1.57 1.87-2.78 3.03-2.78.91 0 3.14.71 3.14 4.53v5.64c0 1.11-1.18 1.23-1.27 1.57 0 .24.15.34.42.34.28 0 1.11-.12 2.12-.12.56 0 1.07.03 1.5.06.23.05.57.05.99.05.28 0 1-.11 1.82-.11s1.48.07 1.99.11c.1.01.2.01.3.01.04 0 .08.01.12.01h.01c.32.01.61 0 .74 0 .31 0 .83-.13 2.2-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06v-7.09c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c0 2-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c.93 0 1.53.07 1.91.1-.29.42-.48.9-.51 1.4-.14 2.51 2.93 3.41 5.51 3.37 5.12-.07 6.57-3.62 5.51-5.51-1.09-1.95-3.44-1.87-5.68-1.86-4.2.02-3.41-2.59-1.69-2.49.4.02.2.14 1.57.14 2.43 0 4.76-1.66 4.7-4.38-.01-.23.05-1.03-.53-2.14 1.14.01.69 0 2.41 0l-.01 7.63c0 3.45 1.64 4.03 2.87 4.03 1.74 0 3.01-1.15 3.24-1.68 1.03 1.1 2.46 1.68 4.12 1.68 3.19 0 5.6-2.93 5.6-6.78 0-5.8-3.65-6.96-5.61-6.96zM95.62 21.72c.21-.01.27.08 2.64.17 2.45.06 3.33.77 3.49 1.4.26 1.12-.53 3.52-4.05 3.29-2.22-.15-2.87-1.2-3.03-1.44-.84-1.16-.16-3.35.95-3.42zm2.01-4.57c-2.08 0-2.78-2-2.78-3.91 0-1.96.59-3.58 2.67-3.58 2.11 0 2.95 2.16 2.95 4.07.01 1.93-.87 3.42-2.84 3.42zm16.99 4.81c-3.03 0-4.22-3.76-4.22-6.82 0-2.65 1.04-5.1 3.57-5.1 3.08 0 4.19 3.29 4.19 6.51.01 3.87-1.36 5.41-3.54 5.41z\">\n      </path>\n      <path\n        d=\"M131.11 20.19v-5.08c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-1.04 1.01-3.07 1.62-.13.03-.5.04-.51.27 0 .65 2.03-.84 2 1.68v7.64c0 2-1.35 1.52-1.66 2.04-.15.27.25.33.59.33.31 0 .83-.13 2.2-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06v-7.09c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c-.03 2.27-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c1.27 0 1.82.12 2.16.12.26 0 .73-.2.44-.44-.65-.49-1.94.31-1.92-2.03zM77.41 8.16c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6.02.35.77 1.57 1.07 1.57zm-17.3 6.96c-.51-.24-1.27-.68-1.65-.88-1.63-.89-2.27-1.47-2.31-2.3-.08-1.44 1.15-2.19 2.21-2.08 2.54-.04 2.88 2.8 3.14 2.8.39 0 .28-.37.28-1.21 0-.21.03-1.27-.13-1.52-.31-.46-2.1-.74-2.55-.74-.11 0-.52-.01-.6-.02-.13 0-.28.02-.28.02-1.81-.03-3.5 1.11-3.45 3.53.05 2.21 2.64 3.47 4.04 4.3 1.04.59 2.26 1.15 2.24 2.57-.02 1.61-1.27 2.68-2.61 2.6-3.15-.05-2.72-4-3.28-4-.39 0-.31 1-.31 1.52 0 .51-.01.98-.01 1.38-.07.36-.2.7-.54.72-1.24.08-.94-1.9-.94-2.95v-6.43c-.06-1.97-1.54-3.25-3.8-3.25-3.09 0-5.31 3.81-4.25 5 .25.28 1.26-.8 1.32-.86s.08-.13.08-.13c-.01-1.3.97-2.95 2.37-3.09 1.6-.15 2.4 1.04 2.4 2.65v2.09c-6.06 1.21-6.93 3.22-6.93 4.87 0 2.21 1.55 3.2 3.23 3.2 1.45 0 2.88-.69 3.96-1.8.34 1.03 1.01 1.65 2.02 1.62.35-.01.41.09 1.46-.37.37-.1.35-.09.77-.01.56.19 1.32.57 2.66.57 2.03.03 3.85-1.85 3.85-4.17 0-1.5-.43-2.41-2.39-3.63zm-8.43 4.32c0 1.65-1.68 2.52-2.6 2.52-1.38 0-2.33-.89-2.33-2.66 0-2.73 3.28-3.23 4.94-3.67-.01-.01-.01 3.81-.01 3.81zm219.99.19c-.31 0-1.07 1.29-1.07 1.63 0 .34.77 1.6 1.07 1.6.33 0 1.07-1.23 1.07-1.6s-.73-1.63-1.07-1.63zm33.71 1.12V9.92c0-.61-.34-.77-.44-.77-.39 0-.61.1-.88.16-.27.1-.58.23-1.29.23-.13 0-.79-.12-.76.25.04.37 1.57.15 1.58 1.23v7.83c-.12 1.37-1.27 2.88-2.66 2.88-.32 0-2.39-.22-2.37-3.65V9.92c0-.61-.34-.77-.44-.77-.39 0-.61.1-.88.16-.27.1-.61.22-1.32.19-.38-.02-.79-.07-.73.29.06.32 1.59 0 1.59 1.23v7.51c0 2.74 1.61 4.32 3.56 4.32 1.3 0 2.49-.28 3.24-1.8h.05v1.32c0 .13.03.48.22.48.37 0 .56-.3.83-.4.29-.07.37-.33 1.28-.42.39-.04.82-.24.82-.5-.11-.53-1.4.06-1.4-.78zM290.09 9.11c-3.26 0-5.77 3.28-5.77 7.13 0 1.73.42 3.15 1.13 4.23-.79.57-2.23 1.1-4.96 1.1-2.13 0-1.93-.74-1.93-2.55V4.57c0-2.66 1.99-1.89 2.03-2.37.03-.34-.28-.26-.61-.26-.38 0-1.07.15-2.52.15-1.25 0-2.34-.12-2.88-.12-.33 0-.63.1-.52.35.25.57 2.14.05 2.14 1.65v15.1c0 1.44.21 2.36-.45 2.73-.81.49-1.76.51-1.68.83.05.19.45.2.68.2 1.02 0 2.42-.13 3.44-.15 1.94-.06 3.86.13 5.79.13 1.12 0 1.4-.22 2.22-1.33.01-.02.02-.03.04-.05 1.01.94 2.34 1.44 3.87 1.44 3.19 0 5.6-2.93 5.6-6.78.01-5.82-3.65-6.98-5.62-6.98zm.26 12.85c-3.03 0-4.22-3.76-4.22-6.82 0-2.65 1.04-5.1 3.57-5.1 3.08 0 4.19 3.29 4.19 6.51.01 3.87-1.36 5.41-3.54 5.41zm-32.03-10.49c-.75-.37-1.85-1.04-2.39-1.36-2.37-1.37-3.3-2.26-3.37-3.52-.12-2.21 2.04-3.52 3.58-3.35 1.96 0 3.57 1.19 4.24 3.73.07.27.31.89.56.89.22 0 .26-.2.24-.45l-.33-4.02c-.02-.33-.14-.42-.27-.42-.22 0-.36.33-.56.33-.31 0-1.1-1.11-3.8-1.09-.18-.01-.43.02-.43.02-2.63-.05-5.1 1.7-5.02 5.4.07 3.37 3.85 5.3 5.89 6.59 1.51.9 3.09 2.34 3.04 3.95-.08 2.47-1.63 4.08-3.58 3.94-4.59-.08-3.96-6.13-4.78-6.13-.56 0-.45 1.52-.46 2.32 0 1.92-.08 3.49.14 3.77.07.09.29.05.74.05.9 0 2 1.05 4.65 1.05 2.95.05 5.38-2.69 5.38-6.25-.01-2.19-.62-3.58-3.47-5.45zm51.69-3.31c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.76 1.57 1.07 1.57zM312.64 22c-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04-.84-.01-.63.1-.63.36.03.31.53.33 1.37.34.28 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.33 0 .76-.8.07-.69zm5.98-6.88c-.51-.24-1.27-.68-1.65-.88-1.63-.89-2.27-1.47-2.31-2.3-.08-1.44 1.15-2.19 2.21-2.08 2.54-.05 2.88 2.8 3.14 2.8.39 0 .28-.37.28-1.21 0-.21.03-1.27-.13-1.52-.31-.46-2.11-.74-2.55-.74-.11 0-.52-.01-.6-.01-.13 0-.28.01-.28.01-1.81-.03-3.5 1.11-3.44 3.53.05 2.21 2.64 3.46 4.04 4.3 1.04.59 2.26 1.15 2.24 2.57-.02 1.61-1.27 2.68-2.61 2.6-3.15-.05-2.72-4-3.28-4-.39 0-.31 1-.31 1.52-.01 1.25-.06 2.28.1 2.46.05.06.2.03.5.03.62 0 1.38.69 3.19.69 2.03.03 3.85-1.85 3.85-4.17-.01-1.48-.43-2.39-2.39-3.6zm-48.73 5.66c-.26.13-.85.77-2.28.77-1.07 0-1.68-.64-1.74-2v-8.82l3.38-.01c.22 0 .65-1.44.67-1.52.04-.18.1-.33.12-.46.04-.28-.17-.3-.37-.01-.15.15-.32.55-.99.55h-2.81c0-2.41.03-3.04-.35-3.04-.36 0-.3.1-.63 1.17-.54 1.79-2.52 2.58-3.15 2.97-.15.08-.15.11-.15.19-.01.23.75.14 2.31.17l-.01 8.07c0 3.45 1.64 4.03 2.87 4.03 1.87 0 3.21-1.34 3.28-1.8.03-.25 0-.28-.15-.26zm-81.32-1.09c-.57 0-1.42 1.62-3.66 1.62-1.58 0-4.17-1.53-4.17-6.66h6.9c.6 0 .88.03.88-.52 0-1.25-1.4-4.95-4.59-4.95-3.24 0-5.08 3.33-5.08 7.31 0 2.05 1.35 6.38 5.24 6.38 2.33 0 4.59-2.24 4.59-2.95-.01-.11-.01-.23-.11-.23zm-5.08-9.81c1.42 0 2.88 1.56 2.88 3.3 0 .46-.15.62-.52.62h-5.11c0-1.71 1.13-3.92 2.75-3.92zm-31.7-7.33c.1-.16-.25-.24-.37-.24-.42 0-1.37.11-1.8.11-.89 0-1.64-.09-2.53-.09-.07 0-.46.05-.46.18-.01.63 2.13-.11 2.13 2.6v10.57c0 3.13-.99 6.41-5.29 6.41-3.09 0-4.76-1.94-4.76-6.17V4.41c0-1.91 1.49-1.49 1.52-1.92.03-.41-1.33-.16-1.43-.16-.71 0-1.21.08-1.95.08-.62 0-1.37-.1-1.97-.1-.12 0-.53-.02-.61.15-.23.56 1.91.26 1.91 1.83v10.92c0 4.08 1.14 8.08 7.17 7.97 7.14-.12 7.01-6.54 7.01-7.83V5.12c.01-2.43 1.2-2.2 1.43-2.57zm28.19 7.24c.17-.2.22-.53-.57-.46-.45 0-.77.08-1.22.08-.57 0-.68-.02-1.22-.04-.68-.02-.86.05-.82.25.12.6 1.55.01 1.36 1.8-.16 1.5-.65 2.79-1.14 4.07l-1.73 4.62-2.54-7.7c-.31-.96-.45-1.47-.45-1.57 0-.96 1.16-.75 1.42-1.14.16-.26-.17-.4-.54-.4-.31 0-.67.11-1.63.13-.79.02-1.36.02-1.7-.05-.89-.16-.82.33-.51.48s.46.01.91 1.36l3.91 11.06c.08.22.18.77.52.77.39 0 .39-.39.88-1.69 0 0 3.75-10.48 4-10.86.51-.74.89-.5 1.07-.71zm14.47-.5c-1.07 0-1.8 1.28-2.33 2.16h-.05V9.53c0-.3-.15-.48-.3-.48-.41 0-.72.81-2.87 1.33-.13.03-.48.1-.48.28 0 .64 1.82-.19 1.82 1.93v8.07c0 1.25-1.29 1.12-1.29 1.77 0 .18.08.27.28.27.17 0 .63-.12 2.32-.12 1.41 0 2.02.12 2.37.12.28 0 .41-.06.41-.34 0-.98-2.25.48-2.25-2.34v-6.88c0-.4.6-1.8 1.64-1.8.91 0 1.02.7 1.5.7.3 0 .91-.91.91-1.38-.01-.58-1.16-1.37-1.68-1.37zm32.55.1c-.27 0-.96.04-1.59.04-.76 0-1.13-.09-1.45-.09-.48 0-.96 0-.87.32.1.36 1.73.23 1.73 2.01 0 .23 0 .52-.33 1.71l-2.08 6.63-2.9-8.15s-.14-.26-.14-.79c0-1.32 1.54-1.17 1.6-1.41.05-.19-.21-.4-.62-.4h-3.63c-.02 0-.03.01-.05.01h-2.81c0-2.41.03-3.04-.35-3.04-.36 0-.3.1-.63 1.17-.54 1.79-2.52 2.58-3.15 2.97-.15.08-.15.11-.15.19-.01.22.76.14 2.31.17l-.01 8.07c0 3.45 1.64 4.03 2.87 4.03 1.87 0 3.21-1.33 3.28-1.8 0-.27-.04-.29-.18-.27-.26.13-.85.77-2.28.77-1.07 0-1.68-.64-1.74-2V10.7s2.5-.01 3.21-.01c.04.06.08.13.1.19l2.99 8.45c.24.69.39.92.68 2.14.19.79.12 1.51.12 1.51-.29 1.27-1.07 1.99-2.26 4.34-.12.22 1.71-.02 1.81-.05.15-.05.13-.09.31-.42l1.32-3.93 3.69-11.34c.54-1.98 1.39-1.62 1.53-1.89.12-.13 0-.3-.33-.3z\">\n      </path>\n      <path\n        d=\"M222.22 22.76l-.07.19V23l.07-.24zm-14.74-14.6c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.76 1.57 1.07 1.57zM210.11 22c-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04-.84-.01-.63.1-.63.36.03.31.53.33 1.37.34.28 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.33 0 .76-.8.07-.69zM166.52 8.16c.33 0 1.07-1.2 1.07-1.57 0-.36-.74-1.6-1.07-1.6-.3 0-1.07 1.26-1.07 1.6s.77 1.57 1.07 1.57zM169.17 22c-.52-.03-1.63-.23-1.63-1.35V9.59c0-.31-.15-.49-.31-.49-.6 0-.98 1.08-2.63 1.64-.13.03-.37.06-.37.24 0 .65 1.49-.61 1.42 1.69v7.27c.06 1.86-.96 2.04-1.52 2.04h-.17c-.54-.1-1.06-.32-1.05-1.79v-5.08c0-2.34-.76-5.76-4.22-5.76-2.51 0-3.81 2.38-3.76 2.01V9.59c0-.31-.15-.49-.31-.49-.6 0-1.04 1.01-3.07 1.62-.13.03-.5.04-.51.27 0 .65 2.03-.84 2 1.68v7.64c0 2-1.35 1.52-1.66 2.04-.15.27.25.33.59.33.31 0 .83-.13 2.2-.13 1.5 0 2.02.13 2.46.13.39 0 .83-.17.57-.44-.42-.41-2.28.06-2.28-2.06v-7.09c-.03-.49.88-2.4 3.06-2.4 2.1 0 3.03 2.31 3.03 3.85v5.76c-.03 2.27-.8 1.55-1.11 2-.17.25.13.37.46.37s.88-.13 1.87-.13c1.27 0 1.82.12 2.16.12.04 0 .09-.01.13-.01.11 0 .21.01.34.01.28 0 1-.11 1.82-.11 1.07 0 1.87.12 2.41.12.34.02.75-.78.08-.67zm32.72-6.89c-.51-.24-1.27-.68-1.65-.88-1.63-.89-2.27-1.47-2.31-2.3-.08-1.44 1.15-2.19 2.21-2.08 2.54-.05 2.88 2.8 3.14 2.8.39 0 .28-.37.28-1.21 0-.21.03-1.27-.13-1.52-.31-.46-2.1-.74-2.55-.74-.11 0-.52-.01-.6-.02-.13 0-.28.02-.28.02-1.81-.03-3.5 1.11-3.45 3.53.05 2.21 2.64 3.46 4.04 4.3 1.04.59 2.26 1.15 2.24 2.57-.02 1.62-1.27 2.68-2.61 2.6-3.15-.05-2.72-4-3.28-4-.39 0-.31 1-.31 1.52 0 1.25-.06 2.28.1 2.46.05.06.2.03.5.03.62 0 1.38.69 3.19.69 2.03.03 3.85-1.85 3.85-4.17 0-1.47-.42-2.38-2.38-3.6z\">\n      </path>\n    </g>\n  </svg>\n</div>\n<header role=\"banner\">\n  <div class=\"container\">\n    <!-- <a class=\"site-title\" href=\"files/index.html\">Nursery School</a> -->\n  </div>\n  <div id=\"main-menu-container\">\n    <div class=\"container\">\n      <div class=\"navbar\">\n        <a class=\"site-title\" href=\"files/index.html\">Nursery School</a>\n        <div class=\"dropdown\">\n          <button class=\"dropbtn\">\n            <a id=\"about\" href=\"files/about.html\">About\n            </a>\n          </button>\n          <div class=\"dropdown-content\">\n            <a id=\"tuition\" href=\"files/tuition.html\">Tuition</a>\n            <a id=\"parent-handbook\" href=\"files/parent_handbook.html\">Curriculum</a>\n            <a id=\"staff\" href=\"files/staff.html\">Staff</a>\n            \n          </div>\n        </div>\n        <div class=\"dropdown\">\n          <button class=\"dropbtn\">\n            <a id=\"classrooms\" href=\"files/classrooms.html\">Classroom News\n            </a>\n          </button>\n          <div class=\"dropdown-content\">\n            <a id=\"classrooms-2\" href=\"files/classrooms.html\">Classrooms\n            </a>\n            <a id=\"summer-camp\" href=\"files/summer_camp.html\">Summer Camp</a>\n            <a id=\"calendar\" href=\"files/calendar.html\">Calendar</a>\n          </div>\n        </div>\n        <div class=\"dropdown\">\n          <button class=\"dropbtn\">\n            <a id=\"get-involved\" href=\"files/get_involved.html\">Get Involved</a>\n          </button>\n          <div class=\"dropdown-content\">\n            <a id=\"nursery-school-merchandise\" href=\"files/nursery_school_merchandise.html\">Nursery School\n              Merchandise</a>\n            <a id=\"parent-association\" href=\"files/parent_association.html\">Parent Association</a>\n          </div>\n        </div>\n\n        <a id=\"apply\" href=\"files/apply.html\">Admissions</a>\n        <!-- <a id=\"forms\" href=\"files/forms.html\">Forms</a> -->\n\n        <a id=\"parent-resources\" href=\"files/parent_resources.html\">Parent Resources</a>\n      </div>\n    </div>\n  </div>\n</header>";

},{}],148:[function(require,module,exports){
module.exports = "<ts-load data-name=\"footer\"></ts-load>";

},{}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var document_1 = require("./../core/dom/document");
var Slideshow = /** @class */ (function () {
    function Slideshow(outer) {
        var _this = this;
        this.outer = outer;
        this.slideIndex = 0;
        this.slideCount = 0;
        this.slides = [];
        this.dots = [];
        document_1.D.eachRecur(this.outer, function (elem) {
            var cList = elem.classList;
            if (cList.contains("prev-slideshow-button")) {
                document_1.D.addEventListener(elem, "click", function () { return _this.minusSlide(1); });
            }
            else if (cList.contains("next-slideshow-button")) {
                document_1.D.addEventListener(elem, "click", function () { return _this.plusSlide(1); });
            }
            else if (cList.contains("slideshow-entry")) {
                _this.slides.push(elem);
            }
            else if (cList.contains("slideshow-dot")) {
                _this.dots.push(elem);
            }
        });
        var _loop_1 = function (i) {
            document_1.D.addEventListener(this_1.dots[i], "click", function () { return _this.showSlide(i); });
        };
        var this_1 = this;
        for (var i = 0; i < this.dots.length; ++i) {
            _loop_1(i);
        }
        this.slideCount = this.slides.length;
        this.showSlide(this.slideIndex);
    }
    Slideshow.setupAll = function () {
        Slideshow.discardAll();
        var slideshows = document_1.D.claz("slideshow");
        for (var ssIndex = 0; ssIndex < slideshows.length; ++ssIndex) {
            var elem = slideshows.item(ssIndex);
            if (elem == null) {
                continue;
            }
            Slideshow.slideshows.push(new Slideshow(elem));
        }
    };
    Slideshow.discardAll = function () {
        Slideshow.slideshows = [];
    };
    Slideshow.prototype.plusSlide = function (n) {
        this.showSlide((this.slideIndex += n));
    };
    Slideshow.prototype.minusSlide = function (n) {
        this.showSlide((this.slideIndex -= n));
    };
    Slideshow.prototype.showSlide = function (index) {
        this.slideIndex = index % this.slideCount;
        this.slideIndex = Math.max(this.slideIndex, -1 * this.slideIndex);
        for (var i = 0; i < this.slides.length; ++i) {
            this.slides[i].style.display = "none";
        }
        for (var i = 0; i < this.dots.length; i++) {
            this.dots[i].classList.remove("active");
        }
        this.slides[this.slideIndex].style.display = "block";
        this.dots[this.slideIndex].classList.add("active");
    };
    Slideshow.slideshows = [];
    return Slideshow;
}());
exports.Slideshow = Slideshow;

},{"./../core/dom/document":127}],150:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("./../core/data-log/data");
var document_1 = require("./../core/dom/document");
var elements_1 = require("./../core/dom/elements");
var scroll_1 = require("./../core/dom/scroll");
var history_1 = require("./../core/router/history");
var router_1 = require("./../core/router/router");
var tracker_1 = require("./../core/tracker/tracker");
var html_loader_1 = require("./../core/utils/html_loader");
var id_generator_1 = require("./../core/utils/id_generator");
var ready_1 = require("./../core/utils/ready");
var setup = function () { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, ready_1.waitUntilReady()];
            case 1:
                _a.sent();
                // const scenarioTag = window.location.hash.split('?')[0].replace('#', '');
                // const scenario = scenarios.find((scen) => scen.tag === scenarioTag);
                // if (scenario === null || scenario === undefined) {
                //     alert('This HIT is broken and cannot be completed at this time.');
                //     return;
                // }
                // Tracker.loadScenario(scenario);
                tracker_1.Tracker.start({
                    keyPrefix: 'information-foraging',
                    bucketName: 'cse-256-log',
                    allowSubmission: {
                        allow: function () {
                            try {
                                var textArea = document_1.D.id('text-area');
                                console.log(textArea.value);
                                if (textArea.value === '') {
                                    return 'You must fill out the text box to turn this HIT in.';
                                }
                                else {
                                    return null;
                                }
                            }
                            catch (error) {
                                console.log(error);
                                return 'There was an error fill out the form and try again.';
                            }
                        },
                        preSubmit: function () {
                            data_1.data.data.response = document_1.D.id('text-area').value;
                            return;
                        },
                    },
                    debugLevel: 1 /* NONE */,
                    setup: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            var sElem;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        // configure router
                                        router_1.Router.defaultAllowancesOn();
                                        router_1.Router.configure([
                                            {
                                                mode: 2 /* STANDARD_ALLOWANCES */,
                                                module: "A" /* A */,
                                            },
                                            { mode: 0 /* OFF */, module: "FORM" /* FORM */ },
                                            {
                                                mode: 2 /* STANDARD_ALLOWANCES */,
                                                module: "IMG" /* IMG */,
                                            },
                                        ], 'files/');
                                        history_1.History.setup(window.location.href, { wrapper: true });
                                        // configure html loader post operation
                                        html_loader_1.HTMLLoader.finish();
                                        html_loader_1.HTMLLoader.registerPostLoadFunc(function () {
                                            id_generator_1.IDGenerator.reset();
                                            id_generator_1.IDGenerator.attachIdsToAllElements();
                                            router_1.Router.setup(elements_1.Elements.htmlLoc);
                                            scroll_1.Scroll.promise(0);
                                        });
                                        // configure listeners on html loc
                                        document_1.D.addEventListener(elements_1.Elements.htmlLoc, "click" /* CLICK */, function (e) {
                                            var ev = e;
                                            var obj = {
                                                x: ev.clientX,
                                                y: ev.clientY,
                                                id: ev.target.id,
                                            };
                                            tracker_1.Tracker.getEventDispatchFunc("click" /* CLICK */)(obj);
                                        });
                                        document_1.D.addEventListener(elements_1.Elements.document, 'keypress', function (e) {
                                            var ev = e;
                                            var obj = {
                                                key: ev.key,
                                                id: ev.srcElement.id,
                                            };
                                            tracker_1.Tracker.getEventDispatchFunc("button" /* BUTTON */)(obj);
                                        });
                                        sElem = document.scrollingElement;
                                        document.addEventListener('scroll', function (e) {
                                            var dx = sElem.scrollLeft;
                                            var dy = sElem.scrollTop;
                                            var dtime = new Date().getTime();
                                            if (Math.abs(tracker_1.Tracker.lastPos.x - dx) > 10 ||
                                                (Math.abs(tracker_1.Tracker.lastPos.y - dy) > 10 &&
                                                    dtime - tracker_1.Tracker.lastPos.time > 100)) {
                                                tracker_1.Tracker.lastPos.x = dx;
                                                tracker_1.Tracker.lastPos.y = dy;
                                                tracker_1.Tracker.lastPos.time = dtime;
                                                var obj = { x: dx, y: dy };
                                                tracker_1.Tracker.getEventDispatchFunc("scroll" /* SCROLL */)(obj);
                                            }
                                        });
                                        // configure tracked events
                                        tracker_1.Tracker.registerEvent("history" /* HISTORY */);
                                        tracker_1.Tracker.registerEvent("button" /* BUTTON */);
                                        tracker_1.Tracker.registerEvent("click" /* CLICK */);
                                        tracker_1.Tracker.registerEvent("scroll" /* SCROLL */);
                                        // load first page
                                        return [4 /*yield*/, router_1.Router.load('files/index.html')];
                                    case 1:
                                        // load first page
                                        _a.sent();
                                        return [2 /*return*/];
                                }
                            });
                        });
                    },
                });
                return [2 /*return*/];
        }
    });
}); };
setup();

},{"./../core/data-log/data":123,"./../core/dom/document":127,"./../core/dom/elements":128,"./../core/dom/scroll":131,"./../core/router/history":134,"./../core/router/router":135,"./../core/tracker/tracker":136,"./../core/utils/html_loader":139,"./../core/utils/id_generator":140,"./../core/utils/ready":141}]},{},[144,150])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL2NvZ25pdG8taWRlbnRpdHktMjAxNC0wNi0zMC5taW4uanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLnBhZ2luYXRvcnMuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvbWV0YWRhdGEuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS5taW4uanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvczMtMjAwNi0wMy0wMS5wYWdpbmF0b3JzLmpzb24iLCJub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3MzLTIwMDYtMDMtMDEud2FpdGVyczIuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2FwaXMvc3RzLTIwMTEtMDYtMTUubWluLmpzb24iLCJub2RlX21vZHVsZXMvYXdzLXNkay9hcGlzL3N0cy0yMDExLTA2LTE1LnBhZ2luYXRvcnMuanNvbiIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9jbGllbnRzL2NvZ25pdG9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2NsaWVudHMvczMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9jbGllbnRzL3N0cy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9hcGlfbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJDcnlwdG9MaWIuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3Nlckhhc2hVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VySG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9icm93c2VyTWQ1LmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJTaGExLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2Jyb3dzZXJTaGEyNTYuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvYnJvd3Nlcl9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NvbmZpZ19yZWdpb25hbF9lbmRwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL2NoYWluYWJsZV90ZW1wb3JhcnlfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvY29nbml0b19pZGVudGl0eV9jcmVkZW50aWFscy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9jcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3NhbWxfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvY3JlZGVudGlhbHMvdGVtcG9yYXJ5X2NyZWRlbnRpYWxzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2NyZWRlbnRpYWxzL3dlYl9pZGVudGl0eV9jcmVkZW50aWFscy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9kaXNjb3Zlcl9lbmRwb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vYnVmZmVyZWQtY3JlYXRlLWV2ZW50LXN0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vZXZlbnQtbWVzc2FnZS1jaHVua2VyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2V2ZW50LXN0cmVhbS9pbnQ2NC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9ldmVudC1zdHJlYW0vcGFyc2UtZXZlbnQuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3BhcnNlLW1lc3NhZ2UuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnQtc3RyZWFtL3NwbGl0LW1lc3NhZ2UuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvZXZlbnRfbGlzdGVuZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2h0dHAuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvaHR0cC94aHIuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvanNvbi9idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL2pzb24vcGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL2FwaS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL29wZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9tb2RlbC9wYWdpbmF0b3IuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvbW9kZWwvcmVzb3VyY2Vfd2FpdGVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL21vZGVsL3NoYXBlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3BhcmFtX3ZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Byb3RvY29sL2pzb24uanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcXVlcnkuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9wcm90b2NvbC9yZXN0X2pzb24uanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcHJvdG9jb2wvcmVzdF94bWwuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcXVlcnkvcXVlcnlfcGFyYW1fc2VyaWFsaXplci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWFsY2xvY2svYnJvd3NlckNsb2NrLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlZ2lvbi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9yZWdpb25fY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlZ2lvbl9jb25maWdfZGF0YS5qc29uIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3JlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvcmVzb3VyY2Vfd2FpdGVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3Jlc3BvbnNlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3MzL21hbmFnZWRfdXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NlcXVlbnRpYWxfZXhlY3V0b3IuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXJ2aWNlcy9zMy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zZXJ2aWNlcy9zM3V0aWwuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2VydmljZXMvc3RzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvYmVhcmVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvcHJlc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3JlcXVlc3Rfc2lnbmVyLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvczMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc2lnbmVycy92Mi5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3YzLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjNodHRwcy5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi9zaWduZXJzL3Y0LmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3NpZ25lcnMvdjRfY3JlZGVudGlhbHMuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIvc3RhdGVfbWFjaGluZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC9icm93c2VyX3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvYnVpbGRlci5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWF0dHJpYnV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL2xpYi94bWwvZXNjYXBlLWVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvYXdzLXNkay9saWIveG1sL3htbC1ub2RlLmpzIiwibm9kZV9tb2R1bGVzL2F3cy1zZGsvbGliL3htbC94bWwtdGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL3ZlbmRvci9lbmRwb2ludC1jYWNoZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9hd3Mtc2RrL3ZlbmRvci9lbmRwb2ludC1jYWNoZS91dGlscy9MUlUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2ptZXNwYXRoL2ptZXNwYXRoLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvbWQ1LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9zaGExLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3YxLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92My5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjM1LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvZGlzdC92NC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdjUuanMiLCJzY3JpcHRzL3RzL2NvcmUvYXdzL2NvZ25pdG8udHMiLCJzY3JpcHRzL3RzL2NvcmUvYXdzL210dXJrLnRzIiwic2NyaXB0cy90cy9jb3JlL2F3cy9zMy50cyIsInNjcmlwdHMvdHMvY29yZS9kYXRhLWxvZy9kYXRhLnRzIiwic2NyaXB0cy90cy9jb3JlL2RhdGEtbG9nL2V2ZW50LnRzIiwic2NyaXB0cy90cy9jb3JlL2RhdGEtbG9nL3JlY2VpdmVyLnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS9iYW5uZXIudHMiLCJzY3JpcHRzL3RzL2NvcmUvZG9tL2RvY3VtZW50LnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS9lbGVtZW50cy50cyIsInNjcmlwdHMvdHMvY29yZS9kb20vaHRtbF9sb2MudHMiLCJzY3JpcHRzL3RzL2NvcmUvZG9tL21vZGFsLnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS9zY3JvbGwudHMiLCJzY3JpcHRzL3RzL2NvcmUvZG9tL3N1Ym1pdF9mb3JtLnRzIiwic2NyaXB0cy90cy9jb3JlL2RvbS90cmFja2VyX2VsZW1zLnRzIiwic2NyaXB0cy90cy9jb3JlL3JvdXRlci9oaXN0b3J5LnRzIiwic2NyaXB0cy90cy9jb3JlL3JvdXRlci9yb3V0ZXIudHMiLCJzY3JpcHRzL3RzL2NvcmUvdHJhY2tlci90cmFja2VyLnRzIiwic2NyaXB0cy90cy9jb3JlL3V0aWxzL2NvbnNvbGVfd3JhcHBlci50cyIsInNjcmlwdHMvdHMvY29yZS91dGlscy9mdW5jcy50cyIsInNjcmlwdHMvdHMvY29yZS91dGlscy9odG1sX2xvYWRlci50cyIsInNjcmlwdHMvdHMvY29yZS91dGlscy9pZF9nZW5lcmF0b3IudHMiLCJzY3JpcHRzL3RzL2NvcmUvdXRpbHMvcmVhZHkudHMiLCJzY3JpcHRzL3RzL2R5bmFtaWMtZG9tL2FjY29yZGlvbi50cyIsInNjcmlwdHMvdHMvZHluYW1pYy1kb20vZG8tc29tZXRoaW5nLmpzIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9keW5hbWljLWRvbS50cyIsInNjcmlwdHMvdHMvZHluYW1pYy1kb20vaHRtbC1pbXBvcnRzLnRzIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9odG1sL2Zvb3Rlci5odG1sIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9odG1sL2hlYWRlci5odG1sIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9odG1sL25lc3RlZC5odG1sIiwic2NyaXB0cy90cy9keW5hbWljLWRvbS9zbGlkZXNob3cudHMiLCJzY3JpcHRzL3RzL3RyYWNrZXIvdHJhY2tlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdDFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3h4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3aUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Z3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeG9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkEsa0RBQXNDO0FBQ3RDLDhEQUFpRTtBQUNqRSxxQkFBRyxDQUFDLGlCQUFpQixnQkFBdUIsQ0FBQztBQUM3QztJQWFJLDZCQUFZLGNBQXNCLEVBQVUsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDdEQsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsMEJBQTBCLENBQUM7WUFDNUMsY0FBYyxFQUFFLGNBQWM7U0FDakMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBQyxLQUFLO1lBQ2pCLEtBQUs7Z0JBQ0QsQ0FBQyxDQUFDLHFCQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sbUJBQTBCO2dCQUM3QyxDQUFDLENBQUMscUJBQUcsQ0FBQyx3QkFBd0IsbUJBQTBCLENBQUM7UUFDakUsQ0FBQyxDQUFDLENBQUM7UUFDSCxHQUFHLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ3hDLENBQUM7SUFwQmEsdUJBQUcsR0FBakIsVUFDSSxjQUF5QyxFQUN6QyxNQUFtQztRQURuQywrQkFBQSxFQUFBLGlCQUFpQixtQkFBbUIsQ0FBQyxJQUFJO1FBQ3pDLHVCQUFBLEVBQUEsU0FBUyxtQkFBbUIsQ0FBQyxNQUFNO1FBRW5DLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxjQUFjLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQWlCRCxzQkFBVyw0Q0FBVzthQUF0QjtZQUNJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN0QixDQUFDOzs7T0FBQTtJQTNCYSx3QkFBSSxHQUFHLGdEQUFnRCxDQUFDO0lBQ3hELDBCQUFNLEdBQUcsV0FBVyxDQUFDO0lBMkJ2QywwQkFBQztDQTdCRCxBQTZCQyxJQUFBO0FBN0JZLGtEQUFtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGaEMsNERBQXNFO0FBQ3RFLHFDQUFnRDtBQUNoRCwyQkFBZ0M7QUFDaEMscUJBQUcsQ0FBQyxlQUFlLGdCQUF1QixDQUFDO0FBQzNDO0lBQUE7SUFrQ0EsQ0FBQztJQWpDaUIsZ0JBQUksR0FBbEIsVUFBbUIsVUFBa0IsRUFBRSxTQUFpQjtRQUNwRCxXQUFXLENBQUMsRUFBRSxHQUFHLGFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2xCLEVBQUUsRUFBRSxXQUFXLENBQUMsRUFBRTtZQUNsQixHQUFHLEVBQUUsV0FBVyxDQUFDLE9BQU87WUFDeEIsR0FBRyxFQUFFLFdBQVcsQ0FBQyxNQUFNO1NBQzFCLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFbUIsa0JBQU0sR0FBMUIsVUFBMkIsSUFBWSxFQUFFLElBQVM7Ozs7Z0JBQzlDLHNCQUFPLHVCQUFLLENBQUM7Ozs7O29DQUNILE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO29DQUNyQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO29DQUNYLHFCQUFNLFdBQVcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsRUFBQTs7b0NBQWhELEdBQUcsR0FBRyxTQUEwQztvQ0FDcEQsR0FBRyxHQUFHLEdBQXlCLENBQUM7Ozs7eUJBQ25DLENBQUMsRUFBQzs7O0tBQ047SUFFYSxrQkFBTSxHQUFwQixVQUFxQixLQUFhLEVBQUUsWUFBb0I7UUFDcEQsT0FBVSxLQUFLLFNBQUksWUFBWSxjQUFXLENBQUM7SUFDL0MsQ0FBQztJQUVhLHlCQUFhLEdBQTNCLFVBQTRCLEVBQXVCO1FBQy9DLFdBQVcsQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFYSxvQkFBUSxHQUF0QixVQUF1QixFQUFZO1FBQy9CLFdBQVcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFRCxzREFBc0Q7SUFDeEMsbUJBQU8sR0FBRyw2QkFBbUIsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUV0RCxrQkFBQztDQWxDRCxBQWtDQyxJQUFBO0FBbENZLGtDQUFXOzs7Ozs7OztBQ0x4QiwwREFBb0M7QUFFcEMsNERBQStEO0FBQy9ELHFCQUFHLENBQUMsWUFBWSxnQkFBdUIsQ0FBQztBQUN4QztJQVdJLGtCQUFvQixVQUFrQixFQUFVLFNBQWlCO1FBQTdDLGVBQVUsR0FBVixVQUFVLENBQVE7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQzdELElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxZQUFFLENBQUM7WUFDYixVQUFVLEVBQUUsUUFBUSxDQUFDLFVBQVU7U0FDbEMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQVZhLFlBQUcsR0FBakIsVUFBa0IsTUFBb0MsRUFBRSxTQUFpQjtRQUF2RCx1QkFBQSxFQUFBLFNBQWlCLFFBQVEsQ0FBQyxVQUFVO1FBQ2xELE9BQU8sSUFBSSxRQUFRLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFVRCxzQkFBVyw0QkFBTTthQUFqQjtZQUNJLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUMzQixDQUFDOzs7T0FBQTtJQUVNLHlCQUFNLEdBQWIsVUFDSSxJQUFZLEVBQ1osSUFBUztRQUZiLGlCQW9CQztRQWhCRyxPQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDL0IsS0FBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQ2I7Z0JBQ0ksR0FBRyxFQUFFLEtBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxHQUFHLElBQUk7Z0JBQ2hDLElBQUksRUFBRSxJQUFJO2dCQUNWLE1BQU0sRUFBRSxLQUFJLENBQUMsTUFBTTthQUN0QixFQUNELFVBQUMsR0FBaUIsRUFBRSxPQUEyQjtnQkFDM0MsSUFBSSxHQUFHLEVBQUU7b0JBQ0wsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUNmO3FCQUFNO29CQUNILE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDcEI7WUFDTCxDQUFDLENBQ0osQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQXhDYSxtQkFBVSxHQUFHLEVBQUUsQ0FBQztJQUNoQixtQkFBVSxHQUFHLFlBQVksQ0FBQztJQUMxQixrQkFBUyxHQUFHLEVBQUUsQ0FBQztJQXVDakMsZUFBQztDQTFDRCxBQTBDQyxJQUFBO0FBMUNZLDRCQUFROzs7OztBQ0hyQixPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBUzVCLElBQU0sU0FBUyxHQUFHLElBQUksZUFBZSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRTdELFFBQUEsT0FBTyxHQUFpQjtJQUNqQyxHQUFHLEVBQUUsU0FBUyxDQUFDLFFBQVEsRUFBRTtJQUN6QixZQUFZLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUM7SUFDM0MsS0FBSyxFQUFFLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO0lBQzdCLFFBQVEsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztJQUNuQyxRQUFRLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUM7Q0FDMUMsQ0FBQztBQUVGO0lBTUksY0FBWSxlQUE2QjtRQUxsQyxTQUFJLEdBQTRDLEVBQUUsQ0FBQztRQUNuRCxTQUFJLEdBQTJCLEVBQUUsQ0FBQztRQUNsQyxXQUFNLEdBQVUsRUFBRSxDQUFDO1FBSXRCLElBQUksQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDO0lBQ25DLENBQUM7SUFFTSx3QkFBUyxHQUFoQjtRQUNJLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBQ0wsV0FBQztBQUFELENBYkEsQUFhQyxJQUFBO0FBYlksb0JBQUk7QUFlSixRQUFBLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxlQUFPLENBQUMsQ0FBQztBQUV0QyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLElBQUksY0FBQSxFQUFFLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNoQyw0REFBK0Q7QUFDL0Qsd0NBQXFDO0FBQ3JDLHFCQUFHLENBQUMsZUFBZSxnQkFBdUIsQ0FBQztBQWEzQyxTQUFnQixvQkFBb0IsQ0FBQyxHQUFRLEVBQUUsTUFBYztJQUMzRCxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztJQUNwQixHQUFHLENBQUMsSUFBSSxHQUFHLFdBQUcsRUFBRSxDQUFDO0FBQ25CLENBQUM7QUFIRCxvREFHQztBQUVELFNBQWdCLGNBQWMsQ0FBQyxHQUFRO0lBQ3JDLE9BQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxTQUFTLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUM7QUFDNUQsQ0FBQztBQUZELHdDQUVDO0FBRUQ7SUFJRSwwQkFBWSxNQUFjLEVBQUUsYUFBOEM7UUFDeEUsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBRyxXQUFHLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRUQsc0JBQVcsb0NBQU07YUFBakI7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBQ0gsdUJBQUM7QUFBRCxDQWJBLEFBYUMsSUFBQTtBQWJZLDRDQUFnQjtBQWU3QixpREFBaUQ7QUFDakQ7SUFBZ0MsOEJBSTlCO0lBQ0Esb0JBQ0UsQ0FBUyxFQUNULENBQVMsRUFDVCxFQUFVLEVBQ1YsYUFFYTtRQU5mLFlBUUUsdUNBQXdCLGFBQWEsQ0FBQyxTQUl2QztRQUhDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQixLQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDOztJQUN0QixDQUFDO0lBQ0gsaUJBQUM7QUFBRCxDQWxCQSxBQWtCQyxDQWxCK0IsZ0JBQWdCLEdBa0IvQztBQWxCWSxnQ0FBVTtBQW9CdkIsaURBQWlEO0FBQ2pEO0lBQWlDLCtCQUE2QztJQUM1RSxxQkFDRSxHQUFXLEVBQ1gsRUFBVSxFQUNWLGFBQXdFO1FBSDFFLFlBS0UsdUNBQXdCLGFBQWEsQ0FBQyxTQUd2QztRQUZDLEtBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUN0QixLQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7O0lBQ3RCLENBQUM7SUFDSCxrQkFBQztBQUFELENBVkEsQUFVQyxDQVZnQyxnQkFBZ0IsR0FVaEQ7QUFWWSxrQ0FBVztBQVl4QixpREFBaUQ7QUFDakQ7SUFBa0MsZ0NBR2hDO0lBQ0Esc0JBQ0UsR0FBVyxFQUNYLEtBQVcsRUFDWCxhQUE0RDtRQUg5RCxZQUtFLDJDQUEwQixhQUFhLENBQUMsU0FHekM7UUFGQyxLQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDOztJQUM1QixDQUFDO0lBQ0gsbUJBQUM7QUFBRCxDQWJBLEFBYUMsQ0FiaUMsZ0JBQWdCLEdBYWpEO0FBYlksb0NBQVk7Ozs7O0FDMUV6Qiw0REFBK0Q7QUFDL0QsaUNBQXVEO0FBQ3ZELHFCQUFHLENBQUMsa0JBQWtCLGdCQUF1QixDQUFDO0FBQzlDO0lBQUE7UUFDVSxRQUFHLEdBQUcsSUFBSSxHQUFHLEVBQXlDLENBQUM7UUFDdkQsWUFBTyxHQUFHLElBQUksV0FBVyxFQUFFLENBQUM7SUFxQnRDLENBQUM7SUFuQlEsZ0NBQVEsR0FBZixVQUFnQixTQUFpQixFQUFFLFFBQXdDO1FBQ3pFLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQUMsS0FBWTtZQUNwRCxJQUFNLE9BQU8sR0FBSyxLQUFpQztpQkFDaEQsTUFBc0IsQ0FBQztZQUMxQixJQUFJLHNCQUFjLENBQUMsT0FBTyxDQUFDLElBQUksUUFBUSxFQUFFO2dCQUN2QyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDbkI7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksUUFBUSxFQUFFO1lBQ1osSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ25DO0lBQ0gsQ0FBQztJQUVNLCtCQUFPLEdBQWQsVUFBZSxLQUFtQjtRQUNoQyxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2pELElBQUksUUFBUSxFQUFFO1lBQ1osUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQztJQUNILG9CQUFDO0FBQUQsQ0F2QkEsQUF1QkMsSUFBQTtBQXZCWSxzQ0FBYTs7Ozs7QUNIMUIsMkNBQTBDO0FBQzFDLDREQUErRDtBQUMvRCwrQ0FBOEM7QUFDOUMsdUNBQStCO0FBQy9CLHVDQUFzQztBQUN0QyxxQkFBRyxDQUFDLGdCQUFnQixnQkFBdUIsQ0FBQztBQUM1QztJQUFBO0lBdUJBLENBQUM7SUF0QmUsY0FBSSxHQUFsQjtRQUNFLFNBQVMsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLFlBQUMsQ0FBQyxPQUFPLENBQUMsbUJBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDL0IsWUFBQyxDQUFDLE9BQU8sQ0FBQyxtQkFBUSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNsQyxZQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFRLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFYSxjQUFJLEdBQWxCO1FBQ0UsU0FBUyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDMUIsWUFBQyxDQUFDLE9BQU8sQ0FBQyxtQkFBUSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNqQyxZQUFDLENBQUMsT0FBTyxDQUFDLG1CQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hDLFlBQUMsQ0FBQyxPQUFPLENBQUMsbUJBQVEsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVhLHlCQUFlLEdBQTdCO1FBQ0UsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDMUQsQ0FBQztJQUNhLGVBQUssR0FBbkI7UUFDRSxZQUFDLENBQUMsZ0JBQWdCLENBQUMsbUJBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRWMsaUJBQU8sR0FBRyxJQUFJLENBQUM7SUFDaEMsZ0JBQUM7Q0F2QkQsQUF1QkMsSUFBQTtBQXZCWSw4QkFBUztBQXlCdEIsWUFBQyxDQUFDLGdCQUFnQixDQUFDLHVCQUF1QixFQUFFLE9BQU8sRUFBRSxVQUFDLENBQUM7SUFDckQsSUFBSSxpQkFBTyxDQUFDLFdBQVcsRUFBRSxFQUFFO1FBQ3pCLGVBQU0sQ0FBQyxrQkFBa0IsQ0FBQyxpQkFBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7S0FDL0M7U0FBTTtRQUNMLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0tBQ2hFO0FBQ0gsQ0FBQyxDQUFDLENBQUM7Ozs7O0FDckNILDhEQUF3RTtBQUN4RSxxQkFBRyxDQUFDLGtCQUFrQixnQkFBdUIsQ0FBQztBQUM5QztJQUFBO0lBb0ZBLENBQUM7SUFqRmUsTUFBSSxHQUFsQixVQUFtQixJQUFzQjtRQUN2QyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtZQUM1QixPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbkI7YUFBTTtZQUNMLE9BQU8sSUFBZSxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQztJQUVhLFNBQU8sR0FBckIsVUFBc0IsSUFBc0IsRUFBRSxJQUFhO1FBQ3pELElBQUksR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLElBQUksSUFBSSxFQUFFO1lBQ1IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDL0I7YUFBTTtZQUNMLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztJQUVhLElBQUUsR0FBaEIsVUFBaUIsRUFBVTtRQUN6QixJQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6QyxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBK0IsRUFBRSxPQUFJLENBQUMsQ0FBQztTQUN4RDthQUFNO1lBQ0wsT0FBTyxPQUFPLENBQUM7U0FDaEI7SUFDSCxDQUFDO0lBQ2EsTUFBSSxHQUFsQixVQUFtQixJQUFZO1FBQzdCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ2EsS0FBRyxHQUFqQixVQUFrQixHQUFXO1FBQzNCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBQ2EsT0FBSyxHQUFuQixVQUFvQixFQUFVLEVBQUUsR0FBVztRQUN6Qyx1QkFBSyxDQUFDLGNBQU0sT0FBQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEVBQWpDLENBQWlDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRWEsa0JBQWdCLEdBQTlCLFVBQ0UsSUFBc0IsRUFDdEIsSUFBWSxFQUNaLFFBQTJCO1FBRTNCLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQU0sV0FBVyxHQUFHLFVBQUMsQ0FBUTtZQUMzQixJQUFJO2dCQUNGLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNiO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1osT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQztRQUNELElBQWdCLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3RELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFYSxNQUFJLEdBQWxCLFVBQW1CLElBQXNCLEVBQUUsS0FBNkI7UUFDdEUsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkIsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN4QyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDcEI7SUFDSCxDQUFDO0lBRWEsV0FBUyxHQUF2QixVQUNFLElBQXNCLEVBQ3RCLEtBQTZCO1FBRTdCLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDL0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsSUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzFCLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNiLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzNCO0lBQ0gsQ0FBQztJQUVhLFFBQU0sR0FBcEIsVUFDRSxPQUFVLEVBQ1YsT0FBZ0M7UUFFaEMsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBbEZhLEtBQUcsR0FBYSxRQUFRLENBQUM7SUFtRnpDLFFBQUM7Q0FwRkQsQUFvRkMsSUFBQTtBQXBGWSxjQUFDOzs7OztBQ0ZkLDREQUErRDtBQUMvRCx1Q0FBK0I7QUFDL0IscUJBQUcsQ0FBQyxpQkFBaUIsZ0JBQXVCLENBQUM7QUFDN0M7Ozs7OztHQU1HO0FBRUg7Ozs7R0FJRztBQUNILFNBQVMsa0JBQWtCLENBQUMsRUFBVTtJQUNsQyxJQUFJLElBQUksQ0FBQztJQUNULElBQUk7UUFDQSxJQUFJLEdBQUcsWUFBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUNuQjtJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1YsSUFBSSxHQUFHLFlBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDNUIsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDOUI7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBRUQ7O0dBRUc7QUFDVSxRQUFBLFFBQVEsR0FBRztJQUNwQixRQUFRLEVBQUUsWUFBQyxDQUFDLEdBQUcsQ0FBQyxlQUFlO0lBQy9CLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxTQUFTLENBQUM7SUFDdEMsT0FBTyxFQUFFLGtCQUFrQixDQUFDLFVBQVUsQ0FBQztJQUN2QyxTQUFTLEVBQUUsa0JBQWtCLENBQUMsWUFBWSxDQUFDO0lBQzNDLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxtQ0FBbUMsQ0FBQztJQUMvRCxJQUFJLEVBQUUsa0JBQWtCLENBQUMsa0NBQWtDLENBQUM7SUFDNUQsU0FBUyxFQUFFLGtCQUFrQixDQUFDLG9DQUFvQyxDQUFDO0lBQ25FLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQyx1QkFBdUIsQ0FBQztJQUN2RCxPQUFPLEVBQUUsa0JBQWtCLENBQUMsd0JBQXdCLENBQUM7SUFDckQsZUFBZSxFQUFFLGtCQUFrQixDQUFDLHVCQUF1QixDQUFDO0lBQzVELGlCQUFpQixFQUFFLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDO0lBQ3pELGtCQUFrQixFQUFFLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDO0lBQzNELFlBQVksRUFBRSxrQkFBa0IsQ0FDNUIsbURBQW1ELENBQ3REO0lBQ0QsVUFBVSxFQUFFLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDO0lBQ25ELEtBQUssRUFBRSxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7Q0FDckMsQ0FBQzs7Ozs7QUNsREYsNERBQStEO0FBQy9ELDhDQUE2QztBQUM3QyxxQkFBRyxDQUFDLGtCQUFrQixnQkFBdUIsQ0FBQztBQUM5QyxJQUFZLE9BS1g7QUFMRCxXQUFZLE9BQU87SUFDZix3REFBNkMsQ0FBQTtJQUM3Qyw0Q0FBaUMsQ0FBQTtJQUNqQyxvQ0FBeUIsQ0FBQTtJQUN6QiwwQkFBZSxDQUFBO0FBQ25CLENBQUMsRUFMVyxPQUFPLEdBQVAsZUFBTyxLQUFQLGVBQU8sUUFLbEI7QUFFRCxJQUFZLFFBS1g7QUFMRCxXQUFZLFFBQVE7SUFDaEIseUJBQWEsQ0FBQTtJQUNiLCtCQUFtQixDQUFBO0lBQ25CLHlCQUFhLENBQUE7SUFDYiwyQkFBZSxDQUFBO0FBQ25CLENBQUMsRUFMVyxRQUFRLEdBQVIsZ0JBQVEsS0FBUixnQkFBUSxRQUtuQjtBQUVEO0lBQUE7SUFZQSxDQUFDO0lBTmlCLGFBQUssR0FBbkI7UUFDSSxPQUFPLENBQUMsR0FBRyxHQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQWUsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDO1FBQ3JFLE9BQU8sQ0FBQyxJQUFJO1lBQ1AsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBaUIsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDO1FBQzlELE9BQU8sQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxJQUFJLE9BQU8sQ0FBQztJQUNoRSxDQUFDO0lBVmEsWUFBSSxHQUFHLG1CQUFRLENBQUMsT0FBTyxDQUFDO0lBVzFDLGNBQUM7Q0FaRCxBQVlDLElBQUE7QUFaWSwwQkFBTzs7Ozs7QUNqQnBCLDhEQUFpRTtBQUNqRSx1Q0FBK0I7QUFDL0IsdUNBQXNDO0FBQ3RDLHFCQUFHLENBQUMsZUFBZSxnQkFBdUIsQ0FBQztBQUMzQztJQUFBO0lBd0JBLENBQUM7SUFyQmlCLGFBQU8sR0FBckIsVUFBc0IsR0FBVztRQUM3QixLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FDbkIsT0FBTyxFQUNQLFdBQVMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLGlCQUFZLElBQUksQ0FBQyxLQUFLLENBQ3pELE1BQU0sQ0FBQyxXQUFXLENBQ3JCLFFBQUssQ0FDVCxDQUFDO1FBQ0YsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsQ0FBQztRQUN6RCxZQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsVUFBQyxJQUFJO1lBQ25CLElBQTBCLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztRQUNILFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRWEsVUFBSSxHQUFsQjtRQUNJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDekQsWUFBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFVBQUMsSUFBSTtZQUNuQixJQUEwQixDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDekMsQ0FBQyxDQUFDLENBQUM7UUFDSCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQXRCYSxVQUFJLEdBQUcsbUJBQVEsQ0FBQyxLQUFLLENBQUM7SUF1QnhDLFlBQUM7Q0F4QkQsQUF3QkMsSUFBQTtBQXhCWSxzQkFBSztBQTBCbEIsWUFBQyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQztJQUN0QyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUM7QUFDSCxZQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsVUFBQyxJQUFJO0lBQ3BCLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQztRQUNoQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQzs7Ozs7QUNyQ0gsNERBQXNFO0FBQ3RFLDBDQUE2QztBQUM3QyxxQkFBRyxDQUFDLGdCQUFnQixnQkFBdUIsQ0FBQztBQUM1Qzs7Ozs7O0dBTUc7QUFDSDtJQTJDRSxnQkFDVSxNQUFjLEVBQ2QsUUFBZ0IsRUFDeEIsUUFBK0I7UUFGdkIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLGFBQVEsR0FBUixRQUFRLENBQVE7UUFHeEIsSUFBSSxDQUFDLFFBQVEsR0FBRztZQUFDLGNBQVk7aUJBQVosVUFBWSxFQUFaLHFCQUFZLEVBQVosSUFBWTtnQkFBWix5QkFBWTs7WUFDM0IsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ2xELFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQixDQUFDLENBQUM7SUFDSixDQUFDO0lBakRhLGVBQVEsR0FBdEIsVUFDRSxNQUFjLEVBQ2QsUUFBc0IsRUFDdEIsUUFBc0M7UUFEdEMseUJBQUEsRUFBQSxjQUFzQjtRQUN0Qix5QkFBQSxFQUFBLFdBQWtDLFlBQUk7UUFFdEMsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFO1lBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMsd0RBQXdELENBQUMsQ0FBQztTQUMzRTtRQUNELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLElBQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQztRQUM3QixRQUFRLEdBQUc7WUFDVCxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztZQUN2Qix1QkFBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3JCLENBQUMsQ0FBQztRQUNGLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDbkUsQ0FBQztJQUVhLGNBQU8sR0FBckIsVUFBc0IsTUFBYyxFQUFFLFFBQXNCO1FBQTVELGlCQWlCQztRQWpCcUMseUJBQUEsRUFBQSxjQUFzQjtRQUMxRCxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQzNFO1FBQ0QsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDdEIsT0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQW1CLEVBQUUsTUFBMkI7WUFDbEUsSUFBSTtnQkFDRixJQUFNLFdBQVcsR0FBRztvQkFDbEIsTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7b0JBQ3ZCLE9BQU8sRUFBRSxDQUFDO2dCQUNaLENBQUMsQ0FBQztnQkFDRixLQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDO2FBQ3JFO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1osTUFBTSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7Z0JBQ3ZCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNiO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBaUJELHNCQUFrQixtQkFBUzthQUEzQjtZQUNFLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQztRQUN4QixDQUFDOzs7T0FBQTtJQUVPLHVCQUFNLEdBQWQsVUFDRSxNQUFjLEVBQ2QsUUFBZ0IsRUFDaEIsUUFBK0I7UUFFL0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU8saUNBQWdCLEdBQXhCO1FBQ0UsSUFBTSxPQUFPLEdBQUcsV0FBRyxFQUFFLENBQUM7UUFDdEIsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN6RSxJQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBQ2xDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDbkQsQ0FBQztJQUVPLHVCQUFNLEdBQWQ7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO1FBQzFDLElBQUksTUFBTSxDQUFDLFdBQVcsS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ3RDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNqQjthQUFNO1lBQ0wscUJBQXFCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVPLDhCQUFhLEdBQXJCO1FBQ0UsSUFBSSx1QkFBdUIsSUFBSSxNQUFNLEtBQUssS0FBSyxFQUFFO1lBQy9DLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMvQjtRQUNELElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBekZhLGlCQUFVLEdBQUcsRUFBRSxDQUFDO0lBc0NmLGNBQU8sR0FBRyxLQUFLLENBQUM7SUFDaEIsZUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsWUFBSSxDQUFDLENBQUM7SUFtRG5ELGFBQUM7Q0EzRkQsQUEyRkMsSUFBQTtBQTNGWSx3QkFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWbkIsd0NBQXNDO0FBQ3RDLHdDQUE2QztBQUM3QywyQ0FBMEM7QUFDMUMsOERBQWlFO0FBQ2pFLHVDQUErQjtBQUMvQix1Q0FBc0M7QUFDdEMscUJBQUcsQ0FBQyxxQkFBcUIsZ0JBQXVCLENBQUM7QUFNakQsSUFBTSxzQkFBc0IsR0FBb0I7SUFDNUMsS0FBSyxFQUFFLGNBQU0sT0FBQSxJQUFJLEVBQUosQ0FBSTtJQUNqQixTQUFTLEVBQUUsWUFBSTtDQUNsQixDQUFDO0FBRUY7SUFBQTtJQThDQSxDQUFDO0lBMUNpQixnQkFBSyxHQUFuQixVQUNJLGVBQXlEO1FBRDdELGlCQXVDQztRQXRDRyxnQ0FBQSxFQUFBLHdDQUF5RDtRQUV6RCxJQUFJLFdBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxLQUFLLElBQUksRUFBRTtZQUNuQyxZQUFDLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBc0IsQ0FBQyxLQUFLO2dCQUM3QyxXQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQztTQUNqQztRQUNELElBQUksV0FBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEtBQUssSUFBSSxFQUFFO1lBQzVCLFlBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFzQixDQUFDLEtBQUssR0FBRyxXQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztTQUNuRTtRQUNELFVBQVUsQ0FBQyxVQUFVLEdBQUcsVUFBTyxLQUFLOzs7Ozt3QkFDaEMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO3dCQUNqQixPQUFPLEdBQUcsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDOzZCQUNwQyxDQUFBLE9BQU8sS0FBSyxJQUFJLENBQUEsRUFBaEIsd0JBQWdCO3dCQUNoQixlQUFlLENBQUMsU0FBUyxFQUFFLENBQUM7d0JBQ3hCLEtBQUssR0FBRyxXQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQzt3QkFDL0IsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFOzRCQUNoQixLQUFLLEdBQUcsT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDO3lCQUN4RDt3QkFDRyxZQUFZLEdBQUcsV0FBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUM7d0JBQzdDLElBQUksWUFBWSxLQUFLLElBQUksRUFBRTs0QkFDdkIsWUFBWTtnQ0FDUixjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUM7eUJBQzNEO3dCQUNELHFCQUFNLG1CQUFXLENBQUMsTUFBTSxDQUNwQixtQkFBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLEVBQ3ZDLFdBQUksQ0FDUCxFQUFBOzt3QkFIRCxTQUdDLENBQUM7d0JBQ0YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDckIsVUFBVSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FDL0IsUUFBUSxFQUNSLFVBQVUsQ0FBQyxVQUFVLENBQ3hCLENBQUM7d0JBQ0YsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7O3dCQUV6QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7Ozs7O2FBRXRCLENBQUM7UUFDRixVQUFVLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQTFDYSxlQUFJLEdBQUcsbUJBQVEsQ0FBQyxVQUE2QixDQUFDO0lBQzlDLDZCQUFrQixHQUFHLEVBQUUsS0FBSyxFQUFFLGNBQU0sT0FBQSxJQUFJLEVBQUosQ0FBSSxFQUFFLFNBQVMsRUFBRSxZQUFJLEVBQUUsQ0FBQztJQTRDOUUsaUJBQUM7Q0E5Q0QsQUE4Q0MsSUFBQTtBQTlDWSxnQ0FBVTs7Ozs7QUNqQnZCLG1DQUFxQztBQUNyQyx1Q0FBcUM7QUFFckM7SUFBQTtJQU1BLENBQUM7SUFMZSxvQ0FBb0IsR0FBbEM7UUFDRSxxQkFBcUI7UUFDckIsa0JBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNsQixrQkFBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2xCLENBQUM7SUFDSCxzQkFBQztBQUFELENBTkEsQUFNQyxJQUFBO0FBTlksMENBQWU7Ozs7O0FDSDVCLGdEQUErQztBQVUvQyxTQUFTLGVBQWUsQ0FDcEIsT0FBZSxFQUNmLFVBQW1CLEVBQ25CLFNBQXdCLEVBQ3hCLEtBQVc7SUFFWCxpQkFBTyxDQUFDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxLQUFLLE9BQUEsRUFBRSxDQUFDLENBQUM7SUFDakUsT0FBTztRQUNILE9BQU8sU0FBQTtRQUNQLFVBQVUsWUFBQTtRQUNWLFNBQVMsV0FBQTtRQUNULEtBQUssT0FBQTtRQUNMLFdBQVcsRUFBRSxFQUFFO0tBQ2xCLENBQUM7QUFDTixDQUFDO0FBRUQ7SUFBQTtJQXVDQSxDQUFDO0lBdENpQixlQUFPLEdBQXJCLFVBQXNCLEdBQVcsRUFBRSxLQUFXO1FBQzFDLElBQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDdkUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLE9BQU8sQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDO1FBQzlCLE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVhLG1CQUFXLEdBQXpCOztRQUNJLE9BQU8sQ0FDSCxPQUFPLENBQUMsV0FBVyxDQUFDLFVBQVU7WUFDOUIsY0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFNBQVMsMENBQUUsS0FBSywwQ0FBRSxPQUFPLENBQUEsQ0FDakQsQ0FBQztJQUNOLENBQUM7SUFFYSxnQkFBUSxHQUF0QjtRQUNJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNDLElBQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsU0FBeUIsQ0FBQztRQUNoRSxJQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO1FBQ2xDLElBQU0sT0FBTyxHQUFHLGVBQWUsQ0FDM0IsT0FBTyxFQUNQLFNBQVMsQ0FBQyxVQUFVLEVBQ3BCLFNBQVMsQ0FBQyxTQUFTLEVBQ25CLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUNqQixDQUFDO1FBQ0YsT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7UUFDOUIsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVhLGFBQUssR0FBbkIsVUFBb0IsR0FBVyxFQUFFLEtBQVc7UUFDeEMsT0FBTyxDQUFDLFlBQVksR0FBRyxlQUFlLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDckUsT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDO0lBQy9DLENBQUM7SUFJTCxjQUFDO0FBQUQsQ0F2Q0EsQUF1Q0MsSUFBQTtBQXZDWSwwQkFBTztBQXlDbkIsTUFBYyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRTVCLDRDQUFvQztBQUNwQyw0Q0FBMkM7QUFDM0Msc0NBQXFDO0FBQ3JDLDREQUFzRTtBQUN0RSx3Q0FBc0M7QUFDdEMsb0RBQWtEO0FBQ2xELHFDQUFvQztBQUNwQyxxQkFBRyxDQUFDLGdCQUFnQixnQkFBdUIsQ0FBQztBQXdCNUMsU0FBUyxNQUFNLENBQUMsSUFBYSxFQUFFLE1BQW9CO0lBQy9DLE9BQU8sQ0FDSCxJQUFJLENBQUMsT0FBTyxLQUFLLE1BQU0sQ0FBQyxNQUFNO1FBQzlCLENBQUMsTUFBTSxDQUFDLElBQUksZUFBa0I7WUFDMUIsTUFBTSxDQUFDLElBQUksZ0NBQW1DLENBQUMsQ0FDdEQsQ0FBQztBQUNOLENBQUM7QUFDRCxTQUFTLGFBQWEsQ0FBQyxNQUFvQjtJQUN2QyxPQUFPLE1BQU0sQ0FBQyxJQUFJLGdDQUFtQyxDQUFDO0FBQzFELENBQUM7QUFFRDtJQUFBO0lBaU5BLENBQUM7SUFyTWlCLGdCQUFTLEdBQXZCLFVBQXdCLE9BQXVCLEVBQUUsVUFBa0I7UUFDL0QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU07WUFDbkIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDcEUsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztJQUNuQyxDQUFDO0lBRWEsWUFBSyxHQUFuQixVQUFvQixJQUFzQjtRQUN0QyxZQUFDLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFDLElBQUk7OztnQkFDbkIsS0FBcUIsSUFBQSxLQUFBLFNBQUEsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQSxnQkFBQSw0QkFBRTtvQkFBekMsSUFBTSxNQUFNLFdBQUE7b0JBQ2IsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxFQUFFO3dCQUN0QixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztxQkFDOUI7aUJBQ0o7Ozs7Ozs7OztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVhLDZCQUFzQixHQUFwQyxVQUFxQyxDQUFhO1FBQzlDLE9BQU8sdUJBQUssQ0FBQztZQUNULENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUNuQixJQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBMkIsQ0FBQztZQUM3QyxJQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ3hCLGlCQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN6QyxJQUFNLEdBQUcsR0FBRyx3QkFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN0RCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7WUFDckQsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFYSxzQkFBZSxHQUE3QixVQUE4QixJQUE0QjtRQUExRCxpQkFPQztRQU5HLE9BQU8sVUFBQyxDQUFhO1lBQ2pCLHVCQUFLLENBQUM7OztnQ0FDRixxQkFBTSxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLEVBQUE7OzRCQUF0QyxTQUFzQyxDQUFDOzRCQUN2QyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7aUJBQ1gsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVhLDBCQUFtQixHQUFqQyxVQUFrQyxDQUFhO1FBQzNDLE9BQU8sdUJBQUssQ0FBQztZQUNULG9EQUFvRDtZQUNwRCxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDbkIsSUFBTSxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQTBCLENBQUM7WUFDNUMsSUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUN2QixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDekMsT0FBTyx3QkFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyRCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFYSx3QkFBaUIsR0FBL0IsVUFBZ0MsQ0FBUTtRQUNwQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDbkIsT0FBTyxDQUFDLEtBQUssQ0FDVCw4REFBOEQsQ0FDakUsQ0FBQztJQUNOLENBQUM7SUFFYSwwQkFBbUIsR0FBakM7UUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQ3BCLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxlQUFlLEVBQUUsRUFDckQsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLEVBQzVELEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUNoRSxDQUFDO0lBQ04sQ0FBQztJQUNhLDJCQUFvQixHQUFsQztRQUNJLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDdEIsTUFBTSxDQUFDLEtBQUssRUFDWixNQUFNLENBQUMsU0FBUyxFQUNoQixNQUFNLENBQUMsU0FBUyxDQUNuQixDQUFDO0lBQ04sQ0FBQztJQUNhLHdCQUFpQixHQUEvQjtRQUNJLGdCQUFnRTthQUFoRSxVQUFnRSxFQUFoRSxxQkFBZ0UsRUFBaEUsSUFBZ0U7WUFBaEUsMkJBQWdFOztRQUVoRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSztZQUNqQixPQUFBLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQztRQUFsRCxDQUFrRCxDQUNyRCxDQUFDO0lBQ04sQ0FBQztJQUNhLDBCQUFtQixHQUFqQztRQUFrQyxnQkFBbUI7YUFBbkIsVUFBbUIsRUFBbkIscUJBQW1CLEVBQW5CLElBQW1CO1lBQW5CLDJCQUFtQjs7UUFDakQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFDLEtBQUssSUFBSyxPQUFBLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFuQyxDQUFtQyxDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUNhLHNCQUFlLEdBQTdCO1FBQ0ksTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRW1CLFdBQUksR0FBeEIsVUFBeUIsR0FBVzs7Ozs7O3dCQUNoQyxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7d0JBQzdCLHFCQUFNLHdCQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxtQkFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFBOzt3QkFBckQsR0FBRyxHQUFHLFNBQStDO3dCQUMzRCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7d0JBQ3JELHNCQUFPLEdBQUcsRUFBQzs7OztLQUNkO0lBRW1CLHlCQUFrQixHQUF0QyxVQUF1QyxJQUFZOzs7O2dCQUN6QyxHQUFHLEdBQUcsd0JBQVUsQ0FBQyxPQUFPLENBQzFCLE1BQU0sQ0FBQyxVQUFVLEdBQUcsSUFBSSxFQUN4QixtQkFBUSxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztnQkFDRixNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JELHNCQUFPLEdBQUcsRUFBQzs7O0tBQ2Q7SUF3RmMsb0JBQWEsR0FBNUIsVUFBNkIsTUFBb0I7UUFDN0MsT0FBTztZQUNILE1BQU0sRUFBRSxNQUFNLENBQUMsTUFBTTtZQUNyQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7WUFDakIsS0FBSyxFQUFFLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUM5QyxDQUFDO0lBQ04sQ0FBQztJQUNjLGtCQUFXLEdBQTFCLFVBQTJCLEdBQVc7UUFDbEMsSUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsT0FBTyxHQUFHLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUM5RCxDQUFDO0lBL01hLGdCQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDNUIsWUFBSyxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pCLGdCQUFTLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFNUIseUJBQWtCLEdBQUcsWUFBSSxDQUFDO0lBQzFCLHNCQUFlLEdBQUcsVUFBQyxLQUFZLElBQUssT0FBQSxLQUFLLENBQUMsY0FBYyxFQUFFLEVBQXRCLENBQXNCLENBQUM7SUFDM0QsMEJBQW1CLEdBQUcsVUFBQyxLQUFZO1FBQzdDLE9BQUEsS0FBSyxDQUFDLGNBQWMsRUFBRTtJQUF0QixDQUFzQixDQUFDO0lBRWIsaUJBQVUsR0FBRyxFQUFFLENBQUM7SUFzR2YscUJBQWMsR0FBRztRQUM1QixDQUFDLEVBQUUsVUFBQyxNQUF3QixFQUFFLElBQWE7WUFDdkMsSUFBTSxLQUFLLEdBQUcsSUFBeUIsQ0FBQztZQUN4QyxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDdkIsSUFBSSxpQkFBZSxHQUFHLElBQUksQ0FBQztnQkFDM0IsSUFBTSxNQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQztnQkFDeEIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUUsS0FBSztvQkFDdEMsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFJLENBQUMsQ0FBQztvQkFDOUIsaUJBQWUsR0FBRyxpQkFBZSxJQUFJLENBQUMsSUFBSSxDQUFDO29CQUMzQyxJQUFJLElBQUksRUFBRTt3QkFDTixZQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztxQkFDM0M7Z0JBQ0wsQ0FBQyxDQUFDLENBQUM7Z0JBQ0gsSUFBSSxpQkFBZSxFQUFFO29CQUNqQixJQUFJLE1BQUksQ0FBQyxNQUFNLENBQUMsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxLQUFLLEVBQUU7d0JBQ3hDLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQzs0QkFDaEMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDOzRCQUNuQixhQUFLLENBQUMsT0FBTyxDQUFDLE1BQUksQ0FBQyxDQUFDO3dCQUN4QixDQUFDLENBQUMsQ0FBQztxQkFDTjt5QkFBTTt3QkFDSCxZQUFDLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFDLENBQUM7NEJBQ2hDLE9BQUEsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQWUsQ0FBQzt3QkFBOUMsQ0FBOEMsQ0FDakQsQ0FBQztxQkFDTDtpQkFDSjthQUNKO2lCQUFNO2dCQUNILFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQztvQkFDaEMsT0FBQSxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBZSxDQUFDO2dCQUE5QyxDQUE4QyxDQUNqRCxDQUFDO2FBQ0w7UUFDTCxDQUFDO1FBQ0QsR0FBRyxFQUFFLFVBQUMsTUFBd0IsRUFBRSxJQUFhO1lBQ3pDLElBQU0sT0FBTyxHQUFHLElBQXdCLENBQUM7WUFDekMsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ3ZCLElBQUksaUJBQWUsR0FBRyxJQUFJLENBQUM7Z0JBQzNCLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSSxFQUFFLEtBQUs7b0JBQ3RDLElBQU0sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3RDLGlCQUFlLEdBQUcsaUJBQWUsSUFBSSxJQUFJLENBQUM7b0JBQzFDLElBQUksSUFBSSxFQUFFO3dCQUNOLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO3FCQUMzQztnQkFDTCxDQUFDLENBQUMsQ0FBQztnQkFDSCxJQUFJLGlCQUFlLEVBQUU7b0JBQ2pCLFlBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQUMsQ0FBQzt3QkFDaEMsT0FBQSxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBZSxDQUFDO29CQUE5QyxDQUE4QyxDQUNqRCxDQUFDO2lCQUNMO2FBQ0o7aUJBQU07Z0JBQ0gsWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsVUFBQyxDQUFDO29CQUNoQyxPQUFBLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxDQUFlLENBQUM7Z0JBQTlDLENBQThDLENBQ2pELENBQUM7YUFDTDtRQUNMLENBQUM7UUFDRCxJQUFJLEVBQUUsVUFBQyxNQUF3QixFQUFFLElBQWE7WUFDMUMsSUFBTSxRQUFRLEdBQUcsSUFBdUIsQ0FBQztZQUN6QyxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDdkIsSUFBSSxpQkFBZSxHQUFHLElBQUksQ0FBQztnQkFDM0IsTUFBTSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUUsS0FBSztvQkFDdEMsSUFBTSxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDdkMsaUJBQWUsR0FBRyxpQkFBZSxJQUFJLElBQUksQ0FBQztvQkFDMUMsSUFBSSxJQUFJLEVBQUU7d0JBQ04sWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7cUJBQzNDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUNILElBQUksaUJBQWUsRUFBRTtvQkFDakIsWUFBQyxDQUFDLGdCQUFnQixDQUNkLElBQUksRUFDSixRQUFRLEVBQ1IsTUFBTSxDQUFDLGlCQUFpQixDQUMzQixDQUFDO2lCQUNMO2FBQ0o7aUJBQU07Z0JBQ0gsWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDaEU7UUFDTCxDQUFDO0tBQ0osQ0FBQztJQUVhLGNBQU8sR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQUVwRCxxQkFBYyxHQUF1QyxJQUFJLEdBQUcsRUFHeEUsQ0FBQztJQUVXLGdCQUFTLEdBQUcsZ0JBQWdCLENBQUM7SUFhaEQsYUFBQztDQWpORCxBQWlOQyxJQUFBO0FBak5ZLHdCQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUNuQiwyQ0FBeUU7QUFDekUsaURBQXFEO0FBQ3JELDRDQUEyQztBQUMzQyxzREFBdUQ7QUFDdkQsNERBQThFO0FBRTlFLHdDQUE2QztBQUM3QywyQ0FBMEM7QUFDMUMsb0RBQW1FO0FBRW5FLHFCQUFHLENBQUMsaUJBQWlCLGdCQUF1QixDQUFDO0FBVTdDO0lBQUE7SUE4REEsQ0FBQztJQTNEaUIsb0JBQVksR0FBMUIsVUFBMkIsSUFBYztRQUNyQyxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3hCLElBQUksR0FBRyxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7WUFDakIsR0FBRyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQzNCLElBQU0sSUFBSSxHQUFHO2dCQUNULEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO2dCQUNwQixHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQztnQkFDcEIsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7Z0JBQ3BCLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDO2dCQUNwQixHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQzthQUN2QixDQUFDO1lBQ0YsSUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsT0FBUixJQUFJLFdBQVEsSUFBSSxFQUFDLENBQUM7WUFDOUIsR0FBRyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztTQUN2QztRQUVELG1CQUFRLENBQUMsZUFBZSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUM7UUFDekMsbUJBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUNyRCxtQkFBUSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3RELG1CQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUM3QyxDQUFDO0lBRWEsYUFBSyxHQUFuQixVQUFvQixNQUE0QjtRQUM1QywrQkFBYSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNqQyxzQ0FBc0M7UUFDdEMsK0JBQWUsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQ3ZDLHdCQUFVLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUN6QyxtQkFBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0RCxXQUFJLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxtQkFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQy9DLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRWEscUJBQWEsR0FBM0IsVUFBNEIsU0FBaUI7UUFDekMsV0FBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLFVBQUMsS0FBSztZQUNwQyxXQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQyxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFYSw0QkFBb0IsR0FBbEMsVUFBbUMsU0FBaUI7UUFBcEQsaUJBU0M7UUFSRyxPQUFPLFVBQUMsTUFBVztZQUNmLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO2dCQUM1QixJQUFJLENBQUMsc0JBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRTtvQkFDekIsNEJBQW9CLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2lCQUMzQztnQkFDRCxLQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNqQztRQUNMLENBQUMsQ0FBQztJQUNOLENBQUM7SUFFYSxrQkFBVSxHQUF4QixVQUF5QixHQUFXLEVBQUUsU0FBYztRQUNoRCxXQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUMvQixDQUFDO0lBRWEsd0JBQWdCLEdBQTlCLFVBQStCLElBQVksRUFBRSxPQUEwQjtRQUNuRSxXQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxXQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQTFEYSxlQUFPLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBNERqQyxnQkFBUSxHQUFHLElBQUksd0JBQWEsRUFBRSxDQUFDO0lBQ2xELGNBQUM7Q0E5REQsQUE4REMsSUFBQTtBQTlEWSwwQkFBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQnBCLDJDQUEwQztBQUMxQyxHQUFHLENBQUMseUJBQXlCLGdCQUF1QixDQUFDO0FBQ3JELFNBQXNCLEtBQUssQ0FDekIsSUFBeUI7OztZQUV6QixzQkFBTyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBQzs7O0NBQ3hCO0FBSkQsc0JBSUM7QUFFRCxTQUFnQixPQUFPLENBQ3JCLElBQXlCO0lBRDNCLGlCQVdDO0lBUkMsT0FBTztRQUFPLGNBQVk7YUFBWixVQUFZLEVBQVoscUJBQVksRUFBWixJQUFZO1lBQVoseUJBQVk7Ozs7Z0JBQ3hCLElBQUk7b0JBQ0Ysc0JBQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFDO2lCQUNuQjtnQkFBQyxPQUFPLEtBQUssRUFBRTtvQkFDZCxXQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDeEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDdEI7Ozs7S0FDRixDQUFDO0FBQ0osQ0FBQztBQVhELDBCQVdDO0FBUUQsSUFBSSxVQUFVLGdCQUF1QyxDQUFDO0FBRXRELFNBQWdCLGFBQWEsQ0FBQyxLQUFxQjtJQUNqRCxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLENBQUM7QUFGRCxzQ0FFQztBQUVELFNBQWdCLEdBQUcsQ0FBQyxPQUFlLEVBQUUsVUFBMEI7SUFDN0QsSUFBSSxVQUFVLElBQUksVUFBVSxFQUFFO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDdEI7QUFDSCxDQUFDO0FBSkQsa0JBSUM7Ozs7O0FDckNELHFEQUF3RDtBQUN4RCxxQkFBRyxDQUFDLGVBQWUsZ0JBQXVCLENBQUM7QUFDM0MscUNBQXFDO0FBQ3JDLFNBQWdCLElBQUksS0FBSSxDQUFDO0FBQXpCLG9CQUF5QjtBQUN6QixTQUFnQixHQUFHO0lBQ2pCLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM5QixDQUFDO0FBRkQsa0JBRUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkQsNENBQW9DO0FBQ3BDLHFEQUF3RDtBQUN4RCxpQ0FBK0I7QUFDL0IscUJBQUcsQ0FBQyxxQkFBcUIsZ0JBQXVCLENBQUM7QUFJakQ7SUFBQTtJQXFLQSxDQUFDO0lBbEtpQixpQkFBTSxHQUFwQjtRQUNJLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQzNCLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFYSxxQkFBVSxHQUF4QjtRQUNJLE9BQU8sVUFBVSxDQUFDLFFBQVEsQ0FBQztJQUMvQixDQUFDO0lBRWEsb0JBQVMsR0FBdkIsVUFBd0IsSUFBWSxFQUFFLE9BQWU7UUFDakQsSUFBSSxVQUFVLENBQUMsUUFBUSxFQUFFO1lBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQ1gsd0VBQXdFLENBQzNFLENBQUM7U0FDTDtRQUNELElBQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDOUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ3hCLEdBQUcsQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQzNCLENBQUM7SUFFYSwrQkFBb0IsR0FBbEMsVUFBbUMsSUFBZTtRQUM5QyxxQkFBRyxDQUFDLDZCQUE2QixtQkFBMEIsQ0FBQztRQUM1RCxVQUFVLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztJQUNuQyxDQUFDO0lBRWEsZUFBSSxHQUFsQixVQUFtQixJQUFZLEVBQUUsSUFBc0I7UUFDbkQsT0FBTyxJQUFJLE9BQU8sQ0FBVSxVQUFDLE9BQU8sRUFBRSxNQUFNO1lBQ3hDLElBQUk7Z0JBQ0EscUJBQUcsQ0FBQyxZQUFZLG1CQUEwQixDQUFDO2dCQUMzQyxJQUFNLE9BQU8sR0FBRyxZQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM3QixJQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ3JDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDbEMsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsRCxVQUFVLENBQUMsOEJBQThCLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUMxRCxVQUFVLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZDLE9BQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO2dCQUN2QixPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMxQixxQkFBRyxDQUFDLFVBQVUsbUJBQTBCLENBQUM7Z0JBQ3pDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztnQkFDMUIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2pCO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1YsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2Y7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFbUIsa0JBQU8sR0FBM0IsVUFBNEIsR0FBVyxFQUFFLElBQXNCOzs7Ozs7d0JBQ3BELEtBQUEsQ0FBQSxLQUFBLFVBQVUsQ0FBQSxDQUFDLElBQUksQ0FBQTt3QkFBQyxxQkFBTSxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFBOzRCQUFwRCxzQkFBTyxjQUFnQixTQUE2QixFQUFFLElBQUksRUFBQyxFQUFDOzs7O0tBQy9EO0lBRWEsa0JBQU8sR0FBckIsVUFBc0IsR0FBVztRQUM3QixPQUFPLElBQUksT0FBTyxDQUFTLFVBQUMsT0FBTyxFQUFFLE1BQU07WUFDdkMsSUFBSTtnQkFDQSxxQkFBRyxDQUFDLGVBQWUsbUJBQTBCLENBQUM7Z0JBQzlDLElBQU0sU0FBTyxHQUFHLElBQUksY0FBYyxFQUFFLENBQUM7Z0JBQ3JDLFNBQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDL0IsU0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkIsU0FBTyxDQUFDLGtCQUFrQixHQUFHO29CQUN6QixJQUFJLFNBQU8sQ0FBQyxVQUFVLEtBQUssQ0FBQyxFQUFFO3dCQUMxQixxQkFBRyxDQUFDLGlCQUFpQixtQkFBMEIsQ0FBQzt3QkFDaEQsT0FBTyxDQUFDLFNBQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztxQkFDakM7Z0JBQ0wsQ0FBQyxDQUFDO2FBQ0w7WUFBQyxPQUFPLEdBQUcsRUFBRTtnQkFDVixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDZjtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQU1jLHlDQUE4QixHQUE3QyxVQUNJLElBQXNCLEVBQ3RCLE9BQWU7UUFFZixJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsR0FBRyxJQUFLLE9BQUEsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsRUFBckIsQ0FBcUIsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFYyw0QkFBaUIsR0FBaEM7UUFDSSxxQkFBRyxDQUFDLFlBQVksbUJBQTBCLENBQUM7UUFDM0MsSUFBTSxDQUFDLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQUM1QixNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQ2pDLFVBQUMsSUFBSTtZQUNELE9BQUEsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FDakQsVUFBVSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBWSxFQUM1QyxDQUFDLEVBQ0QsQ0FBQyxDQUNPLENBQUM7UUFKYixDQUlhLENBQ3BCLENBQUM7SUFDTixDQUFDO0lBRWMsdUJBQVksR0FBM0IsVUFBNEIsQ0FBUztRQUNqQyxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDYixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hCLEdBQUcsSUFBSSxJQUFJLENBQUM7U0FDZjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVjLDJCQUFnQixHQUEvQixVQUNJLElBQWEsRUFDYixTQUFzQixFQUN0QixLQUFhO1FBRWIsSUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM1QyxJQUFJLEtBQUssR0FBRyxHQUFHLEVBQUU7WUFDYixLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQztZQUNuRCxNQUFNLElBQUksS0FBSyxDQUNYLGtFQUFrRTtnQkFDOUQsOERBQThEO2dCQUM5RCxTQUFTO2dCQUNULDZDQUE2QztnQkFDN0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FDckMsQ0FBQztTQUNMO1FBQ0QsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUM1QyxJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7WUFDZixPQUFPLElBQUksQ0FBQztTQUNmO1FBQ0QsSUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xELElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtZQUNsQixPQUFPLElBQUksQ0FBQztTQUNmO1FBQ0QsSUFBSSxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3JCLE9BQU8sT0FBTyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBVixDQUFVLENBQUMsQ0FBQztRQUM5RCxPQUFPLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsQ0FBQztZQUMxQyxJQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDbkUsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO2dCQUNoQixDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3hCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFYywyQkFBZ0IsR0FBL0IsVUFDSSxJQUErQjtRQUUvQixJQUFJLElBQUksS0FBSyxTQUFTLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtZQUNyQyxPQUFPLElBQUksQ0FBQztTQUNmO1FBQ0QsSUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QyxJQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtZQUMzQyxPQUFPLElBQUksQ0FBQztTQUNmO1FBQ0QsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBWSxDQUFDO0lBQzlDLENBQUM7SUFFYyxnQ0FBcUIsR0FBcEMsVUFBcUMsSUFBc0I7UUFDdkQsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQUk7WUFDMUMsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM1QyxJQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbEQsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFO2dCQUNqQixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQzdCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBbkthLGdCQUFLLEdBQVUsRUFBRSxDQUFDO0lBd0VqQixtQkFBUSxHQUFHLEtBQUssQ0FBQztJQUVqQix1QkFBWSxHQUFjLFlBQUksQ0FBQztJQTBGbEQsaUJBQUM7Q0FyS0QsQUFxS0MsSUFBQTtBQXJLWSxnQ0FBVTs7Ozs7QUNQdkIsNENBQTJDO0FBQzNDLDhDQUFzQztBQUN0QyxxREFBd0Q7QUFDeEQscUJBQUcsQ0FBQyxxQkFBcUIsZ0JBQXVCLENBQUM7QUFDakQ7SUFBQTtJQWtDQSxDQUFDO0lBakNlLGlCQUFLLEdBQW5CO1FBQ0UsV0FBVyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDMUIsQ0FBQztJQUVELHNCQUFrQixtQkFBSTthQUF0QjtZQUNFLFdBQVcsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO1lBQ3pCLE9BQU8sV0FBVyxDQUFDLE1BQU0sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDO1FBQ2xELENBQUM7OztPQUFBO0lBRWEsbUJBQU8sR0FBckIsVUFBc0IsSUFBYTtRQUNqQyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNXLHNCQUFVLEdBQXhCLFVBQXlCLElBQXNCO1FBQzdDLFlBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7O09BRUc7SUFDVyxrQ0FBc0IsR0FBcEM7UUFDRSxXQUFXLENBQUMsVUFBVSxDQUFDLG1CQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVjLG1CQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQ1osa0JBQU0sR0FBRyxrQkFBa0IsQ0FBQztJQUM3QyxrQkFBQztDQWxDRCxBQWtDQyxJQUFBO0FBbENZLGtDQUFXOzs7OztBQ0p4QixxREFBd0Q7QUFFeEQscUJBQUcsQ0FBQyxjQUFjLGdCQUF1QixDQUFDO0FBRTFDLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQztBQUVsQixJQUFJLFdBQWtDLENBQUM7QUFDdkMsSUFBSSxVQUFVLENBQUM7QUFDZixJQUFNLFlBQVksR0FBRyxJQUFJLE9BQU8sQ0FBQyxVQUFDLE9BQThCLEVBQUUsTUFBTTtJQUN0RSxXQUFXLEdBQUcsT0FBTyxDQUFDO0lBQ3RCLFVBQVUsR0FBRyxNQUFNLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUU7SUFDNUMscUJBQUcsQ0FBQyxtQkFBbUIsbUJBQTBCLENBQUM7SUFDbEQsS0FBSyxHQUFHLElBQUksQ0FBQztJQUNiLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwQixDQUFDLENBQUMsQ0FBQztBQUVILFNBQWdCLE9BQU87SUFDckIsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRkQsMEJBRUM7QUFDRCxTQUFnQixjQUFjO0lBQzVCLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7QUFDdEQsQ0FBQztBQUZELHdDQUVDOzs7OztBQ3hCRCxtREFBMkM7QUFFM0M7SUFtQkUsbUJBQW9CLEtBQWM7UUFBbEMsaUJBY0M7UUFkbUIsVUFBSyxHQUFMLEtBQUssQ0FBUztRQUNoQyxZQUFDLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRTtZQUNqQzt3RUFDNEQ7WUFDNUQsS0FBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXRDLHdEQUF3RDtZQUN4RCxJQUFNLEtBQUssR0FBRyxLQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFpQyxDQUFDO1lBQzNELElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFFO2dCQUNuQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7YUFDOUI7aUJBQU07Z0JBQ0wsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO2FBQy9CO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBaENhLGtCQUFRLEdBQXRCO1FBQ0UsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZCLElBQU0sVUFBVSxHQUFHLFlBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkMsS0FBSyxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUUsUUFBUSxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxRQUFRLEVBQUU7WUFDL0QsSUFBTSxJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN2QyxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7Z0JBQ2hCLFNBQVM7YUFDVjtZQUNELFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDaEQ7SUFDSCxDQUFDO0lBRWEsb0JBQVUsR0FBeEI7UUFDRSxTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBRWMsb0JBQVUsR0FBZ0IsRUFBRSxDQUFDO0lBaUI5QyxnQkFBQztDQWxDRCxBQWtDQyxJQUFBO0FBbENZLDhCQUFTOzs7OztBQ0Z0QixTQUFnQixXQUFXO0lBQ3pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRkQsa0NBRUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkQseURBQXVEO0FBQ3ZELHlDQUF3QztBQUN4QywrQ0FBNkM7QUFDN0MsK0NBQTJEO0FBQzNELHlDQUF3QztBQUV4QyxvR0FBb0c7QUFDcEcsU0FBZ0IsaURBQWlEO0lBQzdELHVGQUF1RjtJQUN2Riw4Q0FBOEM7SUFDOUMsMEJBQVcsRUFBRSxDQUFDO0FBQ2xCLENBQUM7QUFKRCw4R0FJQztBQUVELFNBQXNCLFFBQVE7Ozs7d0JBQzFCLHFCQUFNLElBQUksT0FBTyxDQUFDLFVBQUMsQ0FBTSxJQUFLLE9BQUEsVUFBVSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQyxFQUFBOztvQkFBakQsU0FBaUQsQ0FBQztvQkFDbEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDekIscUJBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDckIscUJBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztvQkFDckIsaURBQWlELEVBQUUsQ0FBQztvQkFDcEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7Ozs7Q0FDM0I7QUFQRCw0QkFPQztBQUVELDJCQUFZLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBaUI7SUFDbkMsd0JBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbEQsQ0FBQyxDQUFDLENBQUM7QUFDRixNQUFjLENBQUMsVUFBVSxHQUFHLHdCQUFVLENBQUM7QUFFeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQ2xDLDhGQUE4RjtBQUM5RixNQUFNLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxFQUFFLGNBQU0sT0FBQSxRQUFRLEVBQUUsRUFBVixDQUFVLENBQUMsQ0FBQzs7Ozs7QUNyQnpELHdEQUF3RDtBQUN4RCxJQUFJO0FBQ0osc0JBQXNCO0FBQ3RCLDhDQUE4QztBQUM5QyxJQUFJO0FBRUosa0hBQWtIO0FBQ2xILHlDQUF5QztBQUV6Qyw2R0FBNkc7QUFDN0csb0dBQW9HO0FBRXZGLFFBQUEsWUFBWSxHQUFHO0lBQ3hCLDJHQUEyRztJQUMzRztRQUNJLElBQUksRUFBRSxRQUFRO1FBQ2QsT0FBTyxFQUFFLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztLQUN6QztJQUNEO1FBQ0ksSUFBSSxFQUFFLFFBQVE7UUFDZCxPQUFPLEVBQUUsT0FBTyxDQUFDLG9CQUFvQixDQUFDO0tBQ3pDO0lBQ0Q7UUFDSSxJQUFJLEVBQUUsUUFBUTtRQUNkLE9BQU8sRUFBRSxPQUFPLENBQUMsb0JBQW9CLENBQUM7S0FDekM7Q0FFSixDQUFDOzs7QUNuQ0Y7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7Ozs7QUNEQSxtREFBMkM7QUFFM0M7SUF3QkUsbUJBQW9CLEtBQWM7UUFBbEMsaUJBa0JDO1FBbEJtQixVQUFLLEdBQUwsS0FBSyxDQUFTO1FBTDFCLGVBQVUsR0FBRyxDQUFDLENBQUM7UUFDZixlQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsV0FBTSxHQUFjLEVBQUUsQ0FBQztRQUN2QixTQUFJLEdBQWMsRUFBRSxDQUFDO1FBRzNCLFlBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxVQUFDLElBQUk7WUFDM0IsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztZQUM3QixJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsRUFBRTtnQkFDM0MsWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQWxCLENBQWtCLENBQUMsQ0FBQzthQUM3RDtpQkFBTSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsRUFBRTtnQkFDbEQsWUFBQyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsY0FBTSxPQUFBLEtBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQWpCLENBQWlCLENBQUMsQ0FBQzthQUM1RDtpQkFBTSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsRUFBRTtnQkFDNUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDeEI7aUJBQU0sSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxFQUFFO2dCQUMxQyxLQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QjtRQUNILENBQUMsQ0FBQyxDQUFDO2dDQUNNLENBQUM7WUFDUixZQUFDLENBQUMsZ0JBQWdCLENBQUMsT0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLGNBQU0sT0FBQSxLQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFqQixDQUFpQixDQUFDLENBQUM7OztRQURyRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO29CQUFoQyxDQUFDO1NBRVQ7UUFDRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUF6Q2Esa0JBQVEsR0FBdEI7UUFDRSxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkIsSUFBTSxVQUFVLEdBQUcsWUFBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN2QyxLQUFLLElBQUksT0FBTyxHQUFHLENBQUMsRUFBRSxPQUFPLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxFQUFFLE9BQU8sRUFBRTtZQUM1RCxJQUFNLElBQUksR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3RDLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtnQkFDaEIsU0FBUzthQUNWO1lBQ0QsU0FBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNoRDtJQUNILENBQUM7SUFFYSxvQkFBVSxHQUF4QjtRQUNFLFNBQVMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO0lBQzVCLENBQUM7SUE2Qk0sNkJBQVMsR0FBaEIsVUFBaUIsQ0FBUztRQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFDTSw4QkFBVSxHQUFqQixVQUFrQixDQUFTO1FBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUNNLDZCQUFTLEdBQWhCLFVBQWlCLEtBQWE7UUFDNUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUMxQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDbEUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFpQixDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1NBQ3hEO1FBQ0QsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3pDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN6QztRQUNBLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBaUIsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN0RSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUE1Q2Msb0JBQVUsR0FBZ0IsRUFBRSxDQUFDO0lBNkM5QyxnQkFBQztDQTlERCxBQThEQyxJQUFBO0FBOURZLDhCQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0Z0QixnREFBK0M7QUFFL0MsbURBQTJDO0FBQzNDLG1EQUFrRDtBQUNsRCwrQ0FBOEM7QUFDOUMsb0RBQW1EO0FBQ25ELGtEQUEyRTtBQUMzRSxxREFBb0Q7QUFFcEQsMkRBQXlEO0FBQ3pELDZEQUEyRDtBQUMzRCwrQ0FBdUQ7QUFHdkQsSUFBTSxLQUFLLEdBQUc7OztvQkFDVixxQkFBTSxzQkFBYyxFQUFFLEVBQUE7O2dCQUF0QixTQUFzQixDQUFDO2dCQUN2QiwyRUFBMkU7Z0JBQzNFLHVFQUF1RTtnQkFDdkUscURBQXFEO2dCQUNyRCx5RUFBeUU7Z0JBQ3pFLGNBQWM7Z0JBQ2QsSUFBSTtnQkFDSixrQ0FBa0M7Z0JBQ2xDLGlCQUFPLENBQUMsS0FBSyxDQUFDO29CQUNWLFNBQVMsRUFBRSxzQkFBc0I7b0JBQ2pDLFVBQVUsRUFBRSxhQUFhO29CQUN6QixlQUFlLEVBQUU7d0JBQ2IsS0FBSyxFQUFMOzRCQUNJLElBQUk7Z0NBQ0EsSUFBTSxRQUFRLEdBQUcsWUFBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQXdCLENBQUM7Z0NBQzFELE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUM1QixJQUFJLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRSxFQUFFO29DQUN2QixPQUFPLHFEQUFxRCxDQUFDO2lDQUNoRTtxQ0FBTTtvQ0FDSCxPQUFPLElBQUksQ0FBQztpQ0FDZjs2QkFDSjs0QkFBQyxPQUFPLEtBQUssRUFBRTtnQ0FDWixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUNuQixPQUFPLHFEQUFxRCxDQUFDOzZCQUNoRTt3QkFDTCxDQUFDO3dCQUNELFNBQVMsRUFBVDs0QkFDSSxXQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBSSxZQUFDLENBQUMsRUFBRSxDQUN0QixXQUFXLENBQ1UsQ0FBQyxLQUFLLENBQUM7NEJBQ2hDLE9BQU87d0JBQ1gsQ0FBQztxQkFDSjtvQkFFRCxVQUFVLGNBQXFCO29CQUV6QixLQUFLLEVBQVg7Ozs7Ozt3Q0FDSSxtQkFBbUI7d0NBQ25CLGVBQU0sQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO3dDQUM3QixlQUFNLENBQUMsU0FBUyxDQUNaOzRDQUNJO2dEQUNJLElBQUksNkJBQWdDO2dEQUNwQyxNQUFNLGFBQWdCOzZDQUN6Qjs0Q0FDRCxFQUFFLElBQUksYUFBZ0IsRUFBRSxNQUFNLG1CQUFtQixFQUFFOzRDQUNuRDtnREFDSSxJQUFJLDZCQUFnQztnREFDcEMsTUFBTSxpQkFBa0I7NkNBQzNCO3lDQUNKLEVBQ0QsUUFBUSxDQUNYLENBQUM7d0NBQ0YsaUJBQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQzt3Q0FDdkQsdUNBQXVDO3dDQUN2Qyx3QkFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO3dDQUNwQix3QkFBVSxDQUFDLG9CQUFvQixDQUFDOzRDQUM1QiwwQkFBVyxDQUFDLEtBQUssRUFBRSxDQUFDOzRDQUNwQiwwQkFBVyxDQUFDLHNCQUFzQixFQUFFLENBQUM7NENBQ3JDLGVBQU0sQ0FBQyxLQUFLLENBQUMsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs0Q0FDL0IsZUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzt3Q0FDdEIsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsa0NBQWtDO3dDQUNsQyxZQUFDLENBQUMsZ0JBQWdCLENBQUMsbUJBQVEsQ0FBQyxPQUFPLHVCQUFvQixVQUFDLENBQUM7NENBQ3JELElBQU0sRUFBRSxHQUFHLENBQWUsQ0FBQzs0Q0FDM0IsSUFBTSxHQUFHLEdBQUc7Z0RBQ1IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxPQUFPO2dEQUNiLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTztnREFDYixFQUFFLEVBQUcsRUFBRSxDQUFDLE1BQXNCLENBQUMsRUFBRTs2Q0FDcEMsQ0FBQzs0Q0FDRixpQkFBTyxDQUFDLG9CQUFvQixxQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3Q0FDeEQsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsWUFBQyxDQUFDLGdCQUFnQixDQUFDLG1CQUFRLENBQUMsUUFBUSxFQUFFLFVBQVUsRUFBRSxVQUFDLENBQUM7NENBQ2hELElBQU0sRUFBRSxHQUFHLENBQWtCLENBQUM7NENBQzlCLElBQU0sR0FBRyxHQUFHO2dEQUNSLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRztnREFDWCxFQUFFLEVBQUcsRUFBRSxDQUFDLFVBQTBCLENBQUMsRUFBRTs2Q0FDeEMsQ0FBQzs0Q0FDRixpQkFBTyxDQUFDLG9CQUFvQix1QkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3Q0FDekQsQ0FBQyxDQUFDLENBQUM7d0NBRUcsS0FBSyxHQUFHLFFBQVEsQ0FBQyxnQkFBMkIsQ0FBQzt3Q0FDbkQsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxVQUFDLENBQUM7NENBQ2xDLElBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7NENBQzVCLElBQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7NENBQzNCLElBQU0sS0FBSyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7NENBQ25DLElBQ0ksSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRTtnREFDckMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxFQUFFO29EQUNsQyxLQUFLLEdBQUcsaUJBQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUN6QztnREFDRSxpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dEQUN2QixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dEQUN2QixpQkFBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO2dEQUM3QixJQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDO2dEQUM3QixpQkFBTyxDQUFDLG9CQUFvQix1QkFBbUIsQ0FBQyxHQUFHLENBQUMsQ0FBQzs2Q0FDeEQ7d0NBQ0wsQ0FBQyxDQUFDLENBQUM7d0NBQ0gsMkJBQTJCO3dDQUMzQixpQkFBTyxDQUFDLGFBQWEseUJBQW9CLENBQUM7d0NBQzFDLGlCQUFPLENBQUMsYUFBYSx1QkFBbUIsQ0FBQzt3Q0FDekMsaUJBQU8sQ0FBQyxhQUFhLHFCQUFrQixDQUFDO3dDQUN4QyxpQkFBTyxDQUFDLGFBQWEsdUJBQW1CLENBQUM7d0NBQ3pDLGtCQUFrQjt3Q0FDbEIscUJBQU0sZUFBTSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFBOzt3Q0FEckMsa0JBQWtCO3dDQUNsQixTQUFxQyxDQUFDOzs7OztxQkFDekM7aUJBQ0osQ0FBQyxDQUFDOzs7O0tBQ04sQ0FBQztBQUVGLEtBQUssRUFBRSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInZlcnNpb25cIjogXCIyLjBcIixcbiAgXCJtZXRhZGF0YVwiOiB7XG4gICAgXCJhcGlWZXJzaW9uXCI6IFwiMjAxNC0wNi0zMFwiLFxuICAgIFwiZW5kcG9pbnRQcmVmaXhcIjogXCJjb2duaXRvLWlkZW50aXR5XCIsXG4gICAgXCJqc29uVmVyc2lvblwiOiBcIjEuMVwiLFxuICAgIFwicHJvdG9jb2xcIjogXCJqc29uXCIsXG4gICAgXCJzZXJ2aWNlRnVsbE5hbWVcIjogXCJBbWF6b24gQ29nbml0byBJZGVudGl0eVwiLFxuICAgIFwic2VydmljZUlkXCI6IFwiQ29nbml0byBJZGVudGl0eVwiLFxuICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInY0XCIsXG4gICAgXCJ0YXJnZXRQcmVmaXhcIjogXCJBV1NDb2duaXRvSWRlbnRpdHlTZXJ2aWNlXCIsXG4gICAgXCJ1aWRcIjogXCJjb2duaXRvLWlkZW50aXR5LTIwMTQtMDYtMzBcIlxuICB9LFxuICBcIm9wZXJhdGlvbnNcIjoge1xuICAgIFwiQ3JlYXRlSWRlbnRpdHlQb29sXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCIsXG4gICAgICAgICAgXCJBbGxvd1VuYXV0aGVudGljYXRlZElkZW50aXRpZXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIkFsbG93VW5hdXRoZW50aWNhdGVkSWRlbnRpdGllc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWxsb3dDbGFzc2ljRmxvd1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3VwcG9ydGVkTG9naW5Qcm92aWRlcnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiT3BlbklkQ29ubmVjdFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb2duaXRvSWRlbnRpdHlQcm92aWRlcnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNiXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2FtbFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2dcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiU2tcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVJZGVudGl0aWVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eUlkc1RvRGVsZXRlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRzVG9EZWxldGVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVW5wcm9jZXNzZWRJZGVudGl0eUlkc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkVycm9yQ29kZVwiOiB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUlkZW50aXR5UG9vbFwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZXNjcmliZUlkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eUlkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlN2XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVzY3JpYmVJZGVudGl0eVBvb2xcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTa1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzEwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ3VzdG9tUm9sZUFyblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiQWNjZXNzS2V5SWRcIjoge30sXG4gICAgICAgICAgICAgIFwiU2VjcmV0S2V5XCI6IHt9LFxuICAgICAgICAgICAgICBcIlNlc3Npb25Ub2tlblwiOiB7fSxcbiAgICAgICAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhdXRodHlwZVwiOiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCJHZXRJZFwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQWNjb3VudElkXCI6IHt9LFxuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJMb2dpbnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYXV0aHR5cGVcIjogXCJub25lXCJcbiAgICB9LFxuICAgIFwiR2V0SWRlbnRpdHlQb29sUm9sZXNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJSb2xlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUm9sZU1hcHBpbmdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPcGVuSWRUb2tlblwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiTG9naW5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMTBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICAgIFwiVG9rZW5cIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYXV0aHR5cGVcIjogXCJub25lXCJcbiAgICB9LFxuICAgIFwiR2V0T3BlbklkVG9rZW5Gb3JEZXZlbG9wZXJJZGVudGl0eVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgICBcIkxvZ2luc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJMb2dpbnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxMFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByaW5jaXBhbFRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRva2VuRHVyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJUb2tlblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldFByaW5jaXBhbFRhZ0F0dHJpYnV0ZU1hcFwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgICBcIklkZW50aXR5UHJvdmlkZXJOYW1lXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiSWRlbnRpdHlQcm92aWRlck5hbWVcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5UHJvdmlkZXJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiVXNlRGVmYXVsdHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByaW5jaXBhbFRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxc1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RJZGVudGl0aWVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiLFxuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIk1heFJlc3VsdHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5leHRUb2tlblwiOiB7fSxcbiAgICAgICAgICBcIkhpZGVEaXNhYmxlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0aWVzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlN2XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdElkZW50aXR5UG9vbHNcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIk1heFJlc3VsdHNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTWF4UmVzdWx0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCI6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdFRhZ3NGb3JSZXNvdXJjZVwiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiUmVzb3VyY2VBcm5cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVzb3VyY2VBcm5cIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxvb2t1cERldmVsb3BlcklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllclwiOiB7fSxcbiAgICAgICAgICBcIk1heFJlc3VsdHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5leHRUb2tlblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJVc2VySWRlbnRpZmllckxpc3RcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge31cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmV4dFRva2VuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTWVyZ2VEZXZlbG9wZXJJZGVudGl0aWVzXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJTb3VyY2VVc2VySWRlbnRpZmllclwiLFxuICAgICAgICAgIFwiRGVzdGluYXRpb25Vc2VySWRlbnRpZmllclwiLFxuICAgICAgICAgIFwiRGV2ZWxvcGVyUHJvdmlkZXJOYW1lXCIsXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJTb3VyY2VVc2VySWRlbnRpZmllclwiOiB7fSxcbiAgICAgICAgICBcIkRlc3RpbmF0aW9uVXNlcklkZW50aWZpZXJcIjoge30sXG4gICAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTZXRJZGVudGl0eVBvb2xSb2xlc1wiOiB7XG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgICBcIlJvbGVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICAgIFwiUm9sZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxY1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJvbGVNYXBwaW5nc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2V0UHJpbmNpcGFsVGFnQXR0cmlidXRlTWFwXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiLFxuICAgICAgICAgIFwiSWRlbnRpdHlQcm92aWRlck5hbWVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0eVByb3ZpZGVyTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlVzZURlZmF1bHRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcmluY2lwYWxUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMXNcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIklkZW50aXR5UHJvdmlkZXJOYW1lXCI6IHt9LFxuICAgICAgICAgIFwiVXNlRGVmYXVsdHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByaW5jaXBhbFRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxc1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlRhZ1Jlc291cmNlXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSZXNvdXJjZUFyblwiLFxuICAgICAgICAgIFwiVGFnc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXNvdXJjZUFyblwiOiB7fSxcbiAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNoXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiVW5saW5rRGV2ZWxvcGVySWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIixcbiAgICAgICAgICBcIklkZW50aXR5UG9vbElkXCIsXG4gICAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIixcbiAgICAgICAgICBcIkRldmVsb3BlclVzZXJJZGVudGlmaWVyXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIjoge30sXG4gICAgICAgICAgXCJJZGVudGl0eVBvb2xJZFwiOiB7fSxcbiAgICAgICAgICBcIkRldmVsb3BlclByb3ZpZGVyTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIkRldmVsb3BlclVzZXJJZGVudGlmaWVyXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiVW5saW5rSWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIklkZW50aXR5SWRcIixcbiAgICAgICAgICBcIkxvZ2luc1wiLFxuICAgICAgICAgIFwiTG9naW5zVG9SZW1vdmVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSWRlbnRpdHlJZFwiOiB7fSxcbiAgICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzEwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTG9naW5zVG9SZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlN3XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImF1dGh0eXBlXCI6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIlVudGFnUmVzb3VyY2VcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlJlc291cmNlQXJuXCIsXG4gICAgICAgICAgXCJUYWdLZXlzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlc291cmNlQXJuXCI6IHt9LFxuICAgICAgICAgIFwiVGFnS2V5c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVcGRhdGVJZGVudGl0eVBvb2xcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTa1wiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiU2tcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJzaGFwZXNcIjoge1xuICAgIFwiUzVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICBcImtleVwiOiB7fSxcbiAgICAgIFwidmFsdWVcIjoge31cbiAgICB9LFxuICAgIFwiUzlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge31cbiAgICB9LFxuICAgIFwiU2JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlByb3ZpZGVyTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIkNsaWVudElkXCI6IHt9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZVRva2VuQ2hlY2tcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNnXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHt9XG4gICAgfSxcbiAgICBcIlNoXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlNrXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiSWRlbnRpdHlQb29sSWRcIixcbiAgICAgICAgXCJJZGVudGl0eVBvb2xOYW1lXCIsXG4gICAgICAgIFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIklkZW50aXR5UG9vbElkXCI6IHt9LFxuICAgICAgICBcIklkZW50aXR5UG9vbE5hbWVcIjoge30sXG4gICAgICAgIFwiQWxsb3dVbmF1dGhlbnRpY2F0ZWRJZGVudGl0aWVzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJBbGxvd0NsYXNzaWNGbG93XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJTdXBwb3J0ZWRMb2dpblByb3ZpZGVyc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM1XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJEZXZlbG9wZXJQcm92aWRlck5hbWVcIjoge30sXG4gICAgICAgIFwiT3BlbklkQ29ubmVjdFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM5XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJDb2duaXRvSWRlbnRpdHlQcm92aWRlcnNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTYlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiU2FtbFByb3ZpZGVyQVJOc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlNnXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJJZGVudGl0eVBvb2xUYWdzXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiU2hcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlN2XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJZGVudGl0eUlkXCI6IHt9LFxuICAgICAgICBcIkxvZ2luc1wiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlN3XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJDcmVhdGlvbkRhdGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiTGFzdE1vZGlmaWVkRGF0ZVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTd1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7fVxuICAgIH0sXG4gICAgXCJTMTBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibWFwXCIsXG4gICAgICBcImtleVwiOiB7fSxcbiAgICAgIFwidmFsdWVcIjoge31cbiAgICB9LFxuICAgIFwiUzFjXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm1hcFwiLFxuICAgICAgXCJrZXlcIjoge30sXG4gICAgICBcInZhbHVlXCI6IHt9XG4gICAgfSxcbiAgICBcIlMxZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJtYXBcIixcbiAgICAgIFwia2V5XCI6IHt9LFxuICAgICAgXCJ2YWx1ZVwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlR5cGVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVHlwZVwiOiB7fSxcbiAgICAgICAgICBcIkFtYmlndW91c1JvbGVSZXNvbHV0aW9uXCI6IHt9LFxuICAgICAgICAgIFwiUnVsZXNDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiUnVsZXNcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIkNsYWltXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiTWF0Y2hUeXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJSb2xlQVJOXCJcbiAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIkNsYWltXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcIk1hdGNoVHlwZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJWYWx1ZVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJSb2xlQVJOXCI6IHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMxc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJtYXBcIixcbiAgICAgIFwia2V5XCI6IHt9LFxuICAgICAgXCJ2YWx1ZVwiOiB7fVxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJwYWdpbmF0aW9uXCI6IHtcbiAgICBcIkxpc3RJZGVudGl0eVBvb2xzXCI6IHtcbiAgICAgIFwiaW5wdXRfdG9rZW5cIjogXCJOZXh0VG9rZW5cIixcbiAgICAgIFwibGltaXRfa2V5XCI6IFwiTWF4UmVzdWx0c1wiLFxuICAgICAgXCJvdXRwdXRfdG9rZW5cIjogXCJOZXh0VG9rZW5cIixcbiAgICAgIFwicmVzdWx0X2tleVwiOiBcIklkZW50aXR5UG9vbHNcIlxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJhY21cIjoge1xuICAgIFwibmFtZVwiOiBcIkFDTVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYXBpZ2F0ZXdheVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQVBJR2F0ZXdheVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYXBwbGljYXRpb25hdXRvc2NhbGluZ1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJhcHBsaWNhdGlvbi1hdXRvc2NhbGluZ1wiLFxuICAgIFwibmFtZVwiOiBcIkFwcGxpY2F0aW9uQXV0b1NjYWxpbmdcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwcHN0cmVhbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBwU3RyZWFtXCJcbiAgfSxcbiAgXCJhdXRvc2NhbGluZ1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXV0b1NjYWxpbmdcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImJhdGNoXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCYXRjaFwiXG4gIH0sXG4gIFwiYnVkZ2V0c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiQnVkZ2V0c1wiXG4gIH0sXG4gIFwiY2xvdWRkaXJlY3RvcnlcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkRGlyZWN0b3J5XCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTYtMDUtMTAqXCJcbiAgICBdXG4gIH0sXG4gIFwiY2xvdWRmb3JtYXRpb25cIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkRm9ybWF0aW9uXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjbG91ZGZyb250XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZEZyb250XCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTMtMDUtMTIqXCIsXG4gICAgICBcIjIwMTMtMTEtMTEqXCIsXG4gICAgICBcIjIwMTQtMDUtMzEqXCIsXG4gICAgICBcIjIwMTQtMTAtMjEqXCIsXG4gICAgICBcIjIwMTQtMTEtMDYqXCIsXG4gICAgICBcIjIwMTUtMDQtMTcqXCIsXG4gICAgICBcIjIwMTUtMDctMjcqXCIsXG4gICAgICBcIjIwMTUtMDktMTcqXCIsXG4gICAgICBcIjIwMTYtMDEtMTMqXCIsXG4gICAgICBcIjIwMTYtMDEtMjgqXCIsXG4gICAgICBcIjIwMTYtMDgtMDEqXCIsXG4gICAgICBcIjIwMTYtMDgtMjAqXCIsXG4gICAgICBcIjIwMTYtMDktMDcqXCIsXG4gICAgICBcIjIwMTYtMDktMjkqXCIsXG4gICAgICBcIjIwMTYtMTEtMjUqXCIsXG4gICAgICBcIjIwMTctMDMtMjUqXCIsXG4gICAgICBcIjIwMTctMTAtMzAqXCIsXG4gICAgICBcIjIwMTgtMDYtMTgqXCIsXG4gICAgICBcIjIwMTgtMTEtMDUqXCIsXG4gICAgICBcIjIwMTktMDMtMjYqXCJcbiAgICBdLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY2xvdWRoc21cIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkSFNNXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjbG91ZHNlYXJjaFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRTZWFyY2hcIlxuICB9LFxuICBcImNsb3Vkc2VhcmNoZG9tYWluXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDbG91ZFNlYXJjaERvbWFpblwiXG4gIH0sXG4gIFwiY2xvdWR0cmFpbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRUcmFpbFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY2xvdWR3YXRjaFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtb25pdG9yaW5nXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRXYXRjaFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY2xvdWR3YXRjaGV2ZW50c1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJldmVudHNcIixcbiAgICBcIm5hbWVcIjogXCJDbG91ZFdhdGNoRXZlbnRzXCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTQtMDItMDMqXCJcbiAgICBdLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY2xvdWR3YXRjaGxvZ3NcIjoge1xuICAgIFwicHJlZml4XCI6IFwibG9nc1wiLFxuICAgIFwibmFtZVwiOiBcIkNsb3VkV2F0Y2hMb2dzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2RlYnVpbGRcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVCdWlsZFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29kZWNvbW1pdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29kZUNvbW1pdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29kZWRlcGxveVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29kZURlcGxveVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiY29kZXBpcGVsaW5lXCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb2RlUGlwZWxpbmVcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZ25pdG9pZGVudGl0eVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2duaXRvLWlkZW50aXR5XCIsXG4gICAgXCJuYW1lXCI6IFwiQ29nbml0b0lkZW50aXR5XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb2duaXRvaWRlbnRpdHlzZXJ2aWNlcHJvdmlkZXJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29nbml0by1pZHBcIixcbiAgICBcIm5hbWVcIjogXCJDb2duaXRvSWRlbnRpdHlTZXJ2aWNlUHJvdmlkZXJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvZ25pdG9zeW5jXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvZ25pdG8tc3luY1wiLFxuICAgIFwibmFtZVwiOiBcIkNvZ25pdG9TeW5jXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJjb25maWdzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvbmZpZ1wiLFxuICAgIFwibmFtZVwiOiBcIkNvbmZpZ1NlcnZpY2VcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImN1clwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ1VSXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJkYXRhcGlwZWxpbmVcIjoge1xuICAgIFwibmFtZVwiOiBcIkRhdGFQaXBlbGluZVwiXG4gIH0sXG4gIFwiZGV2aWNlZmFybVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRGV2aWNlRmFybVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZGlyZWN0Y29ubmVjdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRGlyZWN0Q29ubmVjdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZGlyZWN0b3J5c2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJkc1wiLFxuICAgIFwibmFtZVwiOiBcIkRpcmVjdG9yeVNlcnZpY2VcIlxuICB9LFxuICBcImRpc2NvdmVyeVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRGlzY292ZXJ5XCJcbiAgfSxcbiAgXCJkbXNcIjoge1xuICAgIFwibmFtZVwiOiBcIkRNU1wiXG4gIH0sXG4gIFwiZHluYW1vZGJcIjoge1xuICAgIFwibmFtZVwiOiBcIkR5bmFtb0RCXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJkeW5hbW9kYnN0cmVhbXNcIjoge1xuICAgIFwicHJlZml4XCI6IFwic3RyZWFtcy5keW5hbW9kYlwiLFxuICAgIFwibmFtZVwiOiBcIkR5bmFtb0RCU3RyZWFtc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWMyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFQzJcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxMy0wNi0xNSpcIixcbiAgICAgIFwiMjAxMy0xMC0xNSpcIixcbiAgICAgIFwiMjAxNC0wMi0wMSpcIixcbiAgICAgIFwiMjAxNC0wNS0wMSpcIixcbiAgICAgIFwiMjAxNC0wNi0xNSpcIixcbiAgICAgIFwiMjAxNC0wOS0wMSpcIixcbiAgICAgIFwiMjAxNC0xMC0wMSpcIixcbiAgICAgIFwiMjAxNS0wMy0wMSpcIixcbiAgICAgIFwiMjAxNS0wNC0xNSpcIixcbiAgICAgIFwiMjAxNS0xMC0wMSpcIixcbiAgICAgIFwiMjAxNi0wNC0wMSpcIixcbiAgICAgIFwiMjAxNi0wOS0xNSpcIlxuICAgIF0sXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlY3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkVDUlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFQ1NcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVmc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbGFzdGljZmlsZXN5c3RlbVwiLFxuICAgIFwibmFtZVwiOiBcIkVGU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWxhc3RpY2FjaGVcIjoge1xuICAgIFwibmFtZVwiOiBcIkVsYXN0aUNhY2hlXCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTItMTEtMTUqXCIsXG4gICAgICBcIjIwMTQtMDMtMjQqXCIsXG4gICAgICBcIjIwMTQtMDctMTUqXCIsXG4gICAgICBcIjIwMTQtMDktMzAqXCJcbiAgICBdLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWxhc3RpY2JlYW5zdGFsa1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRWxhc3RpY0JlYW5zdGFsa1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZWxiXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVsYXN0aWNsb2FkYmFsYW5jaW5nXCIsXG4gICAgXCJuYW1lXCI6IFwiRUxCXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlbGJ2MlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbGFzdGljbG9hZGJhbGFuY2luZ3YyXCIsXG4gICAgXCJuYW1lXCI6IFwiRUxCdjJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImVtclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbGFzdGljbWFwcmVkdWNlXCIsXG4gICAgXCJuYW1lXCI6IFwiRU1SXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJlc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRVNcIlxuICB9LFxuICBcImVsYXN0aWN0cmFuc2NvZGVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJFbGFzdGljVHJhbnNjb2RlclwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZmlyZWhvc2VcIjoge1xuICAgIFwibmFtZVwiOiBcIkZpcmVob3NlXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJnYW1lbGlmdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR2FtZUxpZnRcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImdsYWNpZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkdsYWNpZXJcIlxuICB9LFxuICBcImhlYWx0aFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSGVhbHRoXCJcbiAgfSxcbiAgXCJpYW1cIjoge1xuICAgIFwibmFtZVwiOiBcIklBTVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiaW1wb3J0ZXhwb3J0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJJbXBvcnRFeHBvcnRcIlxuICB9LFxuICBcImluc3BlY3RvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW5zcGVjdG9yXCIsXG4gICAgXCJ2ZXJzaW9uc1wiOiBbXG4gICAgICBcIjIwMTUtMDgtMTgqXCJcbiAgICBdLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiaW90XCI6IHtcbiAgICBcIm5hbWVcIjogXCJJb3RcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImlvdGRhdGFcIjoge1xuICAgIFwicHJlZml4XCI6IFwiaW90LWRhdGFcIixcbiAgICBcIm5hbWVcIjogXCJJb3REYXRhXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJraW5lc2lzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJraW5lc2lzYW5hbHl0aWNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzQW5hbHl0aWNzXCJcbiAgfSxcbiAgXCJrbXNcIjoge1xuICAgIFwibmFtZVwiOiBcIktNU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibGFtYmRhXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMYW1iZGFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImxleHJ1bnRpbWVcIjoge1xuICAgIFwicHJlZml4XCI6IFwicnVudGltZS5sZXhcIixcbiAgICBcIm5hbWVcIjogXCJMZXhSdW50aW1lXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJsaWdodHNhaWxcIjoge1xuICAgIFwibmFtZVwiOiBcIkxpZ2h0c2FpbFwiXG4gIH0sXG4gIFwibWFjaGluZWxlYXJuaW5nXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNYWNoaW5lTGVhcm5pbmdcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm1hcmtldHBsYWNlY29tbWVyY2VhbmFseXRpY3NcIjoge1xuICAgIFwibmFtZVwiOiBcIk1hcmtldHBsYWNlQ29tbWVyY2VBbmFseXRpY3NcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm1hcmtldHBsYWNlbWV0ZXJpbmdcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWV0ZXJpbmdtYXJrZXRwbGFjZVwiLFxuICAgIFwibmFtZVwiOiBcIk1hcmtldHBsYWNlTWV0ZXJpbmdcIlxuICB9LFxuICBcIm10dXJrXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm10dXJrLXJlcXVlc3RlclwiLFxuICAgIFwibmFtZVwiOiBcIk1UdXJrXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJtb2JpbGVhbmFseXRpY3NcIjoge1xuICAgIFwibmFtZVwiOiBcIk1vYmlsZUFuYWx5dGljc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwib3Bzd29ya3NcIjoge1xuICAgIFwibmFtZVwiOiBcIk9wc1dvcmtzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJvcHN3b3Jrc2NtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJPcHNXb3Jrc0NNXCJcbiAgfSxcbiAgXCJvcmdhbml6YXRpb25zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJPcmdhbml6YXRpb25zXCJcbiAgfSxcbiAgXCJwaW5wb2ludFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUGlucG9pbnRcIlxuICB9LFxuICBcInBvbGx5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJQb2xseVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicmRzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSRFNcIixcbiAgICBcInZlcnNpb25zXCI6IFtcbiAgICAgIFwiMjAxNC0wOS0wMSpcIlxuICAgIF0sXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJyZWRzaGlmdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUmVkc2hpZnRcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJla29nbml0aW9uXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSZWtvZ25pdGlvblwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicmVzb3VyY2Vncm91cHN0YWdnaW5nYXBpXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSZXNvdXJjZUdyb3Vwc1RhZ2dpbmdBUElcIlxuICB9LFxuICBcInJvdXRlNTNcIjoge1xuICAgIFwibmFtZVwiOiBcIlJvdXRlNTNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJvdXRlNTNkb21haW5zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSb3V0ZTUzRG9tYWluc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiczNcIjoge1xuICAgIFwibmFtZVwiOiBcIlMzXCIsXG4gICAgXCJkdWFsc3RhY2tBdmFpbGFibGVcIjogdHJ1ZSxcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInMzY29udHJvbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUzNDb250cm9sXCIsXG4gICAgXCJkdWFsc3RhY2tBdmFpbGFibGVcIjogdHJ1ZSxcbiAgICBcInhtbE5vRGVmYXVsdExpc3RzXCI6IHRydWVcbiAgfSxcbiAgXCJzZXJ2aWNlY2F0YWxvZ1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VydmljZUNhdGFsb2dcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNlc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbWFpbFwiLFxuICAgIFwibmFtZVwiOiBcIlNFU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwic2hpZWxkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTaGllbGRcIlxuICB9LFxuICBcInNpbXBsZWRiXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNkYlwiLFxuICAgIFwibmFtZVwiOiBcIlNpbXBsZURCXCJcbiAgfSxcbiAgXCJzbXNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNNU1wiXG4gIH0sXG4gIFwic25vd2JhbGxcIjoge1xuICAgIFwibmFtZVwiOiBcIlNub3diYWxsXCJcbiAgfSxcbiAgXCJzbnNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNOU1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwic3FzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTUVNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNzbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU1NNXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJzdG9yYWdlZ2F0ZXdheVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU3RvcmFnZUdhdGV3YXlcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInN0ZXBmdW5jdGlvbnNcIjoge1xuICAgIFwicHJlZml4XCI6IFwic3RhdGVzXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RlcEZ1bmN0aW9uc1wiXG4gIH0sXG4gIFwic3RzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTVFNcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInN1cHBvcnRcIjoge1xuICAgIFwibmFtZVwiOiBcIlN1cHBvcnRcIlxuICB9LFxuICBcInN3ZlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU1dGXCJcbiAgfSxcbiAgXCJ4cmF5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJYUmF5XCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJ3YWZcIjoge1xuICAgIFwibmFtZVwiOiBcIldBRlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwid2FmcmVnaW9uYWxcIjoge1xuICAgIFwicHJlZml4XCI6IFwid2FmLXJlZ2lvbmFsXCIsXG4gICAgXCJuYW1lXCI6IFwiV0FGUmVnaW9uYWxcIlxuICB9LFxuICBcIndvcmtkb2NzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXb3JrRG9jc1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwid29ya3NwYWNlc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya1NwYWNlc1wiXG4gIH0sXG4gIFwiY29kZXN0YXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVTdGFyXCJcbiAgfSxcbiAgXCJsZXhtb2RlbGJ1aWxkaW5nc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJsZXgtbW9kZWxzXCIsXG4gICAgXCJuYW1lXCI6IFwiTGV4TW9kZWxCdWlsZGluZ1NlcnZpY2VcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIm1hcmtldHBsYWNlZW50aXRsZW1lbnRzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVudGl0bGVtZW50Lm1hcmtldHBsYWNlXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFya2V0cGxhY2VFbnRpdGxlbWVudFNlcnZpY2VcIlxuICB9LFxuICBcImF0aGVuYVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXRoZW5hXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJncmVlbmdyYXNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHcmVlbmdyYXNzXCJcbiAgfSxcbiAgXCJkYXhcIjoge1xuICAgIFwibmFtZVwiOiBcIkRBWFwiXG4gIH0sXG4gIFwibWlncmF0aW9uaHViXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIkFXU01pZ3JhdGlvbkh1YlwiLFxuICAgIFwibmFtZVwiOiBcIk1pZ3JhdGlvbkh1YlwiXG4gIH0sXG4gIFwiY2xvdWRoc212MlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ2xvdWRIU01WMlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZ2x1ZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR2x1ZVwiXG4gIH0sXG4gIFwibW9iaWxlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNb2JpbGVcIlxuICB9LFxuICBcInByaWNpbmdcIjoge1xuICAgIFwibmFtZVwiOiBcIlByaWNpbmdcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImNvc3RleHBsb3JlclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjZVwiLFxuICAgIFwibmFtZVwiOiBcIkNvc3RFeHBsb3JlclwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwibWVkaWFjb252ZXJ0XCI6IHtcbiAgICBcIm5hbWVcIjogXCJNZWRpYUNvbnZlcnRcIlxuICB9LFxuICBcIm1lZGlhbGl2ZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFMaXZlXCJcbiAgfSxcbiAgXCJtZWRpYXBhY2thZ2VcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhUGFja2FnZVwiXG4gIH0sXG4gIFwibWVkaWFzdG9yZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFTdG9yZVwiXG4gIH0sXG4gIFwibWVkaWFzdG9yZWRhdGFcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWVkaWFzdG9yZS1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiTWVkaWFTdG9yZURhdGFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwcHN5bmNcIjoge1xuICAgIFwibmFtZVwiOiBcIkFwcFN5bmNcIlxuICB9LFxuICBcImd1YXJkZHV0eVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR3VhcmREdXR5XCJcbiAgfSxcbiAgXCJtcVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTVFcIlxuICB9LFxuICBcImNvbXByZWhlbmRcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvbXByZWhlbmRcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImlvdGpvYnNkYXRhcGxhbmVcIjoge1xuICAgIFwicHJlZml4XCI6IFwiaW90LWpvYnMtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIklvVEpvYnNEYXRhUGxhbmVcIlxuICB9LFxuICBcImtpbmVzaXN2aWRlb2FyY2hpdmVkbWVkaWFcIjoge1xuICAgIFwicHJlZml4XCI6IFwia2luZXNpcy12aWRlby1hcmNoaXZlZC1tZWRpYVwiLFxuICAgIFwibmFtZVwiOiBcIktpbmVzaXNWaWRlb0FyY2hpdmVkTWVkaWFcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXN2aWRlb21lZGlhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImtpbmVzaXMtdmlkZW8tbWVkaWFcIixcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzVmlkZW9NZWRpYVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwia2luZXNpc3ZpZGVvXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLaW5lc2lzVmlkZW9cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInNhZ2VtYWtlcnJ1bnRpbWVcIjoge1xuICAgIFwicHJlZml4XCI6IFwicnVudGltZS5zYWdlbWFrZXJcIixcbiAgICBcIm5hbWVcIjogXCJTYWdlTWFrZXJSdW50aW1lXCJcbiAgfSxcbiAgXCJzYWdlbWFrZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNhZ2VNYWtlclwiXG4gIH0sXG4gIFwidHJhbnNsYXRlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUcmFuc2xhdGVcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcInJlc291cmNlZ3JvdXBzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJlc291cmNlLWdyb3Vwc1wiLFxuICAgIFwibmFtZVwiOiBcIlJlc291cmNlR3JvdXBzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJhbGV4YWZvcmJ1c2luZXNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBbGV4YUZvckJ1c2luZXNzXCJcbiAgfSxcbiAgXCJjbG91ZDlcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkOVwiXG4gIH0sXG4gIFwic2VydmVybGVzc2FwcGxpY2F0aW9ucmVwb3NpdG9yeVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzZXJ2ZXJsZXNzcmVwb1wiLFxuICAgIFwibmFtZVwiOiBcIlNlcnZlcmxlc3NBcHBsaWNhdGlvblJlcG9zaXRvcnlcIlxuICB9LFxuICBcInNlcnZpY2VkaXNjb3ZlcnlcIjoge1xuICAgIFwibmFtZVwiOiBcIlNlcnZpY2VEaXNjb3ZlcnlcIlxuICB9LFxuICBcIndvcmttYWlsXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXb3JrTWFpbFwiXG4gIH0sXG4gIFwiYXV0b3NjYWxpbmdwbGFuc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJhdXRvc2NhbGluZy1wbGFuc1wiLFxuICAgIFwibmFtZVwiOiBcIkF1dG9TY2FsaW5nUGxhbnNcIlxuICB9LFxuICBcInRyYW5zY3JpYmVzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInRyYW5zY3JpYmVcIixcbiAgICBcIm5hbWVcIjogXCJUcmFuc2NyaWJlU2VydmljZVwiXG4gIH0sXG4gIFwiY29ubmVjdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29ubmVjdFwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiYWNtcGNhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImFjbS1wY2FcIixcbiAgICBcIm5hbWVcIjogXCJBQ01QQ0FcIlxuICB9LFxuICBcImZtc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRk1TXCJcbiAgfSxcbiAgXCJzZWNyZXRzbWFuYWdlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2VjcmV0c01hbmFnZXJcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImlvdGFuYWx5dGljc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9UQW5hbHl0aWNzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJpb3QxY2xpY2tkZXZpY2Vzc2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJpb3QxY2xpY2stZGV2aWNlc1wiLFxuICAgIFwibmFtZVwiOiBcIklvVDFDbGlja0RldmljZXNTZXJ2aWNlXCJcbiAgfSxcbiAgXCJpb3QxY2xpY2twcm9qZWN0c1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJpb3QxY2xpY2stcHJvamVjdHNcIixcbiAgICBcIm5hbWVcIjogXCJJb1QxQ2xpY2tQcm9qZWN0c1wiXG4gIH0sXG4gIFwicGlcIjoge1xuICAgIFwibmFtZVwiOiBcIlBJXCJcbiAgfSxcbiAgXCJuZXB0dW5lXCI6IHtcbiAgICBcIm5hbWVcIjogXCJOZXB0dW5lXCJcbiAgfSxcbiAgXCJtZWRpYXRhaWxvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWVkaWFUYWlsb3JcIlxuICB9LFxuICBcImVrc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUtTXCJcbiAgfSxcbiAgXCJtYWNpZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWFjaWVcIlxuICB9LFxuICBcImRsbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRExNXCJcbiAgfSxcbiAgXCJzaWduZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNpZ25lclwiXG4gIH0sXG4gIFwiY2hpbWVcIjoge1xuICAgIFwibmFtZVwiOiBcIkNoaW1lXCJcbiAgfSxcbiAgXCJwaW5wb2ludGVtYWlsXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInBpbnBvaW50LWVtYWlsXCIsXG4gICAgXCJuYW1lXCI6IFwiUGlucG9pbnRFbWFpbFwiXG4gIH0sXG4gIFwicmFtXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSQU1cIlxuICB9LFxuICBcInJvdXRlNTNyZXNvbHZlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUm91dGU1M1Jlc29sdmVyXCJcbiAgfSxcbiAgXCJwaW5wb2ludHNtc3ZvaWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNtcy12b2ljZVwiLFxuICAgIFwibmFtZVwiOiBcIlBpbnBvaW50U01TVm9pY2VcIlxuICB9LFxuICBcInF1aWNrc2lnaHRcIjoge1xuICAgIFwibmFtZVwiOiBcIlF1aWNrU2lnaHRcIlxuICB9LFxuICBcInJkc2RhdGFzZXJ2aWNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJkcy1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiUkRTRGF0YVNlcnZpY2VcIlxuICB9LFxuICBcImFtcGxpZnlcIjoge1xuICAgIFwibmFtZVwiOiBcIkFtcGxpZnlcIlxuICB9LFxuICBcImRhdGFzeW5jXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEYXRhU3luY1wiXG4gIH0sXG4gIFwicm9ib21ha2VyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSb2JvTWFrZXJcIlxuICB9LFxuICBcInRyYW5zZmVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJUcmFuc2ZlclwiXG4gIH0sXG4gIFwiZ2xvYmFsYWNjZWxlcmF0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkdsb2JhbEFjY2VsZXJhdG9yXCJcbiAgfSxcbiAgXCJjb21wcmVoZW5kbWVkaWNhbFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29tcHJlaGVuZE1lZGljYWxcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImtpbmVzaXNhbmFseXRpY3N2MlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2luZXNpc0FuYWx5dGljc1YyXCJcbiAgfSxcbiAgXCJtZWRpYWNvbm5lY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lZGlhQ29ubmVjdFwiXG4gIH0sXG4gIFwiZnN4XCI6IHtcbiAgICBcIm5hbWVcIjogXCJGU3hcIlxuICB9LFxuICBcInNlY3VyaXR5aHViXCI6IHtcbiAgICBcIm5hbWVcIjogXCJTZWN1cml0eUh1YlwiXG4gIH0sXG4gIFwiYXBwbWVzaFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBwTWVzaFwiLFxuICAgIFwidmVyc2lvbnNcIjogW1xuICAgICAgXCIyMDE4LTEwLTAxKlwiXG4gICAgXVxuICB9LFxuICBcImxpY2Vuc2VtYW5hZ2VyXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImxpY2Vuc2UtbWFuYWdlclwiLFxuICAgIFwibmFtZVwiOiBcIkxpY2Vuc2VNYW5hZ2VyXCJcbiAgfSxcbiAgXCJrYWZrYVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiS2Fma2FcIlxuICB9LFxuICBcImFwaWdhdGV3YXltYW5hZ2VtZW50YXBpXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcGlHYXRld2F5TWFuYWdlbWVudEFwaVwiXG4gIH0sXG4gIFwiYXBpZ2F0ZXdheXYyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcGlHYXRld2F5VjJcIlxuICB9LFxuICBcImRvY2RiXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEb2NEQlwiXG4gIH0sXG4gIFwiYmFja3VwXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCYWNrdXBcIlxuICB9LFxuICBcIndvcmtsaW5rXCI6IHtcbiAgICBcIm5hbWVcIjogXCJXb3JrTGlua1wiXG4gIH0sXG4gIFwidGV4dHJhY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIlRleHRyYWN0XCJcbiAgfSxcbiAgXCJtYW5hZ2VkYmxvY2tjaGFpblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTWFuYWdlZEJsb2NrY2hhaW5cIlxuICB9LFxuICBcIm1lZGlhcGFja2FnZXZvZFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtZWRpYXBhY2thZ2Utdm9kXCIsXG4gICAgXCJuYW1lXCI6IFwiTWVkaWFQYWNrYWdlVm9kXCJcbiAgfSxcbiAgXCJncm91bmRzdGF0aW9uXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHcm91bmRTdGF0aW9uXCJcbiAgfSxcbiAgXCJpb3R0aGluZ3NncmFwaFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9UVGhpbmdzR3JhcGhcIlxuICB9LFxuICBcImlvdGV2ZW50c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9URXZlbnRzXCJcbiAgfSxcbiAgXCJpb3RldmVudHNkYXRhXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImlvdGV2ZW50cy1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiSW9URXZlbnRzRGF0YVwiXG4gIH0sXG4gIFwicGVyc29uYWxpemVcIjoge1xuICAgIFwibmFtZVwiOiBcIlBlcnNvbmFsaXplXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJwZXJzb25hbGl6ZWV2ZW50c1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJwZXJzb25hbGl6ZS1ldmVudHNcIixcbiAgICBcIm5hbWVcIjogXCJQZXJzb25hbGl6ZUV2ZW50c1wiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwicGVyc29uYWxpemVydW50aW1lXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInBlcnNvbmFsaXplLXJ1bnRpbWVcIixcbiAgICBcIm5hbWVcIjogXCJQZXJzb25hbGl6ZVJ1bnRpbWVcIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcImFwcGxpY2F0aW9uaW5zaWdodHNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiYXBwbGljYXRpb24taW5zaWdodHNcIixcbiAgICBcIm5hbWVcIjogXCJBcHBsaWNhdGlvbkluc2lnaHRzXCJcbiAgfSxcbiAgXCJzZXJ2aWNlcXVvdGFzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNlcnZpY2UtcXVvdGFzXCIsXG4gICAgXCJuYW1lXCI6IFwiU2VydmljZVF1b3Rhc1wiXG4gIH0sXG4gIFwiZWMyaW5zdGFuY2Vjb25uZWN0XCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVjMi1pbnN0YW5jZS1jb25uZWN0XCIsXG4gICAgXCJuYW1lXCI6IFwiRUMySW5zdGFuY2VDb25uZWN0XCJcbiAgfSxcbiAgXCJldmVudGJyaWRnZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRXZlbnRCcmlkZ2VcIlxuICB9LFxuICBcImxha2Vmb3JtYXRpb25cIjoge1xuICAgIFwibmFtZVwiOiBcIkxha2VGb3JtYXRpb25cIlxuICB9LFxuICBcImZvcmVjYXN0c2VydmljZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJmb3JlY2FzdFwiLFxuICAgIFwibmFtZVwiOiBcIkZvcmVjYXN0U2VydmljZVwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZm9yZWNhc3RxdWVyeXNlcnZpY2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZm9yZWNhc3RxdWVyeVwiLFxuICAgIFwibmFtZVwiOiBcIkZvcmVjYXN0UXVlcnlTZXJ2aWNlXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJxbGRiXCI6IHtcbiAgICBcIm5hbWVcIjogXCJRTERCXCJcbiAgfSxcbiAgXCJxbGRic2Vzc2lvblwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJxbGRiLXNlc3Npb25cIixcbiAgICBcIm5hbWVcIjogXCJRTERCU2Vzc2lvblwiXG4gIH0sXG4gIFwid29ya21haWxtZXNzYWdlZmxvd1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiV29ya01haWxNZXNzYWdlRmxvd1wiXG4gIH0sXG4gIFwiY29kZXN0YXJub3RpZmljYXRpb25zXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNvZGVzdGFyLW5vdGlmaWNhdGlvbnNcIixcbiAgICBcIm5hbWVcIjogXCJDb2RlU3Rhck5vdGlmaWNhdGlvbnNcIlxuICB9LFxuICBcInNhdmluZ3NwbGFuc1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiU2F2aW5nc1BsYW5zXCJcbiAgfSxcbiAgXCJzc29cIjoge1xuICAgIFwibmFtZVwiOiBcIlNTT1wiXG4gIH0sXG4gIFwic3Nvb2lkY1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzc28tb2lkY1wiLFxuICAgIFwibmFtZVwiOiBcIlNTT09JRENcIlxuICB9LFxuICBcIm1hcmtldHBsYWNlY2F0YWxvZ1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtYXJrZXRwbGFjZS1jYXRhbG9nXCIsXG4gICAgXCJuYW1lXCI6IFwiTWFya2V0cGxhY2VDYXRhbG9nXCJcbiAgfSxcbiAgXCJkYXRhZXhjaGFuZ2VcIjoge1xuICAgIFwibmFtZVwiOiBcIkRhdGFFeGNoYW5nZVwiXG4gIH0sXG4gIFwic2VzdjJcIjoge1xuICAgIFwibmFtZVwiOiBcIlNFU1YyXCJcbiAgfSxcbiAgXCJtaWdyYXRpb25odWJjb25maWdcIjoge1xuICAgIFwicHJlZml4XCI6IFwibWlncmF0aW9uaHViLWNvbmZpZ1wiLFxuICAgIFwibmFtZVwiOiBcIk1pZ3JhdGlvbkh1YkNvbmZpZ1wiXG4gIH0sXG4gIFwiY29ubmVjdHBhcnRpY2lwYW50XCI6IHtcbiAgICBcIm5hbWVcIjogXCJDb25uZWN0UGFydGljaXBhbnRcIlxuICB9LFxuICBcImFwcGNvbmZpZ1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBwQ29uZmlnXCJcbiAgfSxcbiAgXCJpb3RzZWN1cmV0dW5uZWxpbmdcIjoge1xuICAgIFwibmFtZVwiOiBcIklvVFNlY3VyZVR1bm5lbGluZ1wiXG4gIH0sXG4gIFwid2FmdjJcIjoge1xuICAgIFwibmFtZVwiOiBcIldBRlYyXCJcbiAgfSxcbiAgXCJlbGFzdGljaW5mZXJlbmNlXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImVsYXN0aWMtaW5mZXJlbmNlXCIsXG4gICAgXCJuYW1lXCI6IFwiRWxhc3RpY0luZmVyZW5jZVwiXG4gIH0sXG4gIFwiaW1hZ2VidWlsZGVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJbWFnZWJ1aWxkZXJcIlxuICB9LFxuICBcInNjaGVtYXNcIjoge1xuICAgIFwibmFtZVwiOiBcIlNjaGVtYXNcIlxuICB9LFxuICBcImFjY2Vzc2FuYWx5emVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBY2Nlc3NBbmFseXplclwiXG4gIH0sXG4gIFwiY29kZWd1cnVyZXZpZXdlclwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2RlZ3VydS1yZXZpZXdlclwiLFxuICAgIFwibmFtZVwiOiBcIkNvZGVHdXJ1UmV2aWV3ZXJcIlxuICB9LFxuICBcImNvZGVndXJ1cHJvZmlsZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvZGVHdXJ1UHJvZmlsZXJcIlxuICB9LFxuICBcImNvbXB1dGVvcHRpbWl6ZXJcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY29tcHV0ZS1vcHRpbWl6ZXJcIixcbiAgICBcIm5hbWVcIjogXCJDb21wdXRlT3B0aW1pemVyXCJcbiAgfSxcbiAgXCJmcmF1ZGRldGVjdG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJGcmF1ZERldGVjdG9yXCJcbiAgfSxcbiAgXCJrZW5kcmFcIjoge1xuICAgIFwibmFtZVwiOiBcIktlbmRyYVwiXG4gIH0sXG4gIFwibmV0d29ya21hbmFnZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIk5ldHdvcmtNYW5hZ2VyXCJcbiAgfSxcbiAgXCJvdXRwb3N0c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiT3V0cG9zdHNcIlxuICB9LFxuICBcImF1Z21lbnRlZGFpcnVudGltZVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzYWdlbWFrZXItYTJpLXJ1bnRpbWVcIixcbiAgICBcIm5hbWVcIjogXCJBdWdtZW50ZWRBSVJ1bnRpbWVcIlxuICB9LFxuICBcImVic1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiRUJTXCJcbiAgfSxcbiAgXCJraW5lc2lzdmlkZW9zaWduYWxpbmdjaGFubmVsc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJraW5lc2lzLXZpZGVvLXNpZ25hbGluZ1wiLFxuICAgIFwibmFtZVwiOiBcIktpbmVzaXNWaWRlb1NpZ25hbGluZ0NoYW5uZWxzXCIsXG4gICAgXCJjb3JzXCI6IHRydWVcbiAgfSxcbiAgXCJkZXRlY3RpdmVcIjoge1xuICAgIFwibmFtZVwiOiBcIkRldGVjdGl2ZVwiXG4gIH0sXG4gIFwiY29kZXN0YXJjb25uZWN0aW9uc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb2Rlc3Rhci1jb25uZWN0aW9uc1wiLFxuICAgIFwibmFtZVwiOiBcIkNvZGVTdGFyY29ubmVjdGlvbnNcIlxuICB9LFxuICBcInN5bnRoZXRpY3NcIjoge1xuICAgIFwibmFtZVwiOiBcIlN5bnRoZXRpY3NcIlxuICB9LFxuICBcImlvdHNpdGV3aXNlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJb1RTaXRlV2lzZVwiXG4gIH0sXG4gIFwibWFjaWUyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNYWNpZTJcIlxuICB9LFxuICBcImNvZGVhcnRpZmFjdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29kZUFydGlmYWN0XCJcbiAgfSxcbiAgXCJob25leWNvZGVcIjoge1xuICAgIFwibmFtZVwiOiBcIkhvbmV5Y29kZVwiXG4gIH0sXG4gIFwiaXZzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJVlNcIlxuICB9LFxuICBcImJyYWtldFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQnJha2V0XCJcbiAgfSxcbiAgXCJpZGVudGl0eXN0b3JlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJZGVudGl0eVN0b3JlXCJcbiAgfSxcbiAgXCJhcHBmbG93XCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcHBmbG93XCJcbiAgfSxcbiAgXCJyZWRzaGlmdGRhdGFcIjoge1xuICAgIFwicHJlZml4XCI6IFwicmVkc2hpZnQtZGF0YVwiLFxuICAgIFwibmFtZVwiOiBcIlJlZHNoaWZ0RGF0YVwiXG4gIH0sXG4gIFwic3NvYWRtaW5cIjoge1xuICAgIFwicHJlZml4XCI6IFwic3NvLWFkbWluXCIsXG4gICAgXCJuYW1lXCI6IFwiU1NPQWRtaW5cIlxuICB9LFxuICBcInRpbWVzdHJlYW1xdWVyeVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJ0aW1lc3RyZWFtLXF1ZXJ5XCIsXG4gICAgXCJuYW1lXCI6IFwiVGltZXN0cmVhbVF1ZXJ5XCJcbiAgfSxcbiAgXCJ0aW1lc3RyZWFtd3JpdGVcIjoge1xuICAgIFwicHJlZml4XCI6IFwidGltZXN0cmVhbS13cml0ZVwiLFxuICAgIFwibmFtZVwiOiBcIlRpbWVzdHJlYW1Xcml0ZVwiXG4gIH0sXG4gIFwiczNvdXRwb3N0c1wiOiB7XG4gICAgXCJuYW1lXCI6IFwiUzNPdXRwb3N0c1wiXG4gIH0sXG4gIFwiZGF0YWJyZXdcIjoge1xuICAgIFwibmFtZVwiOiBcIkRhdGFCcmV3XCJcbiAgfSxcbiAgXCJzZXJ2aWNlY2F0YWxvZ2FwcHJlZ2lzdHJ5XCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNlcnZpY2VjYXRhbG9nLWFwcHJlZ2lzdHJ5XCIsXG4gICAgXCJuYW1lXCI6IFwiU2VydmljZUNhdGFsb2dBcHBSZWdpc3RyeVwiXG4gIH0sXG4gIFwibmV0d29ya2ZpcmV3YWxsXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm5ldHdvcmstZmlyZXdhbGxcIixcbiAgICBcIm5hbWVcIjogXCJOZXR3b3JrRmlyZXdhbGxcIlxuICB9LFxuICBcIm13YWFcIjoge1xuICAgIFwibmFtZVwiOiBcIk1XQUFcIlxuICB9LFxuICBcImFtcGxpZnliYWNrZW5kXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBbXBsaWZ5QmFja2VuZFwiXG4gIH0sXG4gIFwiYXBwaW50ZWdyYXRpb25zXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcHBJbnRlZ3JhdGlvbnNcIlxuICB9LFxuICBcImNvbm5lY3Rjb250YWN0bGVuc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjb25uZWN0LWNvbnRhY3QtbGVuc1wiLFxuICAgIFwibmFtZVwiOiBcIkNvbm5lY3RDb250YWN0TGVuc1wiXG4gIH0sXG4gIFwiZGV2b3BzZ3VydVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJkZXZvcHMtZ3VydVwiLFxuICAgIFwibmFtZVwiOiBcIkRldk9wc0d1cnVcIlxuICB9LFxuICBcImVjcnB1YmxpY1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlY3ItcHVibGljXCIsXG4gICAgXCJuYW1lXCI6IFwiRUNSUFVCTElDXCJcbiAgfSxcbiAgXCJsb29rb3V0dmlzaW9uXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMb29rb3V0VmlzaW9uXCJcbiAgfSxcbiAgXCJzYWdlbWFrZXJmZWF0dXJlc3RvcmVydW50aW1lXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNhZ2VtYWtlci1mZWF0dXJlc3RvcmUtcnVudGltZVwiLFxuICAgIFwibmFtZVwiOiBcIlNhZ2VNYWtlckZlYXR1cmVTdG9yZVJ1bnRpbWVcIlxuICB9LFxuICBcImN1c3RvbWVycHJvZmlsZXNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY3VzdG9tZXItcHJvZmlsZXNcIixcbiAgICBcIm5hbWVcIjogXCJDdXN0b21lclByb2ZpbGVzXCJcbiAgfSxcbiAgXCJhdWRpdG1hbmFnZXJcIjoge1xuICAgIFwibmFtZVwiOiBcIkF1ZGl0TWFuYWdlclwiXG4gIH0sXG4gIFwiZW1yY29udGFpbmVyc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJlbXItY29udGFpbmVyc1wiLFxuICAgIFwibmFtZVwiOiBcIkVNUmNvbnRhaW5lcnNcIlxuICB9LFxuICBcImhlYWx0aGxha2VcIjoge1xuICAgIFwibmFtZVwiOiBcIkhlYWx0aExha2VcIlxuICB9LFxuICBcInNhZ2VtYWtlcmVkZ2VcIjoge1xuICAgIFwicHJlZml4XCI6IFwic2FnZW1ha2VyLWVkZ2VcIixcbiAgICBcIm5hbWVcIjogXCJTYWdlbWFrZXJFZGdlXCJcbiAgfSxcbiAgXCJhbXBcIjoge1xuICAgIFwibmFtZVwiOiBcIkFtcFwiXG4gIH0sXG4gIFwiZ3JlZW5ncmFzc3YyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJHcmVlbmdyYXNzVjJcIlxuICB9LFxuICBcImlvdGRldmljZWFkdmlzb3JcIjoge1xuICAgIFwibmFtZVwiOiBcIklvdERldmljZUFkdmlzb3JcIlxuICB9LFxuICBcImlvdGZsZWV0aHViXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJb1RGbGVldEh1YlwiXG4gIH0sXG4gIFwiaW90d2lyZWxlc3NcIjoge1xuICAgIFwibmFtZVwiOiBcIklvVFdpcmVsZXNzXCJcbiAgfSxcbiAgXCJsb2NhdGlvblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTG9jYXRpb25cIixcbiAgICBcImNvcnNcIjogdHJ1ZVxuICB9LFxuICBcIndlbGxhcmNoaXRlY3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiV2VsbEFyY2hpdGVjdGVkXCJcbiAgfSxcbiAgXCJsZXhtb2RlbHN2MlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJtb2RlbHMubGV4LnYyXCIsXG4gICAgXCJuYW1lXCI6IFwiTGV4TW9kZWxzVjJcIlxuICB9LFxuICBcImxleHJ1bnRpbWV2MlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJydW50aW1lLmxleC52MlwiLFxuICAgIFwibmFtZVwiOiBcIkxleFJ1bnRpbWVWMlwiLFxuICAgIFwiY29yc1wiOiB0cnVlXG4gIH0sXG4gIFwiZmlzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJGaXNcIlxuICB9LFxuICBcImxvb2tvdXRtZXRyaWNzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJMb29rb3V0TWV0cmljc1wiXG4gIH0sXG4gIFwibWduXCI6IHtcbiAgICBcIm5hbWVcIjogXCJNZ25cIlxuICB9LFxuICBcImxvb2tvdXRlcXVpcG1lbnRcIjoge1xuICAgIFwibmFtZVwiOiBcIkxvb2tvdXRFcXVpcG1lbnRcIlxuICB9LFxuICBcIm5pbWJsZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTmltYmxlXCJcbiAgfSxcbiAgXCJmaW5zcGFjZVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRmluc3BhY2VcIlxuICB9LFxuICBcImZpbnNwYWNlZGF0YVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJmaW5zcGFjZS1kYXRhXCIsXG4gICAgXCJuYW1lXCI6IFwiRmluc3BhY2VkYXRhXCJcbiAgfSxcbiAgXCJzc21jb250YWN0c1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzc20tY29udGFjdHNcIixcbiAgICBcIm5hbWVcIjogXCJTU01Db250YWN0c1wiXG4gIH0sXG4gIFwic3NtaW5jaWRlbnRzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNzbS1pbmNpZGVudHNcIixcbiAgICBcIm5hbWVcIjogXCJTU01JbmNpZGVudHNcIlxuICB9LFxuICBcImFwcGxpY2F0aW9uY29zdHByb2ZpbGVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcHBsaWNhdGlvbkNvc3RQcm9maWxlclwiXG4gIH0sXG4gIFwiYXBwcnVubmVyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJBcHBSdW5uZXJcIlxuICB9LFxuICBcInByb3RvblwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUHJvdG9uXCJcbiAgfSxcbiAgXCJyb3V0ZTUzcmVjb3ZlcnljbHVzdGVyXCI6IHtcbiAgICBcInByZWZpeFwiOiBcInJvdXRlNTMtcmVjb3ZlcnktY2x1c3RlclwiLFxuICAgIFwibmFtZVwiOiBcIlJvdXRlNTNSZWNvdmVyeUNsdXN0ZXJcIlxuICB9LFxuICBcInJvdXRlNTNyZWNvdmVyeWNvbnRyb2xjb25maWdcIjoge1xuICAgIFwicHJlZml4XCI6IFwicm91dGU1My1yZWNvdmVyeS1jb250cm9sLWNvbmZpZ1wiLFxuICAgIFwibmFtZVwiOiBcIlJvdXRlNTNSZWNvdmVyeUNvbnRyb2xDb25maWdcIlxuICB9LFxuICBcInJvdXRlNTNyZWNvdmVyeXJlYWRpbmVzc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJyb3V0ZTUzLXJlY292ZXJ5LXJlYWRpbmVzc1wiLFxuICAgIFwibmFtZVwiOiBcIlJvdXRlNTNSZWNvdmVyeVJlYWRpbmVzc1wiXG4gIH0sXG4gIFwiY2hpbWVzZGtpZGVudGl0eVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjaGltZS1zZGstaWRlbnRpdHlcIixcbiAgICBcIm5hbWVcIjogXCJDaGltZVNES0lkZW50aXR5XCJcbiAgfSxcbiAgXCJjaGltZXNka21lc3NhZ2luZ1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJjaGltZS1zZGstbWVzc2FnaW5nXCIsXG4gICAgXCJuYW1lXCI6IFwiQ2hpbWVTREtNZXNzYWdpbmdcIlxuICB9LFxuICBcInNub3dkZXZpY2VtYW5hZ2VtZW50XCI6IHtcbiAgICBcInByZWZpeFwiOiBcInNub3ctZGV2aWNlLW1hbmFnZW1lbnRcIixcbiAgICBcIm5hbWVcIjogXCJTbm93RGV2aWNlTWFuYWdlbWVudFwiXG4gIH0sXG4gIFwibWVtb3J5ZGJcIjoge1xuICAgIFwibmFtZVwiOiBcIk1lbW9yeURCXCJcbiAgfSxcbiAgXCJvcGVuc2VhcmNoXCI6IHtcbiAgICBcIm5hbWVcIjogXCJPcGVuU2VhcmNoXCJcbiAgfSxcbiAgXCJrYWZrYWNvbm5lY3RcIjoge1xuICAgIFwibmFtZVwiOiBcIkthZmthQ29ubmVjdFwiXG4gIH0sXG4gIFwidm9pY2VpZFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJ2b2ljZS1pZFwiLFxuICAgIFwibmFtZVwiOiBcIlZvaWNlSURcIlxuICB9LFxuICBcIndpc2RvbVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiV2lzZG9tXCJcbiAgfSxcbiAgXCJhY2NvdW50XCI6IHtcbiAgICBcIm5hbWVcIjogXCJBY2NvdW50XCJcbiAgfSxcbiAgXCJjbG91ZGNvbnRyb2xcIjoge1xuICAgIFwibmFtZVwiOiBcIkNsb3VkQ29udHJvbFwiXG4gIH0sXG4gIFwiZ3JhZmFuYVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiR3JhZmFuYVwiXG4gIH0sXG4gIFwicGFub3JhbWFcIjoge1xuICAgIFwibmFtZVwiOiBcIlBhbm9yYW1hXCJcbiAgfSxcbiAgXCJjaGltZXNka21lZXRpbmdzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImNoaW1lLXNkay1tZWV0aW5nc1wiLFxuICAgIFwibmFtZVwiOiBcIkNoaW1lU0RLTWVldGluZ3NcIlxuICB9LFxuICBcInJlc2lsaWVuY2VodWJcIjoge1xuICAgIFwibmFtZVwiOiBcIlJlc2lsaWVuY2VodWJcIlxuICB9LFxuICBcIm1pZ3JhdGlvbmh1YnN0cmF0ZWd5XCI6IHtcbiAgICBcIm5hbWVcIjogXCJNaWdyYXRpb25IdWJTdHJhdGVneVwiXG4gIH0sXG4gIFwiYXBwY29uZmlnZGF0YVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQXBwQ29uZmlnRGF0YVwiXG4gIH0sXG4gIFwiZHJzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJEcnNcIlxuICB9LFxuICBcIm1pZ3JhdGlvbmh1YnJlZmFjdG9yc3BhY2VzXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIm1pZ3JhdGlvbi1odWItcmVmYWN0b3Itc3BhY2VzXCIsXG4gICAgXCJuYW1lXCI6IFwiTWlncmF0aW9uSHViUmVmYWN0b3JTcGFjZXNcIlxuICB9LFxuICBcImV2aWRlbnRseVwiOiB7XG4gICAgXCJuYW1lXCI6IFwiRXZpZGVudGx5XCJcbiAgfSxcbiAgXCJpbnNwZWN0b3IyXCI6IHtcbiAgICBcIm5hbWVcIjogXCJJbnNwZWN0b3IyXCJcbiAgfSxcbiAgXCJyYmluXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSYmluXCJcbiAgfSxcbiAgXCJydW1cIjoge1xuICAgIFwibmFtZVwiOiBcIlJVTVwiXG4gIH0sXG4gIFwiYmFja3VwZ2F0ZXdheVwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJiYWNrdXAtZ2F0ZXdheVwiLFxuICAgIFwibmFtZVwiOiBcIkJhY2t1cEdhdGV3YXlcIlxuICB9LFxuICBcImlvdHR3aW5tYWtlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSW9UVHdpbk1ha2VyXCJcbiAgfSxcbiAgXCJ3b3Jrc3BhY2Vzd2ViXCI6IHtcbiAgICBcInByZWZpeFwiOiBcIndvcmtzcGFjZXMtd2ViXCIsXG4gICAgXCJuYW1lXCI6IFwiV29ya1NwYWNlc1dlYlwiXG4gIH0sXG4gIFwiYW1wbGlmeXVpYnVpbGRlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQW1wbGlmeVVJQnVpbGRlclwiXG4gIH0sXG4gIFwia2V5c3BhY2VzXCI6IHtcbiAgICBcIm5hbWVcIjogXCJLZXlzcGFjZXNcIlxuICB9LFxuICBcImJpbGxpbmdjb25kdWN0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkJpbGxpbmdjb25kdWN0b3JcIlxuICB9LFxuICBcImdhbWVzcGFya3NcIjoge1xuICAgIFwibmFtZVwiOiBcIkdhbWVTcGFya3NcIlxuICB9LFxuICBcInBpbnBvaW50c21zdm9pY2V2MlwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJwaW5wb2ludC1zbXMtdm9pY2UtdjJcIixcbiAgICBcIm5hbWVcIjogXCJQaW5wb2ludFNNU1ZvaWNlVjJcIlxuICB9LFxuICBcIml2c2NoYXRcIjoge1xuICAgIFwibmFtZVwiOiBcIkl2c2NoYXRcIlxuICB9LFxuICBcImNoaW1lc2RrbWVkaWFwaXBlbGluZXNcIjoge1xuICAgIFwicHJlZml4XCI6IFwiY2hpbWUtc2RrLW1lZGlhLXBpcGVsaW5lc1wiLFxuICAgIFwibmFtZVwiOiBcIkNoaW1lU0RLTWVkaWFQaXBlbGluZXNcIlxuICB9LFxuICBcImVtcnNlcnZlcmxlc3NcIjoge1xuICAgIFwicHJlZml4XCI6IFwiZW1yLXNlcnZlcmxlc3NcIixcbiAgICBcIm5hbWVcIjogXCJFTVJTZXJ2ZXJsZXNzXCJcbiAgfSxcbiAgXCJtMlwiOiB7XG4gICAgXCJuYW1lXCI6IFwiTTJcIlxuICB9LFxuICBcImNvbm5lY3RjYW1wYWlnbnNcIjoge1xuICAgIFwibmFtZVwiOiBcIkNvbm5lY3RDYW1wYWlnbnNcIlxuICB9LFxuICBcInJlZHNoaWZ0c2VydmVybGVzc1wiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJyZWRzaGlmdC1zZXJ2ZXJsZXNzXCIsXG4gICAgXCJuYW1lXCI6IFwiUmVkc2hpZnRTZXJ2ZXJsZXNzXCJcbiAgfSxcbiAgXCJyb2xlc2FueXdoZXJlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJSb2xlc0FueXdoZXJlXCJcbiAgfSxcbiAgXCJsaWNlbnNlbWFuYWdlcnVzZXJzdWJzY3JpcHRpb25zXCI6IHtcbiAgICBcInByZWZpeFwiOiBcImxpY2Vuc2UtbWFuYWdlci11c2VyLXN1YnNjcmlwdGlvbnNcIixcbiAgICBcIm5hbWVcIjogXCJMaWNlbnNlTWFuYWdlclVzZXJTdWJzY3JpcHRpb25zXCJcbiAgfSxcbiAgXCJiYWNrdXBzdG9yYWdlXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCYWNrdXBTdG9yYWdlXCJcbiAgfSxcbiAgXCJwcml2YXRlbmV0d29ya3NcIjoge1xuICAgIFwibmFtZVwiOiBcIlByaXZhdGVOZXR3b3Jrc1wiXG4gIH0sXG4gIFwic3VwcG9ydGFwcFwiOiB7XG4gICAgXCJwcmVmaXhcIjogXCJzdXBwb3J0LWFwcFwiLFxuICAgIFwibmFtZVwiOiBcIlN1cHBvcnRBcHBcIlxuICB9LFxuICBcImNvbnRyb2x0b3dlclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQ29udHJvbFRvd2VyXCJcbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJ2ZXJzaW9uXCI6IFwiMi4wXCIsXG4gIFwibWV0YWRhdGFcIjoge1xuICAgIFwiYXBpVmVyc2lvblwiOiBcIjIwMDYtMDMtMDFcIixcbiAgICBcImNoZWNrc3VtRm9ybWF0XCI6IFwibWQ1XCIsXG4gICAgXCJlbmRwb2ludFByZWZpeFwiOiBcInMzXCIsXG4gICAgXCJnbG9iYWxFbmRwb2ludFwiOiBcInMzLmFtYXpvbmF3cy5jb21cIixcbiAgICBcInByb3RvY29sXCI6IFwicmVzdC14bWxcIixcbiAgICBcInNlcnZpY2VBYmJyZXZpYXRpb25cIjogXCJBbWF6b24gUzNcIixcbiAgICBcInNlcnZpY2VGdWxsTmFtZVwiOiBcIkFtYXpvbiBTaW1wbGUgU3RvcmFnZSBTZXJ2aWNlXCIsXG4gICAgXCJzZXJ2aWNlSWRcIjogXCJTM1wiLFxuICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInMzXCIsXG4gICAgXCJ1aWRcIjogXCJzMy0yMDA2LTAzLTAxXCJcbiAgfSxcbiAgXCJvcGVyYXRpb25zXCI6IHtcbiAgICBcIkFib3J0TXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJVcGxvYWRJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidXBsb2FkSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCIsXG4gICAgICAgICAgXCJVcGxvYWRJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNdWx0aXBhcnRVcGxvYWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb21wbGV0ZU11bHRpcGFydFVwbG9hZFwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlBhcnRzXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlBhcnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIkVUYWdcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMlwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJDaGVja3N1bUNSQzMyQ1wiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJDaGVja3N1bVNIQTFcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiQ2hlY2tzdW1TSEEyNTZcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidXBsb2FkSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUNSQzMyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tY3JjMzJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUNSQzMyQ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNoZWNrc3VtLWNyYzMyY1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNoZWNrc3VtLXNoYTFcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bVNIQTI1NlwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNoZWNrc3VtLXNoYTI1NlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTa1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk11bHRpcGFydFVwbG9hZFwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkxvY2F0aW9uXCI6IHt9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGlyYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMlwiOiB7fSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHt9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHt9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEEyNTZcIjoge30sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRLZXlFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1idWNrZXQta2V5LWVuYWJsZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkNvcHlPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiQ29weVNvdXJjZVwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFDTFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFjbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1UeXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tb2RpZmllZC1zaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTm9uZU1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbm9uZS1tYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZlVubW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLXVubW9kaWZpZWQtc2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWV0YWRhdGFEaXJlY3RpdmVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhZGF0YS1kaXJlY3RpdmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nRGlyZWN0aXZlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdGFnZ2luZy1kaXJlY3RpdmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei13ZWJzaXRlLXJlZGlyZWN0LWxvY2F0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTa1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNFbmNyeXB0aW9uQ29udGV4dFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY29udGV4dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldEtleUVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWJ1Y2tldC1rZXktZW5hYmxlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWtcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnZ2luZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXRhZ2dpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMW9cIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZFNvdXJjZUJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc291cmNlLWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNvcHlPYmplY3RSZXN1bHRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkVUYWdcIjoge30sXG4gICAgICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge30sXG4gICAgICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMkNcIjoge30sXG4gICAgICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHt9LFxuICAgICAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBpcmF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXZlcnNpb24taWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNFbmNyeXB0aW9uQ29udGV4dFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY29udGV4dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldEtleUVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWJ1Y2tldC1rZXktZW5hYmxlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkNvcHlPYmplY3RSZXN1bHRcIlxuICAgICAgfSxcbiAgICAgIFwiYWxpYXNcIjogXCJQdXRPYmplY3RDb3B5XCJcbiAgICB9LFxuICAgIFwiQ3JlYXRlQnVja2V0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBQ0xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hY2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkxvY2F0aW9uQ29uc3RyYWludFwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tFbmFibGVkRm9yQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYnVja2V0LW9iamVjdC1sb2NrLWVuYWJsZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RPd25lcnNoaXBcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3Qtb3duZXJzaGlwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkNyZWF0ZUJ1Y2tldENvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkxvY2F0aW9uXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiUHV0QnVja2V0XCJcbiAgICB9LFxuICAgIFwiQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/dXBsb2Fkc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFDTFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFjbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIldlYnNpdGVSZWRpcmVjdExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotd2Vic2l0ZS1yZWRpcmVjdC1sb2NhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2tcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TRW5jcnlwdGlvbkNvbnRleHRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWNvbnRleHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRLZXlFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1idWNrZXQta2V5LWVuYWJsZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVGFnZ2luZ1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXRhZ2dpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMW9cIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFib3J0RGF0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFib3J0LWRhdGVcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFib3J0UnVsZUlkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWJvcnQtcnVsZS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHt9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNFbmNyeXB0aW9uQ29udGV4dFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY29udGV4dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldEtleUVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWJ1Y2tldC1rZXktZW5hYmxlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWxpYXNcIjogXCJJbml0aWF0ZU11bHRpcGFydFVwbG9hZFwiXG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH1cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0QW5hbHl0aWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YW5hbHl0aWNzXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRDb3JzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9jb3JzXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldEVuY3J5cHRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2VuY3J5cHRpb25cIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0SW50ZWxsaWdlbnRUaWVyaW5nQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/aW50ZWxsaWdlbnQtdGllcmluZ1wiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9pbnZlbnRvcnlcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldExpZmVjeWNsZVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bGlmZWN5Y2xlXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldE1ldHJpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9tZXRyaWNzXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVCdWNrZXRPd25lcnNoaXBDb250cm9sc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/b3duZXJzaGlwQ29udHJvbHNcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0UG9saWN5XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiREVMRVRFXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wb2xpY3lcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0UmVwbGljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCIsXG4gICAgICAgIFwicmVzcG9uc2VDb2RlXCI6IDIwNFxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkRlbGV0ZUJ1Y2tldFRhZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3RhZ2dpbmdcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlQnVja2V0V2Vic2l0ZVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/d2Vic2l0ZVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiLFxuICAgICAgICBcInJlc3BvbnNlQ29kZVwiOiAyMDRcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTUZBXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWZhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnlwYXNzR292ZXJuYW5jZVJldGVudGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWJ5cGFzcy1nb3Zlcm5hbmNlLXJldGVudGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVsZXRlT2JqZWN0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3RhZ2dpbmdcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXZlcnNpb24taWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVPYmplY3RzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9kZWxldGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIkRlbGV0ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxldGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJEZWxldGVcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiT2JqZWN0c1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJPYmplY3RzXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk9iamVjdFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICBcIktleVwiXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUXVpZXRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1GQVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1mYVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCeXBhc3NHb3Zlcm5hbmNlUmV0ZW50aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYnlwYXNzLWdvdmVybmFuY2UtcmV0ZW50aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJEZWxldGVcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWxldGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgXCJWZXJzaW9uSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkRlbGV0ZU1hcmtlclZlcnNpb25JZFwiOiB7fVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVycm9yc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkVycm9yXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiQ29kZVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIk1lc3NhZ2VcIjoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiRGVsZXRlTXVsdGlwbGVPYmplY3RzXCIsXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdEFsZ29yaXRobU1lbWJlclwiOiBcIkNoZWNrc3VtQWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJEZWxldGVQdWJsaWNBY2Nlc3NCbG9ja1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cHVibGljQWNjZXNzQmxvY2tcIixcbiAgICAgICAgXCJyZXNwb25zZUNvZGVcIjogMjA0XG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0QWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2FjY2VsZXJhdGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldEFjbFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YWNsXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2dcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQWNjZXNzQ29udHJvbExpc3RcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hbmFseXRpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3BcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldENvcnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2NvcnNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNPUlNSdWxlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzQ0XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNPUlNSdWxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0RW5jcnlwdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/ZW5jcnlwdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNGhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0SW50ZWxsaWdlbnRUaWVyaW5nQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/aW50ZWxsaWdlbnQtdGllcmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSW50ZWxsaWdlbnRUaWVyaW5nQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkludGVsbGlnZW50VGllcmluZ0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9pbnZlbnRvcnlcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNHhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldExpZmVjeWNsZVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bGlmZWN5Y2xlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVkXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldExpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1dFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSdWxlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0TG9jYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xvY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJMb2NhdGlvbkNvbnN0cmFpbnRcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRMb2dnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9sb2dnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJMb2dnaW5nRW5hYmxlZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzY1XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0TWV0cmljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P21ldHJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJpZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0Tm90aWZpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9ub3RpZmljYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInNoYXBlXCI6IFwiUzZoXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTNmlcIlxuICAgICAgfSxcbiAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldE5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P25vdGlmaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTNmhcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJzaGFwZVwiOiBcIlM2dFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldE93bmVyc2hpcENvbnRyb2xzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9vd25lcnNoaXBDb250cm9sc1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiT3duZXJzaGlwQ29udHJvbHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3YVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJPd25lcnNoaXBDb250cm9sc1wiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFBvbGljeVwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cG9saWN5XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQb2xpY3lcIjoge31cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUG9saWN5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0UG9saWN5U3RhdHVzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wb2xpY3lTdGF0dXNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlBvbGljeVN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiSXNQdWJsaWNcIjoge1xuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSXNQdWJsaWNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUG9saWN5U3RhdHVzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0UmVwbGljYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3JlcGxpY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM3bVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRCdWNrZXRSZXF1ZXN0UGF5bWVudFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/cmVxdWVzdFBheW1lbnRcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlBheWVyXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0QnVja2V0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlRhZ1NldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJUYWdTZXRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzdlwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFZlcnNpb25pbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3ZlcnNpb25pbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICBcIk1GQURlbGV0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk1mYURlbGV0ZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldEJ1Y2tldFdlYnNpdGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3dlYnNpdGVcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlZGlyZWN0QWxsUmVxdWVzdHNUb1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzhwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW5kZXhEb2N1bWVudFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzhzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXJyb3JEb2N1bWVudFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzh1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUm91dGluZ1J1bGVzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOHZcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklmTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1NYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklmTW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLU1vZGlmaWVkLVNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk5vbmVNYXRjaFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLU5vbmUtTWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZlVubW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJhbmdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUmFuZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXNwb25zZUNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicmVzcG9uc2UtY2FjaGUtY29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3BvbnNlQ29udGVudERpc3Bvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzcG9uc2VDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInJlc3BvbnNlLWNvbnRlbnQtZW5jb2RpbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXNwb25zZUNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicmVzcG9uc2UtY29udGVudC1sYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3BvbnNlQ29udGVudFR5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInJlc3BvbnNlLWNvbnRlbnQtdHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3BvbnNlRXhwaXJlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicmVzcG9uc2UtZXhwaXJlc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcInRpbWVzdGFtcEZvcm1hdFwiOiBcInJmYzgyMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTa1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInBhcnROdW1iZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1Nb2RlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tbW9kZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJvZHlcIjoge1xuICAgICAgICAgICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJsb2JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXB0UmFuZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiYWNjZXB0LXJhbmdlc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBpcmF0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzdG9yZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlc3RvcmVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJMYXN0LU1vZGlmaWVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TGVuZ3RoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1jcmMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tY3JjMzJjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMjU2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWlzc2luZ01ldGFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1taXNzaW5nLW1ldGFcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei12ZXJzaW9uLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2FjaGUtQ29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnREaXNwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RW5jb2RpbmdcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MYW5ndWFnZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRSYW5nZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtUmFuZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFiXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyc1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhLVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0S2V5RW5hYmxlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYnVja2V0LWtleS1lbmFibGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVwbGljYXRpb25TdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXBsaWNhdGlvbi1zdGF0dXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0c0NvdW50XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbXAtcGFydHMtY291bnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdDb3VudFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXRhZ2dpbmctY291bnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMW9cIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCb2R5XCJcbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdFZhbGlkYXRpb25Nb2RlTWVtYmVyXCI6IFwiQ2hlY2tzdW1Nb2RlXCIsXG4gICAgICAgIFwicmVzcG9uc2VBbGdvcml0aG1zXCI6IFtcbiAgICAgICAgICBcIkNSQzMyXCIsXG4gICAgICAgICAgXCJDUkMzMkNcIixcbiAgICAgICAgICBcIlNIQTI1NlwiLFxuICAgICAgICAgIFwiU0hBMVwiXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0QWNsXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/YWNsXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2RcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2Nlc3NDb250cm9sTGlzdFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0QXR0cmlidXRlc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P2F0dHJpYnV0ZXNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiT2JqZWN0QXR0cmlidXRlc1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1heFBhcnRzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWF4LXBhcnRzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlck1hcmtlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXBhcnQtbnVtYmVyLW1hcmtlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2tcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0QXR0cmlidXRlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1hdHRyaWJ1dGVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1kZWxldGUtbWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGFzdC1Nb2RpZmllZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICBcIkNoZWNrc3VtXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJDaGVja3N1bUNSQzMyXCI6IHt9LFxuICAgICAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHt9LFxuICAgICAgICAgICAgICBcIkNoZWNrc3VtU0hBMVwiOiB7fSxcbiAgICAgICAgICAgICAgXCJDaGVja3N1bVNIQTI1NlwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RQYXJ0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiVG90YWxQYXJ0c0NvdW50XCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlBhcnRzQ291bnRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJQYXJ0TnVtYmVyTWFya2VyXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJOZXh0UGFydE51bWJlck1hcmtlclwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiTWF4UGFydHNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJQYXJ0c1wiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJQYXJ0XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJQYXJ0TnVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJTaXplXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJDaGVja3N1bUNSQzMyXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICBcIkNoZWNrc3VtU0hBMVwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgXCJDaGVja3N1bVNIQTI1NlwiOiB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fSxcbiAgICAgICAgICBcIk9iamVjdFNpemVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldE9iamVjdExlZ2FsSG9sZFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P2xlZ2FsLWhvbGRcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTGVnYWxIb2xkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYTlcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTGVnYWxIb2xkXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0TG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P29iamVjdC1sb2NrXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FjXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk9iamVjdExvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0UmV0ZW50aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/cmV0ZW50aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJldGVudGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FrXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlJldGVudGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldE9iamVjdFRhZ2dpbmdcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT90YWdnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJUYWdTZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ1NldFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzN2XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0T2JqZWN0VG9ycmVudFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3RvcnJlbnRcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJvZHlcIjoge1xuICAgICAgICAgICAgXCJzdHJlYW1pbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJsb2JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCb2R5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0UHVibGljQWNjZXNzQmxvY2tcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3B1YmxpY0FjY2Vzc0Jsb2NrXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNhclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJIZWFkQnVja2V0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiSEVBRFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH1cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkhlYWRPYmplY3RcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJIRUFEXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWYtTWF0Y2hcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZk1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Nb2RpZmllZC1TaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZOb25lTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Ob25lLU1hdGNoXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWZVbm1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJZi1Vbm1vZGlmaWVkLVNpbmNlXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSYW5nZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJhbmdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNrXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydE51bWJlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bU1vZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1tb2RlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRGVsZXRlTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZGVsZXRlLW1hcmtlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFjY2VwdFJhbmdlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImFjY2VwdC1yYW5nZXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwaXJhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlc3RvcmVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXN0b3JlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQXJjaGl2ZVN0YXR1c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFyY2hpdmUtc3RhdHVzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTGFzdE1vZGlmaWVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGFzdC1Nb2RpZmllZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExlbmd0aFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMlwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNoZWNrc3VtLWNyYzMyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMkNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1jcmMzMmNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bVNIQTFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1zaGExXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEEyNTZcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1zaGEyNTZcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1pc3NpbmdNZXRhXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWlzc2luZy1tZXRhXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGlyZXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFeHBpcmVzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlUmVkaXJlY3RMb2NhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXdlYnNpdGUtcmVkaXJlY3QtbG9jYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFiXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyc1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1tZXRhLVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0S2V5RW5hYmxlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYnVja2V0LWtleS1lbmFibGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc3RvcmFnZS1jbGFzc1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVwbGljYXRpb25TdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXBsaWNhdGlvbi1zdGF0dXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0c0NvdW50XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbXAtcGFydHMtY291bnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTW9kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrUmV0YWluVW50aWxEYXRlXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMW9cIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbGVnYWwtaG9sZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RCdWNrZXRBbmFseXRpY3NDb25maWd1cmF0aW9uc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YW5hbHl0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJjb250aW51YXRpb24tdG9rZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSXNUcnVuY2F0ZWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dENvbnRpbnVhdGlvblRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvbkxpc3RcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3BcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdEJ1Y2tldEludGVsbGlnZW50VGllcmluZ0NvbmZpZ3VyYXRpb25zXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9pbnRlbGxpZ2VudC10aWVyaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJjb250aW51YXRpb24tdG9rZW5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJJbnRlbGxpZ2VudFRpZXJpbmdDb25maWd1cmF0aW9uTGlzdFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkludGVsbGlnZW50VGllcmluZ0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0blwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJMaXN0QnVja2V0SW52ZW50b3J5Q29uZmlndXJhdGlvbnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2ludmVudG9yeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250aW51YXRpb25Ub2tlblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiY29udGludWF0aW9uLXRva2VuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNvbnRpbnVhdGlvblRva2VuXCI6IHt9LFxuICAgICAgICAgIFwiSW52ZW50b3J5Q29uZmlndXJhdGlvbkxpc3RcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJJbnZlbnRvcnlDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNHhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSXNUcnVuY2F0ZWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5leHRDb250aW51YXRpb25Ub2tlblwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RCdWNrZXRNZXRyaWNzQ29uZmlndXJhdGlvbnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJHRVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P21ldHJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImNvbnRpbnVhdGlvbi10b2tlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvbkxpc3RcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RCdWNrZXRzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0c1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkNyZWF0aW9uRGF0ZVwiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiR2V0U2VydmljZVwiXG4gICAgfSxcbiAgICBcIkxpc3RNdWx0aXBhcnRVcGxvYWRzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT91cGxvYWRzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiZGVsaW1pdGVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJlbmNvZGluZy10eXBlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5TWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJrZXktbWFya2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4VXBsb2Fkc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwibWF4LXVwbG9hZHNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInByZWZpeFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWQtaWQtbWFya2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICBcIktleU1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIlVwbG9hZElkTWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dEtleU1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICBcIk5leHRVcGxvYWRJZE1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIk1heFVwbG9hZHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJVcGxvYWRzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVXBsb2FkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiVXBsb2FkSWRcIjoge30sXG4gICAgICAgICAgICAgICAgXCJLZXlcIjoge30sXG4gICAgICAgICAgICAgICAgXCJJbml0aWF0ZWRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkluaXRpYXRvclwiOiB7XG4gICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNic1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVuY29kaW5nVHlwZVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkxpc3RPYmplY3RWZXJzaW9uc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dmVyc2lvbnNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJkZWxpbWl0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImVuY29kaW5nLXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImtleS1tYXJrZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJtYXgta2V5c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicHJlZml4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uLWlkLW1hcmtlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJJc1RydW5jYXRlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiVmVyc2lvbklkTWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiTmV4dEtleU1hcmtlclwiOiB7fSxcbiAgICAgICAgICBcIk5leHRWZXJzaW9uSWRNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJWZXJzaW9uc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlZlcnNpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjMVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlNpemVcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIklzTGF0ZXN0XCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRGVsZXRlTWFya2VyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIklzTGF0ZXN0XCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgXCJEZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiR2V0QnVja2V0T2JqZWN0VmVyc2lvbnNcIlxuICAgIH0sXG4gICAgXCJMaXN0T2JqZWN0c1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH1cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJkZWxpbWl0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImVuY29kaW5nLXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIm1hcmtlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1heEtleXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIm1heC1rZXlzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJwcmVmaXhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXJrZXJcIjoge30sXG4gICAgICAgICAgXCJOZXh0TWFya2VyXCI6IHt9LFxuICAgICAgICAgIFwiQ29udGVudHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjYVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgXCJEZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb21tb25QcmVmaXhlc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRW5jb2RpbmdUeXBlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFsaWFzXCI6IFwiR2V0QnVja2V0XCJcbiAgICB9LFxuICAgIFwiTGlzdE9iamVjdHNWMlwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIkdFVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bGlzdC10eXBlPTJcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRGVsaW1pdGVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJkZWxpbWl0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImVuY29kaW5nLXR5cGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNYXhLZXlzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJtYXgta2V5c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicHJlZml4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImNvbnRpbnVhdGlvbi10b2tlblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkZldGNoT3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImZldGNoLW93bmVyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RhcnRBZnRlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwic3RhcnQtYWZ0ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50c1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2NhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICBcIkRlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICBcIk1heEtleXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbW1vblByZWZpeGVzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTYnNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFbmNvZGluZ1R5cGVcIjoge30sXG4gICAgICAgICAgXCJLZXlDb3VudFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJOZXh0Q29udGludWF0aW9uVG9rZW5cIjoge30sXG4gICAgICAgICAgXCJTdGFydEFmdGVyXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiTGlzdFBhcnRzXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiR0VUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiVXBsb2FkSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4UGFydHNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIm1heC1wYXJ0c1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhcnROdW1iZXJNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInBhcnQtbnVtYmVyLW1hcmtlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTa1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQWJvcnREYXRlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWJvcnQtZGF0ZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWJvcnRSdWxlSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1hYm9ydC1ydWxlLWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICAgIFwiVXBsb2FkSWRcIjoge30sXG4gICAgICAgICAgXCJQYXJ0TnVtYmVyTWFya2VyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOZXh0UGFydE51bWJlck1hcmtlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4UGFydHNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklzVHJ1bmNhdGVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0c1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlBhcnRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJQYXJ0TnVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlNpemVcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge30sXG4gICAgICAgICAgICAgICAgXCJDaGVja3N1bUNSQzMyQ1wiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkNoZWNrc3VtU0hBMVwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkluaXRpYXRvclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2JyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT3duZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fSxcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRBY2NlbGVyYXRlQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YWNjZWxlcmF0ZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2NlbGVyYXRlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZGstY2hlY2tzdW0tYWxnb3JpdGhtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFjY2VsZXJhdGVDb25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdEFsZ29yaXRobU1lbWJlclwiOiBcIkNoZWNrc3VtQWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0QWNsXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9hY2xcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXNzQ29udHJvbFBvbGljeVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2NwXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudEZ1bGxDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtZnVsbC1jb250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZEFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWQtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRXcml0ZUFDUFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXdyaXRlLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQWNjZXNzQ29udHJvbFBvbGljeVwiXG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0QW5hbHl0aWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/YW5hbHl0aWNzXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJJZFwiLFxuICAgICAgICAgIFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbmFseXRpY3NDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3BcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQW5hbHl0aWNzQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldENvcnNcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2NvcnNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIkNPUlNDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNPUlNDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ09SU0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiQ09SU1J1bGVzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkNPUlNSdWxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0NFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ09SU1J1bGVcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQ09SU0NvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldEVuY3J5cHRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2VuY3J5cHRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0aFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0SW50ZWxsaWdlbnRUaWVyaW5nQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/aW50ZWxsaWdlbnQtdGllcmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIixcbiAgICAgICAgICBcIkludGVsbGlnZW50VGllcmluZ0NvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW50ZWxsaWdlbnRUaWVyaW5nQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzRuXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkludGVsbGlnZW50VGllcmluZ0NvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiSW50ZWxsaWdlbnRUaWVyaW5nQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldEludmVudG9yeUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2ludmVudG9yeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiSWRcIixcbiAgICAgICAgICBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcImlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSW52ZW50b3J5Q29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzR4XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkludmVudG9yeUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRMaWZlY3ljbGVcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1ZFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUnVsZVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldExpZmVjeWNsZUNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P2xpZmVjeWNsZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTGlmZWN5Y2xlQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJSdWxlc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1dFwiLFxuICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUnVsZVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJMaWZlY3ljbGVDb25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdEFsZ29yaXRobU1lbWJlclwiOiBcIkNoZWNrc3VtQWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRMb2dnaW5nXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9sb2dnaW5nXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJCdWNrZXRMb2dnaW5nU3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldExvZ2dpbmdTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRMb2dnaW5nU3RhdHVzXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiTG9nZ2luZ0VuYWJsZWRcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNjVcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiQnVja2V0TG9nZ2luZ1N0YXR1c1wiXG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0TWV0cmljc0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P21ldHJpY3NcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIklkXCIsXG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZkXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk1ldHJpY3NDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJNZXRyaWNzQ29uZmlndXJhdGlvblwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldE5vdGlmaWNhdGlvblwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/bm90aWZpY2F0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2aVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldE5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P25vdGlmaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb3RpZmljYXRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNnRcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTm90aWZpY2F0aW9uQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTa2lwRGVzdGluYXRpb25WYWxpZGF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2tpcC1kZXN0aW5hdGlvbi12YWxpZGF0aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk5vdGlmaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRPd25lcnNoaXBDb250cm9sc1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/b3duZXJzaGlwQ29udHJvbHNcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIk93bmVyc2hpcENvbnRyb2xzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPd25lcnNoaXBDb250cm9sc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzdhXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk93bmVyc2hpcENvbnRyb2xzXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIk93bmVyc2hpcENvbnRyb2xzXCJcbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRQb2xpY3lcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9P3BvbGljeVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUG9saWN5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbmZpcm1SZW1vdmVTZWxmQnVja2V0QWNjZXNzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29uZmlybS1yZW1vdmUtc2VsZi1idWNrZXQtYWNjZXNzXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUG9saWN5XCI6IHt9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJQb2xpY3lcIlxuICAgICAgfSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldFJlcGxpY2F0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXBsaWNhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUmVwbGljYXRpb25Db25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzdtXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJlcGxpY2F0aW9uQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYnVja2V0LW9iamVjdC1sb2NrLXRva2VuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXBsaWNhdGlvbkNvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dEJ1Y2tldFJlcXVlc3RQYXltZW50XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9yZXF1ZXN0UGF5bWVudFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUmVxdWVzdFBheW1lbnRDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJQYXllclwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJQYXllclwiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlJlcXVlc3RQYXltZW50Q29uZmlndXJhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiVGFnZ2luZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTZGZcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnZ2luZ1wiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiVGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0QnVja2V0VmVyc2lvbmluZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0/dmVyc2lvbmluZ1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiVmVyc2lvbmluZ0NvbmZpZ3VyYXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZGstY2hlY2tzdW0tYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTUZBXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWZhXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbmluZ0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJWZXJzaW9uaW5nQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIk1GQURlbGV0ZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJNZmFEZWxldGVcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlZlcnNpb25pbmdDb25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdEFsZ29yaXRobU1lbWJlclwiOiBcIkNoZWNrc3VtQWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRCdWNrZXRXZWJzaXRlXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT93ZWJzaXRlXCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJXZWJzaXRlQ29uZmlndXJhdGlvblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJXZWJzaXRlQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIldlYnNpdGVDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRXJyb3JEb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM4dVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiSW5kZXhEb2N1bWVudFwiOiB7XG4gICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM4c1wiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUmVkaXJlY3RBbGxSZXF1ZXN0c1RvXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzhwXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJSb3V0aW5nUnVsZXNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOHZcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiV2Vic2l0ZUNvbmZpZ3VyYXRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9XCJcbiAgICAgIH0sXG4gICAgICBcImlucHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQUNMXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYWNsXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQm9keVwiOiB7XG4gICAgICAgICAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNhY2hlQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNhY2hlLUNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50RGlzcG9zaXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1FbmNvZGluZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGFuZ3VhZ2VcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TGVuZ3RoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1MZW5ndGhcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ29udGVudC1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb250ZW50VHlwZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1jcmMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tY3JjMzJjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMjU2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV4cGlyZXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50RnVsbENvbnRyb2xcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1mdWxsLWNvbnRyb2xcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRSZWFkQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtcmVhZC1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFdyaXRlQUNQXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZ3JhbnQtd3JpdGUtYWNwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxYlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlcnNcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotbWV0YS1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zdG9yYWdlLWNsYXNzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiV2Vic2l0ZVJlZGlyZWN0TG9jYXRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei13ZWJzaXRlLXJlZGlyZWN0LWxvY2F0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTa1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VLTVNFbmNyeXB0aW9uQ29udGV4dFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY29udGV4dFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldEtleUVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWJ1Y2tldC1rZXktZW5hYmxlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdnaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdGFnZ2luZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tNb2RlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotb2JqZWN0LWxvY2stbW9kZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tSZXRhaW5VbnRpbERhdGVcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxb1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1yZXRhaW4tdW50aWwtZGF0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk9iamVjdExvY2tMZWdhbEhvbGRTdGF0dXNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1vYmplY3QtbG9jay1sZWdhbC1ob2xkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJCb2R5XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGlyYXRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1jcmMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tY3JjMzJjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMjU2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUtNU0tleUlkXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWF3cy1rbXMta2V5LWlkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TRW5jcnlwdGlvbkNvbnRleHRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMxaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWNvbnRleHRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRLZXlFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1idWNrZXQta2V5LWVuYWJsZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdEFjbFwiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P2FjbFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkFDTFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWFjbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjcFwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJBY2Nlc3NDb250cm9sUG9saWN5XCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZGstY2hlY2tzdW0tYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiR3JhbnRGdWxsQ29udHJvbFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LWZ1bGwtY29udHJvbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50UmVhZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWdyYW50LXJlYWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJHcmFudFJlYWRBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC1yZWFkLWFjcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50V3JpdGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC13cml0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkdyYW50V3JpdGVBQ1BcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1ncmFudC13cml0ZS1hY3BcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkFjY2Vzc0NvbnRyb2xQb2xpY3lcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0T2JqZWN0TGVnYWxIb2xkXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/bGVnYWwtaG9sZFwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxlZ2FsSG9sZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2E5XCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkxlZ2FsSG9sZFwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiTGVnYWxIb2xkXCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dE9iamVjdExvY2tDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9vYmplY3QtbG9ja1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FjXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIk9iamVjdExvY2tDb25maWd1cmF0aW9uXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVxdWVzdFBheWVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1wYXllclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRva2VuXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYnVja2V0LW9iamVjdC1sb2NrLXRva2VuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZGstY2hlY2tzdW0tYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJPYmplY3RMb2NrQ29uZmlndXJhdGlvblwiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlJlcXVlc3RDaGFyZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdEFsZ29yaXRobU1lbWJlclwiOiBcIkNoZWNrc3VtQWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJQdXRPYmplY3RSZXRlbnRpb25cIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJtZXRob2RcIjogXCJQVVRcIixcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9yZXRlbnRpb25cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXRlbnRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNha1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSZXRlbnRpb25cIixcbiAgICAgICAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vczMuYW1hem9uYXdzLmNvbS9kb2MvMjAwNi0wMy0wMS9cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiVmVyc2lvbklkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ2ZXJzaW9uSWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCeXBhc3NHb3Zlcm5hbmNlUmV0ZW50aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotYnlwYXNzLWdvdmVybmFuY2UtcmV0ZW50aW9uXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudE1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZGstY2hlY2tzdW0tYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJSZXRlbnRpb25cIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUHV0T2JqZWN0VGFnZ2luZ1wiOiB7XG4gICAgICBcImh0dHBcIjoge1xuICAgICAgICBcIm1ldGhvZFwiOiBcIlBVVFwiLFxuICAgICAgICBcInJlcXVlc3RVcmlcIjogXCIve0J1Y2tldH0ve0tleSt9P3RhZ2dpbmdcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiVGFnZ2luZ1wiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJCdWNrZXRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJLZXlcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInVyaVwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJLZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJWZXJzaW9uSWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcInF1ZXJ5c3RyaW5nXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInZlcnNpb25JZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNkZlwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUYWdnaW5nXCIsXG4gICAgICAgICAgICBcInhtbE5hbWVzcGFjZVwiOiB7XG4gICAgICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiVGFnZ2luZ1wiXG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXZlcnNpb24taWRcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiaHR0cENoZWNrc3VtXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0QWxnb3JpdGhtTWVtYmVyXCI6IFwiQ2hlY2tzdW1BbGdvcml0aG1cIixcbiAgICAgICAgXCJyZXF1ZXN0Q2hlY2tzdW1SZXF1aXJlZFwiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlB1dFB1YmxpY0FjY2Vzc0Jsb2NrXCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fT9wdWJsaWNBY2Nlc3NCbG9ja1wiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2FyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1leHBlY3RlZC1idWNrZXQtb3duZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYXlsb2FkXCI6IFwiUHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBcImh0dHBDaGVja3N1bVwiOiB7XG4gICAgICAgIFwicmVxdWVzdEFsZ29yaXRobU1lbWJlclwiOiBcIkNoZWNrc3VtQWxnb3JpdGhtXCIsXG4gICAgICAgIFwicmVxdWVzdENoZWNrc3VtUmVxdWlyZWRcIjogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJSZXN0b3JlT2JqZWN0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K30/cmVzdG9yZVwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgIFwiS2V5XCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIktleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwidmVyc2lvbklkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzdG9yZVJlcXVlc3RcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSZXN0b3JlUmVxdWVzdFwiLFxuICAgICAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgICAgICBcInVyaVwiOiBcImh0dHA6Ly9zMy5hbWF6b25hd3MuY29tL2RvYy8yMDA2LTAzLTAxL1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkRheXNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkdsYWNpZXJKb2JQYXJhbWV0ZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiVGllclwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJUaWVyXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlR5cGVcIjoge30sXG4gICAgICAgICAgICAgIFwiVGllclwiOiB7fSxcbiAgICAgICAgICAgICAgXCJEZXNjcmlwdGlvblwiOiB7fSxcbiAgICAgICAgICAgICAgXCJTZWxlY3RQYXJhbWV0ZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgIFwiSW5wdXRTZXJpYWxpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCIsXG4gICAgICAgICAgICAgICAgICBcIkV4cHJlc3Npb25cIixcbiAgICAgICAgICAgICAgICAgIFwiT3V0cHV0U2VyaWFsaXphdGlvblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJJbnB1dFNlcmlhbGl6YXRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU2U1XCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJFeHByZXNzaW9uXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJPdXRwdXRTZXJpYWxpemF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNla1wiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIk91dHB1dExvY2F0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTM1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ1Y2tldE5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIlByZWZpeFwiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJCdWNrZXROYW1lXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25UeXBlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25UeXBlXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIktNU0tleUlkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiU3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIktNU0NvbnRleHRcIjoge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQ2FubmVkQUNMXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQWNjZXNzQ29udHJvbExpc3RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlRhZ2dpbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNkZlwiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlVzZXJNZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiTWV0YWRhdGFFbnRyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJWYWx1ZVwiOiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDaGVja3N1bUFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNkay1jaGVja3N1bS1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlJlc3RvcmVSZXF1ZXN0XCJcbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUmVxdWVzdENoYXJnZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LWNoYXJnZWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXN0b3JlT3V0cHV0UGF0aFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlc3RvcmUtb3V0cHV0LXBhdGhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWxpYXNcIjogXCJQb3N0T2JqZWN0UmVzdG9yZVwiLFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNlbGVjdE9iamVjdENvbnRlbnRcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL3tCdWNrZXR9L3tLZXkrfT9zZWxlY3Qmc2VsZWN0LXR5cGU9MlwiXG4gICAgICB9LFxuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiU2VsZWN0T2JqZWN0Q29udGVudFJlcXVlc3RcIixcbiAgICAgICAgXCJ4bWxOYW1lc3BhY2VcIjoge1xuICAgICAgICAgIFwidXJpXCI6IFwiaHR0cDovL3MzLmFtYXpvbmF3cy5jb20vZG9jLzIwMDYtMDMtMDEvXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgIFwiQnVja2V0XCIsXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIkV4cHJlc3Npb25cIixcbiAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCIsXG4gICAgICAgICAgXCJJbnB1dFNlcmlhbGl6YXRpb25cIixcbiAgICAgICAgICBcIk91dHB1dFNlcmlhbGl6YXRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTa1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwcmVzc2lvblwiOiB7fSxcbiAgICAgICAgICBcIkV4cHJlc3Npb25UeXBlXCI6IHt9LFxuICAgICAgICAgIFwiUmVxdWVzdFByb2dyZXNzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJFbmFibGVkXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJJbnB1dFNlcmlhbGl6YXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNlNVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk91dHB1dFNlcmlhbGl6YXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNla1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNjYW5SYW5nZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiU3RhcnRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkVuZFwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlBheWxvYWRcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIlJlY29yZHNcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIlBheWxvYWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImV2ZW50cGF5bG9hZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJibG9iXCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZXZlbnRcIjogdHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlN0YXRzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJEZXRhaWxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJldmVudHBheWxvYWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJCeXRlc1NjYW5uZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzUHJvY2Vzc2VkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJCeXRlc1JldHVybmVkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiUHJvZ3Jlc3NcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIkRldGFpbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcImV2ZW50cGF5bG9hZFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzU2Nhbm5lZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiQnl0ZXNQcm9jZXNzZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkJ5dGVzUmV0dXJuZWRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImV2ZW50XCI6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJDb250XCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge30sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRW5kXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge30sXG4gICAgICAgICAgICAgICAgXCJldmVudFwiOiB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImV2ZW50c3RyZWFtXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIlBheWxvYWRcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJVcGxvYWRQYXJ0XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiUGFydE51bWJlclwiLFxuICAgICAgICAgIFwiVXBsb2FkSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQm9keVwiOiB7XG4gICAgICAgICAgICBcInN0cmVhbWluZ1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYmxvYlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJ1Y2tldFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRMZW5ndGhcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LUxlbmd0aFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvbnRlbnRNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDb250ZW50LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2RrLWNoZWNrc3VtLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1jcmMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tY3JjMzJjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMjU2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydE51bWJlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2tcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RQYXllclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtcGF5ZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBlY3RlZEJ1Y2tldE93bmVyXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkJvZHlcIlxuICAgICAgfSxcbiAgICAgIFwib3V0cHV0XCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJTZXJ2ZXJTaWRlRW5jcnlwdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRVRhZ1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jaGVja3N1bS1jcmMzMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJDXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tY3JjMzJjXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1TSEExXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY2hlY2tzdW0tc2hhMjU2XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRLZXlFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1idWNrZXQta2V5LWVuYWJsZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJodHRwQ2hlY2tzdW1cIjoge1xuICAgICAgICBcInJlcXVlc3RBbGdvcml0aG1NZW1iZXJcIjogXCJDaGVja3N1bUFsZ29yaXRobVwiLFxuICAgICAgICBcInJlcXVlc3RDaGVja3N1bVJlcXVpcmVkXCI6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlVwbG9hZFBhcnRDb3B5XCI6IHtcbiAgICAgIFwiaHR0cFwiOiB7XG4gICAgICAgIFwibWV0aG9kXCI6IFwiUFVUXCIsXG4gICAgICAgIFwicmVxdWVzdFVyaVwiOiBcIi97QnVja2V0fS97S2V5K31cIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJCdWNrZXRcIixcbiAgICAgICAgICBcIkNvcHlTb3VyY2VcIixcbiAgICAgICAgICBcIktleVwiLFxuICAgICAgICAgIFwiUGFydE51bWJlclwiLFxuICAgICAgICAgIFwiVXBsb2FkSWRcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQnVja2V0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTWF0Y2hcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZk1vZGlmaWVkU2luY2VcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1pZi1tb2RpZmllZC1zaW5jZVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZUlmTm9uZU1hdGNoXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2UtaWYtbm9uZS1tYXRjaFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VJZlVubW9kaWZpZWRTaW5jZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLWlmLXVubW9kaWZpZWQtc2luY2VcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VSYW5nZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXJhbmdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiS2V5XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJ1cmlcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiS2V5XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFydE51bWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwicXVlcnlzdHJpbmdcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwicGFydE51bWJlclwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlVwbG9hZElkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJxdWVyeXN0cmluZ1wiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ1cGxvYWRJZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyQWxnb3JpdGhtXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1hbGdvcml0aG1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2tcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTU0VDdXN0b21lcktleU1ENVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXIta2V5LU1ENVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNvcHlTb3VyY2VTU0VDdXN0b21lckFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5XCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWtcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXlcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5U291cmNlU1NFQ3VzdG9tZXJLZXlNRDVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1jb3B5LXNvdXJjZS1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0UGF5ZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1yZXF1ZXN0LXBheWVyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwZWN0ZWRCdWNrZXRPd25lclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4cGVjdGVkU291cmNlQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zb3VyY2UtZXhwZWN0ZWQtYnVja2V0LW93bmVyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ29weVNvdXJjZVZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWNvcHktc291cmNlLXZlcnNpb24taWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJDb3B5UGFydFJlc3VsdFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiRVRhZ1wiOiB7fSxcbiAgICAgICAgICAgICAgXCJMYXN0TW9kaWZpZWRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMlwiOiB7fSxcbiAgICAgICAgICAgICAgXCJDaGVja3N1bUNSQzMyQ1wiOiB7fSxcbiAgICAgICAgICAgICAgXCJDaGVja3N1bVNIQTFcIjoge30sXG4gICAgICAgICAgICAgIFwiQ2hlY2tzdW1TSEEyNTZcIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VydmVyU2lkZUVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWFsZ29yaXRobVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYXdzLWttcy1rZXktaWRcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCdWNrZXRLZXlFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1idWNrZXQta2V5LWVuYWJsZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtY2hhcmdlZFwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInBheWxvYWRcIjogXCJDb3B5UGFydFJlc3VsdFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIldyaXRlR2V0T2JqZWN0UmVzcG9uc2VcIjoge1xuICAgICAgXCJodHRwXCI6IHtcbiAgICAgICAgXCJyZXF1ZXN0VXJpXCI6IFwiL1dyaXRlR2V0T2JqZWN0UmVzcG9uc2VcIlxuICAgICAgfSxcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSZXF1ZXN0Um91dGVcIixcbiAgICAgICAgICBcIlJlcXVlc3RUb2tlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSZXF1ZXN0Um91dGVcIjoge1xuICAgICAgICAgICAgXCJob3N0TGFiZWxcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotcmVxdWVzdC1yb3V0ZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcXVlc3RUb2tlblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LXJlcXVlc3QtdG9rZW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJCb2R5XCI6IHtcbiAgICAgICAgICAgIFwic3RyZWFtaW5nXCI6IHRydWUsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJibG9iXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU3RhdHVzQ29kZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1zdGF0dXNcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFcnJvckNvZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtZXJyb3ItY29kZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkVycm9yTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1lcnJvci1tZXNzYWdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQWNjZXB0UmFuZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1hY2NlcHQtcmFuZ2VzXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2FjaGVDb250cm9sXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1DYWNoZS1Db250cm9sXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudERpc3Bvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1Db250ZW50LURpc3Bvc2l0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudEVuY29kaW5nXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1Db250ZW50LUVuY29kaW5nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1Db250ZW50LUxhbmd1YWdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudExlbmd0aFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsb25nXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudFJhbmdlXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1Db250ZW50LVJhbmdlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ29udGVudFR5cGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLUNvbnRlbnQtVHlwZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtQ1JDMzJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LWNoZWNrc3VtLWNyYzMyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1DUkMzMkNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LWNoZWNrc3VtLWNyYzMyY1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotY2hlY2tzdW0tc2hhMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkNoZWNrc3VtU0hBMjU2XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci14LWFtei1jaGVja3N1bS1zaGEyNTZcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJEZWxldGVNYXJrZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LWRlbGV0ZS1tYXJrZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci1FVGFnXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJlc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXItRXhwaXJlc1wiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotZXhwaXJhdGlvblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXItTGFzdC1Nb2RpZmllZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGltZXN0YW1wXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWlzc2luZ01ldGFcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LW1pc3NpbmctbWV0YVwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTMWJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJzXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LW1ldGEtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja01vZGVcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LW9iamVjdC1sb2NrLW1vZGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJPYmplY3RMb2NrTGVnYWxIb2xkU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci14LWFtei1vYmplY3QtbG9jay1sZWdhbC1ob2xkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiT2JqZWN0TG9ja1JldGFpblVudGlsRGF0ZVwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzFvXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotb2JqZWN0LWxvY2stcmV0YWluLXVudGlsLWRhdGVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYXJ0c0NvdW50XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci14LWFtei1tcC1wYXJ0cy1jb3VudFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlJlcGxpY2F0aW9uU3RhdHVzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci14LWFtei1yZXBsaWNhdGlvbi1zdGF0dXNcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJSZXF1ZXN0Q2hhcmdlZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotcmVxdWVzdC1jaGFyZ2VkXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVzdG9yZVwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotcmVzdG9yZVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNlcnZlclNpZGVFbmNyeXB0aW9uXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci14LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFQ3VzdG9tZXJBbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU1NFS01TS2V5SWRcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1hd3Mta21zLWtleS1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNTRUN1c3RvbWVyS2V5TUQ1XCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwieC1hbXotZndkLWhlYWRlci14LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LXN0b3JhZ2UtY2xhc3NcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdDb3VudFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotdGFnZ2luZy1jb3VudFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlZlcnNpb25JZFwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaGVhZGVyXCIsXG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWZ3ZC1oZWFkZXIteC1hbXotdmVyc2lvbi1pZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkJ1Y2tldEtleUVuYWJsZWRcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiBcImhlYWRlclwiLFxuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJ4LWFtei1md2QtaGVhZGVyLXgtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tYnVja2V0LWtleS1lbmFibGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGF5bG9hZFwiOiBcIkJvZHlcIlxuICAgICAgfSxcbiAgICAgIFwiYXV0aHR5cGVcIjogXCJ2NC11bnNpZ25lZC1ib2R5XCIsXG4gICAgICBcImVuZHBvaW50XCI6IHtcbiAgICAgICAgXCJob3N0UHJlZml4XCI6IFwie1JlcXVlc3RSb3V0ZX0uXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwic2hhcGVzXCI6IHtcbiAgICBcIlNrXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJsb2JcIixcbiAgICAgIFwic2Vuc2l0aXZlXCI6IHRydWVcbiAgICB9LFxuICAgIFwiU3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcInNlbnNpdGl2ZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlMxYlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJtYXBcIixcbiAgICAgIFwia2V5XCI6IHt9LFxuICAgICAgXCJ2YWx1ZVwiOiB7fVxuICAgIH0sXG4gICAgXCJTMWlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcInNlbnNpdGl2ZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlMxa1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJibG9iXCIsXG4gICAgICBcInNlbnNpdGl2ZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlMxb1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIixcbiAgICAgIFwidGltZXN0YW1wRm9ybWF0XCI6IFwiaXNvODYwMVwiXG4gICAgfSxcbiAgICBcIlMzZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiRGlzcGxheU5hbWVcIjoge30sXG4gICAgICAgIFwiSURcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzNnXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJHcmFudFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkdyYW50ZWVcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzaVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBlcm1pc3Npb25cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTM2lcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJUeXBlXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkRpc3BsYXlOYW1lXCI6IHt9LFxuICAgICAgICBcIkVtYWlsQWRkcmVzc1wiOiB7fSxcbiAgICAgICAgXCJJRFwiOiB7fSxcbiAgICAgICAgXCJUeXBlXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcInhzaTp0eXBlXCIsXG4gICAgICAgICAgXCJ4bWxBdHRyaWJ1dGVcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcIlVSSVwiOiB7fVxuICAgICAgfSxcbiAgICAgIFwieG1sTmFtZXNwYWNlXCI6IHtcbiAgICAgICAgXCJwcmVmaXhcIjogXCJ4c2lcIixcbiAgICAgICAgXCJ1cmlcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMzcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIklkXCIsXG4gICAgICAgIFwiU3RvcmFnZUNsYXNzQW5hbHlzaXNcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiSWRcIjoge30sXG4gICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICBcIlRhZ1wiOiB7XG4gICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3NcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiQW5kXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3ZcIixcbiAgICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRhZ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIlN0b3JhZ2VDbGFzc0FuYWx5c2lzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJEYXRhRXhwb3J0XCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgIFwiT3V0cHV0U2NoZW1hVmVyc2lvblwiLFxuICAgICAgICAgICAgICAgIFwiRGVzdGluYXRpb25cIlxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgIFwiT3V0cHV0U2NoZW1hVmVyc2lvblwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkRlc3RpbmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiUzNCdWNrZXREZXN0aW5hdGlvblwiXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJTM0J1Y2tldERlc3RpbmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiXG4gICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJGb3JtYXRcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkJ1Y2tldEFjY291bnRJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge31cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzNzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiS2V5XCIsXG4gICAgICAgIFwiVmFsdWVcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiS2V5XCI6IHt9LFxuICAgICAgICBcIlZhbHVlXCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlMzdlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwic2hhcGVcIjogXCJTM3NcIixcbiAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJUYWdcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNDRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJBbGxvd2VkTWV0aG9kc1wiLFxuICAgICAgICAgIFwiQWxsb3dlZE9yaWdpbnNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiSURcIjoge30sXG4gICAgICAgICAgXCJBbGxvd2VkSGVhZGVyc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFsbG93ZWRIZWFkZXJcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbGxvd2VkTWV0aG9kc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFsbG93ZWRNZXRob2RcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJBbGxvd2VkT3JpZ2luc1wiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFsbG93ZWRPcmlnaW5cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFeHBvc2VIZWFkZXJzXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXhwb3NlSGVhZGVyXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgICBcIm1lbWJlclwiOiB7fSxcbiAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTWF4QWdlU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlM0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlJ1bGVzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkFwcGx5U2VydmVyU2lkZUVuY3J5cHRpb25CeURlZmF1bHRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgXCJTU0VBbGdvcml0aG1cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiU1NFQWxnb3JpdGhtXCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJLTVNNYXN0ZXJLZXlJRFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTclwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIkJ1Y2tldEtleUVuYWJsZWRcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzRuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiSWRcIixcbiAgICAgICAgXCJTdGF0dXNcIixcbiAgICAgICAgXCJUaWVyaW5nc1wiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgIFwiVGFnXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzc1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJBbmRcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzdlwiLFxuICAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICBcIlRpZXJpbmdzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRpZXJpbmdcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJEYXlzXCIsXG4gICAgICAgICAgICAgIFwiQWNjZXNzVGllclwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJEYXlzXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJBY2Nlc3NUaWVyXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzR4XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiRGVzdGluYXRpb25cIixcbiAgICAgICAgXCJJc0VuYWJsZWRcIixcbiAgICAgICAgXCJJZFwiLFxuICAgICAgICBcIkluY2x1ZGVkT2JqZWN0VmVyc2lvbnNcIixcbiAgICAgICAgXCJTY2hlZHVsZVwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEZXN0aW5hdGlvblwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICBcIlMzQnVja2V0RGVzdGluYXRpb25cIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUzNCdWNrZXREZXN0aW5hdGlvblwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiLFxuICAgICAgICAgICAgICAgIFwiRm9ybWF0XCJcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIkFjY291bnRJZFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkJ1Y2tldFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkZvcm1hdFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIlNTRVMzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlNTRS1TM1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIlNTRUtNU1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJTU0UtS01TXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIktleUlkXCJcbiAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIktleUlkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiSXNFbmFibGVkXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgXCJQcmVmaXhcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICBcIkluY2x1ZGVkT2JqZWN0VmVyc2lvbnNcIjoge30sXG4gICAgICAgIFwiT3B0aW9uYWxGaWVsZHNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkZpZWxkXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiU2NoZWR1bGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgXCJGcmVxdWVuY3lcIlxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiRnJlcXVlbmN5XCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM1ZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlByZWZpeFwiLFxuICAgICAgICAgIFwiU3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1ZlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIklEXCI6IHt9LFxuICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgIFwiU3RhdHVzXCI6IHt9LFxuICAgICAgICAgIFwiVHJhbnNpdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVrXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiTm9uY3VycmVudFZlcnNpb25UcmFuc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNW1cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb25jdXJyZW50VmVyc2lvbkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1b1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFib3J0SW5jb21wbGV0ZU11bHRpcGFydFVwbG9hZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlM1ZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiRGF0ZVwiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlM1Z1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiRGF5c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiRXhwaXJlZE9iamVjdERlbGV0ZU1hcmtlclwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzVnXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInRpbWVzdGFtcFwiLFxuICAgICAgXCJ0aW1lc3RhbXBGb3JtYXRcIjogXCJpc284NjAxXCJcbiAgICB9LFxuICAgIFwiUzVrXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEYXRlXCI6IHtcbiAgICAgICAgICBcInNoYXBlXCI6IFwiUzVnXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJEYXlzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJOb25jdXJyZW50RGF5c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiU3RvcmFnZUNsYXNzXCI6IHt9LFxuICAgICAgICBcIk5ld2VyTm9uY3VycmVudFZlcnNpb25zXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNW9cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIk5vbmN1cnJlbnREYXlzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJOZXdlck5vbmN1cnJlbnRWZXJzaW9uc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzVwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJEYXlzQWZ0ZXJJbml0aWF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJTdGF0dXNcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRXhwaXJhdGlvblwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVmXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiSURcIjoge30sXG4gICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgXCJkZXByZWNhdGVkXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgIFwiVGFnXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNzXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJPYmplY3RTaXplR3JlYXRlclRoYW5cIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIk9iamVjdFNpemVMZXNzVGhhblwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiQW5kXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzN2XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIk9iamVjdFNpemVHcmVhdGVyVGhhblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvbmdcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiT2JqZWN0U2l6ZUxlc3NUaGFuXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9uZ1wiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICBcIlRyYW5zaXRpb25zXCI6IHtcbiAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVHJhbnNpdGlvblwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVrXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIk5vbmN1cnJlbnRWZXJzaW9uVHJhbnNpdGlvbnNcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJOb25jdXJyZW50VmVyc2lvblRyYW5zaXRpb25cIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1bVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJOb25jdXJyZW50VmVyc2lvbkV4cGlyYXRpb25cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM1b1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFib3J0SW5jb21wbGV0ZU11bHRpcGFydFVwbG9hZFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiUzVwXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlM2NVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlRhcmdldEJ1Y2tldFwiLFxuICAgICAgICBcIlRhcmdldFByZWZpeFwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJUYXJnZXRCdWNrZXRcIjoge30sXG4gICAgICAgIFwiVGFyZ2V0R3JhbnRzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJHcmFudFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkdyYW50ZWVcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2lcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlBlcm1pc3Npb25cIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiVGFyZ2V0UHJlZml4XCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM2ZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIklkXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICBcIkZpbHRlclwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUHJlZml4XCI6IHt9LFxuICAgICAgICAgICAgXCJUYWdcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzNzXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIkFjY2Vzc1BvaW50QXJuXCI6IHt9LFxuICAgICAgICAgICAgXCJBbmRcIjoge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICBcIlByZWZpeFwiOiB7fSxcbiAgICAgICAgICAgICAgICBcIlRhZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlMzdlwiLFxuICAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiVGFnXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiQWNjZXNzUG9pbnRBcm5cIjoge31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNmhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiQnVja2V0XCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uXCI6IFwidXJpXCIsXG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJCdWNrZXRcIlxuICAgICAgICB9LFxuICAgICAgICBcIkV4cGVjdGVkQnVja2V0T3duZXJcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25cIjogXCJoZWFkZXJcIixcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIngtYW16LWV4cGVjdGVkLWJ1Y2tldC1vd25lclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzZpXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJUb3BpY0NvbmZpZ3VyYXRpb25cIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZsXCIsXG4gICAgICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiRXZlbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiRXZlbnRcIjoge1xuICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiVG9waWNcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiUXVldWVDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgIFwiRXZlbnRcIjoge1xuICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiRXZlbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2bFwiLFxuICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIlF1ZXVlXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIkNsb3VkRnVuY3Rpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgIFwiRXZlbnRcIjoge1xuICAgICAgICAgICAgICBcImRlcHJlY2F0ZWRcIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiRXZlbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM2bFwiLFxuICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIkNsb3VkRnVuY3Rpb25cIjoge30sXG4gICAgICAgICAgICBcIkludm9jYXRpb25Sb2xlXCI6IHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM2bFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7fSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiUzZ0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJUb3BpY0NvbmZpZ3VyYXRpb25zXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRvcGljQ29uZmlndXJhdGlvblwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlRvcGljQXJuXCIsXG4gICAgICAgICAgICAgIFwiRXZlbnRzXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIklkXCI6IHt9LFxuICAgICAgICAgICAgICBcIlRvcGljQXJuXCI6IHtcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRvcGljXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNmxcIixcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNndcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiUXVldWVDb25maWd1cmF0aW9uc1wiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJRdWV1ZUNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJRdWV1ZUFyblwiLFxuICAgICAgICAgICAgICBcIkV2ZW50c1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJRdWV1ZUFyblwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJRdWV1ZVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRXZlbnRzXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZsXCIsXG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJFdmVudFwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcInNoYXBlXCI6IFwiUzZ3XCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBcIkxhbWJkYUZ1bmN0aW9uQ29uZmlndXJhdGlvbnNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiQ2xvdWRGdW5jdGlvbkNvbmZpZ3VyYXRpb25cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJMYW1iZGFGdW5jdGlvbkFyblwiLFxuICAgICAgICAgICAgICBcIkV2ZW50c1wiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgXCJJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJMYW1iZGFGdW5jdGlvbkFyblwiOiB7XG4gICAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJDbG91ZEZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJFdmVudHNcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNmxcIixcbiAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkV2ZW50XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJGaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNndcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIFwiRXZlbnRCcmlkZ2VDb25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTNndcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIktleVwiOiB7XG4gICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJTM0tleVwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIkZpbHRlclJ1bGVzXCI6IHtcbiAgICAgICAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJGaWx0ZXJSdWxlXCIsXG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICBcIk5hbWVcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIlZhbHVlXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM3YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIlJ1bGVzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlJ1bGVzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJ1bGVcIixcbiAgICAgICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgXCJPYmplY3RPd25lcnNoaXBcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgIFwiT2JqZWN0T3duZXJzaGlwXCI6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzdtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiUm9sZVwiLFxuICAgICAgICBcIlJ1bGVzXCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlJvbGVcIjoge30sXG4gICAgICAgIFwiUnVsZXNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiUnVsZVwiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICBcIlN0YXR1c1wiLFxuICAgICAgICAgICAgICBcIkRlc3RpbmF0aW9uXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIklEXCI6IHt9LFxuICAgICAgICAgICAgICBcIlByaW9yaXR5XCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge1xuICAgICAgICAgICAgICAgIFwiZGVwcmVjYXRlZFwiOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRmlsdGVyXCI6IHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIlRhZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3NcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiQW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJQcmVmaXhcIjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM3ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlRhZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICAgICAgXCJTb3VyY2VTZWxlY3Rpb25Dcml0ZXJpYVwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiU3NlS21zRW5jcnlwdGVkT2JqZWN0c1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiUmVwbGljYU1vZGlmaWNhdGlvbnNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRXhpc3RpbmdPYmplY3RSZXBsaWNhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJTdGF0dXNcIjoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiRGVzdGluYXRpb25cIjoge1xuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgXCJCdWNrZXRcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiQnVja2V0XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJBY2NvdW50XCI6IHt9LFxuICAgICAgICAgICAgICAgICAgXCJTdG9yYWdlQ2xhc3NcIjoge30sXG4gICAgICAgICAgICAgICAgICBcIkFjY2Vzc0NvbnRyb2xUcmFuc2xhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICBcIk93bmVyXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIk93bmVyXCI6IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBcIkVuY3J5cHRpb25Db25maWd1cmF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJSZXBsaWNhS21zS2V5SURcIjoge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiUmVwbGljYXRpb25UaW1lXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaW1lXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIlRpbWVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM4OFwiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJNZXRyaWNzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCJcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXR1c1wiOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICBcIkV2ZW50VGhyZXNob2xkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2hhcGVcIjogXCJTODhcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJEZWxldGVNYXJrZXJSZXBsaWNhdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgICAgICAgIFwiU3RhdHVzXCI6IHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZsYXR0ZW5lZFwiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzg4XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJNaW51dGVzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOHBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJIb3N0TmFtZVwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJIb3N0TmFtZVwiOiB7fSxcbiAgICAgICAgXCJQcm90b2NvbFwiOiB7fVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTOHNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJTdWZmaXhcIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiU3VmZml4XCI6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlM4dVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogW1xuICAgICAgICBcIktleVwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJLZXlcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzh2XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJsb2NhdGlvbk5hbWVcIjogXCJSb3V0aW5nUnVsZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSZWRpcmVjdFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDb25kaXRpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkh0dHBFcnJvckNvZGVSZXR1cm5lZEVxdWFsc1wiOiB7fSxcbiAgICAgICAgICAgICAgXCJLZXlQcmVmaXhFcXVhbHNcIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUmVkaXJlY3RcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkhvc3ROYW1lXCI6IHt9LFxuICAgICAgICAgICAgICBcIkh0dHBSZWRpcmVjdENvZGVcIjoge30sXG4gICAgICAgICAgICAgIFwiUHJvdG9jb2xcIjoge30sXG4gICAgICAgICAgICAgIFwiUmVwbGFjZUtleVByZWZpeFdpdGhcIjoge30sXG4gICAgICAgICAgICAgIFwiUmVwbGFjZUtleVdpdGhcIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2E5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJTdGF0dXNcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2FjXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJPYmplY3RMb2NrRW5hYmxlZFwiOiB7fSxcbiAgICAgICAgXCJSdWxlXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJEZWZhdWx0UmV0ZW50aW9uXCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICAgICAgXCJNb2RlXCI6IHt9LFxuICAgICAgICAgICAgICAgIFwiRGF5c1wiOiB7XG4gICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiWWVhcnNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNha1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiTW9kZVwiOiB7fSxcbiAgICAgICAgXCJSZXRhaW5VbnRpbERhdGVcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTNWdcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNhclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiQmxvY2tQdWJsaWNBY2xzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJsb2NrUHVibGljQWNsc1wiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICB9LFxuICAgICAgICBcIklnbm9yZVB1YmxpY0FjbHNcIjoge1xuICAgICAgICAgIFwibG9jYXRpb25OYW1lXCI6IFwiSWdub3JlUHVibGljQWNsc1wiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICB9LFxuICAgICAgICBcIkJsb2NrUHVibGljUG9saWN5XCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkJsb2NrUHVibGljUG9saWN5XCIsXG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiUmVzdHJpY3RQdWJsaWNCdWNrZXRzXCI6IHtcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIlJlc3RyaWN0UHVibGljQnVja2V0c1wiLFxuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNiclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiSURcIjoge30sXG4gICAgICAgIFwiRGlzcGxheU5hbWVcIjoge31cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2JzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJQcmVmaXhcIjoge31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiU2MxXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgIFwibWVtYmVyXCI6IHt9LFxuICAgICAgXCJmbGF0dGVuZWRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTY2FcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIkxhc3RNb2RpZmllZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJFVGFnXCI6IHt9LFxuICAgICAgICAgIFwiQ2hlY2tzdW1BbGdvcml0aG1cIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNjMVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNpemVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlN0b3JhZ2VDbGFzc1wiOiB7fSxcbiAgICAgICAgICBcIk93bmVyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTM2RcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmxhdHRlbmVkXCI6IHRydWVcbiAgICB9LFxuICAgIFwiU2NwXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJHcmFudHNcIjoge1xuICAgICAgICAgIFwic2hhcGVcIjogXCJTM2dcIixcbiAgICAgICAgICBcImxvY2F0aW9uTmFtZVwiOiBcIkFjY2Vzc0NvbnRyb2xMaXN0XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJPd25lclwiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlMzZFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2RmXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiVGFnU2V0XCJcbiAgICAgIF0sXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIlRhZ1NldFwiOiB7XG4gICAgICAgICAgXCJzaGFwZVwiOiBcIlMzdlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2U1XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJDU1ZcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgICBcIkZpbGVIZWFkZXJJbmZvXCI6IHt9LFxuICAgICAgICAgICAgXCJDb21tZW50c1wiOiB7fSxcbiAgICAgICAgICAgIFwiUXVvdGVFc2NhcGVDaGFyYWN0ZXJcIjoge30sXG4gICAgICAgICAgICBcIlJlY29yZERlbGltaXRlclwiOiB7fSxcbiAgICAgICAgICAgIFwiRmllbGREZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgICBcIlF1b3RlQ2hhcmFjdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJBbGxvd1F1b3RlZFJlY29yZERlbGltaXRlclwiOiB7XG4gICAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJDb21wcmVzc2lvblR5cGVcIjoge30sXG4gICAgICAgIFwiSlNPTlwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiVHlwZVwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJQYXJxdWV0XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJTZWtcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICBcIkNTVlwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICAgIFwiUXVvdGVGaWVsZHNcIjoge30sXG4gICAgICAgICAgICBcIlF1b3RlRXNjYXBlQ2hhcmFjdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJSZWNvcmREZWxpbWl0ZXJcIjoge30sXG4gICAgICAgICAgICBcIkZpZWxkRGVsaW1pdGVyXCI6IHt9LFxuICAgICAgICAgICAgXCJRdW90ZUNoYXJhY3RlclwiOiB7fVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJKU09OXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgXCJSZWNvcmREZWxpbWl0ZXJcIjoge31cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicGFnaW5hdGlvblwiOiB7XG4gICAgXCJMaXN0QnVja2V0c1wiOiB7XG4gICAgICBcInJlc3VsdF9rZXlcIjogXCJCdWNrZXRzXCJcbiAgICB9LFxuICAgIFwiTGlzdE11bHRpcGFydFVwbG9hZHNcIjoge1xuICAgICAgXCJpbnB1dF90b2tlblwiOiBbXG4gICAgICAgIFwiS2V5TWFya2VyXCIsXG4gICAgICAgIFwiVXBsb2FkSWRNYXJrZXJcIlxuICAgICAgXSxcbiAgICAgIFwibGltaXRfa2V5XCI6IFwiTWF4VXBsb2Fkc1wiLFxuICAgICAgXCJtb3JlX3Jlc3VsdHNcIjogXCJJc1RydW5jYXRlZFwiLFxuICAgICAgXCJvdXRwdXRfdG9rZW5cIjogW1xuICAgICAgICBcIk5leHRLZXlNYXJrZXJcIixcbiAgICAgICAgXCJOZXh0VXBsb2FkSWRNYXJrZXJcIlxuICAgICAgXSxcbiAgICAgIFwicmVzdWx0X2tleVwiOiBbXG4gICAgICAgIFwiVXBsb2Fkc1wiLFxuICAgICAgICBcIkNvbW1vblByZWZpeGVzXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiTGlzdE9iamVjdFZlcnNpb25zXCI6IHtcbiAgICAgIFwiaW5wdXRfdG9rZW5cIjogW1xuICAgICAgICBcIktleU1hcmtlclwiLFxuICAgICAgICBcIlZlcnNpb25JZE1hcmtlclwiXG4gICAgICBdLFxuICAgICAgXCJsaW1pdF9rZXlcIjogXCJNYXhLZXlzXCIsXG4gICAgICBcIm1vcmVfcmVzdWx0c1wiOiBcIklzVHJ1bmNhdGVkXCIsXG4gICAgICBcIm91dHB1dF90b2tlblwiOiBbXG4gICAgICAgIFwiTmV4dEtleU1hcmtlclwiLFxuICAgICAgICBcIk5leHRWZXJzaW9uSWRNYXJrZXJcIlxuICAgICAgXSxcbiAgICAgIFwicmVzdWx0X2tleVwiOiBbXG4gICAgICAgIFwiVmVyc2lvbnNcIixcbiAgICAgICAgXCJEZWxldGVNYXJrZXJzXCIsXG4gICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJMaXN0T2JqZWN0c1wiOiB7XG4gICAgICBcImlucHV0X3Rva2VuXCI6IFwiTWFya2VyXCIsXG4gICAgICBcImxpbWl0X2tleVwiOiBcIk1heEtleXNcIixcbiAgICAgIFwibW9yZV9yZXN1bHRzXCI6IFwiSXNUcnVuY2F0ZWRcIixcbiAgICAgIFwib3V0cHV0X3Rva2VuXCI6IFwiTmV4dE1hcmtlciB8fCBDb250ZW50c1stMV0uS2V5XCIsXG4gICAgICBcInJlc3VsdF9rZXlcIjogW1xuICAgICAgICBcIkNvbnRlbnRzXCIsXG4gICAgICAgIFwiQ29tbW9uUHJlZml4ZXNcIlxuICAgICAgXVxuICAgIH0sXG4gICAgXCJMaXN0T2JqZWN0c1YyXCI6IHtcbiAgICAgIFwiaW5wdXRfdG9rZW5cIjogXCJDb250aW51YXRpb25Ub2tlblwiLFxuICAgICAgXCJsaW1pdF9rZXlcIjogXCJNYXhLZXlzXCIsXG4gICAgICBcIm91dHB1dF90b2tlblwiOiBcIk5leHRDb250aW51YXRpb25Ub2tlblwiLFxuICAgICAgXCJyZXN1bHRfa2V5XCI6IFtcbiAgICAgICAgXCJDb250ZW50c1wiLFxuICAgICAgICBcIkNvbW1vblByZWZpeGVzXCJcbiAgICAgIF1cbiAgICB9LFxuICAgIFwiTGlzdFBhcnRzXCI6IHtcbiAgICAgIFwiaW5wdXRfdG9rZW5cIjogXCJQYXJ0TnVtYmVyTWFya2VyXCIsXG4gICAgICBcImxpbWl0X2tleVwiOiBcIk1heFBhcnRzXCIsXG4gICAgICBcIm1vcmVfcmVzdWx0c1wiOiBcIklzVHJ1bmNhdGVkXCIsXG4gICAgICBcIm91dHB1dF90b2tlblwiOiBcIk5leHRQYXJ0TnVtYmVyTWFya2VyXCIsXG4gICAgICBcInJlc3VsdF9rZXlcIjogXCJQYXJ0c1wiXG4gICAgfVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInZlcnNpb25cIjogMixcbiAgXCJ3YWl0ZXJzXCI6IHtcbiAgICBcIkJ1Y2tldEV4aXN0c1wiOiB7XG4gICAgICBcImRlbGF5XCI6IDUsXG4gICAgICBcIm9wZXJhdGlvblwiOiBcIkhlYWRCdWNrZXRcIixcbiAgICAgIFwibWF4QXR0ZW1wdHNcIjogMjAsXG4gICAgICBcImFjY2VwdG9yc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDIwMCxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwic3VjY2Vzc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDMwMSxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwic3VjY2Vzc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDQwMyxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwic3VjY2Vzc1wiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDQwNCxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwicmV0cnlcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcIkJ1Y2tldE5vdEV4aXN0c1wiOiB7XG4gICAgICBcImRlbGF5XCI6IDUsXG4gICAgICBcIm9wZXJhdGlvblwiOiBcIkhlYWRCdWNrZXRcIixcbiAgICAgIFwibWF4QXR0ZW1wdHNcIjogMjAsXG4gICAgICBcImFjY2VwdG9yc1wiOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBcImV4cGVjdGVkXCI6IDQwNCxcbiAgICAgICAgICBcIm1hdGNoZXJcIjogXCJzdGF0dXNcIixcbiAgICAgICAgICBcInN0YXRlXCI6IFwic3VjY2Vzc1wiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiT2JqZWN0RXhpc3RzXCI6IHtcbiAgICAgIFwiZGVsYXlcIjogNSxcbiAgICAgIFwib3BlcmF0aW9uXCI6IFwiSGVhZE9iamVjdFwiLFxuICAgICAgXCJtYXhBdHRlbXB0c1wiOiAyMCxcbiAgICAgIFwiYWNjZXB0b3JzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogMjAwLFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJzdWNjZXNzXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogNDA0LFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJyZXRyeVwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiT2JqZWN0Tm90RXhpc3RzXCI6IHtcbiAgICAgIFwiZGVsYXlcIjogNSxcbiAgICAgIFwib3BlcmF0aW9uXCI6IFwiSGVhZE9iamVjdFwiLFxuICAgICAgXCJtYXhBdHRlbXB0c1wiOiAyMCxcbiAgICAgIFwiYWNjZXB0b3JzXCI6IFtcbiAgICAgICAge1xuICAgICAgICAgIFwiZXhwZWN0ZWRcIjogNDA0LFxuICAgICAgICAgIFwibWF0Y2hlclwiOiBcInN0YXR1c1wiLFxuICAgICAgICAgIFwic3RhdGVcIjogXCJzdWNjZXNzXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcInZlcnNpb25cIjogXCIyLjBcIixcbiAgXCJtZXRhZGF0YVwiOiB7XG4gICAgXCJhcGlWZXJzaW9uXCI6IFwiMjAxMS0wNi0xNVwiLFxuICAgIFwiZW5kcG9pbnRQcmVmaXhcIjogXCJzdHNcIixcbiAgICBcImdsb2JhbEVuZHBvaW50XCI6IFwic3RzLmFtYXpvbmF3cy5jb21cIixcbiAgICBcInByb3RvY29sXCI6IFwicXVlcnlcIixcbiAgICBcInNlcnZpY2VBYmJyZXZpYXRpb25cIjogXCJBV1MgU1RTXCIsXG4gICAgXCJzZXJ2aWNlRnVsbE5hbWVcIjogXCJBV1MgU2VjdXJpdHkgVG9rZW4gU2VydmljZVwiLFxuICAgIFwic2VydmljZUlkXCI6IFwiU1RTXCIsXG4gICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwidjRcIixcbiAgICBcInVpZFwiOiBcInN0cy0yMDExLTA2LTE1XCIsXG4gICAgXCJ4bWxOYW1lc3BhY2VcIjogXCJodHRwczovL3N0cy5hbWF6b25hd3MuY29tL2RvYy8yMDExLTA2LTE1L1wiXG4gIH0sXG4gIFwib3BlcmF0aW9uc1wiOiB7XG4gICAgXCJBc3N1bWVSb2xlXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSb2xlQXJuXCIsXG4gICAgICAgICAgXCJSb2xlU2Vzc2lvbk5hbWVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUm9sZUFyblwiOiB7fSxcbiAgICAgICAgICBcIlJvbGVTZXNzaW9uTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlBvbGljeUFybnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUG9saWN5XCI6IHt9LFxuICAgICAgICAgIFwiRHVyYXRpb25TZWNvbmRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlRyYW5zaXRpdmVUYWdLZXlzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImxpc3RcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCI6IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkV4dGVybmFsSWRcIjoge30sXG4gICAgICAgICAgXCJTZXJpYWxOdW1iZXJcIjoge30sXG4gICAgICAgICAgXCJUb2tlbkNvZGVcIjoge30sXG4gICAgICAgICAgXCJTb3VyY2VJZGVudGl0eVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJBc3N1bWVSb2xlUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQ3JlZGVudGlhbHNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNpXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiQXNzdW1lZFJvbGVVc2VyXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTblwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBhY2tlZFBvbGljeVNpemVcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlNvdXJjZUlkZW50aXR5XCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiQXNzdW1lUm9sZVdpdGhTQU1MXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJSb2xlQXJuXCIsXG4gICAgICAgICAgXCJQcmluY2lwYWxBcm5cIixcbiAgICAgICAgICBcIlNBTUxBc3NlcnRpb25cIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiUm9sZUFyblwiOiB7fSxcbiAgICAgICAgICBcIlByaW5jaXBhbEFyblwiOiB7fSxcbiAgICAgICAgICBcIlNBTUxBc3NlcnRpb25cIjoge30sXG4gICAgICAgICAgXCJQb2xpY3lBcm5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fSxcbiAgICAgICAgICBcIkR1cmF0aW9uU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkFzc3VtZVJvbGVXaXRoU0FNTFJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaVwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIkFzc3VtZWRSb2xlVXNlclwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU25cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJQYWNrZWRQb2xpY3lTaXplXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdWJqZWN0XCI6IHt9LFxuICAgICAgICAgIFwiU3ViamVjdFR5cGVcIjoge30sXG4gICAgICAgICAgXCJJc3N1ZXJcIjoge30sXG4gICAgICAgICAgXCJBdWRpZW5jZVwiOiB7fSxcbiAgICAgICAgICBcIk5hbWVRdWFsaWZpZXJcIjoge30sXG4gICAgICAgICAgXCJTb3VyY2VJZGVudGl0eVwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIlJvbGVBcm5cIixcbiAgICAgICAgICBcIlJvbGVTZXNzaW9uTmFtZVwiLFxuICAgICAgICAgIFwiV2ViSWRlbnRpdHlUb2tlblwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJSb2xlQXJuXCI6IHt9LFxuICAgICAgICAgIFwiUm9sZVNlc3Npb25OYW1lXCI6IHt9LFxuICAgICAgICAgIFwiV2ViSWRlbnRpdHlUb2tlblwiOiB7fSxcbiAgICAgICAgICBcIlByb3ZpZGVySWRcIjoge30sXG4gICAgICAgICAgXCJQb2xpY3lBcm5zXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTNFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fSxcbiAgICAgICAgICBcIkR1cmF0aW9uU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlSZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2lcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJTdWJqZWN0RnJvbVdlYklkZW50aXR5VG9rZW5cIjoge30sXG4gICAgICAgICAgXCJBc3N1bWVkUm9sZVVzZXJcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlNuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFja2VkUG9saWN5U2l6ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUHJvdmlkZXJcIjoge30sXG4gICAgICAgICAgXCJBdWRpZW5jZVwiOiB7fSxcbiAgICAgICAgICBcIlNvdXJjZUlkZW50aXR5XCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiRGVjb2RlQXV0aG9yaXphdGlvbk1lc3NhZ2VcIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIkVuY29kZWRNZXNzYWdlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkVuY29kZWRNZXNzYWdlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkRlY29kZUF1dGhvcml6YXRpb25NZXNzYWdlUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiRGVjb2RlZE1lc3NhZ2VcIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRBY2Nlc3NLZXlJbmZvXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJBY2Nlc3NLZXlJZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJBY2Nlc3NLZXlJZFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJHZXRBY2Nlc3NLZXlJbmZvUmVzdWx0XCIsXG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiQWNjb3VudFwiOiB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIkdldENhbGxlcklkZW50aXR5XCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHt9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJHZXRDYWxsZXJJZGVudGl0eVJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIlVzZXJJZFwiOiB7fSxcbiAgICAgICAgICBcIkFjY291bnRcIjoge30sXG4gICAgICAgICAgXCJBcm5cIjoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJHZXRGZWRlcmF0aW9uVG9rZW5cIjoge1xuICAgICAgXCJpbnB1dFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgICBcIk5hbWVcIlxuICAgICAgICBdLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiTmFtZVwiOiB7fSxcbiAgICAgICAgICBcIlBvbGljeVwiOiB7fSxcbiAgICAgICAgICBcIlBvbGljeUFybnNcIjoge1xuICAgICAgICAgICAgXCJzaGFwZVwiOiBcIlM0XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiRHVyYXRpb25TZWNvbmRzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJUYWdzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTOFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJvdXRwdXRcIjoge1xuICAgICAgICBcInJlc3VsdFdyYXBwZXJcIjogXCJHZXRGZWRlcmF0aW9uVG9rZW5SZXN1bHRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgICAgXCJDcmVkZW50aWFsc1wiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwiU2lcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJGZWRlcmF0ZWRVc2VyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgICAgIFwiRmVkZXJhdGVkVXNlcklkXCIsXG4gICAgICAgICAgICAgIFwiQXJuXCJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgICAgICBcIkZlZGVyYXRlZFVzZXJJZFwiOiB7fSxcbiAgICAgICAgICAgICAgXCJBcm5cIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiUGFja2VkUG9saWN5U2l6ZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiR2V0U2Vzc2lvblRva2VuXCI6IHtcbiAgICAgIFwiaW5wdXRcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkR1cmF0aW9uU2Vjb25kc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiU2VyaWFsTnVtYmVyXCI6IHt9LFxuICAgICAgICAgIFwiVG9rZW5Db2RlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm91dHB1dFwiOiB7XG4gICAgICAgIFwicmVzdWx0V3JhcHBlclwiOiBcIkdldFNlc3Npb25Ub2tlblJlc3VsdFwiLFxuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIkNyZWRlbnRpYWxzXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJTaVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInNoYXBlc1wiOiB7XG4gICAgXCJTNFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJsaXN0XCIsXG4gICAgICBcIm1lbWJlclwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgICBcIm1lbWJlcnNcIjoge1xuICAgICAgICAgIFwiYXJuXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiUzhcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibGlzdFwiLFxuICAgICAgXCJtZW1iZXJcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgICAgXCJLZXlcIixcbiAgICAgICAgICBcIlZhbHVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgICBcIktleVwiOiB7fSxcbiAgICAgICAgICBcIlZhbHVlXCI6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiU2lcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RydWN0dXJlXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcbiAgICAgICAgXCJBY2Nlc3NLZXlJZFwiLFxuICAgICAgICBcIlNlY3JldEFjY2Vzc0tleVwiLFxuICAgICAgICBcIlNlc3Npb25Ub2tlblwiLFxuICAgICAgICBcIkV4cGlyYXRpb25cIlxuICAgICAgXSxcbiAgICAgIFwibWVtYmVyc1wiOiB7XG4gICAgICAgIFwiQWNjZXNzS2V5SWRcIjoge30sXG4gICAgICAgIFwiU2VjcmV0QWNjZXNzS2V5XCI6IHt9LFxuICAgICAgICBcIlNlc3Npb25Ub2tlblwiOiB7fSxcbiAgICAgICAgXCJFeHBpcmF0aW9uXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJ0aW1lc3RhbXBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIlNuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cnVjdHVyZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXG4gICAgICAgIFwiQXNzdW1lZFJvbGVJZFwiLFxuICAgICAgICBcIkFyblwiXG4gICAgICBdLFxuICAgICAgXCJtZW1iZXJzXCI6IHtcbiAgICAgICAgXCJBc3N1bWVkUm9sZUlkXCI6IHt9LFxuICAgICAgICBcIkFyblwiOiB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJwYWdpbmF0aW9uXCI6IHtcbiAgfVxufVxuIiwicmVxdWlyZSgnLi9saWIvYnJvd3Nlcl9sb2FkZXInKTtcblxudmFyIEFXUyA9IHJlcXVpcmUoJy4vbGliL2NvcmUnKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgd2luZG93LkFXUyA9IEFXUztcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBBV1M7XG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLkFXUyA9IEFXUzsiLCJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ2NvZ25pdG9pZGVudGl0eSddID0ge307XG5BV1MuQ29nbml0b0lkZW50aXR5ID0gU2VydmljZS5kZWZpbmVTZXJ2aWNlKCdjb2duaXRvaWRlbnRpdHknLCBbJzIwMTQtMDYtMzAnXSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpTG9hZGVyLnNlcnZpY2VzWydjb2duaXRvaWRlbnRpdHknXSwgJzIwMTQtMDYtMzAnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBtb2RlbCA9IHJlcXVpcmUoJy4uL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvY29nbml0by1pZGVudGl0eS0yMDE0LTA2LTMwLnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5Db2duaXRvSWRlbnRpdHk7XG4iLCJyZXF1aXJlKCcuLi9saWIvbm9kZV9sb2FkZXInKTtcbnZhciBBV1MgPSByZXF1aXJlKCcuLi9saWIvY29yZScpO1xudmFyIFNlcnZpY2UgPSBBV1MuU2VydmljZTtcbnZhciBhcGlMb2FkZXIgPSBBV1MuYXBpTG9hZGVyO1xuXG5hcGlMb2FkZXIuc2VydmljZXNbJ3MzJ10gPSB7fTtcbkFXUy5TMyA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnczMnLCBbJzIwMDYtMDMtMDEnXSk7XG5yZXF1aXJlKCcuLi9saWIvc2VydmljZXMvczMnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcGlMb2FkZXIuc2VydmljZXNbJ3MzJ10sICcyMDA2LTAzLTAxJywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL3MzLTIwMDYtMDMtMDEubWluLmpzb24nKTtcbiAgICBtb2RlbC5wYWdpbmF0b3JzID0gcmVxdWlyZSgnLi4vYXBpcy9zMy0yMDA2LTAzLTAxLnBhZ2luYXRvcnMuanNvbicpLnBhZ2luYXRpb247XG4gICAgbW9kZWwud2FpdGVycyA9IHJlcXVpcmUoJy4uL2FwaXMvczMtMjAwNi0wMy0wMS53YWl0ZXJzMi5qc29uJykud2FpdGVycztcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlMzO1xuIiwicmVxdWlyZSgnLi4vbGliL25vZGVfbG9hZGVyJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vbGliL2NvcmUnKTtcbnZhciBTZXJ2aWNlID0gQVdTLlNlcnZpY2U7XG52YXIgYXBpTG9hZGVyID0gQVdTLmFwaUxvYWRlcjtcblxuYXBpTG9hZGVyLnNlcnZpY2VzWydzdHMnXSA9IHt9O1xuQVdTLlNUUyA9IFNlcnZpY2UuZGVmaW5lU2VydmljZSgnc3RzJywgWycyMDExLTA2LTE1J10pO1xucmVxdWlyZSgnLi4vbGliL3NlcnZpY2VzL3N0cycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaUxvYWRlci5zZXJ2aWNlc1snc3RzJ10sICcyMDExLTA2LTE1Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgbW9kZWwgPSByZXF1aXJlKCcuLi9hcGlzL3N0cy0yMDExLTA2LTE1Lm1pbi5qc29uJyk7XG4gICAgbW9kZWwucGFnaW5hdG9ycyA9IHJlcXVpcmUoJy4uL2FwaXMvc3RzLTIwMTEtMDYtMTUucGFnaW5hdG9ycy5qc29uJykucGFnaW5hdGlvbjtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNUUztcbiIsImZ1bmN0aW9uIGFwaUxvYWRlcihzdmMsIHZlcnNpb24pIHtcbiAgaWYgKCFhcGlMb2FkZXIuc2VydmljZXMuaGFzT3duUHJvcGVydHkoc3ZjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFNlcnZpY2U6IEZhaWxlZCB0byBsb2FkIGFwaSBmb3IgJyArIHN2Yyk7XG4gIH1cbiAgcmV0dXJuIGFwaUxvYWRlci5zZXJ2aWNlc1tzdmNdW3ZlcnNpb25dO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqIFRoaXMgbWVtYmVyIG9mIEFXUy5hcGlMb2FkZXIgaXMgcHJpdmF0ZSwgYnV0IGNoYW5naW5nIGl0IHdpbGwgbmVjZXNzaXRhdGUgYVxuICogY2hhbmdlIHRvIC4uL3NjcmlwdHMvc2VydmljZXMtdGFibGUtZ2VuZXJhdG9yLnRzXG4gKi9cbmFwaUxvYWRlci5zZXJ2aWNlcyA9IHt9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFwaUxvYWRlcjtcbiIsInZhciBIbWFjID0gcmVxdWlyZSgnLi9icm93c2VySG1hYycpO1xudmFyIE1kNSA9IHJlcXVpcmUoJy4vYnJvd3Nlck1kNScpO1xudmFyIFNoYTEgPSByZXF1aXJlKCcuL2Jyb3dzZXJTaGExJyk7XG52YXIgU2hhMjU2ID0gcmVxdWlyZSgnLi9icm93c2VyU2hhMjU2Jyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVIYXNoOiBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZykge1xuICAgICAgYWxnID0gYWxnLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoYWxnID09PSAnbWQ1Jykge1xuICAgICAgICByZXR1cm4gbmV3IE1kNSgpO1xuICAgICAgfSBlbHNlIGlmIChhbGcgPT09ICdzaGEyNTYnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhMjU2KCk7XG4gICAgICB9IGVsc2UgaWYgKGFsZyA9PT0gJ3NoYTEnKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2hhMSgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggYWxnb3JpdGhtICcgKyBhbGcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIgU0RLJyk7XG4gICAgfSxcbiAgICBjcmVhdGVIbWFjOiBmdW5jdGlvbiBjcmVhdGVIbWFjKGFsZywga2V5KSB7XG4gICAgICBhbGcgPSBhbGcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhbGcgPT09ICdtZDUnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSG1hYyhNZDUsIGtleSk7XG4gICAgICB9IGVsc2UgaWYgKGFsZyA9PT0gJ3NoYTI1NicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIbWFjKFNoYTI1Niwga2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoYWxnID09PSAnc2hhMScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIbWFjKFNoYTEsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignSE1BQyBhbGdvcml0aG0gJyArIGFsZyArICcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlciBTREsnKTtcbiAgICB9LFxuICAgIGNyZWF0ZVNpZ246IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVTaWduIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGUgYnJvd3NlcicpO1xuICAgIH1cbiAgfTtcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXIvJykuQnVmZmVyO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgdGhlIHN0YXRpYyBtZXRob2QgYGlzVmlld2Agb2YgYEFycmF5QnVmZmVyYCwgd2hpY2ggaXNcbiAqIGUuZy4gbWlzc2luZyBpbiBJRSAxMC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuaWYgKFxuICAgIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAndW5kZWZpbmVkJ1xuKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB2aWV3U3RyaW5ncy5pbmRleE9mKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpKSA+IC0xO1xuICAgIH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciB2aWV3U3RyaW5ncyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAnW29iamVjdCBEYXRhVmlld10nLFxuXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eURhdGEoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5ieXRlTGVuZ3RoID09PSAwO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0VG9CdWZmZXIoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgJ3V0ZjgnKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGggLyBVaW50OEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHtcbiAgICBpc0VtcHR5RGF0YTogaXNFbXB0eURhdGEsXG4gICAgY29udmVydFRvQnVmZmVyOiBjb252ZXJ0VG9CdWZmZXIsXG59O1xuIiwidmFyIGhhc2hVdGlscyA9IHJlcXVpcmUoJy4vYnJvd3Nlckhhc2hVdGlscycpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBIbWFjKGhhc2hDdG9yLCBzZWNyZXQpIHtcbiAgICB0aGlzLmhhc2ggPSBuZXcgaGFzaEN0b3IoKTtcbiAgICB0aGlzLm91dGVyID0gbmV3IGhhc2hDdG9yKCk7XG5cbiAgICB2YXIgaW5uZXIgPSBidWZmZXJGcm9tU2VjcmV0KGhhc2hDdG9yLCBzZWNyZXQpO1xuICAgIHZhciBvdXRlciA9IG5ldyBVaW50OEFycmF5KGhhc2hDdG9yLkJMT0NLX1NJWkUpO1xuICAgIG91dGVyLnNldChpbm5lcik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhc2hDdG9yLkJMT0NLX1NJWkU7IGkrKykge1xuICAgICAgICBpbm5lcltpXSBePSAweDM2O1xuICAgICAgICBvdXRlcltpXSBePSAweDVjO1xuICAgIH1cblxuICAgIHRoaXMuaGFzaC51cGRhdGUoaW5uZXIpO1xuICAgIHRoaXMub3V0ZXIudXBkYXRlKG91dGVyKTtcblxuICAgIC8vIFplcm8gb3V0IHRoZSBjb3BpZWQga2V5IGJ1ZmZlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpbm5lcltpXSA9IDA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAodG9IYXNoKSB7XG4gICAgaWYgKGhhc2hVdGlscy5pc0VtcHR5RGF0YSh0b0hhc2gpIHx8IHRoaXMuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZShoYXNoVXRpbHMuY29udmVydFRvQnVmZmVyKHRvSGFzaCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMub3V0ZXIuZmluaXNoZWQpIHtcbiAgICAgICAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5oYXNoLmRpZ2VzdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jb2RpbmcpO1xufTtcblxuZnVuY3Rpb24gYnVmZmVyRnJvbVNlY3JldChoYXNoQ3Rvciwgc2VjcmV0KSB7XG4gICAgdmFyIGlucHV0ID0gaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcihzZWNyZXQpO1xuICAgIGlmIChpbnB1dC5ieXRlTGVuZ3RoID4gaGFzaEN0b3IuQkxPQ0tfU0laRSkge1xuICAgICAgICB2YXIgYnVmZmVySGFzaCA9IG5ldyBoYXNoQ3RvcjtcbiAgICAgICAgYnVmZmVySGFzaC51cGRhdGUoaW5wdXQpO1xuICAgICAgICBpbnB1dCA9IGJ1ZmZlckhhc2guZGlnZXN0KCk7XG4gICAgfVxuICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShoYXNoQ3Rvci5CTE9DS19TSVpFKTtcbiAgICBidWZmZXIuc2V0KGlucHV0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuIiwidmFyIGhhc2hVdGlscyA9IHJlcXVpcmUoJy4vYnJvd3Nlckhhc2hVdGlscycpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG5cbnZhciBCTE9DS19TSVpFID0gNjQ7XG5cbnZhciBESUdFU1RfTEVOR1RIID0gMTY7XG5cbnZhciBJTklUID0gW1xuICAgIDB4Njc0NTIzMDEsXG4gICAgMHhlZmNkYWI4OSxcbiAgICAweDk4YmFkY2ZlLFxuICAgIDB4MTAzMjU0NzYsXG5dO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBNZDUoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFtcbiAgICAgICAgMHg2NzQ1MjMwMSxcbiAgICAgICAgMHhlZmNkYWI4OSxcbiAgICAgICAgMHg5OGJhZGNmZSxcbiAgICAgICAgMHgxMDMyNTQ3NixcbiAgICBdO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihCTE9DS19TSVpFKSk7XG4gICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgPSAwO1xuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTWQ1O1xuXG5NZDUuQkxPQ0tfU0laRSA9IEJMT0NLX1NJWkU7XG5cbk1kNS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZURhdGEpIHtcbiAgICBpZiAoaGFzaFV0aWxzLmlzRW1wdHlEYXRhKHNvdXJjZURhdGEpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYW4gYWxyZWFkeSBmaW5pc2hlZCBoYXNoLicpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcihzb3VyY2VEYXRhKTtcbiAgICB2YXIgcG9zaXRpb24gPSAwO1xuICAgIHZhciBieXRlTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgKz0gYnl0ZUxlbmd0aDtcbiAgICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5idWZmZXIuc2V0VWludDgodGhpcy5idWZmZXJMZW5ndGgrKywgZGF0YVtwb3NpdGlvbisrXSk7XG4gICAgICAgIGJ5dGVMZW5ndGgtLTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyTGVuZ3RoID09PSBCTE9DS19TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTWQ1LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgYnVmZmVyID0gX2EuYnVmZmVyLCB1bmRlY29yYXRlZExlbmd0aCA9IF9hLmJ1ZmZlckxlbmd0aCwgYnl0ZXNIYXNoZWQgPSBfYS5ieXRlc0hhc2hlZDtcbiAgICAgICAgdmFyIGJpdHNIYXNoZWQgPSBieXRlc0hhc2hlZCAqIDg7XG4gICAgICAgIGJ1ZmZlci5zZXRVaW50OCh0aGlzLmJ1ZmZlckxlbmd0aCsrLCAxMjgpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbmFsIGJsb2NrIGhhcyBlbm91Z2ggcm9vbSBmb3IgdGhlIGhhc2hlZCBsZW5ndGhcbiAgICAgICAgaWYgKHVuZGVjb3JhdGVkTGVuZ3RoICUgQkxPQ0tfU0laRSA+PSBCTE9DS19TSVpFIC0gOCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldFVpbnQ4KGksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRSAtIDg7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyLnNldFVpbnQ4KGksIDApO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5zZXRVaW50MzIoQkxPQ0tfU0laRSAtIDgsIGJpdHNIYXNoZWQgPj4+IDAsIHRydWUpO1xuICAgICAgICBidWZmZXIuc2V0VWludDMyKEJMT0NLX1NJWkUgLSA0LCBNYXRoLmZsb29yKGJpdHNIYXNoZWQgLyAweDEwMDAwMDAwMCksIHRydWUpO1xuICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKERJR0VTVF9MRU5HVEgpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBvdXQuc2V0VWludDMyKGkgKiA0LCB0aGlzLnN0YXRlW2ldLCB0cnVlKTtcbiAgICB9XG4gICAgdmFyIGJ1ZmYgPSBuZXcgQnVmZmVyKG91dC5idWZmZXIsIG91dC5ieXRlT2Zmc2V0LCBvdXQuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGVuY29kaW5nID8gYnVmZi50b1N0cmluZyhlbmNvZGluZykgOiBidWZmO1xufTtcblxuTWQ1LnByb3RvdHlwZS5oYXNoQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMsIGJ1ZmZlciA9IF9hLmJ1ZmZlciwgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICB2YXIgYSA9IHN0YXRlWzBdLCBiID0gc3RhdGVbMV0sIGMgPSBzdGF0ZVsyXSwgZCA9IHN0YXRlWzNdO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDAsIHRydWUpLCA3LCAweGQ3NmFhNDc4KTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig0LCB0cnVlKSwgMTIsIDB4ZThjN2I3NTYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDgsIHRydWUpLCAxNywgMHgyNDIwNzBkYik7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMTIsIHRydWUpLCAyMiwgMHhjMWJkY2VlZSk7XG4gICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMTYsIHRydWUpLCA3LCAweGY1N2MwZmFmKTtcbiAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMigyMCwgdHJ1ZSksIDEyLCAweDQ3ODdjNjJhKTtcbiAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigyNCwgdHJ1ZSksIDE3LCAweGE4MzA0NjEzKTtcbiAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigyOCwgdHJ1ZSksIDIyLCAweGZkNDY5NTAxKTtcbiAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigzMiwgdHJ1ZSksIDcsIDB4Njk4MDk4ZDgpO1xuICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDM2LCB0cnVlKSwgMTIsIDB4OGI0NGY3YWYpO1xuICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgMTcsIDB4ZmZmZjViYjEpO1xuICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQ0LCB0cnVlKSwgMjIsIDB4ODk1Y2Q3YmUpO1xuICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgNywgMHg2YjkwMTEyMik7XG4gICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoNTIsIHRydWUpLCAxMiwgMHhmZDk4NzE5Myk7XG4gICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNTYsIHRydWUpLCAxNywgMHhhNjc5NDM4ZSk7XG4gICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoNjAsIHRydWUpLCAyMiwgMHg0OWI0MDgyMSk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDUsIDB4ZjYxZTI1NjIpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDI0LCB0cnVlKSwgOSwgMHhjMDQwYjM0MCk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNDQsIHRydWUpLCAxNCwgMHgyNjVlNWE1MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMCwgdHJ1ZSksIDIwLCAweGU5YjZjN2FhKTtcbiAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigyMCwgdHJ1ZSksIDUsIDB4ZDYyZjEwNWQpO1xuICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgOSwgMHgwMjQ0MTQ1Myk7XG4gICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNjAsIHRydWUpLCAxNCwgMHhkOGExZTY4MSk7XG4gICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoMTYsIHRydWUpLCAyMCwgMHhlN2QzZmJjOCk7XG4gICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMzYsIHRydWUpLCA1LCAweDIxZTFjZGU2KTtcbiAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyLmdldFVpbnQzMig1NiwgdHJ1ZSksIDksIDB4YzMzNzA3ZDYpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDEyLCB0cnVlKSwgMTQsIDB4ZjRkNTBkODcpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDMyLCB0cnVlKSwgMjAsIDB4NDU1YTE0ZWQpO1xuICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgNSwgMHhhOWUzZTkwNSk7XG4gICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoOCwgdHJ1ZSksIDksIDB4ZmNlZmEzZjgpO1xuICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDI4LCB0cnVlKSwgMTQsIDB4Njc2ZjAyZDkpO1xuICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgMjAsIDB4OGQyYTRjOGEpO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDIwLCB0cnVlKSwgNCwgMHhmZmZhMzk0Mik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMzIsIHRydWUpLCAxMSwgMHg4NzcxZjY4MSk7XG4gICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNDQsIHRydWUpLCAxNiwgMHg2ZDlkNjEyMik7XG4gICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoNTYsIHRydWUpLCAyMywgMHhmZGU1MzgwYyk7XG4gICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDQsIDB4YTRiZWVhNDQpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDE2LCB0cnVlKSwgMTEsIDB4NGJkZWNmYTkpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDI4LCB0cnVlKSwgMTYsIDB4ZjZiYjRiNjApO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDQwLCB0cnVlKSwgMjMsIDB4YmViZmJjNzApO1xuICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgNCwgMHgyODliN2VjNik7XG4gICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMCwgdHJ1ZSksIDExLCAweGVhYTEyN2ZhKTtcbiAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyLmdldFVpbnQzMigxMiwgdHJ1ZSksIDE2LCAweGQ0ZWYzMDg1KTtcbiAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigyNCwgdHJ1ZSksIDIzLCAweDA0ODgxZDA1KTtcbiAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigzNiwgdHJ1ZSksIDQsIDB4ZDlkNGQwMzkpO1xuICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgMTEsIDB4ZTZkYjk5ZTUpO1xuICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDYwLCB0cnVlKSwgMTYsIDB4MWZhMjdjZjgpO1xuICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDgsIHRydWUpLCAyMywgMHhjNGFjNTY2NSk7XG4gICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlci5nZXRVaW50MzIoMCwgdHJ1ZSksIDYsIDB4ZjQyOTIyNDQpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDI4LCB0cnVlKSwgMTAsIDB4NDMyYWZmOTcpO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDU2LCB0cnVlKSwgMTUsIDB4YWI5NDIzYTcpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDIwLCB0cnVlKSwgMjEsIDB4ZmM5M2EwMzkpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDQ4LCB0cnVlKSwgNiwgMHg2NTViNTljMyk7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoMTIsIHRydWUpLCAxMCwgMHg4ZjBjY2M5Mik7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoNDAsIHRydWUpLCAxNSwgMHhmZmVmZjQ3ZCk7XG4gICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlci5nZXRVaW50MzIoNCwgdHJ1ZSksIDIxLCAweDg1ODQ1ZGQxKTtcbiAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyLmdldFVpbnQzMigzMiwgdHJ1ZSksIDYsIDB4NmZhODdlNGYpO1xuICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXIuZ2V0VWludDMyKDYwLCB0cnVlKSwgMTAsIDB4ZmUyY2U2ZTApO1xuICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXIuZ2V0VWludDMyKDI0LCB0cnVlKSwgMTUsIDB4YTMwMTQzMTQpO1xuICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXIuZ2V0VWludDMyKDUyLCB0cnVlKSwgMjEsIDB4NGUwODExYTEpO1xuICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXIuZ2V0VWludDMyKDE2LCB0cnVlKSwgNiwgMHhmNzUzN2U4Mik7XG4gICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlci5nZXRVaW50MzIoNDQsIHRydWUpLCAxMCwgMHhiZDNhZjIzNSk7XG4gICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlci5nZXRVaW50MzIoOCwgdHJ1ZSksIDE1LCAweDJhZDdkMmJiKTtcbiAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyLmdldFVpbnQzMigzNiwgdHJ1ZSksIDIxLCAweGViODZkMzkxKTtcbiAgICBzdGF0ZVswXSA9IChhICsgc3RhdGVbMF0pICYgMHhGRkZGRkZGRjtcbiAgICBzdGF0ZVsxXSA9IChiICsgc3RhdGVbMV0pICYgMHhGRkZGRkZGRjtcbiAgICBzdGF0ZVsyXSA9IChjICsgc3RhdGVbMl0pICYgMHhGRkZGRkZGRjtcbiAgICBzdGF0ZVszXSA9IChkICsgc3RhdGVbM10pICYgMHhGRkZGRkZGRjtcbn07XG5cbmZ1bmN0aW9uIGNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgYSA9ICgoKGEgKyBxKSAmIDB4RkZGRkZGRkYpICsgKCh4ICsgdCkgJiAweEZGRkZGRkZGKSkgJiAweEZGRkZGRkZGO1xuICAgIHJldHVybiAoKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSkgKyBiKSAmIDB4RkZGRkZGRkY7XG59XG5cbmZ1bmN0aW9uIGZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4gY21uKChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gZ2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBjbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIGNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIGNtbihjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyLycpLkJ1ZmZlcjtcbnZhciBoYXNoVXRpbHMgPSByZXF1aXJlKCcuL2Jyb3dzZXJIYXNoVXRpbHMnKTtcblxudmFyIEJMT0NLX1NJWkUgPSA2NDtcblxudmFyIERJR0VTVF9MRU5HVEggPSAyMDtcblxudmFyIEtFWSA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg1YTgyNzk5OSxcbiAgICAweDZlZDllYmExLFxuICAgIDB4OGYxYmJjZGMgfCAwLFxuICAgIDB4Y2E2MmMxZDYgfCAwXG5dKTtcblxudmFyIElOSVQgPSBbXG4gICAgMHg2YTA5ZTY2NyxcbiAgICAweGJiNjdhZTg1LFxuICAgIDB4M2M2ZWYzNzIsXG4gICAgMHhhNTRmZjUzYSxcbiAgICAweDUxMGU1MjdmLFxuICAgIDB4OWIwNTY4OGMsXG4gICAgMHgxZjgzZDlhYixcbiAgICAweDViZTBjZDE5LFxuXTtcblxudmFyIE1BWF9IQVNIQUJMRV9MRU5HVEggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTaGExKCkge1xuICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxO1xuICAgIHRoaXMuaDEgPSAweEVGQ0RBQjg5O1xuICAgIHRoaXMuaDIgPSAweDk4QkFEQ0ZFO1xuICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2O1xuICAgIHRoaXMuaDQgPSAweEMzRDJFMUYwO1xuICAgIC8vIFRoZSBmaXJzdCA2NCBieXRlcyAoMTYgd29yZHMpIGlzIHRoZSBkYXRhIGNodW5rXG4gICAgdGhpcy5ibG9jayA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMuc2hpZnQgPSAyNDtcbiAgICB0aGlzLnRvdGFsTGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU2hhMTtcblxuU2hhMS5CTE9DS19TSVpFID0gQkxPQ0tfU0laRTtcblxuU2hhMS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1cGRhdGUgYW4gYWxyZWFkeSBmaW5pc2hlZCBoYXNoLicpO1xuICAgIH1cblxuICAgIGlmIChoYXNoVXRpbHMuaXNFbXB0eURhdGEoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZGF0YSA9IGhhc2hVdGlscy5jb252ZXJ0VG9CdWZmZXIoZGF0YSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy50b3RhbExlbmd0aCArPSBsZW5ndGggKiA4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53cml0ZShkYXRhW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblNoYTEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoYnl0ZSkge1xuICAgIHRoaXMuYmxvY2tbdGhpcy5vZmZzZXRdIHw9IChieXRlICYgMHhmZikgPDwgdGhpcy5zaGlmdDtcbiAgICBpZiAodGhpcy5zaGlmdCkge1xuICAgICAgICB0aGlzLnNoaWZ0IC09IDg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5zaGlmdCA9IDI0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gMTYpIHRoaXMucHJvY2Vzc0Jsb2NrKCk7XG59O1xuXG5TaGExLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAvLyBQYWRcbiAgICB0aGlzLndyaXRlKDB4ODApO1xuICAgIGlmICh0aGlzLm9mZnNldCA+IDE0IHx8ICh0aGlzLm9mZnNldCA9PT0gMTQgJiYgdGhpcy5zaGlmdCA8IDI0KSkge1xuICAgICAgdGhpcy5wcm9jZXNzQmxvY2soKTtcbiAgICB9XG4gICAgdGhpcy5vZmZzZXQgPSAxNDtcbiAgICB0aGlzLnNoaWZ0ID0gMjQ7XG5cbiAgICAvLyA2NC1iaXQgbGVuZ3RoIGJpZy1lbmRpYW5cbiAgICB0aGlzLndyaXRlKDB4MDApOyAvLyBudW1iZXJzIHRoaXMgYmlnIGFyZW4ndCBhY2N1cmF0ZSBpbiBqYXZhc2NyaXB0IGFueXdheVxuICAgIHRoaXMud3JpdGUoMHgwMCk7IC8vIC4uU28ganVzdCBoYXJkLWNvZGUgdG8gemVyby5cbiAgICB0aGlzLndyaXRlKHRoaXMudG90YWxMZW5ndGggPiAweGZmZmZmZmZmZmYgPyB0aGlzLnRvdGFsTGVuZ3RoIC8gMHgxMDAwMDAwMDAwMCA6IDB4MDApO1xuICAgIHRoaXMud3JpdGUodGhpcy50b3RhbExlbmd0aCA+IDB4ZmZmZmZmZmYgPyB0aGlzLnRvdGFsTGVuZ3RoIC8gMHgxMDAwMDAwMDAgOiAweDAwKTtcbiAgICBmb3IgKHZhciBzID0gMjQ7IHMgPj0gMDsgcyAtPSA4KSB7XG4gICAgICAgIHRoaXMud3JpdGUodGhpcy50b3RhbExlbmd0aCA+PiBzKTtcbiAgICB9XG4gICAgLy8gVGhlIHZhbHVlIGluIHN0YXRlIGlzIGxpdHRsZS1lbmRpYW4gcmF0aGVyIHRoYW4gYmlnLWVuZGlhbiwgc28gZmxpcFxuICAgIC8vIGVhY2ggd29yZCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXlcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcihESUdFU1RfTEVOR1RIKTtcbiAgICB2YXIgb3V0VmlldyA9IG5ldyBEYXRhVmlldyhvdXQuYnVmZmVyKTtcbiAgICBvdXRWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwLCBmYWxzZSk7XG4gICAgb3V0Vmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSwgZmFsc2UpO1xuICAgIG91dFZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIsIGZhbHNlKTtcbiAgICBvdXRWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMywgZmFsc2UpO1xuICAgIG91dFZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0LCBmYWxzZSk7XG5cbiAgICByZXR1cm4gZW5jb2RpbmcgPyBvdXQudG9TdHJpbmcoZW5jb2RpbmcpIDogb3V0O1xufTtcblxuU2hhMS5wcm90b3R5cGUucHJvY2Vzc0Jsb2NrID0gZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKCkge1xuICAgIC8vIEV4dGVuZCB0aGUgc2l4dGVlbiAzMi1iaXQgd29yZHMgaW50byBlaWdodHkgMzItYml0IHdvcmRzOlxuICAgIGZvciAodmFyIGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy5ibG9ja1tpIC0gM10gXiB0aGlzLmJsb2NrW2kgLSA4XSBeIHRoaXMuYmxvY2tbaSAtIDE0XSBeIHRoaXMuYmxvY2tbaSAtIDE2XTtcbiAgICAgIHRoaXMuYmxvY2tbaV0gPSAodyA8PCAxKSB8ICh3ID4+PiAzMSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBoYXNoIHZhbHVlIGZvciB0aGlzIGNodW5rOlxuICAgIHZhciBhID0gdGhpcy5oMDtcbiAgICB2YXIgYiA9IHRoaXMuaDE7XG4gICAgdmFyIGMgPSB0aGlzLmgyO1xuICAgIHZhciBkID0gdGhpcy5oMztcbiAgICB2YXIgZSA9IHRoaXMuaDQ7XG4gICAgdmFyIGYsIGs7XG5cbiAgICAvLyBNYWluIGxvb3A6XG4gICAgZm9yIChpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICBrID0gMHg1QTgyNzk5OTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGkgPCA0MCkge1xuICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICBrID0gMHg2RUQ5RUJBMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGkgPCA2MCkge1xuICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XG4gICAgICAgIGsgPSAweDhGMUJCQ0RDO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgIGsgPSAweENBNjJDMUQ2O1xuICAgICAgfVxuICAgICAgdmFyIHRlbXAgPSAoYSA8PCA1IHwgYSA+Pj4gMjcpICsgZiArIGUgKyBrICsgKHRoaXMuYmxvY2tbaV18MCk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IChiIDw8IDMwIHwgYiA+Pj4gMik7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0ZW1wO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGlzIGNodW5rJ3MgaGFzaCB0byByZXN1bHQgc28gZmFyOlxuICAgIHRoaXMuaDAgPSAodGhpcy5oMCArIGEpIHwgMDtcbiAgICB0aGlzLmgxID0gKHRoaXMuaDEgKyBiKSB8IDA7XG4gICAgdGhpcy5oMiA9ICh0aGlzLmgyICsgYykgfCAwO1xuICAgIHRoaXMuaDMgPSAodGhpcy5oMyArIGQpIHwgMDtcbiAgICB0aGlzLmg0ID0gKHRoaXMuaDQgKyBlKSB8IDA7XG5cbiAgICAvLyBUaGUgYmxvY2sgaXMgbm93IHJldXNhYmxlLlxuICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICB0aGlzLmJsb2NrW2ldID0gMDtcbiAgICB9XG59O1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG52YXIgaGFzaFV0aWxzID0gcmVxdWlyZSgnLi9icm93c2VySGFzaFV0aWxzJyk7XG5cbnZhciBCTE9DS19TSVpFID0gNjQ7XG5cbnZhciBESUdFU1RfTEVOR1RIID0gMzI7XG5cbnZhciBLRVkgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsXG4gICAgMHg3MTM3NDQ5MSxcbiAgICAweGI1YzBmYmNmLFxuICAgIDB4ZTliNWRiYTUsXG4gICAgMHgzOTU2YzI1YixcbiAgICAweDU5ZjExMWYxLFxuICAgIDB4OTIzZjgyYTQsXG4gICAgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LFxuICAgIDB4MTI4MzViMDEsXG4gICAgMHgyNDMxODViZSxcbiAgICAweDU1MGM3ZGMzLFxuICAgIDB4NzJiZTVkNzQsXG4gICAgMHg4MGRlYjFmZSxcbiAgICAweDliZGMwNmE3LFxuICAgIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSxcbiAgICAweGVmYmU0Nzg2LFxuICAgIDB4MGZjMTlkYzYsXG4gICAgMHgyNDBjYTFjYyxcbiAgICAweDJkZTkyYzZmLFxuICAgIDB4NGE3NDg0YWEsXG4gICAgMHg1Y2IwYTlkYyxcbiAgICAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsXG4gICAgMHhhODMxYzY2ZCxcbiAgICAweGIwMDMyN2M4LFxuICAgIDB4YmY1OTdmYzcsXG4gICAgMHhjNmUwMGJmMyxcbiAgICAweGQ1YTc5MTQ3LFxuICAgIDB4MDZjYTYzNTEsXG4gICAgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LFxuICAgIDB4MmUxYjIxMzgsXG4gICAgMHg0ZDJjNmRmYyxcbiAgICAweDUzMzgwZDEzLFxuICAgIDB4NjUwYTczNTQsXG4gICAgMHg3NjZhMGFiYixcbiAgICAweDgxYzJjOTJlLFxuICAgIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSxcbiAgICAweGE4MWE2NjRiLFxuICAgIDB4YzI0YjhiNzAsXG4gICAgMHhjNzZjNTFhMyxcbiAgICAweGQxOTJlODE5LFxuICAgIDB4ZDY5OTA2MjQsXG4gICAgMHhmNDBlMzU4NSxcbiAgICAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsXG4gICAgMHgxZTM3NmMwOCxcbiAgICAweDI3NDg3NzRjLFxuICAgIDB4MzRiMGJjYjUsXG4gICAgMHgzOTFjMGNiMyxcbiAgICAweDRlZDhhYTRhLFxuICAgIDB4NWI5Y2NhNGYsXG4gICAgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLFxuICAgIDB4NzhhNTYzNmYsXG4gICAgMHg4NGM4NzgxNCxcbiAgICAweDhjYzcwMjA4LFxuICAgIDB4OTBiZWZmZmEsXG4gICAgMHhhNDUwNmNlYixcbiAgICAweGJlZjlhM2Y3LFxuICAgIDB4YzY3MTc4ZjJcbl0pO1xuXG52YXIgSU5JVCA9IFtcbiAgICAweDZhMDllNjY3LFxuICAgIDB4YmI2N2FlODUsXG4gICAgMHgzYzZlZjM3MixcbiAgICAweGE1NGZmNTNhLFxuICAgIDB4NTEwZTUyN2YsXG4gICAgMHg5YjA1Njg4YyxcbiAgICAweDFmODNkOWFiLFxuICAgIDB4NWJlMGNkMTksXG5dO1xuXG52YXIgTUFYX0hBU0hBQkxFX0xFTkdUSCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU2hhMjU2KCkge1xuICAgIHRoaXMuc3RhdGUgPSBbXG4gICAgICAgIDB4NmEwOWU2NjcsXG4gICAgICAgIDB4YmI2N2FlODUsXG4gICAgICAgIDB4M2M2ZWYzNzIsXG4gICAgICAgIDB4YTU0ZmY1M2EsXG4gICAgICAgIDB4NTEwZTUyN2YsXG4gICAgICAgIDB4OWIwNTY4OGMsXG4gICAgICAgIDB4MWY4M2Q5YWIsXG4gICAgICAgIDB4NWJlMGNkMTksXG4gICAgXTtcbiAgICB0aGlzLnRlbXAgPSBuZXcgSW50MzJBcnJheSg2NCk7XG4gICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gICAgdGhpcy5idWZmZXJMZW5ndGggPSAwO1xuICAgIHRoaXMuYnl0ZXNIYXNoZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTaGEyNTY7XG5cblNoYTI1Ni5CTE9DS19TSVpFID0gQkxPQ0tfU0laRTtcblxuU2hhMjU2LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIHVwZGF0ZSBhbiBhbHJlYWR5IGZpbmlzaGVkIGhhc2guJyk7XG4gICAgfVxuXG4gICAgaWYgKGhhc2hVdGlscy5pc0VtcHR5RGF0YShkYXRhKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkYXRhID0gaGFzaFV0aWxzLmNvbnZlcnRUb0J1ZmZlcihkYXRhKTtcblxuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5ieXRlc0hhc2hlZCArPSBieXRlTGVuZ3RoO1xuICAgIGlmICh0aGlzLmJ5dGVzSGFzaGVkICogOCA+IE1BWF9IQVNIQUJMRV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGFzaCBtb3JlIHRoYW4gMl41MyAtIDEgYml0cycpO1xuICAgIH1cblxuICAgIHdoaWxlIChieXRlTGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlckxlbmd0aCsrXSA9IGRhdGFbcG9zaXRpb24rK107XG4gICAgICAgIGJ5dGVMZW5ndGgtLTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyTGVuZ3RoID09PSBCTE9DS19TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuU2hhMjU2LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmluaXNoZWQpIHtcbiAgICAgICAgdmFyIGJpdHNIYXNoZWQgPSB0aGlzLmJ5dGVzSGFzaGVkICogODtcbiAgICAgICAgdmFyIGJ1ZmZlclZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIuYnVmZmVyLCB0aGlzLmJ1ZmZlci5ieXRlT2Zmc2V0LCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFyIHVuZGVjb3JhdGVkTGVuZ3RoID0gdGhpcy5idWZmZXJMZW5ndGg7XG4gICAgICAgIGJ1ZmZlclZpZXcuc2V0VWludDgodGhpcy5idWZmZXJMZW5ndGgrKywgMHg4MCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZmluYWwgYmxvY2sgaGFzIGVub3VnaCByb29tIGZvciB0aGUgaGFzaGVkIGxlbmd0aFxuICAgICAgICBpZiAodW5kZWNvcmF0ZWRMZW5ndGggJSBCTE9DS19TSVpFID49IEJMT0NLX1NJWkUgLSA4KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5idWZmZXJMZW5ndGg7IGkgPCBCTE9DS19TSVpFOyBpKyspIHtcbiAgICAgICAgICAgICAgICBidWZmZXJWaWV3LnNldFVpbnQ4KGksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNoQnVmZmVyKCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuYnVmZmVyTGVuZ3RoOyBpIDwgQkxPQ0tfU0laRSAtIDg7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyVmlldy5zZXRVaW50OChpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJWaWV3LnNldFVpbnQzMihCTE9DS19TSVpFIC0gOCwgTWF0aC5mbG9vcihiaXRzSGFzaGVkIC8gMHgxMDAwMDAwMDApLCB0cnVlKTtcbiAgICAgICAgYnVmZmVyVmlldy5zZXRVaW50MzIoQkxPQ0tfU0laRSAtIDQsIGJpdHNIYXNoZWQpO1xuICAgICAgICB0aGlzLmhhc2hCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIFRoZSB2YWx1ZSBpbiBzdGF0ZSBpcyBsaXR0bGUtZW5kaWFuIHJhdGhlciB0aGFuIGJpZy1lbmRpYW4sIHNvIGZsaXBcbiAgICAvLyBlYWNoIHdvcmQgaW50byBhIG5ldyBVaW50OEFycmF5XG4gICAgdmFyIG91dCA9IG5ldyBCdWZmZXIoRElHRVNUX0xFTkdUSCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgb3V0W2kgKiA0XSA9ICh0aGlzLnN0YXRlW2ldID4+PiAyNCkgJiAweGZmO1xuICAgICAgICBvdXRbaSAqIDQgKyAxXSA9ICh0aGlzLnN0YXRlW2ldID4+PiAxNikgJiAweGZmO1xuICAgICAgICBvdXRbaSAqIDQgKyAyXSA9ICh0aGlzLnN0YXRlW2ldID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIG91dFtpICogNCArIDNdID0gKHRoaXMuc3RhdGVbaV0gPj4+IDApICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5nID8gb3V0LnRvU3RyaW5nKGVuY29kaW5nKSA6IG91dDtcbn07XG5cblNoYTI1Ni5wcm90b3R5cGUuaGFzaEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLFxuICAgICAgICBidWZmZXIgPSBfYS5idWZmZXIsXG4gICAgICAgIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgdmFyIHN0YXRlMCA9IHN0YXRlWzBdLFxuICAgICAgICBzdGF0ZTEgPSBzdGF0ZVsxXSxcbiAgICAgICAgc3RhdGUyID0gc3RhdGVbMl0sXG4gICAgICAgIHN0YXRlMyA9IHN0YXRlWzNdLFxuICAgICAgICBzdGF0ZTQgPSBzdGF0ZVs0XSxcbiAgICAgICAgc3RhdGU1ID0gc3RhdGVbNV0sXG4gICAgICAgIHN0YXRlNiA9IHN0YXRlWzZdLFxuICAgICAgICBzdGF0ZTcgPSBzdGF0ZVs3XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IEJMT0NLX1NJWkU7IGkrKykge1xuICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBbaV0gPSAoKChidWZmZXJbaSAqIDRdICYgMHhmZikgPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAoKGJ1ZmZlclsoaSAqIDQpICsgMV0gJiAweGZmKSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICgoYnVmZmVyWyhpICogNCkgKyAyXSAmIDB4ZmYpIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyWyhpICogNCkgKyAzXSAmIDB4ZmYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1ID0gdGhpcy50ZW1wW2kgLSAyXTtcbiAgICAgICAgICAgIHZhciB0MV8xID0gKHUgPj4+IDE3IHwgdSA8PCAxNSkgXlxuICAgICAgICAgICAgICAgICh1ID4+PiAxOSB8IHUgPDwgMTMpIF5cbiAgICAgICAgICAgICAgICAodSA+Pj4gMTApO1xuICAgICAgICAgICAgdSA9IHRoaXMudGVtcFtpIC0gMTVdO1xuICAgICAgICAgICAgdmFyIHQyXzEgPSAodSA+Pj4gNyB8IHUgPDwgMjUpIF5cbiAgICAgICAgICAgICAgICAodSA+Pj4gMTggfCB1IDw8IDE0KSBeXG4gICAgICAgICAgICAgICAgKHUgPj4+IDMpO1xuICAgICAgICAgICAgdGhpcy50ZW1wW2ldID0gKHQxXzEgKyB0aGlzLnRlbXBbaSAtIDddIHwgMCkgK1xuICAgICAgICAgICAgICAgICh0Ml8xICsgdGhpcy50ZW1wW2kgLSAxNl0gfCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDEgPSAoKCgoKHN0YXRlNCA+Pj4gNiB8IHN0YXRlNCA8PCAyNikgXlxuICAgICAgICAgICAgKHN0YXRlNCA+Pj4gMTEgfCBzdGF0ZTQgPDwgMjEpIF5cbiAgICAgICAgICAgIChzdGF0ZTQgPj4+IDI1IHwgc3RhdGU0IDw8IDcpKVxuICAgICAgICAgICAgKyAoKHN0YXRlNCAmIHN0YXRlNSkgXiAofnN0YXRlNCAmIHN0YXRlNikpKSB8IDApXG4gICAgICAgICAgICArICgoc3RhdGU3ICsgKChLRVlbaV0gKyB0aGlzLnRlbXBbaV0pIHwgMCkpIHwgMCkpIHwgMDtcbiAgICAgICAgdmFyIHQyID0gKCgoc3RhdGUwID4+PiAyIHwgc3RhdGUwIDw8IDMwKSBeXG4gICAgICAgICAgICAoc3RhdGUwID4+PiAxMyB8IHN0YXRlMCA8PCAxOSkgXlxuICAgICAgICAgICAgKHN0YXRlMCA+Pj4gMjIgfCBzdGF0ZTAgPDwgMTApKSArICgoc3RhdGUwICYgc3RhdGUxKSBeIChzdGF0ZTAgJiBzdGF0ZTIpIF4gKHN0YXRlMSAmIHN0YXRlMikpKSB8IDA7XG4gICAgICAgIHN0YXRlNyA9IHN0YXRlNjtcbiAgICAgICAgc3RhdGU2ID0gc3RhdGU1O1xuICAgICAgICBzdGF0ZTUgPSBzdGF0ZTQ7XG4gICAgICAgIHN0YXRlNCA9IChzdGF0ZTMgKyB0MSkgfCAwO1xuICAgICAgICBzdGF0ZTMgPSBzdGF0ZTI7XG4gICAgICAgIHN0YXRlMiA9IHN0YXRlMTtcbiAgICAgICAgc3RhdGUxID0gc3RhdGUwO1xuICAgICAgICBzdGF0ZTAgPSAodDEgKyB0MikgfCAwO1xuICAgIH1cbiAgICBzdGF0ZVswXSArPSBzdGF0ZTA7XG4gICAgc3RhdGVbMV0gKz0gc3RhdGUxO1xuICAgIHN0YXRlWzJdICs9IHN0YXRlMjtcbiAgICBzdGF0ZVszXSArPSBzdGF0ZTM7XG4gICAgc3RhdGVbNF0gKz0gc3RhdGU0O1xuICAgIHN0YXRlWzVdICs9IHN0YXRlNTtcbiAgICBzdGF0ZVs2XSArPSBzdGF0ZTY7XG4gICAgc3RhdGVbN10gKz0gc3RhdGU3O1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIGJyb3dzZXIgc3BlY2lmaWMgbW9kdWxlc1xudXRpbC5jcnlwdG8ubGliID0gcmVxdWlyZSgnLi9icm93c2VyQ3J5cHRvTGliJyk7XG51dGlsLkJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlci8nKS5CdWZmZXI7XG51dGlsLnVybCA9IHJlcXVpcmUoJ3VybC8nKTtcbnV0aWwucXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZy8nKTtcbnV0aWwucmVhbENsb2NrID0gcmVxdWlyZSgnLi9yZWFsY2xvY2svYnJvd3NlckNsb2NrJyk7XG51dGlsLmVudmlyb25tZW50ID0gJ2pzJztcbnV0aWwuY3JlYXRlRXZlbnRTdHJlYW0gPSByZXF1aXJlKCcuL2V2ZW50LXN0cmVhbS9idWZmZXJlZC1jcmVhdGUtZXZlbnQtc3RyZWFtJykuY3JlYXRlRXZlbnRTdHJlYW07XG51dGlsLmlzQnJvd3NlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbnV0aWwuaXNOb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblxudmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUztcblxucmVxdWlyZSgnLi9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jcmVkZW50aWFsX3Byb3ZpZGVyX2NoYWluJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3RlbXBvcmFyeV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jaGFpbmFibGVfdGVtcG9yYXJ5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3dlYl9pZGVudGl0eV9jcmVkZW50aWFscycpO1xucmVxdWlyZSgnLi9jcmVkZW50aWFscy9jb2duaXRvX2lkZW50aXR5X2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL3NhbWxfY3JlZGVudGlhbHMnKTtcblxuLy8gTG9hZCB0aGUgRE9NUGFyc2VyIFhNTCBwYXJzZXJcbkFXUy5YTUwuUGFyc2VyID0gcmVxdWlyZSgnLi94bWwvYnJvd3Nlcl9wYXJzZXInKTtcblxuLy8gTG9hZCB0aGUgWEhSIEh0dHBDbGllbnRcbnJlcXVpcmUoJy4vaHR0cC94aHInKTtcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICB2YXIgcHJvY2VzcyA9IHtcbiAgICBicm93c2VyOiB0cnVlXG4gIH07XG59XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzJyk7XG5yZXF1aXJlKCcuL2NyZWRlbnRpYWxzL2NyZWRlbnRpYWxfcHJvdmlkZXJfY2hhaW4nKTtcbnZhciBQcm9taXNlc0RlcGVuZGVuY3k7XG5cbi8qKlxuICogVGhlIG1haW4gY29uZmlndXJhdGlvbiBjbGFzcyB1c2VkIGJ5IGFsbCBzZXJ2aWNlIG9iamVjdHMgdG8gc2V0XG4gKiB0aGUgcmVnaW9uLCBjcmVkZW50aWFscywgYW5kIG90aGVyIG9wdGlvbnMgZm9yIHJlcXVlc3RzLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGNyZWRlbnRpYWxzIGFuZCByZWdpb24gc2V0dGluZ3MgYXJlIGxlZnQgdW5jb25maWd1cmVkLlxuICogVGhpcyBzaG91bGQgYmUgY29uZmlndXJlZCBieSB0aGUgYXBwbGljYXRpb24gYmVmb3JlIHVzaW5nIGFueVxuICogQVdTIHNlcnZpY2UgQVBJcy5cbiAqXG4gKiBJbiBvcmRlciB0byBzZXQgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucywgcHJvcGVydGllcyBzaG91bGRcbiAqIGJlIGFzc2lnbmVkIHRvIHRoZSBnbG9iYWwge0FXUy5jb25maWd9IG9iamVjdC5cbiAqXG4gKiBAc2VlIEFXUy5jb25maWdcbiAqXG4gKiBAIWdyb3VwIEdlbmVyYWwgQ29uZmlndXJhdGlvbiBPcHRpb25zXG4gKlxuICogQCFhdHRyaWJ1dGUgY3JlZGVudGlhbHNcbiAqICAgQHJldHVybiBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgQVdTIGNyZWRlbnRpYWxzIHRvIHNpZ24gcmVxdWVzdHMgd2l0aC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZWdpb25cbiAqICAgQGV4YW1wbGUgU2V0IHRoZSBnbG9iYWwgcmVnaW9uIHNldHRpbmcgdG8gdXMtd2VzdC0yXG4gKiAgICAgQVdTLmNvbmZpZy51cGRhdGUoe3JlZ2lvbjogJ3VzLXdlc3QtMid9KTtcbiAqICAgQHJldHVybiBbQVdTLkNyZWRlbnRpYWxzXSBUaGUgcmVnaW9uIHRvIHNlbmQgc2VydmljZSByZXF1ZXN0cyB0by5cbiAqICAgQHNlZSBodHRwOi8vZG9jcy5hbWF6b253ZWJzZXJ2aWNlcy5jb20vZ2VuZXJhbC9sYXRlc3QvZ3IvcmFuZGUuaHRtbFxuICogICAgIEEgbGlzdCBvZiBhdmFpbGFibGUgZW5kcG9pbnRzIGZvciBlYWNoIEFXUyBzZXJ2aWNlXG4gKlxuICogQCFhdHRyaWJ1dGUgbWF4UmV0cmllc1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmV0cmllcyB0byBwZXJmb3JtIGZvciBhXG4gKiAgICAgc2VydmljZSByZXF1ZXN0LiBCeSBkZWZhdWx0IHRoaXMgdmFsdWUgaXMgY2FsY3VsYXRlZCBieSB0aGUgc3BlY2lmaWNcbiAqICAgICBzZXJ2aWNlIG9iamVjdCB0aGF0IHRoZSByZXF1ZXN0IGlzIGJlaW5nIG1hZGUgdG8uXG4gKlxuICogQCFhdHRyaWJ1dGUgbWF4UmVkaXJlY3RzXG4gKiAgIEByZXR1cm4gW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZWRpcmVjdHMgdG8gZm9sbG93IGZvciBhXG4gKiAgICAgc2VydmljZSByZXF1ZXN0LiBEZWZhdWx0cyB0byAxMC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbVZhbGlkYXRpb25cbiAqICAgQHJldHVybiBbQm9vbGVhbnxtYXBdIHdoZXRoZXIgaW5wdXQgcGFyYW1ldGVycyBzaG91bGQgYmUgdmFsaWRhdGVkIGFnYWluc3RcbiAqICAgICB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nIHRoZSByZXF1ZXN0LiBEZWZhdWx0cyB0byB0cnVlLlxuICogICAgIFBhc3MgYSBtYXAgdG8gZW5hYmxlIGFueSBvZiB0aGUgZm9sbG93aW5nIHNwZWNpZmljIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gKlxuICogICAgICogKiptaW4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtaW5cbiAqICAgICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICogICAgICAgdG8gYHRydWVgLlxuICogICAgICogKiptYXgqKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHZhbHVlIG1lZXRzIHRoZSBtYXhcbiAqICAgICAgIGNvbnN0cmFpbnQuXG4gKiAgICAgKiAqKnBhdHRlcm4qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIGFcbiAqICAgICAgIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqICAgICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gKiAgICAgICBvZiB0aGUgYWxsb3dhYmxlIGVudW0gdmFsdWVzLlxuICpcbiAqIEAhYXR0cmlidXRlIGNvbXB1dGVDaGVja3N1bXNcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBjb21wdXRlIGNoZWNrc3VtcyBmb3IgcGF5bG9hZCBib2RpZXMgd2hlblxuICogICAgIHRoZSBzZXJ2aWNlIGFjY2VwdHMgaXQgKGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gUzMgYW5kIFNRUyBvbmx5KS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBjb252ZXJ0UmVzcG9uc2VUeXBlc1xuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHR5cGVzIGFyZSBjb252ZXJ0ZWQgd2hlbiBwYXJzaW5nIHJlc3BvbnNlIGRhdGEuXG4gKiAgICAgQ3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGZvciBKU09OIGJhc2VkIHNlcnZpY2VzLiBUdXJuaW5nIHRoaXMgb2ZmIG1heVxuICogICAgIGltcHJvdmUgcGVyZm9ybWFuY2Ugb24gbGFyZ2UgcmVzcG9uc2UgcGF5bG9hZHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBjb3JyZWN0Q2xvY2tTa2V3XG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gYXBwbHkgYSBjbG9jayBza2V3IGNvcnJlY3Rpb24gYW5kIHJldHJ5XG4gKiAgICAgcmVxdWVzdHMgdGhhdCBmYWlsIGJlY2F1c2Ugb2YgYW4gc2tld2VkIGNsaWVudCBjbG9jay4gRGVmYXVsdHMgdG9cbiAqICAgICBgZmFsc2VgLlxuICpcbiAqIEAhYXR0cmlidXRlIHNzbEVuYWJsZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciBTU0wgaXMgZW5hYmxlZCBmb3IgcmVxdWVzdHNcbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM0ZvcmNlUGF0aFN0eWxlXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZm9yY2UgcGF0aCBzdHlsZSBVUkxzIGZvciBTMyBvYmplY3RzXG4gKlxuICogQCFhdHRyaWJ1dGUgczNCdWNrZXRFbmRwb2ludFxuICogICBAbm90ZSBTZXR0aW5nIHRoaXMgY29uZmlndXJhdGlvbiBvcHRpb24gcmVxdWlyZXMgYW4gYGVuZHBvaW50YCB0byBiZVxuICogICAgIHByb3ZpZGVkIGV4cGxpY2l0bHkgdG8gdGhlIHNlcnZpY2UgY29uc3RydWN0b3IuXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVuZHBvaW50IGFkZHJlc3NlcyBhbiBpbmRpdmlkdWFsXG4gKiAgICAgYnVja2V0IChmYWxzZSBpZiBpdCBhZGRyZXNzZXMgdGhlIHJvb3QgQVBJIGVuZHBvaW50KS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzM0Rpc2FibGVCb2R5U2lnbmluZ1xuICogICBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRvIGRpc2FibGUgUzMgYm9keSBzaWduaW5nIHdoZW4gdXNpbmcgc2lnbmF0dXJlIHZlcnNpb24gYHY0YC5cbiAqICAgICBCb2R5IHNpZ25pbmcgY2FuIG9ubHkgYmUgZGlzYWJsZWQgd2hlbiB1c2luZyBodHRwcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICpcbiAqIEAhYXR0cmlidXRlIHMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnRcbiAqICAgQHJldHVybiBbJ2xlZ2FjeSd8J3JlZ2lvbmFsJ10gd2hlbiByZWdpb24gaXMgc2V0IHRvICd1cy1lYXN0LTEnLCB3aGV0aGVyIHRvIHNlbmQgczNcbiAqICAgICByZXF1ZXN0IHRvIGdsb2JhbCBlbmRwb2ludHMgb3IgJ3VzLWVhc3QtMScgcmVnaW9uYWwgZW5kcG9pbnRzLiBUaGlzIGNvbmZpZyBpcyBvbmx5XG4gKiAgICAgYXBwbGljYWJsZSB0byBTMyBjbGllbnQ7XG4gKiAgICAgRGVmYXVsdHMgdG8gJ2xlZ2FjeSdcbiAqIEAhYXR0cmlidXRlIHMzVXNlQXJuUmVnaW9uXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdG8gb3ZlcnJpZGUgdGhlIHJlcXVlc3QgcmVnaW9uIHdpdGggdGhlIHJlZ2lvbiBpbmZlcnJlZFxuICogICAgIGZyb20gcmVxdWVzdGVkIHJlc291cmNlJ3MgQVJOLiBPbmx5IGF2YWlsYWJsZSBmb3IgUzMgYnVja2V0c1xuICogICAgIERlZmF1bHRzIHRvIGB0cnVlYFxuICpcbiAqIEAhYXR0cmlidXRlIHVzZUFjY2VsZXJhdGVFbmRwb2ludFxuICogICBAbm90ZSBUaGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIFMzIHdoaWxlIGFjY2Vzc2luZ1xuICogICAgIGRucy1jb21wYXRpYmxlIGJ1Y2tldHMuXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIFdoZXRoZXIgdG8gdXNlIHRoZSBBY2NlbGVyYXRlIGVuZHBvaW50IHdpdGggdGhlIFMzIHNlcnZpY2UuXG4gKiAgICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSByZXRyeURlbGF5T3B0aW9uc1xuICogICBAZXhhbXBsZSBTZXQgdGhlIGJhc2UgcmV0cnkgZGVsYXkgZm9yIGFsbCBzZXJ2aWNlcyB0byAzMDAgbXNcbiAqICAgICBBV1MuY29uZmlnLnVwZGF0ZSh7cmV0cnlEZWxheU9wdGlvbnM6IHtiYXNlOiAzMDB9fSk7XG4gKiAgICAgLy8gRGVsYXlzIHdpdGggbWF4UmV0cmllcyA9IDM6IDMwMCwgNjAwLCAxMjAwXG4gKiAgIEBleGFtcGxlIFNldCBhIGN1c3RvbSBiYWNrb2ZmIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGVsYXkgdmFsdWVzIG9uIHJldHJpZXNcbiAqICAgICBBV1MuY29uZmlnLnVwZGF0ZSh7cmV0cnlEZWxheU9wdGlvbnM6IHtjdXN0b21CYWNrb2ZmOiBmdW5jdGlvbihyZXRyeUNvdW50LCBlcnIpIHtcbiAqICAgICAgIC8vIHJldHVybnMgZGVsYXkgaW4gbXNcbiAqICAgICB9fX0pO1xuICogICBAcmV0dXJuIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSByZXRyeSBkZWxheSBvbiByZXRyeWFibGUgZXJyb3JzLlxuICogICAgIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogICAgICogKipiYXNlKiogW0ludGVnZXJdICZtZGFzaDsgVGhlIGJhc2UgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgaW4gdGhlXG4gKiAgICAgICBleHBvbmVudGlhbCBiYWNrb2ZmIGZvciBvcGVyYXRpb24gcmV0cmllcy4gRGVmYXVsdHMgdG8gMTAwIG1zIGZvciBhbGwgc2VydmljZXMgZXhjZXB0XG4gKiAgICAgICBEeW5hbW9EQiwgd2hlcmUgaXQgZGVmYXVsdHMgdG8gNTBtcy5cbiAqXG4gKiAgICAgKiAqKmN1c3RvbUJhY2tvZmYgKiogW2Z1bmN0aW9uXSAmbWRhc2g7IEEgY3VzdG9tIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhXG4gKiAgICAgICByZXRyeSBjb3VudCBhbmQgZXJyb3IgYW5kIHJldHVybnMgdGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGluXG4gKiAgICAgICBtaWxsaXNlY29uZHMuIElmIHRoZSByZXN1bHQgaXMgYSBub24temVybyBuZWdhdGl2ZSB2YWx1ZSwgbm8gZnVydGhlclxuICogICAgICAgcmV0cnkgYXR0ZW1wdHMgd2lsbCBiZSBtYWRlLiBUaGUgYGJhc2VgIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQgaWYgdGhpc1xuICogICAgICAgb3B0aW9uIGlzIHN1cHBsaWVkLiBUaGUgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgZm9yIHJldHJ5YWJsZSBlcnJvcnMuXG4gKlxuICogQCFhdHRyaWJ1dGUgaHR0cE9wdGlvbnNcbiAqICAgQHJldHVybiBbbWFwXSBBIHNldCBvZiBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIGxvdy1sZXZlbCBIVFRQIHJlcXVlc3QuXG4gKiAgICAgQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAgICAgKiAqKnByb3h5KiogW1N0cmluZ10gJm1kYXNoOyB0aGUgVVJMIHRvIHByb3h5IHJlcXVlc3RzIHRocm91Z2hcbiAqICAgICAqICoqYWdlbnQqKiBbaHR0cC5BZ2VudCwgaHR0cHMuQWdlbnRdICZtZGFzaDsgdGhlIEFnZW50IG9iamVjdCB0byBwZXJmb3JtXG4gKiAgICAgICBIVFRQIHJlcXVlc3RzIHdpdGguIFVzZWQgZm9yIGNvbm5lY3Rpb24gcG9vbGluZy4gTm90ZSB0aGF0IGZvclxuICogICAgICAgU1NMIGNvbm5lY3Rpb25zLCBhIHNwZWNpYWwgQWdlbnQgb2JqZWN0IGlzIHVzZWQgaW4gb3JkZXIgdG8gZW5hYmxlXG4gKiAgICAgICBwZWVyIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi4gVGhpcyBmZWF0dXJlIGlzIG9ubHkgc3VwcG9ydGVkIGluIHRoZVxuICogICAgICAgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqICAgICAqICoqY29ubmVjdFRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBTZXRzIHRoZSBzb2NrZXQgdG8gdGltZW91dCBhZnRlclxuICogICAgICAgZmFpbGluZyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlciBhZnRlclxuICogICAgICAgYGNvbm5lY3RUaW1lb3V0YCBtaWxsaXNlY29uZHMuIFRoaXMgdGltZW91dCBoYXMgbm8gZWZmZWN0IG9uY2UgYSBzb2NrZXRcbiAqICAgICAgIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQuXG4gKiAgICAgKiAqKnRpbWVvdXQqKiBbSW50ZWdlcl0gJm1kYXNoOyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHJlcXVlc3QgY2FuXG4gKiAgICAgICB0YWtlIGJlZm9yZSBhdXRvbWF0aWNhbGx5IGJlaW5nIHRlcm1pbmF0ZWQuXG4gKiAgICAgICBEZWZhdWx0cyB0byB0d28gbWludXRlcyAoMTIwMDAwKS5cbiAqICAgICAqICoqeGhyQXN5bmMqKiBbQm9vbGVhbl0gJm1kYXNoOyBXaGV0aGVyIHRoZSBTREsgd2lsbCBzZW5kIGFzeW5jaHJvbm91c1xuICogICAgICAgSFRUUCByZXF1ZXN0cy4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCBvbmx5LiBTZXQgdG8gZmFsc2UgdG9cbiAqICAgICAgIHNlbmQgcmVxdWVzdHMgc3luY2hyb25vdXNseS4gRGVmYXVsdHMgdG8gdHJ1ZSAoYXN5bmMgb24pLlxuICogICAgICogKip4aHJXaXRoQ3JlZGVudGlhbHMqKiBbQm9vbGVhbl0gJm1kYXNoOyBTZXRzIHRoZSBcIndpdGhDcmVkZW50aWFsc1wiXG4gKiAgICAgICBwcm9wZXJ0eSBvZiBhbiBYTUxIdHRwUmVxdWVzdCBvYmplY3QuIFVzZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqICAgICAgIG9ubHkuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQCFhdHRyaWJ1dGUgbG9nZ2VyXG4gKiAgIEByZXR1cm4gWyN3cml0ZSwjbG9nXSBhbiBvYmplY3QgdGhhdCByZXNwb25kcyB0byAud3JpdGUoKSAobGlrZSBhIHN0cmVhbSlcbiAqICAgICBvciAubG9nKCkgKGxpa2UgdGhlIGNvbnNvbGUgb2JqZWN0KSBpbiBvcmRlciB0byBsb2cgaW5mb3JtYXRpb24gYWJvdXRcbiAqICAgICByZXF1ZXN0c1xuICpcbiAqIEAhYXR0cmlidXRlIHN5c3RlbUNsb2NrT2Zmc2V0XG4gKiAgIEByZXR1cm4gW051bWJlcl0gYW4gb2Zmc2V0IHZhbHVlIGluIG1pbGxpc2Vjb25kcyB0byBhcHBseSB0byBhbGwgc2lnbmluZ1xuICogICAgIHRpbWVzLiBVc2UgdGhpcyB0byBjb21wZW5zYXRlIGZvciBjbG9jayBza2V3IHdoZW4geW91ciBzeXN0ZW0gbWF5IGJlXG4gKiAgICAgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmljZSB0aW1lLiBOb3RlIHRoYXQgdGhpcyBjb25maWd1cmF0aW9uIG9wdGlvblxuICogICAgIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGdsb2JhbCBgQVdTLmNvbmZpZ2Agb2JqZWN0IGFuZCBjYW5ub3QgYmVcbiAqICAgICBvdmVycmlkZGVuIGluIHNlcnZpY2Utc3BlY2lmaWMgY29uZmlndXJhdGlvbi4gRGVmYXVsdHMgdG8gMCBtaWxsaXNlY29uZHMuXG4gKlxuICogQCFhdHRyaWJ1dGUgc2lnbmF0dXJlVmVyc2lvblxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBzaWduYXR1cmUgdmVyc2lvbiB0byBzaWduIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmdcbiAqICAgICB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiAndjInLCAndjMnLCAndjQnLlxuICpcbiAqIEAhYXR0cmlidXRlIHNpZ25hdHVyZUNhY2hlXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHNpZ25hdHVyZSB0byBzaWduIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmdcbiAqICAgICB0aGUgQVBJIGNvbmZpZ3VyYXRpb24pIGlzIGNhY2hlZC4gT25seSBhcHBsaWVzIHRvIHRoZSBzaWduYXR1cmUgdmVyc2lvbiAndjQnLlxuICogICAgIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbnx1bmRlZmluZWRdIHdoZXRoZXIgdG8gY2FsbCBvcGVyYXRpb25zIHdpdGggZW5kcG9pbnRzXG4gKiAgICAgZ2l2ZW4gYnkgc2VydmljZSBkeW5hbWljYWxseS4gU2V0dGluZyB0aGlzIGNvbmZpZyB0byBgdHJ1ZWAgd2lsbCBlbmFibGVcbiAqICAgICBlbmRwb2ludCBkaXNjb3ZlcnkgZm9yIGFsbCBhcHBsaWNhYmxlIG9wZXJhdGlvbnMuIFNldHRpbmcgaXQgdG8gYGZhbHNlYFxuICogICAgIHdpbGwgZXhwbGljaXRseSBkaXNhYmxlIGVuZHBvaW50IGRpc2NvdmVyeSBldmVuIHRob3VnaCBvcGVyYXRpb25zIHRoYXRcbiAqICAgICByZXF1aXJlIGVuZHBvaW50IGRpc2NvdmVyeSB3aWxsIHByZXN1bWFibHkgZmFpbC4gTGVhdmluZyBpdCB0b1xuICogICAgIGB1bmRlZmluZWRgIG1lYW5zIFNESyBvbmx5IGRvIGVuZHBvaW50IGRpc2NvdmVyeSB3aGVuIGl0J3MgcmVxdWlyZWQuXG4gKiAgICAgRGVmYXVsdHMgdG8gYHVuZGVmaW5lZGBcbiAqXG4gKiBAIWF0dHJpYnV0ZSBlbmRwb2ludENhY2hlU2l6ZVxuICogICBAcmV0dXJuIFtOdW1iZXJdIHRoZSBzaXplIG9mIHRoZSBnbG9iYWwgY2FjaGUgc3RvcmluZyBlbmRwb2ludHMgZnJvbSBlbmRwb2ludFxuICogICAgIGRpc2NvdmVyeSBvcGVyYXRpb25zLiBPbmNlIGVuZHBvaW50IGNhY2hlIGlzIGNyZWF0ZWQsIHVwZGF0aW5nIHRoaXMgc2V0dGluZ1xuICogICAgIGNhbm5vdCBjaGFuZ2UgZXhpc3RpbmcgY2FjaGUgc2l6ZS5cbiAqICAgICBEZWZhdWx0cyB0byAxMDAwXG4gKlxuICogQCFhdHRyaWJ1dGUgaG9zdFByZWZpeEVuYWJsZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBtYXJzaGFsIHJlcXVlc3QgcGFyYW1ldGVycyB0byB0aGUgcHJlZml4IG9mXG4gKiAgICAgaG9zdG5hbWUuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBzdHNSZWdpb25hbEVuZHBvaW50c1xuICogICBAcmV0dXJuIFsnbGVnYWN5J3wncmVnaW9uYWwnXSB3aGV0aGVyIHRvIHNlbmQgc3RzIHJlcXVlc3QgdG8gZ2xvYmFsIGVuZHBvaW50cyBvclxuICogICAgIHJlZ2lvbmFsIGVuZHBvaW50cy5cbiAqICAgICBEZWZhdWx0cyB0byAnbGVnYWN5Jy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSB1c2VGaXBzRW5kcG9pbnRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gRW5hYmxlcyBGSVBTIGNvbXBhdGlibGUgZW5kcG9pbnRzLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICpcbiAqIEAhYXR0cmlidXRlIHVzZUR1YWxzdGFja0VuZHBvaW50XG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIEVuYWJsZXMgSVB2NiBkdWFsc3RhY2sgZW5kcG9pbnQuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKi9cbkFXUy5Db25maWcgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIEAhZW5kZ3JvdXBcbiAgICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QuIFRoaXMgaXMgdGhlIG9iamVjdCB0aGF0IHBhc3Nlc1xuICAgKiBvcHRpb24gZGF0YSBhbG9uZyB0byBzZXJ2aWNlIHJlcXVlc3RzLCBpbmNsdWRpbmcgY3JlZGVudGlhbHMsIHNlY3VyaXR5LFxuICAgKiByZWdpb24gaW5mb3JtYXRpb24sIGFuZCBzb21lIHNlcnZpY2Ugc3BlY2lmaWMgc2V0dGluZ3MuXG4gICAqXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggY3JlZGVudGlhbHMgYW5kIHJlZ2lvblxuICAgKiAgIHZhciBjb25maWcgPSBuZXcgQVdTLkNvbmZpZyh7XG4gICAqICAgICBhY2Nlc3NLZXlJZDogJ0FLSUQnLCBzZWNyZXRBY2Nlc3NLZXk6ICdTRUNSRVQnLCByZWdpb246ICd1cy13ZXN0LTInXG4gICAqICAgfSk7XG4gICAqIEBvcHRpb24gb3B0aW9ucyBhY2Nlc3NLZXlJZCBbU3RyaW5nXSB5b3VyIEFXUyBhY2Nlc3Mga2V5IElELlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2VjcmV0QWNjZXNzS2V5IFtTdHJpbmddIHlvdXIgQVdTIHNlY3JldCBhY2Nlc3Mga2V5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2Vzc2lvblRva2VuIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBvcHRpb25hbCBBV1NcbiAgICogICBzZXNzaW9uIHRva2VuIHRvIHNpZ24gcmVxdWVzdHMgd2l0aC5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBBV1MgY3JlZGVudGlhbHNcbiAgICogICB0byBzaWduIHJlcXVlc3RzIHdpdGguIFlvdSBjYW4gZWl0aGVyIHNwZWNpZnkgdGhpcyBvYmplY3QsIG9yXG4gICAqICAgc3BlY2lmeSB0aGUgYWNjZXNzS2V5SWQgYW5kIHNlY3JldEFjY2Vzc0tleSBvcHRpb25zIGRpcmVjdGx5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY3JlZGVudGlhbFByb3ZpZGVyIFtBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW5dIHRoZVxuICAgKiAgIHByb3ZpZGVyIGNoYWluIHVzZWQgdG8gcmVzb2x2ZSBjcmVkZW50aWFscyBpZiBubyBzdGF0aWMgYGNyZWRlbnRpYWxzYFxuICAgKiAgIHByb3BlcnR5IGlzIHNldC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHJlZ2lvbiBbU3RyaW5nXSB0aGUgcmVnaW9uIHRvIHNlbmQgc2VydmljZSByZXF1ZXN0cyB0by5cbiAgICogICBTZWUge3JlZ2lvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXhSZXRyaWVzIFtJbnRlZ2VyXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgcmV0cmllcyB0b1xuICAgKiAgIGF0dGVtcHQgd2l0aCBhIHJlcXVlc3QuIFNlZSB7bWF4UmV0cmllc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBtYXhSZWRpcmVjdHMgW0ludGVnZXJdIHRoZSBtYXhpbXVtIGFtb3VudCBvZiByZWRpcmVjdHMgdG9cbiAgICogICBmb2xsb3cgd2l0aCBhIHJlcXVlc3QuIFNlZSB7bWF4UmVkaXJlY3RzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNzbEVuYWJsZWQgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gZW5hYmxlIFNTTCBmb3JcbiAgICogICByZXF1ZXN0cy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHBhcmFtVmFsaWRhdGlvbiBbQm9vbGVhbnxtYXBdIHdoZXRoZXIgaW5wdXQgcGFyYW1ldGVyc1xuICAgKiAgIHNob3VsZCBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nXG4gICAqICAgdGhlIHJlcXVlc3QuIERlZmF1bHRzIHRvIHRydWUuIFBhc3MgYSBtYXAgdG8gZW5hYmxlIGFueSBvZiB0aGVcbiAgICogICBmb2xsb3dpbmcgc3BlY2lmaWMgdmFsaWRhdGlvbiBmZWF0dXJlczpcbiAgICpcbiAgICogICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gICAqICAgICBjb25zdHJhaW50LiBUaGlzIGlzIGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIHBhcmFtVmFsaWRhdGlvbiBpcyBzZXRcbiAgICogICAgIHRvIGB0cnVlYC5cbiAgICogICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gICAqICAgICBjb25zdHJhaW50LlxuICAgKiAgICogKipwYXR0ZXJuKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSBzdHJpbmcgdmFsdWUgbWF0Y2hlcyBhXG4gICAqICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqICAgKiAqKmVudW0qKiBbQm9vbGVhbl0gJm1kYXNoOyBWYWxpZGF0ZXMgdGhhdCBhIHN0cmluZyB2YWx1ZSBtYXRjaGVzIG9uZVxuICAgKiAgICAgb2YgdGhlIGFsbG93YWJsZSBlbnVtIHZhbHVlcy5cbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbXB1dGVDaGVja3N1bXMgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gY29tcHV0ZSBjaGVja3N1bXNcbiAgICogICBmb3IgcGF5bG9hZCBib2RpZXMgd2hlbiB0aGUgc2VydmljZSBhY2NlcHRzIGl0IChjdXJyZW50bHkgc3VwcG9ydGVkXG4gICAqICAgaW4gUzMgb25seSlcbiAgICogQG9wdGlvbiBvcHRpb25zIGNvbnZlcnRSZXNwb25zZVR5cGVzIFtCb29sZWFuXSB3aGV0aGVyIHR5cGVzIGFyZSBjb252ZXJ0ZWRcbiAgICogICAgIHdoZW4gcGFyc2luZyByZXNwb25zZSBkYXRhLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgZm9yIEpTT04gYmFzZWRcbiAgICogICAgIHNlcnZpY2VzLiBUdXJuaW5nIHRoaXMgb2ZmIG1heSBpbXByb3ZlIHBlcmZvcm1hbmNlIG9uIGxhcmdlIHJlc3BvbnNlXG4gICAqICAgICBwYXlsb2Fkcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY29ycmVjdENsb2NrU2tldyBbQm9vbGVhbl0gd2hldGhlciB0byBhcHBseSBhIGNsb2NrIHNrZXdcbiAgICogICAgIGNvcnJlY3Rpb24gYW5kIHJldHJ5IHJlcXVlc3RzIHRoYXQgZmFpbCBiZWNhdXNlIG9mIGFuIHNrZXdlZCBjbGllbnRcbiAgICogICAgIGNsb2NrLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNGb3JjZVBhdGhTdHlsZSBbQm9vbGVhbl0gd2hldGhlciB0byBmb3JjZSBwYXRoXG4gICAqICAgc3R5bGUgVVJMcyBmb3IgUzMgb2JqZWN0cy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHMzQnVja2V0RW5kcG9pbnQgW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVuZHBvaW50XG4gICAqICAgYWRkcmVzc2VzIGFuIGluZGl2aWR1YWwgYnVja2V0IChmYWxzZSBpZiBpdCBhZGRyZXNzZXMgdGhlIHJvb3QgQVBJXG4gICAqICAgZW5kcG9pbnQpLiBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHJlcXVpcmVzIGFuXG4gICAqICAgYGVuZHBvaW50YCB0byBiZSBwcm92aWRlZCBleHBsaWNpdGx5IHRvIHRoZSBzZXJ2aWNlIGNvbnN0cnVjdG9yLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNEaXNhYmxlQm9keVNpZ25pbmcgW0Jvb2xlYW5dIHdoZXRoZXIgUzMgYm9keSBzaWduaW5nXG4gICAqICAgc2hvdWxkIGJlIGRpc2FibGVkIHdoZW4gdXNpbmcgc2lnbmF0dXJlIHZlcnNpb24gYHY0YC4gQm9keSBzaWduaW5nXG4gICAqICAgY2FuIG9ubHkgYmUgZGlzYWJsZWQgd2hlbiB1c2luZyBodHRwcy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgczNVc0Vhc3QxUmVnaW9uYWxFbmRwb2ludCBbJ2xlZ2FjeSd8J3JlZ2lvbmFsJ10gd2hlbiByZWdpb25cbiAgICogICBpcyBzZXQgdG8gJ3VzLWVhc3QtMScsIHdoZXRoZXIgdG8gc2VuZCBzMyByZXF1ZXN0IHRvIGdsb2JhbCBlbmRwb2ludHMgb3JcbiAgICogICAndXMtZWFzdC0xJyByZWdpb25hbCBlbmRwb2ludHMuIFRoaXMgY29uZmlnIGlzIG9ubHkgYXBwbGljYWJsZSB0byBTMyBjbGllbnQuXG4gICAqICAgRGVmYXVsdHMgdG8gYGxlZ2FjeWBcbiAgICogQG9wdGlvbiBvcHRpb25zIHMzVXNlQXJuUmVnaW9uIFtCb29sZWFuXSB3aGV0aGVyIHRvIG92ZXJyaWRlIHRoZSByZXF1ZXN0IHJlZ2lvblxuICAgKiAgIHdpdGggdGhlIHJlZ2lvbiBpbmZlcnJlZCBmcm9tIHJlcXVlc3RlZCByZXNvdXJjZSdzIEFSTi4gT25seSBhdmFpbGFibGUgZm9yIFMzIGJ1Y2tldHNcbiAgICogICBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAgICpcbiAgICogQG9wdGlvbiBvcHRpb25zIHJldHJ5RGVsYXlPcHRpb25zIFttYXBdIEEgc2V0IG9mIG9wdGlvbnMgdG8gY29uZmlndXJlXG4gICAqICAgdGhlIHJldHJ5IGRlbGF5IG9uIHJldHJ5YWJsZSBlcnJvcnMuIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgKiAqKmJhc2UqKiBbSW50ZWdlcl0gJm1kYXNoOyBUaGUgYmFzZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBpbiB0aGVcbiAgICogICAgIGV4cG9uZW50aWFsIGJhY2tvZmYgZm9yIG9wZXJhdGlvbiByZXRyaWVzLiBEZWZhdWx0cyB0byAxMDAgbXMgZm9yIGFsbFxuICAgKiAgICAgc2VydmljZXMgZXhjZXB0IER5bmFtb0RCLCB3aGVyZSBpdCBkZWZhdWx0cyB0byA1MG1zLlxuICAgKiAgICogKipjdXN0b21CYWNrb2ZmICoqIFtmdW5jdGlvbl0gJm1kYXNoOyBBIGN1c3RvbSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYVxuICAgKiAgICAgcmV0cnkgY291bnQgYW5kIGVycm9yIGFuZCByZXR1cm5zIHRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSBpblxuICAgKiAgICAgbWlsbGlzZWNvbmRzLiBJZiB0aGUgcmVzdWx0IGlzIGEgbm9uLXplcm8gbmVnYXRpdmUgdmFsdWUsIG5vIGZ1cnRoZXJcbiAgICogICAgIHJldHJ5IGF0dGVtcHRzIHdpbGwgYmUgbWFkZS4gVGhlIGBiYXNlYCBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIGlmIHRoaXNcbiAgICogICAgIG9wdGlvbiBpcyBzdXBwbGllZC4gVGhlIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGZvciByZXRyeWFibGUgZXJyb3JzLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgaHR0cE9wdGlvbnMgW21hcF0gQSBzZXQgb2Ygb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBsb3ctbGV2ZWxcbiAgICogICBIVFRQIHJlcXVlc3QuIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAqXG4gICAqICAgKiAqKnByb3h5KiogW1N0cmluZ10gJm1kYXNoOyB0aGUgVVJMIHRvIHByb3h5IHJlcXVlc3RzIHRocm91Z2hcbiAgICogICAqICoqYWdlbnQqKiBbaHR0cC5BZ2VudCwgaHR0cHMuQWdlbnRdICZtZGFzaDsgdGhlIEFnZW50IG9iamVjdCB0byBwZXJmb3JtXG4gICAqICAgICBIVFRQIHJlcXVlc3RzIHdpdGguIFVzZWQgZm9yIGNvbm5lY3Rpb24gcG9vbGluZy4gRGVmYXVsdHMgdG8gdGhlIGdsb2JhbFxuICAgKiAgICAgYWdlbnQgKGBodHRwLmdsb2JhbEFnZW50YCkgZm9yIG5vbi1TU0wgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBmb3JcbiAgICogICAgIFNTTCBjb25uZWN0aW9ucywgYSBzcGVjaWFsIEFnZW50IG9iamVjdCBpcyB1c2VkIGluIG9yZGVyIHRvIGVuYWJsZVxuICAgKiAgICAgcGVlciBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb24uIFRoaXMgZmVhdHVyZSBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGVcbiAgICogICAgIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAqICAgKiAqKmNvbm5lY3RUaW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXJcbiAgICogICAgIGZhaWxpbmcgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIgYWZ0ZXJcbiAgICogICAgIGBjb25uZWN0VGltZW91dGAgbWlsbGlzZWNvbmRzLiBUaGlzIHRpbWVvdXQgaGFzIG5vIGVmZmVjdCBvbmNlIGEgc29ja2V0XG4gICAqICAgICBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgKiAgICogKip0aW1lb3V0KiogW0ludGVnZXJdICZtZGFzaDsgU2V0cyB0aGUgc29ja2V0IHRvIHRpbWVvdXQgYWZ0ZXIgdGltZW91dFxuICAgKiAgICAgbWlsbGlzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gdGhlIHNvY2tldC4gRGVmYXVsdHMgdG8gdHdvIG1pbnV0ZXNcbiAgICogICAgICgxMjAwMDApLlxuICAgKiAgICogKip4aHJBc3luYyoqIFtCb29sZWFuXSAmbWRhc2g7IFdoZXRoZXIgdGhlIFNESyB3aWxsIHNlbmQgYXN5bmNocm9ub3VzXG4gICAqICAgICBIVFRQIHJlcXVlc3RzLiBVc2VkIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9ubHkuIFNldCB0byBmYWxzZSB0b1xuICAgKiAgICAgc2VuZCByZXF1ZXN0cyBzeW5jaHJvbm91c2x5LiBEZWZhdWx0cyB0byB0cnVlIChhc3luYyBvbikuXG4gICAqICAgKiAqKnhocldpdGhDcmVkZW50aWFscyoqIFtCb29sZWFuXSAmbWRhc2g7IFNldHMgdGhlIFwid2l0aENyZWRlbnRpYWxzXCJcbiAgICogICAgIHByb3BlcnR5IG9mIGFuIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC4gVXNlZCBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgKiAgICAgb25seS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBhcGlWZXJzaW9uIFtTdHJpbmcsIERhdGVdIGEgU3RyaW5nIGluIFlZWVktTU0tREQgZm9ybWF0XG4gICAqICAgKG9yIGEgZGF0ZSkgdGhhdCByZXByZXNlbnRzIHRoZSBsYXRlc3QgcG9zc2libGUgQVBJIHZlcnNpb24gdGhhdCBjYW4gYmVcbiAgICogICB1c2VkIGluIGFsbCBzZXJ2aWNlcyAodW5sZXNzIG92ZXJyaWRkZW4gYnkgYGFwaVZlcnNpb25zYCkuIFNwZWNpZnlcbiAgICogICAnbGF0ZXN0JyB0byB1c2UgdGhlIGxhdGVzdCBwb3NzaWJsZSB2ZXJzaW9uLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgYXBpVmVyc2lvbnMgW21hcDxTdHJpbmcsIFN0cmluZ3xEYXRlPl0gYSBtYXAgb2Ygc2VydmljZVxuICAgKiAgIGlkZW50aWZpZXJzICh0aGUgbG93ZXJjYXNlIHNlcnZpY2UgY2xhc3MgbmFtZSkgd2l0aCB0aGUgQVBJIHZlcnNpb24gdG9cbiAgICogICB1c2Ugd2hlbiBpbnN0YW50aWF0aW5nIGEgc2VydmljZS4gU3BlY2lmeSAnbGF0ZXN0JyBmb3IgZWFjaCBpbmRpdmlkdWFsXG4gICAqICAgdGhhdCBjYW4gdXNlIHRoZSBsYXRlc3QgYXZhaWxhYmxlIHZlcnNpb24uXG4gICAqIEBvcHRpb24gb3B0aW9ucyBsb2dnZXIgWyN3cml0ZSwjbG9nXSBhbiBvYmplY3QgdGhhdCByZXNwb25kcyB0byAud3JpdGUoKVxuICAgKiAgIChsaWtlIGEgc3RyZWFtKSBvciAubG9nKCkgKGxpa2UgdGhlIGNvbnNvbGUgb2JqZWN0KSBpbiBvcmRlciB0byBsb2dcbiAgICogICBpbmZvcm1hdGlvbiBhYm91dCByZXF1ZXN0c1xuICAgKiBAb3B0aW9uIG9wdGlvbnMgc3lzdGVtQ2xvY2tPZmZzZXQgW051bWJlcl0gYW4gb2Zmc2V0IHZhbHVlIGluIG1pbGxpc2Vjb25kc1xuICAgKiAgIHRvIGFwcGx5IHRvIGFsbCBzaWduaW5nIHRpbWVzLiBVc2UgdGhpcyB0byBjb21wZW5zYXRlIGZvciBjbG9jayBza2V3XG4gICAqICAgd2hlbiB5b3VyIHN5c3RlbSBtYXkgYmUgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmljZSB0aW1lLiBOb3RlIHRoYXRcbiAgICogICB0aGlzIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGdsb2JhbCBgQVdTLmNvbmZpZ2BcbiAgICogICBvYmplY3QgYW5kIGNhbm5vdCBiZSBvdmVycmlkZGVuIGluIHNlcnZpY2Utc3BlY2lmaWMgY29uZmlndXJhdGlvbi5cbiAgICogICBEZWZhdWx0cyB0byAwIG1pbGxpc2Vjb25kcy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNpZ25hdHVyZVZlcnNpb24gW1N0cmluZ10gdGhlIHNpZ25hdHVyZSB2ZXJzaW9uIHRvIHNpZ25cbiAgICogICByZXF1ZXN0cyB3aXRoIChvdmVycmlkaW5nIHRoZSBBUEkgY29uZmlndXJhdGlvbikuIFBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAqICAgJ3YyJywgJ3YzJywgJ3Y0Jy5cbiAgICogQG9wdGlvbiBvcHRpb25zIHNpZ25hdHVyZUNhY2hlIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBzaWduYXR1cmUgdG8gc2lnblxuICAgKiAgIHJlcXVlc3RzIHdpdGggKG92ZXJyaWRpbmcgdGhlIEFQSSBjb25maWd1cmF0aW9uKSBpcyBjYWNoZWQuIE9ubHkgYXBwbGllc1xuICAgKiAgIHRvIHRoZSBzaWduYXR1cmUgdmVyc2lvbiAndjQnLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBkeW5hbW9EYkNyYzMyIFtCb29sZWFuXSB3aGV0aGVyIHRvIHZhbGlkYXRlIHRoZSBDUkMzMlxuICAgKiAgIGNoZWNrc3VtIG9mIEhUVFAgcmVzcG9uc2UgYm9kaWVzIHJldHVybmVkIGJ5IER5bmFtb0RCLiBEZWZhdWx0OiBgdHJ1ZWAuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB1c2VBY2NlbGVyYXRlRW5kcG9pbnQgW0Jvb2xlYW5dIFdoZXRoZXIgdG8gdXNlIHRoZVxuICAgKiAgIFMzIFRyYW5zZmVyIEFjY2VsZXJhdGlvbiBlbmRwb2ludCB3aXRoIHRoZSBTMyBzZXJ2aWNlLiBEZWZhdWx0OiBgZmFsc2VgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgY2xpZW50U2lkZU1vbml0b3JpbmcgW0Jvb2xlYW5dIHdoZXRoZXIgdG8gY29sbGVjdCBhbmRcbiAgICogICBwdWJsaXNoIHRoaXMgY2xpZW50J3MgcGVyZm9ybWFuY2UgbWV0cmljcyBvZiBhbGwgaXRzIEFQSSByZXF1ZXN0cy5cbiAgICogQG9wdGlvbiBvcHRpb25zIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZCBbQm9vbGVhbnx1bmRlZmluZWRdIHdoZXRoZXIgdG9cbiAgICogICBjYWxsIG9wZXJhdGlvbnMgd2l0aCBlbmRwb2ludHMgZ2l2ZW4gYnkgc2VydmljZSBkeW5hbWljYWxseS4gU2V0dGluZyB0aGlzXG4gICAqIGNvbmZpZyB0byBgdHJ1ZWAgd2lsbCBlbmFibGUgZW5kcG9pbnQgZGlzY292ZXJ5IGZvciBhbGwgYXBwbGljYWJsZSBvcGVyYXRpb25zLlxuICAgKiAgIFNldHRpbmcgaXQgdG8gYGZhbHNlYCB3aWxsIGV4cGxpY2l0bHkgZGlzYWJsZSBlbmRwb2ludCBkaXNjb3ZlcnkgZXZlbiB0aG91Z2hcbiAgICogICBvcGVyYXRpb25zIHRoYXQgcmVxdWlyZSBlbmRwb2ludCBkaXNjb3Zlcnkgd2lsbCBwcmVzdW1hYmx5IGZhaWwuIExlYXZpbmcgaXRcbiAgICogICB0byBgdW5kZWZpbmVkYCBtZWFucyBTREsgd2lsbCBvbmx5IGRvIGVuZHBvaW50IGRpc2NvdmVyeSB3aGVuIGl0J3MgcmVxdWlyZWQuXG4gICAqICAgRGVmYXVsdHMgdG8gYHVuZGVmaW5lZGBcbiAgICogQG9wdGlvbiBvcHRpb25zIGVuZHBvaW50Q2FjaGVTaXplIFtOdW1iZXJdIHRoZSBzaXplIG9mIHRoZSBnbG9iYWwgY2FjaGUgc3RvcmluZ1xuICAgKiAgIGVuZHBvaW50cyBmcm9tIGVuZHBvaW50IGRpc2NvdmVyeSBvcGVyYXRpb25zLiBPbmNlIGVuZHBvaW50IGNhY2hlIGlzIGNyZWF0ZWQsXG4gICAqICAgdXBkYXRpbmcgdGhpcyBzZXR0aW5nIGNhbm5vdCBjaGFuZ2UgZXhpc3RpbmcgY2FjaGUgc2l6ZS5cbiAgICogICBEZWZhdWx0cyB0byAxMDAwXG4gICAqIEBvcHRpb24gb3B0aW9ucyBob3N0UHJlZml4RW5hYmxlZCBbQm9vbGVhbl0gd2hldGhlciB0byBtYXJzaGFsIHJlcXVlc3RcbiAgICogICBwYXJhbWV0ZXJzIHRvIHRoZSBwcmVmaXggb2YgaG9zdG5hbWUuXG4gICAqICAgRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc3RzUmVnaW9uYWxFbmRwb2ludHMgWydsZWdhY3knfCdyZWdpb25hbCddIHdoZXRoZXIgdG8gc2VuZCBzdHMgcmVxdWVzdFxuICAgKiAgIHRvIGdsb2JhbCBlbmRwb2ludHMgb3IgcmVnaW9uYWwgZW5kcG9pbnRzLlxuICAgKiAgIERlZmF1bHRzIHRvICdsZWdhY3knLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgdXNlRmlwc0VuZHBvaW50IFtCb29sZWFuXSBFbmFibGVzIEZJUFMgY29tcGF0aWJsZSBlbmRwb2ludHMuXG4gICAqICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICogQG9wdGlvbiBvcHRpb25zIHVzZUR1YWxzdGFja0VuZHBvaW50IFtCb29sZWFuXSBFbmFibGVzIElQdjYgZHVhbHN0YWNrIGVuZHBvaW50LlxuICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ29uZmlnKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XG4gICAgb3B0aW9ucyA9IHRoaXMuZXh0cmFjdENyZWRlbnRpYWxzKG9wdGlvbnMpO1xuXG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMua2V5cywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgb3B0aW9uc1trZXldLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhZ3JvdXAgTWFuYWdpbmcgQ3JlZGVudGlhbHNcbiAgICovXG5cbiAgLyoqXG4gICAqIExvYWRzIGNyZWRlbnRpYWxzIGZyb20gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LiBUaGlzIGlzIHVzZWQgaW50ZXJuYWxseVxuICAgKiBieSB0aGUgU0RLIHRvIGVuc3VyZSB0aGF0IHJlZnJlc2hhYmxlIHtDcmVkZW50aWFsc30gb2JqZWN0cyBhcmUgcHJvcGVybHlcbiAgICogcmVmcmVzaGVkIGFuZCBsb2FkZWQgd2hlbiBzZW5kaW5nIGEgcmVxdWVzdC4gSWYgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXRcbiAgICogeW91ciBjcmVkZW50aWFscyBhcmUgbG9hZGVkIHByaW9yIHRvIGEgcmVxdWVzdCwgeW91IGNhbiB1c2UgdGhpcyBtZXRob2RcbiAgICogZGlyZWN0bHkgdG8gcHJvdmlkZSBhY2N1cmF0ZSBjcmVkZW50aWFsIGRhdGEgc3RvcmVkIGluIHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBub3RlIElmIHlvdSBjb25maWd1cmUgdGhlIFNESyB3aXRoIHN0YXRpYyBvciBlbnZpcm9ubWVudCBjcmVkZW50aWFscyxcbiAgICogICB0aGUgY3JlZGVudGlhbCBkYXRhIHNob3VsZCBhbHJlYWR5IGJlIHByZXNlbnQgaW4ge2NyZWRlbnRpYWxzfSBhdHRyaWJ1dGUuXG4gICAqICAgVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IG5lY2Vzc2FyeSB0byBsb2FkIGNyZWRlbnRpYWxzIGZyb20gYXN5bmNocm9ub3VzXG4gICAqICAgc291cmNlcywgb3Igc291cmNlcyB0aGF0IGNhbiByZWZyZXNoIGNyZWRlbnRpYWxzIHBlcmlvZGljYWxseS5cbiAgICogQGV4YW1wbGUgR2V0dGluZyB5b3VyIGFjY2VzcyBrZXlcbiAgICogICBBV1MuY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uKGVycikge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coZXJyLnN0YWNrKTsgLy8gY3JlZGVudGlhbHMgbm90IGxvYWRlZFxuICAgKiAgICAgZWxzZSBjb25zb2xlLmxvZyhcIkFjY2VzcyBLZXk6XCIsIEFXUy5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQpO1xuICAgKiAgIH0pXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIHtjcmVkZW50aWFsc30gaGF2ZSBiZWVuIHByb3Blcmx5IHNldCBvbiB0aGUgY29uZmlndXJhdGlvblxuICAgKiAgIG9iamVjdC5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgdGhpcyBpcyBzZXQsIGNyZWRlbnRpYWxzIHdlcmUgbm90IHN1Y2Nlc3NmdWxseVxuICAgKiAgICAgbG9hZGVkIGFuZCB0aGlzIGVycm9yIHByb3ZpZGVzIGluZm9ybWF0aW9uIHdoeS5cbiAgICogQHNlZSBjcmVkZW50aWFsc1xuICAgKiBAc2VlIENyZWRlbnRpYWxzXG4gICAqL1xuICBnZXRDcmVkZW50aWFsczogZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIGVyciA/IG51bGwgOiBzZWxmLmNyZWRlbnRpYWxzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVkRXJyb3IobXNnLCBlcnIpIHtcbiAgICAgIHJldHVybiBuZXcgQVdTLnV0aWwuZXJyb3IoZXJyIHx8IG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdDcmVkZW50aWFsc0Vycm9yJyxcbiAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICBuYW1lOiAnQ3JlZGVudGlhbHNFcnJvcidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFzeW5jQ3JlZGVudGlhbHMoKSB7XG4gICAgICBzZWxmLmNyZWRlbnRpYWxzLmdldChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHZhciBtc2cgPSAnQ291bGQgbm90IGxvYWQgY3JlZGVudGlhbHMgZnJvbSAnICtcbiAgICAgICAgICAgIHNlbGYuY3JlZGVudGlhbHMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICBlcnIgPSBjcmVkRXJyb3IobXNnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdGljQ3JlZGVudGlhbHMoKSB7XG4gICAgICB2YXIgZXJyID0gbnVsbDtcbiAgICAgIGlmICghc2VsZi5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCB8fCAhc2VsZi5jcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkpIHtcbiAgICAgICAgZXJyID0gY3JlZEVycm9yKCdNaXNzaW5nIGNyZWRlbnRpYWxzJyk7XG4gICAgICB9XG4gICAgICBmaW5pc2goZXJyKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5jcmVkZW50aWFscykge1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLmNyZWRlbnRpYWxzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBnZXRBc3luY0NyZWRlbnRpYWxzKCk7XG4gICAgICB9IGVsc2UgeyAvLyBzdGF0aWMgY3JlZGVudGlhbHNcbiAgICAgICAgZ2V0U3RhdGljQ3JlZGVudGlhbHMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNlbGYuY3JlZGVudGlhbFByb3ZpZGVyKSB7XG4gICAgICBzZWxmLmNyZWRlbnRpYWxQcm92aWRlci5yZXNvbHZlKGZ1bmN0aW9uKGVyciwgY3JlZHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGVyciA9IGNyZWRFcnJvcignQ291bGQgbm90IGxvYWQgY3JlZGVudGlhbHMgZnJvbSBhbnkgcHJvdmlkZXJzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmNyZWRlbnRpYWxzID0gY3JlZHM7XG4gICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaChjcmVkRXJyb3IoJ05vIGNyZWRlbnRpYWxzIHRvIGxvYWQnKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyB0b2tlbiBmcm9tIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHlcbiAgICogYnkgdGhlIFNESyB0byBlbnN1cmUgdGhhdCByZWZyZXNoYWJsZSB7VG9rZW59IG9iamVjdHMgYXJlIHByb3Blcmx5XG4gICAqIHJlZnJlc2hlZCBhbmQgbG9hZGVkIHdoZW4gc2VuZGluZyBhIHJlcXVlc3QuIElmIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0XG4gICAqIHlvdXIgdG9rZW4gaXMgbG9hZGVkIHByaW9yIHRvIGEgcmVxdWVzdCwgeW91IGNhbiB1c2UgdGhpcyBtZXRob2RcbiAgICogZGlyZWN0bHkgdG8gcHJvdmlkZSBhY2N1cmF0ZSB0b2tlbiBkYXRhIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBJZiB5b3UgY29uZmlndXJlIHRoZSBTREsgd2l0aCBzdGF0aWMgdG9rZW4sIHRoZSB0b2tlbiBkYXRhIHNob3VsZFxuICAgKiAgIGFscmVhZHkgYmUgcHJlc2VudCBpbiB7dG9rZW59IGF0dHJpYnV0ZS4gVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IG5lY2Vzc2FyeVxuICAgKiAgIHRvIGxvYWQgdG9rZW4gZnJvbSBhc3luY2hyb25vdXMgc291cmNlcywgb3Igc291cmNlcyB0aGF0IGNhbiByZWZyZXNoXG4gICAqICAgdG9rZW4gcGVyaW9kaWNhbGx5LlxuICAgKiBAZXhhbXBsZSBHZXR0aW5nIHlvdXIgYWNjZXNzIHRva2VuXG4gICAqICAgQVdTLmNvbmZpZy5nZXRUb2tlbihmdW5jdGlvbihlcnIpIHtcbiAgICogICAgIGlmIChlcnIpIGNvbnNvbGUubG9nKGVyci5zdGFjayk7IC8vIHRva2VuIG5vdCBsb2FkZWRcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coXCJUb2tlbjpcIiwgQVdTLmNvbmZpZy50b2tlbi50b2tlbik7XG4gICAqICAgfSlcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUge3Rva2VufSBoYXZlIGJlZW4gcHJvcGVybHkgc2V0IG9uIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgdGhpcyBpcyBzZXQsIHRva2VuIHdhcyBub3Qgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBhbmRcbiAgICogICAgIHRoaXMgZXJyb3IgcHJvdmlkZXMgaW5mb3JtYXRpb24gd2h5LlxuICAgKiBAc2VlIHRva2VuXG4gICAqL1xuICBnZXRUb2tlbjogZnVuY3Rpb24gZ2V0VG9rZW4oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIsIGVyciA/IG51bGwgOiBzZWxmLnRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbkVycm9yKG1zZywgZXJyKSB7XG4gICAgICByZXR1cm4gbmV3IEFXUy51dGlsLmVycm9yKGVyciB8fCBuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnVG9rZW5FcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgbmFtZTogJ1Rva2VuRXJyb3InXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3luY1Rva2VuKCkge1xuICAgICAgc2VsZi50b2tlbi5nZXQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICB2YXIgbXNnID0gJ0NvdWxkIG5vdCBsb2FkIHRva2VuIGZyb20gJyArXG4gICAgICAgICAgICBzZWxmLnRva2VuLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgZXJyID0gdG9rZW5FcnJvcihtc2csIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNUb2tlbigpIHtcbiAgICAgIHZhciBlcnIgPSBudWxsO1xuICAgICAgaWYgKCFzZWxmLnRva2VuLnRva2VuKSB7XG4gICAgICAgIGVyciA9IHRva2VuRXJyb3IoJ01pc3NpbmcgdG9rZW4nKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaChlcnIpO1xuICAgIH1cblxuICAgIGlmIChzZWxmLnRva2VuKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGYudG9rZW4uZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGdldEFzeW5jVG9rZW4oKTtcbiAgICAgIH0gZWxzZSB7IC8vIHN0YXRpYyB0b2tlblxuICAgICAgICBnZXRTdGF0aWNUb2tlbigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZi50b2tlblByb3ZpZGVyKSB7XG4gICAgICBzZWxmLnRva2VuUHJvdmlkZXIucmVzb2x2ZShmdW5jdGlvbihlcnIsIHRva2VuKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBlcnIgPSB0b2tlbkVycm9yKCdDb3VsZCBub3QgbG9hZCB0b2tlbiBmcm9tIGFueSBwcm92aWRlcnMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgZmluaXNoKGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoKHRva2VuRXJyb3IoJ05vIHRva2VuIHRvIGxvYWQnKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAIWdyb3VwIExvYWRpbmcgYW5kIFNldHRpbmcgQ29uZmlndXJhdGlvbiBPcHRpb25zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAb3ZlcmxvYWQgdXBkYXRlKG9wdGlvbnMsIGFsbG93VW5rbm93bktleXMgPSBmYWxzZSlcbiAgICogICBVcGRhdGVzIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggbmV3IG9wdGlvbnMuXG4gICAqXG4gICAqICAgQGV4YW1wbGUgVXBkYXRlIG1heFJldHJpZXMgcHJvcGVydHkgb2YgYSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiAgICAgY29uZmlnLnVwZGF0ZSh7bWF4UmV0cmllczogMTB9KTtcbiAgICogICBAcGFyYW0gW09iamVjdF0gb3B0aW9ucyBhIG1hcCBvZiBvcHRpb24ga2V5cyBhbmQgdmFsdWVzLlxuICAgKiAgIEBwYXJhbSBbQm9vbGVhbl0gYWxsb3dVbmtub3duS2V5cyB3aGV0aGVyIHVua25vd24ga2V5cyBjYW4gYmUgc2V0IG9uXG4gICAqICAgICB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAqICAgQHNlZSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob3B0aW9ucywgYWxsb3dVbmtub3duS2V5cykge1xuICAgIGFsbG93VW5rbm93bktleXMgPSBhbGxvd1Vua25vd25LZXlzIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMgPSB0aGlzLmV4dHJhY3RDcmVkZW50aWFscyhvcHRpb25zKTtcbiAgICBBV1MudXRpbC5lYWNoLmNhbGwodGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChhbGxvd1Vua25vd25LZXlzIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmtleXMsIGtleSkgfHxcbiAgICAgICAgICBBV1MuU2VydmljZS5oYXNTZXJ2aWNlKGtleSkpIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvYWRzIGNvbmZpZ3VyYXRpb24gZGF0YSBmcm9tIGEgSlNPTiBmaWxlIGludG8gdGhpcyBjb25maWcgb2JqZWN0LlxuICAgKiBAbm90ZSBMb2FkaW5nIGNvbmZpZ3VyYXRpb24gd2lsbCByZXNldCBhbGwgZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKiAgIG9uIHRoZSBvYmplY3QuXG4gICAqIEAhbWFjcm8gbm9icm93c2VyXG4gICAqIEBwYXJhbSBwYXRoIFtTdHJpbmddIHRoZSBwYXRoIHJlbGF0aXZlIHRvIHlvdXIgcHJvY2VzcydzIGN1cnJlbnRcbiAgICogICAgd29ya2luZyBkaXJlY3RvcnkgdG8gbG9hZCBjb25maWd1cmF0aW9uIGZyb20uXG4gICAqIEByZXR1cm4gW0FXUy5Db25maWddIHRoZSBzYW1lIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBsb2FkRnJvbVBhdGg6IGZ1bmN0aW9uIGxvYWRGcm9tUGF0aChwYXRoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBKU09OLnBhcnNlKEFXUy51dGlsLnJlYWRGaWxlU3luYyhwYXRoKSk7XG4gICAgdmFyIGZpbGVTeXN0ZW1DcmVkcyA9IG5ldyBBV1MuRmlsZVN5c3RlbUNyZWRlbnRpYWxzKHBhdGgpO1xuICAgIHZhciBjaGFpbiA9IG5ldyBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4oKTtcbiAgICBjaGFpbi5wcm92aWRlcnMudW5zaGlmdChmaWxlU3lzdGVtQ3JlZHMpO1xuICAgIGNoYWluLnJlc29sdmUoZnVuY3Rpb24gKGVyciwgY3JlZHMpIHtcbiAgICAgIGlmIChlcnIpIHRocm93IGVycjtcbiAgICAgIGVsc2Ugb3B0aW9ucy5jcmVkZW50aWFscyA9IGNyZWRzO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb25zdHJ1Y3RvcihvcHRpb25zKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhcnMgY29uZmlndXJhdGlvbiBkYXRhIG9uIHRoaXMgb2JqZWN0XG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIC8qanNoaW50IGZvcmluOmZhbHNlICovXG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMua2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIHJlc2V0IGNyZWRlbnRpYWwgcHJvdmlkZXJcbiAgICB0aGlzLnNldCgnY3JlZGVudGlhbHMnLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuc2V0KCdjcmVkZW50aWFsUHJvdmlkZXInLCB1bmRlZmluZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgcHJvcGVydHkgb24gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBhbGxvd2luZyBmb3IgYVxuICAgKiBkZWZhdWx0IHZhbHVlXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiBzZXQocHJvcGVydHksIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IHRoaXMua2V5c1twcm9wZXJ0eV07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGRlZmF1bHRWYWx1ZS5jYWxsKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ2h0dHBPcHRpb25zJyAmJiB0aGlzW3Byb3BlcnR5XSkge1xuICAgICAgLy8gZGVlcCBtZXJnZSBodHRwT3B0aW9uc1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSBBV1MudXRpbC5tZXJnZSh0aGlzW3Byb3BlcnR5XSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBrZXlzIHdpdGggdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXG4gICAqXG4gICAqIEBjb25zdGFudFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGtleXM6IHtcbiAgICBjcmVkZW50aWFsczogbnVsbCxcbiAgICBjcmVkZW50aWFsUHJvdmlkZXI6IG51bGwsXG4gICAgcmVnaW9uOiBudWxsLFxuICAgIGxvZ2dlcjogbnVsbCxcbiAgICBhcGlWZXJzaW9uczoge30sXG4gICAgYXBpVmVyc2lvbjogbnVsbCxcbiAgICBlbmRwb2ludDogdW5kZWZpbmVkLFxuICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICB0aW1lb3V0OiAxMjAwMDBcbiAgICB9LFxuICAgIG1heFJldHJpZXM6IHVuZGVmaW5lZCxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIHBhcmFtVmFsaWRhdGlvbjogdHJ1ZSxcbiAgICBzc2xFbmFibGVkOiB0cnVlLFxuICAgIHMzRm9yY2VQYXRoU3R5bGU6IGZhbHNlLFxuICAgIHMzQnVja2V0RW5kcG9pbnQ6IGZhbHNlLFxuICAgIHMzRGlzYWJsZUJvZHlTaWduaW5nOiB0cnVlLFxuICAgIHMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQ6ICdsZWdhY3knLFxuICAgIHMzVXNlQXJuUmVnaW9uOiB1bmRlZmluZWQsXG4gICAgY29tcHV0ZUNoZWNrc3VtczogdHJ1ZSxcbiAgICBjb252ZXJ0UmVzcG9uc2VUeXBlczogdHJ1ZSxcbiAgICBjb3JyZWN0Q2xvY2tTa2V3OiBmYWxzZSxcbiAgICBjdXN0b21Vc2VyQWdlbnQ6IG51bGwsXG4gICAgZHluYW1vRGJDcmMzMjogdHJ1ZSxcbiAgICBzeXN0ZW1DbG9ja09mZnNldDogMCxcbiAgICBzaWduYXR1cmVWZXJzaW9uOiBudWxsLFxuICAgIHNpZ25hdHVyZUNhY2hlOiB0cnVlLFxuICAgIHJldHJ5RGVsYXlPcHRpb25zOiB7fSxcbiAgICB1c2VBY2NlbGVyYXRlRW5kcG9pbnQ6IGZhbHNlLFxuICAgIGNsaWVudFNpZGVNb25pdG9yaW5nOiBmYWxzZSxcbiAgICBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWQ6IHVuZGVmaW5lZCxcbiAgICBlbmRwb2ludENhY2hlU2l6ZTogMTAwMCxcbiAgICBob3N0UHJlZml4RW5hYmxlZDogdHJ1ZSxcbiAgICBzdHNSZWdpb25hbEVuZHBvaW50czogJ2xlZ2FjeScsXG4gICAgdXNlRmlwc0VuZHBvaW50OiBmYWxzZSxcbiAgICB1c2VEdWFsc3RhY2tFbmRwb2ludDogZmFsc2UsXG4gICAgdG9rZW46IG51bGxcbiAgfSxcblxuICAvKipcbiAgICogRXh0cmFjdHMgYWNjZXNzS2V5SWQsIHNlY3JldEFjY2Vzc0tleSBhbmQgc2Vzc2lvblRva2VuXG4gICAqIGZyb20gYSBjb25maWd1cmF0aW9uIGhhc2guXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdENyZWRlbnRpYWxzOiBmdW5jdGlvbiBleHRyYWN0Q3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmFjY2Vzc0tleUlkICYmIG9wdGlvbnMuc2VjcmV0QWNjZXNzS2V5KSB7XG4gICAgICBvcHRpb25zID0gQVdTLnV0aWwuY29weShvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IHRoZSBTREsgd2lsbCB1c2Ugd2hlcmV2ZXIgUHJvbWlzZXMgYXJlIHJldHVybmVkLlxuICAgKiBQYXNzaW5nIGBudWxsYCB3aWxsIGZvcmNlIHRoZSBTREsgdG8gdXNlIG5hdGl2ZSBQcm9taXNlcyBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gICAqIElmIG5hdGl2ZSBQcm9taXNlcyBhcmUgbm90IGF2YWlsYWJsZSwgcGFzc2luZyBgbnVsbGAgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAgICogQHBhcmFtIFtDb25zdHJ1Y3Rvcl0gZGVwIEEgcmVmZXJlbmNlIHRvIGEgUHJvbWlzZSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgc2V0UHJvbWlzZXNEZXBlbmRlbmN5OiBmdW5jdGlvbiBzZXRQcm9taXNlc0RlcGVuZGVuY3koZGVwKSB7XG4gICAgUHJvbWlzZXNEZXBlbmRlbmN5ID0gZGVwO1xuICAgIC8vIGlmIG51bGwgd2FzIHBhc3NlZCBpbiwgd2Ugc2hvdWxkIHRyeSB0byB1c2UgbmF0aXZlIHByb21pc2VzXG4gICAgaWYgKGRlcCA9PT0gbnVsbCAmJiB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUHJvbWlzZXNEZXBlbmRlbmN5ID0gUHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGNvbnN0cnVjdG9ycyA9IFtBV1MuUmVxdWVzdCwgQVdTLkNyZWRlbnRpYWxzLCBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW5dO1xuICAgIGlmIChBV1MuUzMpIHtcbiAgICAgIGNvbnN0cnVjdG9ycy5wdXNoKEFXUy5TMyk7XG4gICAgICBpZiAoQVdTLlMzLk1hbmFnZWRVcGxvYWQpIHtcbiAgICAgICAgY29uc3RydWN0b3JzLnB1c2goQVdTLlMzLk1hbmFnZWRVcGxvYWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBBV1MudXRpbC5hZGRQcm9taXNlcyhjb25zdHJ1Y3RvcnMsIFByb21pc2VzRGVwZW5kZW5jeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHByb21pc2UgZGVwZW5kZW5jeSBzZXQgYnkgYEFXUy5jb25maWcuc2V0UHJvbWlzZXNEZXBlbmRlbmN5YC5cbiAgICovXG4gIGdldFByb21pc2VzRGVwZW5kZW5jeTogZnVuY3Rpb24gZ2V0UHJvbWlzZXNEZXBlbmRlbmN5KCkge1xuICAgIHJldHVybiBQcm9taXNlc0RlcGVuZGVuY3k7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEByZXR1cm4gW0FXUy5Db25maWddIFRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3Qgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBAcmVhZG9ubHlcbiAqIEBzZWUgQVdTLkNvbmZpZ1xuICovXG5BV1MuY29uZmlnID0gbmV3IEFXUy5Db25maWcoKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUoY29uZmlnVmFsdWUsIGVycm9yT3B0aW9ucykge1xuICBpZiAodHlwZW9mIGNvbmZpZ1ZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgZWxzZSBpZiAoWydsZWdhY3knLCAncmVnaW9uYWwnXS5pbmRleE9mKGNvbmZpZ1ZhbHVlLnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICByZXR1cm4gY29uZmlnVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwgZXJyb3JPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWUgZm9yIHJlZ2lvbmFsIGVuZHBvaW50IGZyb20gZGlmZmVyZW5jZSBzb3VyY2VzOiBjbGllbnRcbiAqIGNvbmZpZywgZW52aXJvbm1lbnRhbCB2YXJpYWJsZSwgc2hhcmVkIGNvbmZpZyBmaWxlLiBWYWx1ZSBjYW4gYmUgY2FzZS1pbnNlbnNpdGl2ZVxuICogJ2xlZ2FjeScgb3IgJ3JlZ2luYWwnLlxuICogQHBhcmFtIG9yaWdpbmFsQ29uZmlnIHVzZXItc3VwcGxpZWQgY29uZmlnIG9iamVjdCB0byByZXNvbHZlXG4gKiBAcGFyYW0gb3B0aW9ucyBhIG1hcCBvZiBjb25maWcgcHJvcGVydHkgbmFtZXMgZnJvbSBpbmRpdmlkdWFsIGNvbmZpZ3VyYXRpb24gc291cmNlXG4gKiAgLSBlbnY6IG5hbWUgb2YgZW52aXJvbm1lbnRhbCB2YXJpYWJsZSB0aGF0IHJlZmVycyB0byB0aGUgY29uZmlnXG4gKiAgLSBzaGFyZWRDb25maWc6IG5hbWUgb2Ygc2hhcmVkIGNvbmZpZ3VyYXRpb24gZmlsZSBwcm9wZXJ0eSB0aGF0IHJlZmVycyB0byB0aGUgY29uZmlnXG4gKiAgLSBjbGllbnRDb25maWc6IG5hbWUgb2YgY2xpZW50IGNvbmZpZ3VyYXRpb24gcHJvcGVydHkgdGhhdCByZWZlcnMgdG8gdGhlIGNvbmZpZ1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnKG9yaWdpbmFsQ29uZmlnLCBvcHRpb25zKSB7XG4gIG9yaWdpbmFsQ29uZmlnID0gb3JpZ2luYWxDb25maWcgfHwge307XG4gIC8vdmFsaWRhdGUgY29uZmlnIHZhbHVlXG4gIHZhciByZXNvbHZlZDtcbiAgaWYgKG9yaWdpbmFsQ29uZmlnW29wdGlvbnMuY2xpZW50Q29uZmlnXSkge1xuICAgIHJlc29sdmVkID0gdmFsaWRhdGVSZWdpb25hbEVuZHBvaW50c0ZsYWdWYWx1ZShvcmlnaW5hbENvbmZpZ1tvcHRpb25zLmNsaWVudENvbmZpZ10sIHtcbiAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICBtZXNzYWdlOiAnaW52YWxpZCBcIicgKyBvcHRpb25zLmNsaWVudENvbmZpZyArICdcIiBjb25maWd1cmF0aW9uLiBFeHBlY3QgXCJsZWdhY3lcIiAnICtcbiAgICAgICcgb3IgXCJyZWdpb25hbFwiLiBHb3QgXCInICsgb3JpZ2luYWxDb25maWdbb3B0aW9ucy5jbGllbnRDb25maWddICsgJ1wiLidcbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZDtcbiAgfVxuICBpZiAoIUFXUy51dGlsLmlzTm9kZSgpKSByZXR1cm4gcmVzb2x2ZWQ7XG4gIC8vdmFsaWRhdGUgZW52aXJvbm1lbnRhbCB2YXJpYWJsZVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb2Nlc3MuZW52LCBvcHRpb25zLmVudikpIHtcbiAgICB2YXIgZW52RmxhZyA9IHByb2Nlc3MuZW52W29wdGlvbnMuZW52XTtcbiAgICByZXNvbHZlZCA9IHZhbGlkYXRlUmVnaW9uYWxFbmRwb2ludHNGbGFnVmFsdWUoZW52RmxhZywge1xuICAgICAgY29kZTogJ0ludmFsaWRFbnZpcm9ubWVudGFsVmFyaWFibGUnLFxuICAgICAgbWVzc2FnZTogJ2ludmFsaWQgJyArIG9wdGlvbnMuZW52ICsgJyBlbnZpcm9ubWVudGFsIHZhcmlhYmxlLiBFeHBlY3QgXCJsZWdhY3lcIiAnICtcbiAgICAgICcgb3IgXCJyZWdpb25hbFwiLiBHb3QgXCInICsgcHJvY2Vzcy5lbnZbb3B0aW9ucy5lbnZdICsgJ1wiLidcbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZDtcbiAgfVxuICAvL3ZhbGlkYXRlIHNoYXJlZCBjb25maWcgZmlsZVxuICB2YXIgcHJvZmlsZSA9IHt9O1xuICB0cnkge1xuICAgIHZhciBwcm9maWxlcyA9IEFXUy51dGlsLmdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhBV1MudXRpbC5pbmlMb2FkZXIpO1xuICAgIHByb2ZpbGUgPSBwcm9maWxlc1twcm9jZXNzLmVudi5BV1NfUFJPRklMRSB8fCBBV1MudXRpbC5kZWZhdWx0UHJvZmlsZV07XG4gIH0gY2F0Y2ggKGUpIHt9O1xuICBpZiAocHJvZmlsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvZmlsZSwgb3B0aW9ucy5zaGFyZWRDb25maWcpKSB7XG4gICAgdmFyIGZpbGVGbGFnID0gcHJvZmlsZVtvcHRpb25zLnNoYXJlZENvbmZpZ107XG4gICAgcmVzb2x2ZWQgPSB2YWxpZGF0ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZ1ZhbHVlKGZpbGVGbGFnLCB7XG4gICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgbWVzc2FnZTogJ2ludmFsaWQgJyArIG9wdGlvbnMuc2hhcmVkQ29uZmlnICsgJyBwcm9maWxlIGNvbmZpZy4gRXhwZWN0IFwibGVnYWN5XCIgJyArXG4gICAgICAnIG9yIFwicmVnaW9uYWxcIi4gR290IFwiJyArIHByb2ZpbGVbb3B0aW9ucy5zaGFyZWRDb25maWddICsgJ1wiLidcbiAgICB9KTtcbiAgICBpZiAocmVzb2x2ZWQpIHJldHVybiByZXNvbHZlZDtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZVJlZ2lvbmFsRW5kcG9pbnRzRmxhZztcbiIsIi8qKlxuICogVGhlIG1haW4gQVdTIG5hbWVzcGFjZVxuICovXG52YXIgQVdTID0geyB1dGlsOiByZXF1aXJlKCcuL3V0aWwnKSB9O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICogQCFtYWNybyBbbmV3XSBub2Jyb3dzZXJcbiAqICAgQG5vdGUgVGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQgb2YgdGhlIFNESy5cbiAqL1xudmFyIF9oaWRkZW4gPSB7fTsgX2hpZGRlbi50b1N0cmluZygpOyAvLyBoYWNrIHRvIHBhcnNlIG1hY3JvXG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLCB7XG5cbiAgLyoqXG4gICAqIEBjb25zdGFudFxuICAgKi9cbiAgVkVSU0lPTjogJzIuMTIyMC4wJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBTaWduZXJzOiB7fSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBQcm90b2NvbDoge1xuICAgIEpzb246IHJlcXVpcmUoJy4vcHJvdG9jb2wvanNvbicpLFxuICAgIFF1ZXJ5OiByZXF1aXJlKCcuL3Byb3RvY29sL3F1ZXJ5JyksXG4gICAgUmVzdDogcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0JyksXG4gICAgUmVzdEpzb246IHJlcXVpcmUoJy4vcHJvdG9jb2wvcmVzdF9qc29uJyksXG4gICAgUmVzdFhtbDogcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X3htbCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgWE1MOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi94bWwvYnVpbGRlcicpLFxuICAgIFBhcnNlcjogbnVsbCAvLyBjb25kaXRpb25hbGx5IHNldCBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIEpTT046IHtcbiAgICBCdWlsZGVyOiByZXF1aXJlKCcuL2pzb24vYnVpbGRlcicpLFxuICAgIFBhcnNlcjogcmVxdWlyZSgnLi9qc29uL3BhcnNlcicpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgTW9kZWw6IHtcbiAgICBBcGk6IHJlcXVpcmUoJy4vbW9kZWwvYXBpJyksXG4gICAgT3BlcmF0aW9uOiByZXF1aXJlKCcuL21vZGVsL29wZXJhdGlvbicpLFxuICAgIFNoYXBlOiByZXF1aXJlKCcuL21vZGVsL3NoYXBlJyksXG4gICAgUGFnaW5hdG9yOiByZXF1aXJlKCcuL21vZGVsL3BhZ2luYXRvcicpLFxuICAgIFJlc291cmNlV2FpdGVyOiByZXF1aXJlKCcuL21vZGVsL3Jlc291cmNlX3dhaXRlcicpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBpTG9hZGVyOiByZXF1aXJlKCcuL2FwaV9sb2FkZXInKSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBFbmRwb2ludENhY2hlOiByZXF1aXJlKCcuLi92ZW5kb3IvZW5kcG9pbnQtY2FjaGUnKS5FbmRwb2ludENhY2hlXG59KTtcbnJlcXVpcmUoJy4vc2VxdWVudGlhbF9leGVjdXRvcicpO1xucmVxdWlyZSgnLi9zZXJ2aWNlJyk7XG5yZXF1aXJlKCcuL2NvbmZpZycpO1xucmVxdWlyZSgnLi9odHRwJyk7XG5yZXF1aXJlKCcuL2V2ZW50X2xpc3RlbmVycycpO1xucmVxdWlyZSgnLi9yZXF1ZXN0Jyk7XG5yZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG5yZXF1aXJlKCcuL3Jlc291cmNlX3dhaXRlcicpO1xucmVxdWlyZSgnLi9zaWduZXJzL3JlcXVlc3Rfc2lnbmVyJyk7XG5yZXF1aXJlKCcuL3BhcmFtX3ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEByZWFkb25seVxuICogQHJldHVybiBbQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl0gYSBjb2xsZWN0aW9uIG9mIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMgdGhhdFxuICogICBhcmUgYXR0YWNoZWQgdG8gZXZlcnkgc2VudCByZXF1ZXN0LlxuICogQHNlZSBBV1MuUmVxdWVzdCBBV1MuUmVxdWVzdCBmb3IgYSBsaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gZm9yXG4gKiBAZXhhbXBsZSBMb2dnaW5nIHRoZSB0aW1lIHRha2VuIHRvIHNlbmQgYSByZXF1ZXN0XG4gKiAgIEFXUy5ldmVudHMub24oJ3NlbmQnLCBmdW5jdGlvbiBzdGFydFNlbmQocmVzcCkge1xuICogICAgIHJlc3Auc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gKiAgIH0pLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIGNhbGN1bGF0ZVRpbWUocmVzcCkge1xuICogICAgIHZhciB0aW1lID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gcmVzcC5zdGFydFRpbWUpIC8gMTAwMDtcbiAqICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCB0b29rICcgKyB0aW1lICsgJyBzZWNvbmRzJyk7XG4gKiAgIH0pO1xuICpcbiAqICAgbmV3IEFXUy5TMygpLmxpc3RCdWNrZXRzKCk7IC8vIHByaW50cyAnUmVxdWVzdCB0b29rIDAuMjg1IHNlY29uZHMnXG4gKi9cbkFXUy5ldmVudHMgPSBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpO1xuXG4vL2NyZWF0ZSBlbmRwb2ludCBjYWNoZSBsYXppbHlcbkFXUy51dGlsLm1lbW9pemVkUHJvcGVydHkoQVdTLCAnZW5kcG9pbnRDYWNoZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEFXUy5FbmRwb2ludENhY2hlKEFXUy5jb25maWcuZW5kcG9pbnRDYWNoZVNpemUpO1xufSwgdHJ1ZSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB5b3VyIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscywgc3BlY2lmaWNhbGx5IHRoZVxuICoge2FjY2Vzc0tleUlkfSwge3NlY3JldEFjY2Vzc0tleX0sIGFuZCBvcHRpb25hbCB7c2Vzc2lvblRva2VufS5cbiAqIENyZWF0aW5nIGEgYENyZWRlbnRpYWxzYCBvYmplY3QgYWxsb3dzIHlvdSB0byBwYXNzIGFyb3VuZCB5b3VyXG4gKiBzZWN1cml0eSBpbmZvcm1hdGlvbiB0byBjb25maWd1cmF0aW9uIGFuZCBzZXJ2aWNlIG9iamVjdHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgY2xhc3MgdHlwaWNhbGx5IGRvZXMgbm90IG5lZWQgdG8gYmUgY29uc3RydWN0ZWQgbWFudWFsbHksXG4gKiBhcyB0aGUge0FXUy5Db25maWd9IGFuZCB7QVdTLlNlcnZpY2V9IGNsYXNzZXMgYm90aCBhY2NlcHQgc2ltcGxlXG4gKiBvcHRpb25zIGhhc2hlcyB3aXRoIHRoZSB0aHJlZSBrZXlzLiBUaGVzZSBzdHJ1Y3R1cmVzIHdpbGwgYmUgY29udmVydGVkXG4gKiBpbnRvIENyZWRlbnRpYWxzIG9iamVjdHMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAjIyBFeHBpcmluZyBhbmQgUmVmcmVzaGluZyBDcmVkZW50aWFsc1xuICpcbiAqIE9jY2FzaW9uYWxseSBjcmVkZW50aWFscyBjYW4gZXhwaXJlIGluIHRoZSBtaWRkbGUgb2YgYSBsb25nLXJ1bm5pbmdcbiAqIGFwcGxpY2F0aW9uLiBJbiB0aGlzIGNhc2UsIHRoZSBTREsgd2lsbCBhdXRvbWF0aWNhbGx5IGF0dGVtcHQgdG9cbiAqIHJlZnJlc2ggdGhlIGNyZWRlbnRpYWxzIGZyb20gdGhlIHN0b3JhZ2UgbG9jYXRpb24gaWYgdGhlIENyZWRlbnRpYWxzXG4gKiBjbGFzcyBpbXBsZW1lbnRzIHRoZSB7cmVmcmVzaH0gbWV0aG9kLlxuICpcbiAqIElmIHlvdSBhcmUgaW1wbGVtZW50aW5nIGEgY3JlZGVudGlhbCBzdG9yYWdlIGxvY2F0aW9uLCB5b3VcbiAqIHdpbGwgd2FudCB0byBjcmVhdGUgYSBzdWJjbGFzcyBvZiB0aGUgYENyZWRlbnRpYWxzYCBjbGFzcyBhbmRcbiAqIG92ZXJyaWRlIHRoZSB7cmVmcmVzaH0gbWV0aG9kLiBUaGlzIG1ldGhvZCBhbGxvd3MgY3JlZGVudGlhbHMgdG8gYmVcbiAqIHJldHJpZXZlZCBmcm9tIHRoZSBiYWNraW5nIHN0b3JlLCBiZSBpdCBhIGZpbGUgc3lzdGVtLCBkYXRhYmFzZSwgb3JcbiAqIHNvbWUgbmV0d29yayBzdG9yYWdlLiBUaGUgbWV0aG9kIHNob3VsZCByZXNldCB0aGUgY3JlZGVudGlhbCBhdHRyaWJ1dGVzXG4gKiBvbiB0aGUgb2JqZWN0LlxuICpcbiAqIEAhYXR0cmlidXRlIGV4cGlyZWRcbiAqICAgQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0aGUgY3JlZGVudGlhbHMgaGF2ZSBiZWVuIGV4cGlyZWQgYW5kXG4gKiAgICAgcmVxdWlyZSBhIHJlZnJlc2guIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB7ZXhwaXJlVGltZX0uXG4gKiBAIWF0dHJpYnV0ZSBleHBpcmVUaW1lXG4gKiAgIEByZXR1cm4gW0RhdGVdIGEgdGltZSB3aGVuIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBjb25zaWRlcmVkIGV4cGlyZWQuIFVzZWRcbiAqICAgICBpbiBjb25qdW5jdGlvbiB3aXRoIHtleHBpcmVkfS5cbiAqIEAhYXR0cmlidXRlIGFjY2Vzc0tleUlkXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIEFXUyBhY2Nlc3Mga2V5IElEXG4gKiBAIWF0dHJpYnV0ZSBzZWNyZXRBY2Nlc3NLZXlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5XG4gKiBAIWF0dHJpYnV0ZSBzZXNzaW9uVG9rZW5cbiAqICAgQHJldHVybiBbU3RyaW5nXSBhbiBvcHRpb25hbCBBV1Mgc2Vzc2lvbiB0b2tlblxuICovXG5BV1MuQ3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIEEgY3JlZGVudGlhbHMgb2JqZWN0IGNhbiBiZSBjcmVhdGVkIHVzaW5nIHBvc2l0aW9uYWwgYXJndW1lbnRzIG9yIGFuIG9wdGlvbnNcbiAgICogaGFzaC5cbiAgICpcbiAgICogQG92ZXJsb2FkIEFXUy5DcmVkZW50aWFscyhhY2Nlc3NLZXlJZCwgc2VjcmV0QWNjZXNzS2V5LCBzZXNzaW9uVG9rZW49bnVsbClcbiAgICogICBDcmVhdGVzIGEgQ3JlZGVudGlhbHMgb2JqZWN0IHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbCBpbmZvcm1hdGlvblxuICAgKiAgIGFzIHBvc2l0aW9uYWwgYXJndW1lbnRzLlxuICAgKiAgIEBwYXJhbSBhY2Nlc3NLZXlJZCBbU3RyaW5nXSB0aGUgQVdTIGFjY2VzcyBrZXkgSURcbiAgICogICBAcGFyYW0gc2VjcmV0QWNjZXNzS2V5IFtTdHJpbmddIHRoZSBBV1Mgc2VjcmV0IGFjY2VzcyBrZXlcbiAgICogICBAcGFyYW0gc2Vzc2lvblRva2VuIFtTdHJpbmddIHRoZSBvcHRpb25hbCBBV1Mgc2Vzc2lvbiB0b2tlblxuICAgKiAgIEBleGFtcGxlIENyZWF0ZSBhIGNyZWRlbnRpYWxzIG9iamVjdCB3aXRoIEFXUyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIGNyZWRzID0gbmV3IEFXUy5DcmVkZW50aWFscygnYWtpZCcsICdzZWNyZXQnLCAnc2Vzc2lvbicpO1xuICAgKiBAb3ZlcmxvYWQgQVdTLkNyZWRlbnRpYWxzKG9wdGlvbnMpXG4gICAqICAgQ3JlYXRlcyBhIENyZWRlbnRpYWxzIG9iamVjdCB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGNyZWRlbnRpYWwgaW5mb3JtYXRpb25cbiAgICogICBhcyBhbiBvcHRpb25zIGhhc2guXG4gICAqICAgQG9wdGlvbiBvcHRpb25zIGFjY2Vzc0tleUlkIFtTdHJpbmddIHRoZSBBV1MgYWNjZXNzIGtleSBJRFxuICAgKiAgIEBvcHRpb24gb3B0aW9ucyBzZWNyZXRBY2Nlc3NLZXkgW1N0cmluZ10gdGhlIEFXUyBzZWNyZXQgYWNjZXNzIGtleVxuICAgKiAgIEBvcHRpb24gb3B0aW9ucyBzZXNzaW9uVG9rZW4gW1N0cmluZ10gdGhlIG9wdGlvbmFsIEFXUyBzZXNzaW9uIHRva2VuXG4gICAqICAgQGV4YW1wbGUgQ3JlYXRlIGEgY3JlZGVudGlhbHMgb2JqZWN0IHdpdGggQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgY3JlZHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKHtcbiAgICogICAgICAgYWNjZXNzS2V5SWQ6ICdha2lkJywgc2VjcmV0QWNjZXNzS2V5OiAnc2VjcmV0Jywgc2Vzc2lvblRva2VuOiAnc2Vzc2lvbidcbiAgICogICAgIH0pO1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENyZWRlbnRpYWxzKCkge1xuICAgIC8vIGhpZGUgc2VjcmV0QWNjZXNzS2V5IGZyb20gYmVpbmcgZGlzcGxheWVkIHdpdGggdXRpbC5pbnNwZWN0XG4gICAgQVdTLnV0aWwuaGlkZVByb3BlcnRpZXModGhpcywgWydzZWNyZXRBY2Nlc3NLZXknXSk7XG5cbiAgICB0aGlzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmV4cGlyZVRpbWUgPSBudWxsO1xuICAgIHRoaXMucmVmcmVzaENhbGxiYWNrcyA9IFtdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY3JlZHMgPSBhcmd1bWVudHNbMF0uY3JlZGVudGlhbHMgfHwgYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5hY2Nlc3NLZXlJZCA9IGNyZWRzLmFjY2Vzc0tleUlkO1xuICAgICAgdGhpcy5zZWNyZXRBY2Nlc3NLZXkgPSBjcmVkcy5zZWNyZXRBY2Nlc3NLZXk7XG4gICAgICB0aGlzLnNlc3Npb25Ub2tlbiA9IGNyZWRzLnNlc3Npb25Ub2tlbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2Nlc3NLZXlJZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuc2VjcmV0QWNjZXNzS2V5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIHtleHBpcmVUaW1lfSBkdXJpbmcgd2hpY2hcbiAgICogICB0aGUgY3JlZGVudGlhbHMgd2lsbCBiZSBjb25zaWRlcmVkIGV4cGlyZWQuXG4gICAqL1xuICBleHBpcnlXaW5kb3c6IDE1LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtCb29sZWFuXSB3aGV0aGVyIHRoZSBjcmVkZW50aWFscyBvYmplY3Qgc2hvdWxkIGNhbGwge3JlZnJlc2h9XG4gICAqIEBub3RlIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgY3VzdG9tIHJlZnJlc2hcbiAgICogICBsb2dpYy5cbiAgICovXG4gIG5lZWRzUmVmcmVzaDogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IEFXUy51dGlsLmRhdGUuZ2V0RGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgYWRqdXN0ZWRUaW1lID0gbmV3IERhdGUoY3VycmVudFRpbWUgKyB0aGlzLmV4cGlyeVdpbmRvdyAqIDEwMDApO1xuXG4gICAgaWYgKHRoaXMuZXhwaXJlVGltZSAmJiBhZGp1c3RlZFRpbWUgPiB0aGlzLmV4cGlyZVRpbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBpcmVkIHx8ICF0aGlzLmFjY2Vzc0tleUlkIHx8ICF0aGlzLnNlY3JldEFjY2Vzc0tleTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGV4aXN0aW5nIGNyZWRlbnRpYWxzLCByZWZyZXNoaW5nIHRoZW0gaWYgdGhleSBhcmUgbm90IHlldCBsb2FkZWRcbiAgICogb3IgaGF2ZSBleHBpcmVkLiBVc2VycyBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgdXNpbmcge3JlZnJlc2h9LFxuICAgKiBhcyB0aGlzIHdpbGwgbm90IGF0dGVtcHQgdG8gcmVsb2FkIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBhcmUgYWxyZWFkeVxuICAgKiBsb2FkZWQgaW50byB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgZWl0aGVyIGNyZWRlbnRpYWxzXG4gICAqICAgZG8gbm90IG5lZWQgdG8gYmUgcmVmcmVzaGVkIG9yIHJlZnJlc2hlZCBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXNcbiAgICogICBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCxcbiAgICogICBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIGdldChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goKSkge1xuICAgICAgdGhpcy5yZWZyZXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoIWVycikgc2VsZi5leHBpcmVkID0gZmFsc2U7IC8vIHJlc2V0IGV4cGlyZWQgZmxhZ1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIGdldFByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgR2V0cyB0aGUgZXhpc3RpbmcgY3JlZGVudGlhbHMsIHJlZnJlc2hpbmcgdGhlbSBpZiB0aGV5IGFyZSBub3QgeWV0IGxvYWRlZFxuICAgKiAgIG9yIGhhdmUgZXhwaXJlZC4gVXNlcnMgc2hvdWxkIGNhbGwgdGhpcyBtZXRob2QgYmVmb3JlIHVzaW5nIHtyZWZyZXNofSxcbiAgICogICBhcyB0aGlzIHdpbGwgbm90IGF0dGVtcHQgdG8gcmVsb2FkIGNyZWRlbnRpYWxzIHdoZW4gdGhleSBhcmUgYWxyZWFkeVxuICAgKiAgIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC4gV2hlbiB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCwgaXRcbiAgICogICAgIG1lYW5zIGVpdGhlciBjcmVkZW50aWFscyBkbyBub3QgbmVlZCB0byBiZSByZWZyZXNoZWQgb3IgcmVmcmVzaGVkXG4gICAqICAgICBjcmVkZW50aWFscyBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGVcbiAgICogICAgIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIGBnZXRgIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgQ2FsbGluZyB0aGUgYGdldFByb21pc2VgIG1ldGhvZC5cbiAgICogICAgIHZhciBwcm9taXNlID0gY3JlZFByb3ZpZGVyLmdldFByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcmVmcmVzaFByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgUmVmcmVzaGVzIHRoZSBjcmVkZW50aWFscy4gVXNlcnMgc2hvdWxkIGNhbGwge2dldH0gYmVmb3JlIGF0dGVtcHRpbmdcbiAgICogICB0byBmb3JjaWJseSByZWZyZXNoIGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKClcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuIFdoZW4gdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQsIGl0XG4gICAqICAgICBtZWFucyByZWZyZXNoZWQgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdFxuICAgKiAgICAgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLCBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBgcmVmcmVzaGAgY2FsbC5cbiAgICogICBAZXhhbXBsZSBDYWxsaW5nIHRoZSBgcmVmcmVzaFByb21pc2VgIG1ldGhvZC5cbiAgICogICAgIHZhciBwcm9taXNlID0gY3JlZFByb3ZpZGVyLnJlZnJlc2hQcm9taXNlKCk7XG4gICAqICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBjcmVkZW50aWFscy4gVXNlcnMgc2hvdWxkIGNhbGwge2dldH0gYmVmb3JlIGF0dGVtcHRpbmdcbiAgICogdG8gZm9yY2libHkgcmVmcmVzaCBjcmVkZW50aWFscy5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBXaGVuIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHJlZnJlc2hlZFxuICAgKiAgIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZVxuICAgKiAgIGBhY2Nlc3NLZXlJZGAsIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBub3RlIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgY2xhc3MgdG8gcmVzZXQgdGhlXG4gICAqICAge2FjY2Vzc0tleUlkfSwge3NlY3JldEFjY2Vzc0tleX0gYW5kIG9wdGlvbmFsIHtzZXNzaW9uVG9rZW59XG4gICAqICAgb24gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCBhbmQgdGhlbiBjYWxsIHRoZSBjYWxsYmFjayB3aXRoXG4gICAqICAgYW55IGVycm9yIGluZm9ybWF0aW9uLlxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGNvYWxlc2NlUmVmcmVzaDogZnVuY3Rpb24gY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrLCBzeW5jKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnJlZnJlc2hDYWxsYmFja3MucHVzaChjYWxsYmFjaykgPT09IDEpIHtcbiAgICAgIHNlbGYubG9hZChmdW5jdGlvbiBvbkxvYWQoZXJyKSB7XG4gICAgICAgIEFXUy51dGlsLmFycmF5RWFjaChzZWxmLnJlZnJlc2hDYWxsYmFja3MsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGNvdWxkIHRocm93LCBzbyBkZWZlciB0byBlbnN1cmUgYWxsIGNhbGxiYWNrcyBhcmUgbm90aWZpZWRcbiAgICAgICAgICAgIEFXUy51dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYucmVmcmVzaENhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFscy5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUuZ2V0UHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgnZ2V0JywgUHJvbWlzZURlcGVuZGVuY3kpO1xuICB0aGlzLnByb3RvdHlwZS5yZWZyZXNoUHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgncmVmcmVzaCcsIFByb21pc2VEZXBlbmRlbmN5KTtcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5DcmVkZW50aWFscy5kZWxldGVQcm9taXNlc0Zyb21DbGFzcyA9IGZ1bmN0aW9uIGRlbGV0ZVByb21pc2VzRnJvbUNsYXNzKCkge1xuICBkZWxldGUgdGhpcy5wcm90b3R5cGUuZ2V0UHJvbWlzZTtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnJlZnJlc2hQcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLkNyZWRlbnRpYWxzKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRlbXBvcmFyeSBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSB7QVdTLlNUU30uIFdpdGhvdXQgYW55XG4gKiBleHRyYSBwYXJhbWV0ZXJzLCBjcmVkZW50aWFscyB3aWxsIGJlIGZldGNoZWQgZnJvbSB0aGVcbiAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9uLiBJZiBhbiBJQU0gcm9sZSBpcyBwcm92aWRlZCwgdGhlXG4gKiB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvcGVyYXRpb24gd2lsbCBiZSB1c2VkIHRvIGZldGNoIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAqIHJvbGUgaW5zdGVhZC5cbiAqXG4gKiBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgZGlmZmVycyBmcm9tIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscyBpblxuICogdGhlIHdheSBtYXN0ZXJDcmVkZW50aWFscyBhbmQgcmVmcmVzaGVzIGFyZSBoYW5kbGVkLlxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIHJlZnJlc2hlcyBleHBpcmVkIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICogbWFzdGVyQ3JlZGVudGlhbHMgcGFzc2VkIGJ5IHRoZSB1c2VyIHRvIHN1cHBvcnQgY2hhaW5pbmcgb2YgU1RTIGNyZWRlbnRpYWxzLlxuICogSG93ZXZlciwgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIHJlY3Vyc2l2ZWx5IGNvbGxhcHNlcyB0aGUgbWFzdGVyQ3JlZGVudGlhbHNcbiAqIGR1cmluZyBpbnN0YW50aWF0aW9uLCBwcmVjbHVkaW5nIHRoZSBhYmlsaXR5IHRvIHJlZnJlc2ggY3JlZGVudGlhbHMgd2hpY2hcbiAqIHJlcXVpcmUgaW50ZXJtZWRpYXRlLCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBhcHBsaWNhdGlvbiBzaG91bGQgdXNlIFJvbGVBLCB3aGljaCBtdXN0IGJlIGFzc3VtZWQgZnJvbVxuICogUm9sZUIsIGFuZCB0aGUgZW52aXJvbm1lbnQgcHJvdmlkZXMgY3JlZGVudGlhbHMgd2hpY2ggY2FuIGFzc3VtZSBSb2xlQiwgdGhlblxuICogQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzIG11c3QgYmUgdXNlZCB0byBzdXBwb3J0IHJlZnJlc2hpbmcgdGhlXG4gKiB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZm9yIFJvbGVBOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciByb2xlQUNyZWRzID0gbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgIHBhcmFtczoge1JvbGVBcm46ICdSb2xlQSd9LFxuICogICBtYXN0ZXJDcmVkZW50aWFsczogbmV3IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyh7XG4gKiAgICAgcGFyYW1zOiB7Um9sZUFybjogJ1JvbGVCJ30sXG4gKiAgICAgbWFzdGVyQ3JlZGVudGlhbHM6IG5ldyBBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFscygnQVdTJylcbiAqICAgfSlcbiAqIH0pO1xuICogYGBgXG4gKlxuICogSWYgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGhhZCBiZWVuIHVzZWQgaW4gdGhlIHByZXZpb3VzIGV4YW1wbGUsXG4gKiBgcm9sZUFDcmVkc2Agd291bGQgZmFpbCB0byByZWZyZXNoIGJlY2F1c2UgYHJvbGVBQ3JlZHNgIHdvdWxkXG4gKiB1c2UgdGhlIGVudmlyb25tZW50IGNyZWRlbnRpYWxzIGZvciB0aGUgQXNzdW1lUm9sZSByZXF1ZXN0LlxuICpcbiAqIEFub3RoZXIgZGlmZmVyZW5jZSBpcyB0aGF0IEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyBjcmVhdGVzIHRoZSBTVFNcbiAqIHNlcnZpY2UgaW5zdGFuY2UgZHVyaW5nIGluc3RhbnRpYXRpb24gd2hpbGUgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzIGNyZWF0ZXNcbiAqIHRoZSBTVFMgc2VydmljZSBpbnN0YW5jZSBkdXJpbmcgdGhlIGZpcnN0IHJlZnJlc2guIENyZWF0aW5nIHRoZSBzZXJ2aWNlXG4gKiBpbnN0YW5jZSBkdXJpbmcgaW5zdGFudGlhdGlvbiBlZmZlY3RpdmVseSBjYXB0dXJlcyB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzXG4gKiBmcm9tIHRoZSBnbG9iYWwgY29uZmlnLCBzbyB0aGF0IHN1YnNlcXVlbnQgY2hhbmdlcyB0byB0aGUgZ2xvYmFsIGNvbmZpZyBkb1xuICogbm90IGFmZmVjdCB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzIHVzZWQgdG8gcmVmcmVzaCB0aGUgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLlxuICpcbiAqIFRoaXMgYWxsb3dzIGFuIGluc3RhbmNlIG9mIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyB0byBiZSBhc3NpZ25lZFxuICogdG8gQVdTLmNvbmZpZy5jcmVkZW50aWFsczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgZW52Q3JlZHMgPSBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpO1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IGVudkNyZWRzO1xuICogLy8gbWFzdGVyQ3JlZGVudGlhbHMgd2lsbCBiZSBlbnZDcmVkc1xuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICogICBwYXJhbXM6IHtSb2xlQXJuOiAnLi4uJ31cbiAqIH0pO1xuICogYGBgXG4gKlxuICogU2ltaWxhcmx5LCB0byB1c2UgdGhlIENyZWRlbnRpYWxQcm92aWRlckNoYWluJ3MgZGVmYXVsdCBwcm92aWRlcnMgYXMgdGhlXG4gKiBtYXN0ZXIgY3JlZGVudGlhbHMsIHNpbXBseSBjcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2ZcbiAqIEFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFsczpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IENoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAqICAgcGFyYW1zOiB7Um9sZUFybjogJy4uLid9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEAhYXR0cmlidXRlIHNlcnZpY2VcbiAqICAgQHJldHVybiBbQVdTLlNUU10gdGhlIFNUUyBzZXJ2aWNlIGluc3RhbmNlIHVzZWQgdG9cbiAqICAgICBnZXQgYW5kIHJlZnJlc2ggdGVtcG9yYXJ5IGNyZWRlbnRpYWxzIGZyb20gQVdTIFNUUy5cbiAqIEBub3RlIChzZWUgY29uc3RydWN0b3IpXG4gKi9cbkFXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRlbXBvcmFyeSBjcmVkZW50aWFscyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFttYXBdIGEgc2V0IG9mIG9wdGlvbnNcbiAgICogQG9wdGlvbiBvcHRpb25zIHBhcmFtcyBbbWFwXSAoe30pIGEgbWFwIG9mIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIHRvIHRoZVxuICAgKiAgIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9ucy5cbiAgICogICBJZiBhIGBSb2xlQXJuYCBwYXJhbWV0ZXIgaXMgcGFzc2VkIGluLCBjcmVkZW50aWFscyB3aWxsIGJlIGJhc2VkIG9uIHRoZVxuICAgKiAgIElBTSByb2xlLiBJZiBhIGBTZXJpYWxOdW1iZXJgIHBhcmFtZXRlciBpcyBwYXNzZWQgaW4sIHt0b2tlbkNvZGVGbn0gbXVzdFxuICAgKiAgIGFsc28gYmUgcGFzc2VkIGluIG9yIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgbWFzdGVyQ3JlZGVudGlhbHMgW0FXUy5DcmVkZW50aWFsc10gdGhlIG1hc3RlciBjcmVkZW50aWFsc1xuICAgKiAgIHVzZWQgdG8gZ2V0IGFuZCByZWZyZXNoIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuIEJ5IGRlZmF1bHQsXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyBvciBBV1MuY29uZmlnLmNyZWRlbnRpYWxQcm92aWRlciB3aWxsIGJlIHVzZWQuXG4gICAqIEBvcHRpb24gb3B0aW9ucyB0b2tlbkNvZGVGbiBbRnVuY3Rpb25dIChudWxsKSBGdW5jdGlvbiB0byBwcm92aWRlXG4gICAqICAgYFRva2VuQ29kZWAsIGlmIGBTZXJpYWxOdW1iZXJgIGlzIHByb3ZpZGVkIGZvciBwcm9maWxlIGluIHtwYXJhbXN9LiBGdW5jdGlvblxuICAgKiAgIGlzIGNhbGxlZCB3aXRoIHZhbHVlIG9mIGBTZXJpYWxOdW1iZXJgIGFuZCBgY2FsbGJhY2tgLCBhbmQgc2hvdWxkIHByb3ZpZGVcbiAgICogICB0aGUgYFRva2VuQ29kZWAgb3IgYW4gZXJyb3IgdG8gdGhlIGNhbGxiYWNrIGluIHRoZSBmb3JtYXRcbiAgICogICBgY2FsbGJhY2soZXJyLCB0b2tlbilgLlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGdlbmVyaWMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBhbiBJQU0gcm9sZVxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAgICogICAgIHBhcmFtczoge1xuICAgKiAgICAgICBSb2xlQXJuOiAnYXJuOmF3czppYW06OjEyMzQ1Njc4OTA6cm9sZS9UZW1wb3JhcnlDcmVkZW50aWFscydcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVcbiAgICogQHNlZSBBV1MuU1RTLmdldFNlc3Npb25Ub2tlblxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIENoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmVycm9yQ29kZSA9ICdDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFsc1Byb3ZpZGVyRmFpbHVyZSc7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnRva2VuQ29kZUZuID0gbnVsbDtcblxuICAgIHZhciBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KG9wdGlvbnMucGFyYW1zKSB8fCB7fTtcbiAgICBpZiAocGFyYW1zLlJvbGVBcm4pIHtcbiAgICAgIHBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgPSBwYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd0ZW1wb3JhcnktY3JlZGVudGlhbHMnO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLlNlcmlhbE51bWJlcikge1xuICAgICAgaWYgKCFvcHRpb25zLnRva2VuQ29kZUZuIHx8ICh0eXBlb2Ygb3B0aW9ucy50b2tlbkNvZGVGbiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFXUy51dGlsLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcigndG9rZW5Db2RlRm4gbXVzdCBiZSBhIGZ1bmN0aW9uIHdoZW4gcGFyYW1zLlNlcmlhbE51bWJlciBpcyBnaXZlbicpLFxuICAgICAgICAgIHtjb2RlOiB0aGlzLmVycm9yQ29kZX1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5Db2RlRm4gPSBvcHRpb25zLnRva2VuQ29kZUZuO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwubWVyZ2UoXG4gICAgICB7XG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjcmVkZW50aWFsczogb3B0aW9ucy5tYXN0ZXJDcmVkZW50aWFscyB8fCBBV1MuY29uZmlnLmNyZWRlbnRpYWxzXG4gICAgICB9LFxuICAgICAgb3B0aW9ucy5zdHNDb25maWcgfHwge31cbiAgICApO1xuICAgIHRoaXMuc2VydmljZSA9IG5ldyBTVFMoY29uZmlnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaGVzIGNyZWRlbnRpYWxzIHVzaW5nIHtBV1MuU1RTLmFzc3VtZVJvbGV9IG9yXG4gICAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0sIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFuIElBTSByb2xlIEFSTiB3YXMgcGFzc2VkXG4gICAqIHRvIHRoZSBjcmVkZW50aWFscyB7Y29uc3RydWN0b3J9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIEFXUy5DcmVkZW50aWFscy5nZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wZXJhdGlvbiA9IHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLlJvbGVBcm4gPyAnYXNzdW1lUm9sZScgOiAnZ2V0U2Vzc2lvblRva2VuJztcbiAgICB0aGlzLmdldFRva2VuQ29kZShmdW5jdGlvbiAoZXJyLCB0b2tlbkNvZGUpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuQ29kZSkge1xuICAgICAgICBwYXJhbXMuVG9rZW5Db2RlID0gdG9rZW5Db2RlO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXJ2aWNlW29wZXJhdGlvbl0ocGFyYW1zLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VG9rZW5Db2RlOiBmdW5jdGlvbiBnZXRUb2tlbkNvZGUoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMudG9rZW5Db2RlRm4pIHtcbiAgICAgIHRoaXMudG9rZW5Db2RlRm4odGhpcy5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuU2VyaWFsTnVtYmVyLCBmdW5jdGlvbiAoZXJyLCB0b2tlbikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnI7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignRXJyb3IgZmV0Y2hpbmcgTUZBIHRva2VuOiAnICsgbWVzc2FnZSksXG4gICAgICAgICAgICAgIHsgY29kZTogc2VsZi5lcnJvckNvZGV9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdG9rZW4pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIENvZ25pdG9JZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvY29nbml0b2lkZW50aXR5Jyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIFNUUyBXZWIgSWRlbnRpdHkgRmVkZXJhdGlvbiB1c2luZ1xuICogdGhlIEFtYXpvbiBDb2duaXRvIElkZW50aXR5IHNlcnZpY2UuXG4gKlxuICogQnkgZGVmYXVsdCB0aGlzIHByb3ZpZGVyIGdldHMgY3JlZGVudGlhbHMgdXNpbmcgdGhlXG4gKiB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5fSBzZXJ2aWNlIG9wZXJhdGlvbiwgd2hpY2hcbiAqIHJlcXVpcmVzIGVpdGhlciBhbiBgSWRlbnRpdHlJZGAgb3IgYW4gYElkZW50aXR5UG9vbElkYCAoQW1hem9uIENvZ25pdG9cbiAqIElkZW50aXR5IFBvb2wgSUQpLCB3aGljaCBpcyB1c2VkIHRvIGNhbGwge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWR9IHRvXG4gKiBvYnRhaW4gYW4gYElkZW50aXR5SWRgLiBJZiB0aGUgaWRlbnRpdHkgb3IgaWRlbnRpdHkgcG9vbCBpcyBub3QgY29uZmlndXJlZCBpblxuICogdGhlIEFtYXpvbiBDb2duaXRvIENvbnNvbGUgdG8gdXNlIElBTSByb2xlcyB3aXRoIHRoZSBhcHByb3ByaWF0ZSBwZXJtaXNzaW9ucyxcbiAqIHRoZW4gYWRkaXRpb25hbGx5IGEgYFJvbGVBcm5gIGlzIHJlcXVpcmVkIGNvbnRhaW5pbmcgdGhlIEFSTiBvZiB0aGUgSUFNIHRydXN0XG4gKiBwb2xpY3kgZm9yIHRoZSBBbWF6b24gQ29nbml0byByb2xlIHRoYXQgdGhlIHVzZXIgd2lsbCBsb2cgaW50by4gSWYgYSBgUm9sZUFybmBcbiAqIGlzIHByb3ZpZGVkLCB0aGVuIHRoaXMgcHJvdmlkZXIgZ2V0cyBjcmVkZW50aWFscyB1c2luZyB0aGVcbiAqIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9IHNlcnZpY2Ugb3BlcmF0aW9uLCBhZnRlciBmaXJzdCBnZXR0aW5nIGFuXG4gKiBPcGVuIElEIHRva2VuIGZyb20ge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LlxuICpcbiAqIEluIGFkZGl0aW9uLCBpZiB0aGlzIGNyZWRlbnRpYWwgcHJvdmlkZXIgaXMgdXNlZCB0byBwcm92aWRlIGF1dGhlbnRpY2F0ZWRcbiAqIGxvZ2luLCB0aGUgYExvZ2luc2AgbWFwIG1heSBiZSBzZXQgdG8gdGhlIHRva2VucyBwcm92aWRlZCBieSB0aGUgcmVzcGVjdGl2ZVxuICogaWRlbnRpdHkgcHJvdmlkZXJzLiBTZWUge2NvbnN0cnVjdG9yfSBmb3IgYW4gZXhhbXBsZSBvbiBjcmVhdGluZyBhIGNyZWRlbnRpYWxzXG4gKiBvYmplY3Qgd2l0aCBwcm9wZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHMgZnJvbSBJZGVudGl0eSBTZXJ2aWNlXG4gKlxuICogSW4gYWRkaXRpb24gdG8gQVdTIGNyZWRlbnRpYWxzIGV4cGlyaW5nIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsIHRoZVxuICogbG9naW4gdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgd2lsbCBhbHNvIGV4cGlyZS4gT25jZSB0aGlzIHRva2VuXG4gKiBleHBpcmVzLCBpdCB3aWxsIG5vdCBiZSB1c2FibGUgdG8gcmVmcmVzaCBBV1MgY3JlZGVudGlhbHMsIGFuZCBhbm90aGVyXG4gKiB0b2tlbiB3aWxsIGJlIG5lZWRlZC4gVGhlIFNESyBkb2VzIG5vdCBtYW5hZ2UgcmVmcmVzaGluZyBvZiB0aGUgdG9rZW4gdmFsdWUsXG4gKiBidXQgdGhpcyBjYW4gYmUgZG9uZSB0aHJvdWdoIGEgXCJyZWZyZXNoIHRva2VuXCIgc3VwcG9ydGVkIGJ5IG1vc3QgaWRlbnRpdHlcbiAqIHByb3ZpZGVycy4gQ29uc3VsdCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGlkZW50aXR5IHByb3ZpZGVyIGZvciByZWZyZXNoaW5nXG4gKiB0b2tlbnMuIE9uY2UgdGhlIHJlZnJlc2hlZCB0b2tlbiBpcyBhY3F1aXJlZCwgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gdXBkYXRlXG4gKiB0aGlzIG5ldyB0b2tlbiBpbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0J3Mge3BhcmFtc30gcHJvcGVydHkuIFRoZSBmb2xsb3dpbmdcbiAqIGNvZGUgd2lsbCB1cGRhdGUgdGhlIFdlYklkZW50aXR5VG9rZW4sIGFzc3VtaW5nIHlvdSBoYXZlIHJldHJpZXZlZCBhbiB1cGRhdGVkXG4gKiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLnBhcmFtcy5Mb2dpbnNbJ2dyYXBoLmZhY2Vib29rLmNvbSddID0gdXBkYXRlZFRva2VuO1xuICogYGBgXG4gKlxuICogRnV0dXJlIGNhbGxzIHRvIGBjcmVkZW50aWFscy5yZWZyZXNoKClgIHdpbGwgbm93IHVzZSB0aGUgbmV3IHRva2VuLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtc1xuICogICBAcmV0dXJuIFttYXBdIHRoZSBtYXAgb2YgcGFyYW1zIHBhc3NlZCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldElkfSxcbiAqICAgICB7QVdTLkNvZ25pdG9JZGVudGl0eS5nZXRPcGVuSWRUb2tlbn0sIGFuZFxuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LiBUbyB1cGRhdGUgdGhlIHRva2VuLCBzZXQgdGhlXG4gKiAgICAgYHBhcmFtcy5XZWJJZGVudGl0eVRva2VuYCBwcm9wZXJ0eS5cbiAqIEAhYXR0cmlidXRlIGRhdGFcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgcmF3IGRhdGEgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbCB0b1xuICogICAgIHtBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHl9LCBvclxuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LiBVc2UgdGhpcyBpZiB5b3Ugd2FudCB0byBnZXRcbiAqICAgICBhY2Nlc3MgdG8gb3RoZXIgcHJvcGVydGllcyBmcm9tIHRoZSByZXNwb25zZS5cbiAqIEAhYXR0cmlidXRlIGlkZW50aXR5SWRcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgQ29nbml0byBJRCByZXR1cm5lZCBieSB0aGUgbGFzdCBjYWxsIHRvXG4gKiAgICAge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0T3BlbklkVG9rZW59LiBUaGlzIElEIHJlcHJlc2VudHMgdGhlIGFjdHVhbFxuICogICAgIGZpbmFsIHJlc29sdmVkIGlkZW50aXR5IElEIGZyb20gQW1hem9uIENvZ25pdG8uXG4gKi9cbkFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyA9IEFXUy51dGlsLmluaGVyaXQoQVdTLkNyZWRlbnRpYWxzLCB7XG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxvY2FsU3RvcmFnZUtleToge1xuICAgIGlkOiAnYXdzLmNvZ25pdG8uaWRlbnRpdHktaWQuJyxcbiAgICBwcm92aWRlcnM6ICdhd3MuY29nbml0by5pZGVudGl0eS1wcm92aWRlcnMuJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdC5cbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMoe1xuICAgKlxuICAgKiAgICAgLy8gZWl0aGVyIElkZW50aXR5UG9vbElkIG9yIElkZW50aXR5SWQgaXMgcmVxdWlyZWRcbiAgICogICAgIC8vIFNlZSB0aGUgSWRlbnRpdHlQb29sSWQgcGFyYW0gZm9yIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SUQgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIC8vIFNlZSB0aGUgSWRlbnRpdHlJZCBwYXJhbSBmb3IgQVdTLkNvZ25pdG9JZGVudGl0eS5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5XG4gICAqICAgICAvLyBvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VuIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBJZGVudGl0eVBvb2xJZDogJ3VzLWVhc3QtMToxNjk5ZWJjMC03OTAwLTQwOTktYjkxMC0yZGY5NGY1MmEwMzAnLFxuICAgKiAgICAgSWRlbnRpdHlJZDogJ3VzLWVhc3QtMToxMjhkMGE3NC1jODJmLTQ1NTMtOTE2ZC05MDA1M2U0YThiMGYnXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCwgb25seSBuZWNlc3Nhcnkgd2hlbiB0aGUgaWRlbnRpdHkgcG9vbCBpcyBub3QgY29uZmlndXJlZFxuICAgKiAgICAgLy8gdG8gdXNlIElBTSByb2xlcyBpbiB0aGUgQW1hem9uIENvZ25pdG8gQ29uc29sZVxuICAgKiAgICAgLy8gU2VlIHRoZSBSb2xlQXJuIHBhcmFtIGZvciBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL01ZQVBQLUNvZ25pdG9JZGVudGl0eScsXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCB0b2tlbnMsIHVzZWQgZm9yIGF1dGhlbnRpY2F0ZWQgbG9naW5cbiAgICogICAgIC8vIFNlZSB0aGUgTG9naW5zIHBhcmFtIGZvciBBV1MuQ29nbml0b0lkZW50aXR5LmdldElEIChsaW5rZWQgYmVsb3cpXG4gICAqICAgICBMb2dpbnM6IHtcbiAgICogICAgICAgJ2dyYXBoLmZhY2Vib29rLmNvbSc6ICdGQlRPS0VOJyxcbiAgICogICAgICAgJ3d3dy5hbWF6b24uY29tJzogJ0FNQVpPTlRPS0VOJyxcbiAgICogICAgICAgJ2FjY291bnRzLmdvb2dsZS5jb20nOiAnR09PR0xFVE9LRU4nLFxuICAgKiAgICAgICAnYXBpLnR3aXR0ZXIuY29tJzogJ1RXSVRURVJUT0tFTicsXG4gICAqICAgICAgICd3d3cuZGlnaXRzLmNvbSc6ICdESUdJVFNUT0tFTidcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCBuYW1lLCBkZWZhdWx0cyB0byB3ZWItaWRlbnRpdHlcbiAgICogICAgIC8vIFNlZSB0aGUgUm9sZVNlc3Npb25OYW1lIHBhcmFtIGZvciBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkgKGxpbmtlZCBiZWxvdylcbiAgICogICAgIFJvbGVTZXNzaW9uTmFtZTogJ3dlYicsXG4gICAqXG4gICAqICAgICAvLyBvcHRpb25hbCwgb25seSBuZWNlc3Nhcnkgd2hlbiBhcHBsaWNhdGlvbiBydW5zIGluIGEgYnJvd3NlclxuICAgKiAgICAgLy8gYW5kIG11bHRpcGxlIHVzZXJzIGFyZSBzaWduZWQgaW4gYXQgb25jZSwgdXNlZCBmb3IgY2FjaGluZ1xuICAgKiAgICAgTG9naW5JZDogJ2V4YW1wbGVAZ21haWwuY29tJ1xuICAgKlxuICAgKiAgIH0sIHtcbiAgICogICAgICAvLyBvcHRpb25hbGx5IHByb3ZpZGUgY29uZmlndXJhdGlvbiB0byBhcHBseSB0byB0aGUgdW5kZXJseWluZyBzZXJ2aWNlIGNsaWVudHNcbiAgICogICAgICAvLyBpZiBjb25maWd1cmF0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlbiBjb25maWd1cmF0aW9uIHdpbGwgYmUgcHVsbGVkIGZyb20gQVdTLmNvbmZpZ1xuICAgKlxuICAgKiAgICAgIC8vIHJlZ2lvbiBzaG91bGQgbWF0Y2ggdGhlIHJlZ2lvbiB5b3VyIGlkZW50aXR5IHBvb2wgaXMgbG9jYXRlZCBpblxuICAgKiAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAqXG4gICAqICAgICAgLy8gc3BlY2lmeSB0aW1lb3V0IG9wdGlvbnNcbiAgICogICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICAgdGltZW91dDogMTAwXG4gICAqICAgICAgfVxuICAgKiAgIH0pO1xuICAgKiBAc2VlIEFXUy5Db2duaXRvSWRlbnRpdHkuZ2V0SWRcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHlcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcbiAgICogQHNlZSBBV1MuQ29nbml0b0lkZW50aXR5LmdldE9wZW5JZFRva2VuXG4gICAqIEBzZWUgQVdTLkNvbmZpZ1xuICAgKiBAbm90ZSBJZiBhIHJlZ2lvbiBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIGdsb2JhbCBBV1MuY29uZmlnLCBvclxuICAgKiAgIHNwZWNpZmllZCBpbiB0aGUgYGNsaWVudENvbmZpZ2AgdG8gdGhlIENvZ25pdG9JZGVudGl0eUNyZWRlbnRpYWxzXG4gICAqICAgY29uc3RydWN0b3IsIHlvdSBtYXkgZW5jb3VudGVyIGEgJ01pc3NpbmcgY3JlZGVudGlhbHMgaW4gY29uZmlnJyBlcnJvclxuICAgKiAgIHdoZW4gY2FsbGluZyBtYWtpbmcgYSBzZXJ2aWNlIGNhbGwuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHMocGFyYW1zLCBjbGllbnRDb25maWcpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5faWRlbnRpdHlJZCA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICAgIHRoaXMubG9hZENhY2hlZElkKCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWRlbnRpdHlJZCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYubG9hZENhY2hlZElkKCk7XG4gICAgICAgIHJldHVybiBzZWxmLl9pZGVudGl0eUlkIHx8IHNlbGYucGFyYW1zLklkZW50aXR5SWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpZGVudGl0eUlkKSB7XG4gICAgICAgIHNlbGYuX2lkZW50aXR5SWQgPSBpZGVudGl0eUlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5Db2duaXRvSWRlbnRpdHkuZ2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eX0sXG4gICAqIG9yIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIEFXUy5DcmVkZW50aWFscy5nZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jcmVhdGVDbGllbnRzKCk7XG4gICAgc2VsZi5kYXRhID0gbnVsbDtcbiAgICBzZWxmLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICBzZWxmLmdldElkKGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgaWYgKCFzZWxmLnBhcmFtcy5Sb2xlQXJuKSB7XG4gICAgICAgICAgc2VsZi5nZXRDcmVkZW50aWFsc0ZvcklkZW50aXR5KGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmdldENyZWRlbnRpYWxzRnJvbVNUUyhjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBDb2duaXRvIElEIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWRcbiAgICogaWRlbnRpdHkgcG9vbCBJRC4gVXNlIHRoaXMgdG8gbWFudWFsbHkgaW52YWxpZGF0ZSB5b3VyIGNhY2hlIGlmXG4gICAqIHRoZSBpZGVudGl0eSBwb29sIElEIHdhcyBkZWxldGVkLlxuICAgKi9cbiAgY2xlYXJDYWNoZWRJZDogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9pZGVudGl0eUlkID0gbnVsbDtcbiAgICBkZWxldGUgdGhpcy5wYXJhbXMuSWRlbnRpdHlJZDtcblxuICAgIHZhciBwb29sSWQgPSB0aGlzLnBhcmFtcy5JZGVudGl0eVBvb2xJZDtcbiAgICB2YXIgbG9naW5JZCA9IHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJyc7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleS5pZCArIHBvb2xJZCArIGxvZ2luSWRdO1xuICAgIGRlbGV0ZSB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXkucHJvdmlkZXJzICsgcG9vbElkICsgbG9naW5JZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2xlYXJJZE9uTm90QXV0aG9yaXplZDogZnVuY3Rpb24gY2xlYXJJZE9uTm90QXV0aG9yaXplZChlcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGVyci5jb2RlID09ICdOb3RBdXRob3JpemVkRXhjZXB0aW9uJykge1xuICAgICAgc2VsZi5jbGVhckNhY2hlZElkKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBDb2duaXRvIElELCBsb2FkaW5nIGZyb20gY2FjaGUgaWYgaXQgd2FzIGFscmVhZHkgcmV0cmlldmVkXG4gICAqIG9uIHRoaXMgZGV2aWNlLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBpZGVudGl0eUlkKVxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yLCBudWxsXSBhbiBlcnJvciBvYmplY3QgaWYgdGhlIGNhbGwgZmFpbGVkIG9yIG51bGwgaWZcbiAgICogICAgIGl0IHN1Y2NlZWRlZC5cbiAgICogICBAcGFyYW0gaWRlbnRpdHlJZCBbU3RyaW5nLCBudWxsXSBpZiBzdWNjZXNzZnVsLCB0aGUgY2FsbGJhY2sgd2lsbCByZXR1cm5cbiAgICogICAgIHRoZSBDb2duaXRvIElELlxuICAgKiBAbm90ZSBJZiBub3QgbG9hZGVkIGV4cGxpY2l0bHksIHRoZSBDb2duaXRvIElEIGlzIGxvYWRlZCBhbmQgc3RvcmVkIGluXG4gICAqICAgbG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IG9mIGEgZGV2aWNlLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldElkOiBmdW5jdGlvbiBnZXRJZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCk7XG4gICAgfVxuXG4gICAgc2VsZi5jb2duaXRvLmdldElkKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YS5JZGVudGl0eUlkKSB7XG4gICAgICAgIHNlbGYucGFyYW1zLklkZW50aXR5SWQgPSBkYXRhLklkZW50aXR5SWQ7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEuSWRlbnRpdHlJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZENyZWRlbnRpYWxzOiBmdW5jdGlvbiBsb2FkQ3JlZGVudGlhbHMoZGF0YSwgY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoIWRhdGEgfHwgIWNyZWRlbnRpYWxzKSByZXR1cm47XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlZCA9IGZhbHNlO1xuICAgIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkID0gZGF0YS5DcmVkZW50aWFscy5BY2Nlc3NLZXlJZDtcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXkgPSBkYXRhLkNyZWRlbnRpYWxzLlNlY3JldEtleTtcbiAgICBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4gPSBkYXRhLkNyZWRlbnRpYWxzLlNlc3Npb25Ub2tlbjtcbiAgICBjcmVkZW50aWFscy5leHBpcmVUaW1lID0gZGF0YS5DcmVkZW50aWFscy5FeHBpcmF0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHk6IGZ1bmN0aW9uIGdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jb2duaXRvLmdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBzZWxmLmNhY2hlSWQoZGF0YSk7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubG9hZENyZWRlbnRpYWxzKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmNsZWFySWRPbk5vdEF1dGhvcml6ZWQoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0Q3JlZGVudGlhbHNGcm9tU1RTOiBmdW5jdGlvbiBnZXRDcmVkZW50aWFsc0Zyb21TVFMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5jb2duaXRvLmdldE9wZW5JZFRva2VuKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5jYWNoZUlkKGRhdGEpO1xuICAgICAgICBzZWxmLnBhcmFtcy5XZWJJZGVudGl0eVRva2VuID0gZGF0YS5Ub2tlbjtcbiAgICAgICAgc2VsZi53ZWJJZGVudGl0eUNyZWRlbnRpYWxzLnJlZnJlc2goZnVuY3Rpb24od2ViRXJyKSB7XG4gICAgICAgICAgaWYgKCF3ZWJFcnIpIHtcbiAgICAgICAgICAgIHNlbGYuZGF0YSA9IHNlbGYud2ViSWRlbnRpdHlDcmVkZW50aWFscy5kYXRhO1xuICAgICAgICAgICAgc2VsZi5zdHMuY3JlZGVudGlhbHNGcm9tKHNlbGYuZGF0YSwgc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKHdlYkVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5jbGVhcklkT25Ob3RBdXRob3JpemVkKGVycik7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZENhY2hlZElkOiBmdW5jdGlvbiBsb2FkQ2FjaGVkSWQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gaW4gdGhlIGJyb3dzZXIgd2Ugc291cmNlIGRlZmF1bHQgSWRlbnRpdHlJZCBmcm9tIGxvY2FsU3RvcmFnZVxuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSAmJiAhc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCkge1xuICAgICAgdmFyIGlkID0gc2VsZi5nZXRTdG9yYWdlKCdpZCcpO1xuICAgICAgaWYgKGlkICYmIHNlbGYucGFyYW1zLkxvZ2lucykge1xuICAgICAgICB2YXIgYWN0dWFsUHJvdmlkZXJzID0gT2JqZWN0LmtleXMoc2VsZi5wYXJhbXMuTG9naW5zKTtcbiAgICAgICAgdmFyIGNhY2hlZFByb3ZpZGVycyA9XG4gICAgICAgICAgKHNlbGYuZ2V0U3RvcmFnZSgncHJvdmlkZXJzJykgfHwgJycpLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgLy8gb25seSBsb2FkIElEIGlmIGF0IGxlYXN0IG9uZSBwcm92aWRlciB1c2VkIHRoaXMgSUQgYmVmb3JlXG4gICAgICAgIHZhciBpbnRlcnNlY3QgPSBjYWNoZWRQcm92aWRlcnMuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICByZXR1cm4gYWN0dWFsUHJvdmlkZXJzLmluZGV4T2YobikgIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBzZWxmLnBhcmFtcy5JZGVudGl0eUlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWQpIHtcbiAgICAgICAgc2VsZi5wYXJhbXMuSWRlbnRpdHlJZCA9IGlkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDbGllbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2xpZW50Q29uZmlnID0gdGhpcy5fY2xpZW50Q29uZmlnO1xuICAgIHRoaXMud2ViSWRlbnRpdHlDcmVkZW50aWFscyA9IHRoaXMud2ViSWRlbnRpdHlDcmVkZW50aWFscyB8fFxuICAgICAgbmV3IEFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzKHRoaXMucGFyYW1zLCBjbGllbnRDb25maWcpO1xuICAgIGlmICghdGhpcy5jb2duaXRvKSB7XG4gICAgICB2YXIgY29nbml0b0NvbmZpZyA9IEFXUy51dGlsLm1lcmdlKHt9LCBjbGllbnRDb25maWcpO1xuICAgICAgY29nbml0b0NvbmZpZy5wYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMuY29nbml0byA9IG5ldyBDb2duaXRvSWRlbnRpdHkoY29nbml0b0NvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMuc3RzID0gdGhpcy5zdHMgfHwgbmV3IFNUUyhjbGllbnRDb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNhY2hlSWQ6IGZ1bmN0aW9uIGNhY2hlSWQoZGF0YSkge1xuICAgIHRoaXMuX2lkZW50aXR5SWQgPSBkYXRhLklkZW50aXR5SWQ7XG4gICAgdGhpcy5wYXJhbXMuSWRlbnRpdHlJZCA9IHRoaXMuX2lkZW50aXR5SWQ7XG5cbiAgICAvLyBjYWNoZSB0aGlzIElkZW50aXR5SWQgaW4gYnJvd3NlciBsb2NhbFN0b3JhZ2UgaWYgcG9zc2libGVcbiAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgIHRoaXMuc2V0U3RvcmFnZSgnaWQnLCBkYXRhLklkZW50aXR5SWQpO1xuXG4gICAgICBpZiAodGhpcy5wYXJhbXMuTG9naW5zKSB7XG4gICAgICAgIHRoaXMuc2V0U3RvcmFnZSgncHJvdmlkZXJzJywgT2JqZWN0LmtleXModGhpcy5wYXJhbXMuTG9naW5zKS5qb2luKCcsJykpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTdG9yYWdlOiBmdW5jdGlvbiBnZXRTdG9yYWdlKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VbdGhpcy5sb2NhbFN0b3JhZ2VLZXlba2V5XSArIHRoaXMucGFyYW1zLklkZW50aXR5UG9vbElkICsgKHRoaXMucGFyYW1zLkxvZ2luSWQgfHwgJycpXTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRTdG9yYWdlOiBmdW5jdGlvbiBzZXRTdG9yYWdlKGtleSwgdmFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc3RvcmFnZVt0aGlzLmxvY2FsU3RvcmFnZUtleVtrZXldICsgdGhpcy5wYXJhbXMuSWRlbnRpdHlQb29sSWQgKyAodGhpcy5wYXJhbXMuTG9naW5JZCB8fCAnJyldID0gdmFsO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc3RvcmFnZTogKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgc3RvcmFnZSA9IEFXUy51dGlsLmlzQnJvd3NlcigpICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UgIT09IG51bGwgJiYgdHlwZW9mIHdpbmRvdy5sb2NhbFN0b3JhZ2UgPT09ICdvYmplY3QnID9cbiAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlIDoge307XG5cbiAgICAgIC8vIFRlc3Qgc2V0L3JlbW92ZSB3aGljaCB3b3VsZCB0aHJvdyBhbiBlcnJvciBpbiBTYWZhcmkncyBwcml2YXRlIGJyb3dzaW5nXG4gICAgICBzdG9yYWdlWydhd3MudGVzdC1zdG9yYWdlJ10gPSAnZm9vYmFyJztcbiAgICAgIGRlbGV0ZSBzdG9yYWdlWydhd3MudGVzdC1zdG9yYWdlJ107XG5cbiAgICAgIHJldHVybiBzdG9yYWdlO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH0pKClcbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBwcm92aWRlciBjaGFpbiB0aGF0IHNlYXJjaGVzIGZvciBBV1MgY3JlZGVudGlhbHNcbiAqIGluIGEgbGlzdCBvZiBjcmVkZW50aWFsIHByb3ZpZGVycyBzcGVjaWZpZWQgYnkgdGhlIHtwcm92aWRlcnN9IHByb3BlcnR5LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBjaGFpbiB3aWxsIHVzZSB0aGUge2RlZmF1bHRQcm92aWRlcnN9IHRvIHJlc29sdmUgY3JlZGVudGlhbHMuXG4gKiBUaGVzZSBwcm92aWRlcnMgd2lsbCBsb29rIGluIHRoZSBlbnZpcm9ubWVudCB1c2luZyB0aGVcbiAqIHtBV1MuRW52aXJvbm1lbnRDcmVkZW50aWFsc30gY2xhc3Mgd2l0aCB0aGUgJ0FXUycgYW5kICdBTUFaT04nIHByZWZpeGVzLlxuICpcbiAqICMjIFNldHRpbmcgUHJvdmlkZXJzXG4gKlxuICogRWFjaCBwcm92aWRlciBpbiB0aGUge3Byb3ZpZGVyc30gbGlzdCBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAqIGEge0FXUy5DcmVkZW50aWFsc30gb2JqZWN0LCBvciBhIGhhcmRjb2RlZCBjcmVkZW50aWFscyBvYmplY3QuIFRoZSBmdW5jdGlvblxuICogZm9ybSBhbGxvd3MgZm9yIGRlbGF5ZWQgZXhlY3V0aW9uIG9mIHRoZSBjcmVkZW50aWFsIGNvbnN0cnVjdGlvbi5cbiAqXG4gKiAjIyBSZXNvbHZpbmcgQ3JlZGVudGlhbHMgZnJvbSBhIENoYWluXG4gKlxuICogQ2FsbCB7cmVzb2x2ZX0gdG8gcmV0dXJuIHRoZSBmaXJzdCB2YWxpZCBjcmVkZW50aWFsIG9iamVjdCB0aGF0IGNhbiBiZVxuICogbG9hZGVkIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdG8gcmVzb2x2ZSBhIGNoYWluIHdpdGggYSBjdXN0b20gcHJvdmlkZXIgdGhhdCBjaGVja3MgYSBmaWxlXG4gKiBvbiBkaXNrIGFmdGVyIHRoZSBzZXQgb2Yge2RlZmF1bHRQcm92aWRlcnN9OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBkaXNrUHJvdmlkZXIgPSBuZXcgQVdTLkZpbGVTeXN0ZW1DcmVkZW50aWFscygnLi9jcmVkcy5qc29uJyk7XG4gKiB2YXIgY2hhaW4gPSBuZXcgQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluKCk7XG4gKiBjaGFpbi5wcm92aWRlcnMucHVzaChkaXNrUHJvdmlkZXIpO1xuICogY2hhaW4ucmVzb2x2ZSgpO1xuICogYGBgXG4gKlxuICogVGhlIGFib3ZlIGNvZGUgd2lsbCByZXR1cm4gdGhlIGBkaXNrUHJvdmlkZXJgIG9iamVjdCBpZiB0aGVcbiAqIGZpbGUgY29udGFpbnMgY3JlZGVudGlhbHMgYW5kIHRoZSBgZGVmYXVsdFByb3ZpZGVyc2AgZG8gbm90IGNvbnRhaW5cbiAqIGFueSBjcmVkZW50aWFsIHNldHRpbmdzLlxuICpcbiAqIEAhYXR0cmlidXRlIHByb3ZpZGVyc1xuICogICBAcmV0dXJuIFtBcnJheTxBV1MuQ3JlZGVudGlhbHMsIEZ1bmN0aW9uPl1cbiAqICAgICBhIGxpc3Qgb2YgY3JlZGVudGlhbHMgb2JqZWN0cyBvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gY3JlZGVudGlhbHNcbiAqICAgICBvYmplY3RzLiBJZiB0aGUgcHJvdmlkZXIgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIHdpbGwgYmVcbiAqICAgICBleGVjdXRlZCBsYXppbHkgd2hlbiB0aGUgcHJvdmlkZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCBmb3IgdmFsaWRcbiAqICAgICBjcmVkZW50aWFscy4gQnkgZGVmYXVsdCwgdGhpcyBvYmplY3Qgd2lsbCBiZSBzZXQgdG8gdGhlXG4gKiAgICAge2RlZmF1bHRQcm92aWRlcnN9LlxuICogICBAc2VlIGRlZmF1bHRQcm92aWRlcnNcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbiB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcHJvdmlkZXJzXG4gICAqIHNwZWNpZmllZCBieSB7ZGVmYXVsdFByb3ZpZGVyc30uXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4ocHJvdmlkZXJzKSB7XG4gICAgaWYgKHByb3ZpZGVycykge1xuICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvdmlkZXJzID0gQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlZmF1bHRQcm92aWRlcnMuc2xpY2UoMCk7XG4gICAgfVxuICAgIHRoaXMucmVzb2x2ZUNhbGxiYWNrcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgcmVzb2x2ZVByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqICAgUmVzb2x2ZXMgdGhlIHByb3ZpZGVyIGNoYWluIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHNldCBvZlxuICAgKiAgIGNyZWRlbnRpYWxzIGluIHtwcm92aWRlcnN9LlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGNyZWRlbnRpYWxzKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBhbmQgdGhlIHByb3ZpZGVyIHJlc29sdmVzIHRoZSBjaGFpblxuICAgKiAgICAgdG8gYSBjcmVkZW50aWFscyBvYmplY3RcbiAgICogICAgIEBwYXJhbSBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgY3JlZGVudGlhbHMgb2JqZWN0IHJlc29sdmVkXG4gICAqICAgICAgIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnJvcilcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGlmIG5vIGNyZWRlbnRpYWxzIGFyZSBmb3VuZC5cbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlc29sdmVgIG1ldGhvZCBjYWxsLlxuICAgKiAgIEBleGFtcGxlIENhbGxpbmcgdGhlIGByZXNvbHZlUHJvbWlzZWAgbWV0aG9kLlxuICAgKiAgICAgdmFyIHByb21pc2UgPSBjaGFpbi5yZXNvbHZlUHJvbWlzZSgpO1xuICAgKiAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNyZWRlbnRpYWxzKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHByb3ZpZGVyIGNoYWluIGJ5IHNlYXJjaGluZyBmb3IgdGhlIGZpcnN0IHNldCBvZlxuICAgKiBjcmVkZW50aWFscyBpbiB7cHJvdmlkZXJzfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgY3JlZGVudGlhbHMpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIHByb3ZpZGVyIHJlc29sdmVzIHRoZSBjaGFpbiB0byBhIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIG9yIG51bGwgaWYgbm8gY3JlZGVudGlhbHMgY2FuIGJlIGZvdW5kLlxuICAgKlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGlmIG5vIGNyZWRlbnRpYWxzIGFyZVxuICAgKiAgICAgZm91bmQuXG4gICAqICAgQHBhcmFtIGNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBjcmVkZW50aWFscyBvYmplY3QgcmVzb2x2ZWRcbiAgICogICAgIGJ5IHRoZSBwcm92aWRlciBjaGFpbi5cbiAgICogQHJldHVybiBbQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluXSB0aGUgcHJvdmlkZXIsIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYucHJvdmlkZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdObyBwcm92aWRlcnMnKSk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5yZXNvbHZlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spID09PSAxKSB7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHByb3ZpZGVycyA9IHNlbGYucHJvdmlkZXJzLnNsaWNlKDApO1xuXG4gICAgICBmdW5jdGlvbiByZXNvbHZlTmV4dChlcnIsIGNyZWRzKSB7XG4gICAgICAgIGlmICgoIWVyciAmJiBjcmVkcykgfHwgaW5kZXggPT09IHByb3ZpZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBBV1MudXRpbC5hcnJheUVhY2goc2VsZi5yZXNvbHZlQ2FsbGJhY2tzLCBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgY3JlZHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNlbGYucmVzb2x2ZUNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm92aWRlciA9IHByb3ZpZGVyc1tpbmRleCsrXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNyZWRzID0gcHJvdmlkZXIuY2FsbCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNyZWRzID0gcHJvdmlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JlZHMuZ2V0KSB7XG4gICAgICAgICAgY3JlZHMuZ2V0KGZ1bmN0aW9uIChnZXRFcnIpIHtcbiAgICAgICAgICAgIHJlc29sdmVOZXh0KGdldEVyciwgZ2V0RXJyID8gbnVsbCA6IGNyZWRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlTmV4dChudWxsLCBjcmVkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZU5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgc2V0IG9mIHByb3ZpZGVycyB1c2VkIGJ5IGEgdmFuaWxsYSBDcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5cbiAqXG4gKiBJbiB0aGUgYnJvd3NlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyA9IFtdXG4gKiBgYGBcbiAqXG4gKiBJbiBOb2RlLmpzOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbi5kZWZhdWx0UHJvdmlkZXJzID0gW1xuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FXUycpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLkVudmlyb25tZW50Q3JlZGVudGlhbHMoJ0FNQVpPTicpOyB9LFxuICogICBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQVdTLlNzb0NyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuU2hhcmVkSW5pRmlsZUNyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRUNTQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Qcm9jZXNzQ3JlZGVudGlhbHMoKTsgfSxcbiAqICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFXUy5Ub2tlbkZpbGVXZWJJZGVudGl0eUNyZWRlbnRpYWxzKCk7IH0sXG4gKiAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBV1MuRUMyTWV0YWRhdGFDcmVkZW50aWFscygpIH1cbiAqIF1cbiAqIGBgYFxuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uZGVmYXVsdFByb3ZpZGVycyA9IFtdO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4uYWRkUHJvbWlzZXNUb0NsYXNzID0gZnVuY3Rpb24gYWRkUHJvbWlzZXNUb0NsYXNzKFByb21pc2VEZXBlbmRlbmN5KSB7XG4gIHRoaXMucHJvdG90eXBlLnJlc29sdmVQcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdyZXNvbHZlJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5yZXNvbHZlUHJvbWlzZTtcbn07XG5cbkFXUy51dGlsLmFkZFByb21pc2VzKEFXUy5DcmVkZW50aWFsUHJvdmlkZXJDaGFpbik7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIFNUUyA9IHJlcXVpcmUoJy4uLy4uL2NsaWVudHMvc3RzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSBTVFMgU0FNTCBzdXBwb3J0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhTQU1MfSBzZXJ2aWNlIG9wZXJhdGlvbi4gVGhpcyBvcGVyYXRpb25cbiAqIHJlcXVpcmVzIGEgYFJvbGVBcm5gIGNvbnRhaW5pbmcgdGhlIEFSTiBvZiB0aGUgSUFNIHRydXN0IHBvbGljeSBmb3IgdGhlXG4gKiBhcHBsaWNhdGlvbiBmb3Igd2hpY2ggY3JlZGVudGlhbHMgd2lsbCBiZSBnaXZlbiwgYXMgd2VsbCBhcyBhIGBQcmluY2lwYWxBcm5gXG4gKiByZXByZXNlbnRpbmcgdGhlIEFSTiBmb3IgdGhlIFNBTUwgaWRlbnRpdHkgcHJvdmlkZXIuIEluIGFkZGl0aW9uLCB0aGVcbiAqIGBTQU1MQXNzZXJ0aW9uYCBtdXN0IGJlIHNldCB0byB0aGUgdG9rZW4gcHJvdmlkZWQgYnkgdGhlIGlkZW50aXR5XG4gKiBwcm92aWRlci4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIGBSb2xlQXJuYCwgYFByaW5jaXBhbEFybmAsIGFuZCBgU0FNTEFzc2VydGlvbmAgdmFsdWVzLlxuICpcbiAqICMjIFJlZnJlc2hpbmcgQ3JlZGVudGlhbHMgZnJvbSBJZGVudGl0eSBTZXJ2aWNlXG4gKlxuICogSW4gYWRkaXRpb24gdG8gQVdTIGNyZWRlbnRpYWxzIGV4cGlyaW5nIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUsIHRoZVxuICogbG9naW4gdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXIgd2lsbCBhbHNvIGV4cGlyZS4gT25jZSB0aGlzIHRva2VuXG4gKiBleHBpcmVzLCBpdCB3aWxsIG5vdCBiZSB1c2FibGUgdG8gcmVmcmVzaCBBV1MgY3JlZGVudGlhbHMsIGFuZCBhbm90aGVyXG4gKiB0b2tlbiB3aWxsIGJlIG5lZWRlZC4gVGhlIFNESyBkb2VzIG5vdCBtYW5hZ2UgcmVmcmVzaGluZyBvZiB0aGUgdG9rZW4gdmFsdWUsXG4gKiBidXQgdGhpcyBjYW4gYmUgZG9uZSB0aHJvdWdoIGEgXCJyZWZyZXNoIHRva2VuXCIgc3VwcG9ydGVkIGJ5IG1vc3QgaWRlbnRpdHlcbiAqIHByb3ZpZGVycy4gQ29uc3VsdCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGlkZW50aXR5IHByb3ZpZGVyIGZvciByZWZyZXNoaW5nXG4gKiB0b2tlbnMuIE9uY2UgdGhlIHJlZnJlc2hlZCB0b2tlbiBpcyBhY3F1aXJlZCwgeW91IHNob3VsZCBtYWtlIHN1cmUgdG8gdXBkYXRlXG4gKiB0aGlzIG5ldyB0b2tlbiBpbiB0aGUgY3JlZGVudGlhbHMgb2JqZWN0J3Mge3BhcmFtc30gcHJvcGVydHkuIFRoZSBmb2xsb3dpbmdcbiAqIGNvZGUgd2lsbCB1cGRhdGUgdGhlIFNBTUxBc3NlcnRpb24sIGFzc3VtaW5nIHlvdSBoYXZlIHJldHJpZXZlZCBhbiB1cGRhdGVkXG4gKiB0b2tlbiBmcm9tIHRoZSBpZGVudGl0eSBwcm92aWRlcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzLnBhcmFtcy5TQU1MQXNzZXJ0aW9uID0gdXBkYXRlZFRva2VuO1xuICogYGBgXG4gKlxuICogRnV0dXJlIGNhbGxzIHRvIGBjcmVkZW50aWFscy5yZWZyZXNoKClgIHdpbGwgbm93IHVzZSB0aGUgbmV3IHRva2VuLlxuICpcbiAqIEAhYXR0cmlidXRlIHBhcmFtc1xuICogICBAcmV0dXJuIFttYXBdIHRoZSBtYXAgb2YgcGFyYW1zIHBhc3NlZCB0b1xuICogICAgIHtBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTH0uIFRvIHVwZGF0ZSB0aGUgdG9rZW4sIHNldCB0aGVcbiAqICAgICBgcGFyYW1zLlNBTUxBc3NlcnRpb25gIHByb3BlcnR5LlxuICovXG5BV1MuU0FNTENyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gKHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTClcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0XG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuU0FNTENyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1NBTUxSb2xlJyxcbiAgICogICAgIFByaW5jaXBhbEFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvU0FNTFByaW5jaXBhbCcsXG4gICAqICAgICBTQU1MQXNzZXJ0aW9uOiAnYmFzZTY0LXRva2VuJywgLy8gYmFzZTY0LWVuY29kZWQgdG9rZW4gZnJvbSBJZFBcbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoU0FNTFxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFNBTUxDcmVkZW50aWFscyhwYXJhbXMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV4cGlyZWQgPSB0cnVlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhTQU1MfVxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgIENhbGxlZCB3aGVuIHRoZSBTVFMgc2VydmljZSByZXNwb25kcyAob3IgZmFpbHMpLiBXaGVuXG4gICAqICAgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBubyBlcnJvciwgaXQgbWVhbnMgdGhhdCB0aGUgY3JlZGVudGlhbHNcbiAgICogICBpbmZvcm1hdGlvbiBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgb2JqZWN0IChhcyB0aGUgYGFjY2Vzc0tleUlkYCxcbiAgICogICBgc2VjcmV0QWNjZXNzS2V5YCwgYW5kIGBzZXNzaW9uVG9rZW5gIHByb3BlcnRpZXMpLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSBpZiBhbiBlcnJvciBvY2N1cnJlZCwgdGhpcyB2YWx1ZSB3aWxsIGJlIGZpbGxlZFxuICAgKiBAc2VlIGdldFxuICAgKi9cbiAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuY3JlYXRlQ2xpZW50cygpO1xuICAgIHNlbGYuc2VydmljZS5hc3N1bWVSb2xlV2l0aFNBTUwoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5zZXJ2aWNlIHx8IG5ldyBTVFMoe3BhcmFtczogdGhpcy5wYXJhbXN9KTtcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRlbXBvcmFyeSBjcmVkZW50aWFscyByZXRyaWV2ZWQgZnJvbSB7QVdTLlNUU30uIFdpdGhvdXQgYW55XG4gKiBleHRyYSBwYXJhbWV0ZXJzLCBjcmVkZW50aWFscyB3aWxsIGJlIGZldGNoZWQgZnJvbSB0aGVcbiAqIHtBV1MuU1RTLmdldFNlc3Npb25Ub2tlbn0gb3BlcmF0aW9uLiBJZiBhbiBJQU0gcm9sZSBpcyBwcm92aWRlZCwgdGhlXG4gKiB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvcGVyYXRpb24gd2lsbCBiZSB1c2VkIHRvIGZldGNoIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAqIHJvbGUgaW5zdGVhZC5cbiAqXG4gKiBAbm90ZSBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgaXMgZGVwcmVjYXRlZCwgYnV0IHJlbWFpbnMgYXZhaWxhYmxlIGZvclxuICogICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4ge0FXUy5DaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFsc30gaXMgdGhlXG4gKiAgIHByZWZlcnJlZCBjbGFzcyBmb3IgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLlxuICpcbiAqIFRvIHNldHVwIHRlbXBvcmFyeSBjcmVkZW50aWFscywgY29uZmlndXJlIGEgc2V0IG9mIG1hc3RlciBjcmVkZW50aWFsc1xuICogdXNpbmcgdGhlIHN0YW5kYXJkIGNyZWRlbnRpYWxzIHByb3ZpZGVycyAoZW52aXJvbm1lbnQsIEVDMiBpbnN0YW5jZSBtZXRhZGF0YSxcbiAqIG9yIGZyb20gdGhlIGZpbGVzeXN0ZW0pLCB0aGVuIHNldCB0aGUgZ2xvYmFsIGNyZWRlbnRpYWxzIHRvIGEgbmV3XG4gKiB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgb2JqZWN0OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIE5vdGUgdGhhdCBlbnZpcm9ubWVudCBjcmVkZW50aWFscyBhcmUgbG9hZGVkIGJ5IGRlZmF1bHQsXG4gKiAvLyB0aGUgZm9sbG93aW5nIGxpbmUgaXMgc2hvd24gZm9yIGNsYXJpdHk6XG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5FbnZpcm9ubWVudENyZWRlbnRpYWxzKCdBV1MnKTtcbiAqXG4gKiAvLyBOb3cgc2V0IHRlbXBvcmFyeSBjcmVkZW50aWFscyBzZWVkZWQgZnJvbSB0aGUgbWFzdGVyIGNyZWRlbnRpYWxzXG4gKiBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICpcbiAqIC8vIHN1YnNlcXVlbnQgcmVxdWVzdHMgd2lsbCBub3cgdXNlIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuXG4gKiBuZXcgQVdTLlMzKCkubGlzdEJ1Y2tldChmdW5jdGlvbihlcnIsIGRhdGEpIHsgLi4uIH0pO1xuICogYGBgXG4gKlxuICogQCFhdHRyaWJ1dGUgbWFzdGVyQ3JlZGVudGlhbHNcbiAqICAgQHJldHVybiBbQVdTLkNyZWRlbnRpYWxzXSB0aGUgbWFzdGVyIChub24tdGVtcG9yYXJ5KSBjcmVkZW50aWFscyB1c2VkIHRvXG4gKiAgICAgZ2V0IGFuZCByZWZyZXNoIHRlbXBvcmFyeSBjcmVkZW50aWFscyBmcm9tIEFXUyBTVFMuXG4gKiBAbm90ZSAoc2VlIGNvbnN0cnVjdG9yKVxuICovXG5BV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5DcmVkZW50aWFscywge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBJbiBvcmRlciB0byBjcmVhdGUgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLCB5b3UgZmlyc3QgbmVlZCB0byBoYXZlXG4gICAqICAgXCJtYXN0ZXJcIiBjcmVkZW50aWFscyBjb25maWd1cmVkIGluIHtBV1MuQ29uZmlnLmNyZWRlbnRpYWxzfS4gVGhlc2VcbiAgICogICBtYXN0ZXIgY3JlZGVudGlhbHMgYXJlIG5lY2Vzc2FyeSB0byByZXRyaWV2ZSB0aGUgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzLFxuICAgKiAgIGFzIHdlbGwgYXMgcmVmcmVzaCB0aGUgY3JlZGVudGlhbHMgd2hlbiB0aGV5IGV4cGlyZS5cbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBvcHRpb25zIHRoYXQgYXJlIHBhc3NlZCB0byB0aGVcbiAgICogICB7QVdTLlNUUy5hc3N1bWVSb2xlfSBvciB7QVdTLlNUUy5nZXRTZXNzaW9uVG9rZW59IG9wZXJhdGlvbnMuXG4gICAqICAgSWYgYSBgUm9sZUFybmAgcGFyYW1ldGVyIGlzIHBhc3NlZCBpbiwgY3JlZGVudGlhbHMgd2lsbCBiZSBiYXNlZCBvbiB0aGVcbiAgICogICBJQU0gcm9sZS5cbiAgICogQHBhcmFtIG1hc3RlckNyZWRlbnRpYWxzIFtBV1MuQ3JlZGVudGlhbHNdIHRoZSBtYXN0ZXIgKG5vbi10ZW1wb3JhcnkpIGNyZWRlbnRpYWxzXG4gICAqICB1c2VkIHRvIGdldCBhbmQgcmVmcmVzaCB0ZW1wb3JhcnkgY3JlZGVudGlhbHMgZnJvbSBBV1MgU1RTLlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIG5ldyBjcmVkZW50aWFscyBvYmplY3QgZm9yIGdlbmVyaWMgdGVtcG9yYXJ5IGNyZWRlbnRpYWxzXG4gICAqICAgQVdTLmNvbmZpZy5jcmVkZW50aWFscyA9IG5ldyBBV1MuVGVtcG9yYXJ5Q3JlZGVudGlhbHMoKTtcbiAgICogQGV4YW1wbGUgQ3JlYXRpbmcgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0IGZvciBhbiBJQU0gcm9sZVxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAgICogICAgIFJvbGVBcm46ICdhcm46YXdzOmlhbTo6MTIzNDU2Nzg5MDpyb2xlL1RlbXBvcmFyeUNyZWRlbnRpYWxzJyxcbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVcbiAgICogQHNlZSBBV1MuU1RTLmdldFNlc3Npb25Ub2tlblxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFRlbXBvcmFyeUNyZWRlbnRpYWxzKHBhcmFtcywgbWFzdGVyQ3JlZGVudGlhbHMpIHtcbiAgICBBV1MuQ3JlZGVudGlhbHMuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxvYWRNYXN0ZXJDcmVkZW50aWFscyhtYXN0ZXJDcmVkZW50aWFscyk7XG4gICAgdGhpcy5leHBpcmVkID0gdHJ1ZTtcblxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGlmICh0aGlzLnBhcmFtcy5Sb2xlQXJuKSB7XG4gICAgICB0aGlzLnBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgPVxuICAgICAgICB0aGlzLnBhcmFtcy5Sb2xlU2Vzc2lvbk5hbWUgfHwgJ3RlbXBvcmFyeS1jcmVkZW50aWFscyc7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZX0gb3JcbiAgICoge0FXUy5TVFMuZ2V0U2Vzc2lvblRva2VufSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYW4gSUFNIHJvbGUgQVJOIHdhcyBwYXNzZWRcbiAgICogdG8gdGhlIGNyZWRlbnRpYWxzIHtjb25zdHJ1Y3Rvcn0uXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgQ2FsbGVkIHdoZW4gdGhlIFNUUyBzZXJ2aWNlIHJlc3BvbmRzIChvciBmYWlscykuIFdoZW5cbiAgICogICB0aGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG5vIGVycm9yLCBpdCBtZWFucyB0aGF0IHRoZSBjcmVkZW50aWFsc1xuICAgKiAgIGluZm9ybWF0aW9uIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSBvYmplY3QgKGFzIHRoZSBgYWNjZXNzS2V5SWRgLFxuICAgKiAgIGBzZWNyZXRBY2Nlc3NLZXlgLCBhbmQgYHNlc3Npb25Ub2tlbmAgcHJvcGVydGllcykuXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGlmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIHZhbHVlIHdpbGwgYmUgZmlsbGVkXG4gICAqIEBzZWUgZ2V0XG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoIChjYWxsYmFjaykge1xuICAgIHRoaXMuY29hbGVzY2VSZWZyZXNoKGNhbGxiYWNrIHx8IEFXUy51dGlsLmZuLmNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkOiBmdW5jdGlvbiBsb2FkIChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLm1hc3RlckNyZWRlbnRpYWxzLmdldChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzID0gc2VsZi5tYXN0ZXJDcmVkZW50aWFscztcbiAgICAgIHZhciBvcGVyYXRpb24gPSBzZWxmLnBhcmFtcy5Sb2xlQXJuID9cbiAgICAgICAgc2VsZi5zZXJ2aWNlLmFzc3VtZVJvbGUgOiBzZWxmLnNlcnZpY2UuZ2V0U2Vzc2lvblRva2VuO1xuICAgICAgb3BlcmF0aW9uLmNhbGwoc2VsZi5zZXJ2aWNlLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZE1hc3RlckNyZWRlbnRpYWxzOiBmdW5jdGlvbiBsb2FkTWFzdGVyQ3JlZGVudGlhbHMgKG1hc3RlckNyZWRlbnRpYWxzKSB7XG4gICAgdGhpcy5tYXN0ZXJDcmVkZW50aWFscyA9IG1hc3RlckNyZWRlbnRpYWxzIHx8IEFXUy5jb25maWcuY3JlZGVudGlhbHM7XG4gICAgd2hpbGUgKHRoaXMubWFzdGVyQ3JlZGVudGlhbHMubWFzdGVyQ3JlZGVudGlhbHMpIHtcbiAgICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSB0aGlzLm1hc3RlckNyZWRlbnRpYWxzLm1hc3RlckNyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5tYXN0ZXJDcmVkZW50aWFscy5nZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMubWFzdGVyQ3JlZGVudGlhbHMgPSBuZXcgQVdTLkNyZWRlbnRpYWxzKHRoaXMubWFzdGVyQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVDbGllbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gdGhpcy5zZXJ2aWNlIHx8IG5ldyBTVFMoe3BhcmFtczogdGhpcy5wYXJhbXN9KTtcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgU1RTID0gcmVxdWlyZSgnLi4vLi4vY2xpZW50cy9zdHMnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNyZWRlbnRpYWxzIHJldHJpZXZlZCBmcm9tIFNUUyBXZWIgSWRlbnRpdHkgRmVkZXJhdGlvbiBzdXBwb3J0LlxuICpcbiAqIEJ5IGRlZmF1bHQgdGhpcyBwcm92aWRlciBnZXRzIGNyZWRlbnRpYWxzIHVzaW5nIHRoZVxuICoge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX0gc2VydmljZSBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uXG4gKiByZXF1aXJlcyBhIGBSb2xlQXJuYCBjb250YWluaW5nIHRoZSBBUk4gb2YgdGhlIElBTSB0cnVzdCBwb2xpY3kgZm9yIHRoZVxuICogYXBwbGljYXRpb24gZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHdpbGwgYmUgZ2l2ZW4uIEluIGFkZGl0aW9uLCB0aGVcbiAqIGBXZWJJZGVudGl0eVRva2VuYCBtdXN0IGJlIHNldCB0byB0aGUgdG9rZW4gcHJvdmlkZWQgYnkgdGhlIGlkZW50aXR5XG4gKiBwcm92aWRlci4gU2VlIHtjb25zdHJ1Y3Rvcn0gZm9yIGFuIGV4YW1wbGUgb24gY3JlYXRpbmcgYSBjcmVkZW50aWFsc1xuICogb2JqZWN0IHdpdGggcHJvcGVyIGBSb2xlQXJuYCBhbmQgYFdlYklkZW50aXR5VG9rZW5gIHZhbHVlcy5cbiAqXG4gKiAjIyBSZWZyZXNoaW5nIENyZWRlbnRpYWxzIGZyb20gSWRlbnRpdHkgU2VydmljZVxuICpcbiAqIEluIGFkZGl0aW9uIHRvIEFXUyBjcmVkZW50aWFscyBleHBpcmluZyBhZnRlciBhIGdpdmVuIGFtb3VudCBvZiB0aW1lLCB0aGVcbiAqIGxvZ2luIHRva2VuIGZyb20gdGhlIGlkZW50aXR5IHByb3ZpZGVyIHdpbGwgYWxzbyBleHBpcmUuIE9uY2UgdGhpcyB0b2tlblxuICogZXhwaXJlcywgaXQgd2lsbCBub3QgYmUgdXNhYmxlIHRvIHJlZnJlc2ggQVdTIGNyZWRlbnRpYWxzLCBhbmQgYW5vdGhlclxuICogdG9rZW4gd2lsbCBiZSBuZWVkZWQuIFRoZSBTREsgZG9lcyBub3QgbWFuYWdlIHJlZnJlc2hpbmcgb2YgdGhlIHRva2VuIHZhbHVlLFxuICogYnV0IHRoaXMgY2FuIGJlIGRvbmUgdGhyb3VnaCBhIFwicmVmcmVzaCB0b2tlblwiIHN1cHBvcnRlZCBieSBtb3N0IGlkZW50aXR5XG4gKiBwcm92aWRlcnMuIENvbnN1bHQgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBpZGVudGl0eSBwcm92aWRlciBmb3IgcmVmcmVzaGluZ1xuICogdG9rZW5zLiBPbmNlIHRoZSByZWZyZXNoZWQgdG9rZW4gaXMgYWNxdWlyZWQsIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHVwZGF0ZVxuICogdGhpcyBuZXcgdG9rZW4gaW4gdGhlIGNyZWRlbnRpYWxzIG9iamVjdCdzIHtwYXJhbXN9IHByb3BlcnR5LiBUaGUgZm9sbG93aW5nXG4gKiBjb2RlIHdpbGwgdXBkYXRlIHRoZSBXZWJJZGVudGl0eVRva2VuLCBhc3N1bWluZyB5b3UgaGF2ZSByZXRyaWV2ZWQgYW4gdXBkYXRlZFxuICogdG9rZW4gZnJvbSB0aGUgaWRlbnRpdHkgcHJvdmlkZXI6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogQVdTLmNvbmZpZy5jcmVkZW50aWFscy5wYXJhbXMuV2ViSWRlbnRpdHlUb2tlbiA9IHVwZGF0ZWRUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEZ1dHVyZSBjYWxscyB0byBgY3JlZGVudGlhbHMucmVmcmVzaCgpYCB3aWxsIG5vdyB1c2UgdGhlIG5ldyB0b2tlbi5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBwYXJhbXNcbiAqICAgQHJldHVybiBbbWFwXSB0aGUgbWFwIG9mIHBhcmFtcyBwYXNzZWQgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVG8gdXBkYXRlIHRoZSB0b2tlbiwgc2V0IHRoZVxuICogICAgIGBwYXJhbXMuV2ViSWRlbnRpdHlUb2tlbmAgcHJvcGVydHkuXG4gKiBAIWF0dHJpYnV0ZSBkYXRhXG4gKiAgIEByZXR1cm4gW21hcF0gdGhlIHJhdyBkYXRhIHJlc3BvbnNlIGZyb20gdGhlIGNhbGwgdG9cbiAqICAgICB7QVdTLlNUUy5hc3N1bWVSb2xlV2l0aFdlYklkZW50aXR5fS4gVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8gZ2V0XG4gKiAgICAgYWNjZXNzIHRvIG90aGVyIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVzcG9uc2UuXG4gKi9cbkFXUy5XZWJJZGVudGl0eUNyZWRlbnRpYWxzID0gQVdTLnV0aWwuaW5oZXJpdChBV1MuQ3JlZGVudGlhbHMsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgb2JqZWN0LlxuICAgKiBAcGFyYW0gKHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHkpXG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGEgbmV3IGNyZWRlbnRpYWxzIG9iamVjdFxuICAgKiAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBuZXcgQVdTLldlYklkZW50aXR5Q3JlZGVudGlhbHMoe1xuICAgKiAgICAgUm9sZUFybjogJ2Fybjphd3M6aWFtOjoxMjM0NTY3ODkwOnJvbGUvV2ViSWRlbnRpdHknLFxuICAgKiAgICAgV2ViSWRlbnRpdHlUb2tlbjogJ0FCQ0RFRkdISUpLTE1OT1AnLCAvLyB0b2tlbiBmcm9tIGlkZW50aXR5IHNlcnZpY2VcbiAgICogICAgIFJvbGVTZXNzaW9uTmFtZTogJ3dlYicgLy8gb3B0aW9uYWwgbmFtZSwgZGVmYXVsdHMgdG8gd2ViLWlkZW50aXR5XG4gICAqICAgfSwge1xuICAgKiAgICAgLy8gb3B0aW9uYWxseSBwcm92aWRlIGNvbmZpZ3VyYXRpb24gdG8gYXBwbHkgdG8gdGhlIHVuZGVybHlpbmcgQVdTLlNUUyBzZXJ2aWNlIGNsaWVudFxuICAgKiAgICAgLy8gaWYgY29uZmlndXJhdGlvbiBpcyBub3QgcHJvdmlkZWQsIHRoZW4gY29uZmlndXJhdGlvbiB3aWxsIGJlIHB1bGxlZCBmcm9tIEFXUy5jb25maWdcbiAgICpcbiAgICogICAgIC8vIHNwZWNpZnkgdGltZW91dCBvcHRpb25zXG4gICAqICAgICBodHRwT3B0aW9uczoge1xuICAgKiAgICAgICB0aW1lb3V0OiAxMDBcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogQHNlZSBBV1MuU1RTLmFzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHlcbiAgICogQHNlZSBBV1MuQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gV2ViSWRlbnRpdHlDcmVkZW50aWFscyhwYXJhbXMsIGNsaWVudENvbmZpZykge1xuICAgIEFXUy5DcmVkZW50aWFscy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZXhwaXJlZCA9IHRydWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lID0gdGhpcy5wYXJhbXMuUm9sZVNlc3Npb25OYW1lIHx8ICd3ZWItaWRlbnRpdHknO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5fY2xpZW50Q29uZmlnID0gQVdTLnV0aWwuY29weShjbGllbnRDb25maWcgfHwge30pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgY3JlZGVudGlhbHMgdXNpbmcge0FXUy5TVFMuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eX1cbiAgICpcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVycilcbiAgICogICBDYWxsZWQgd2hlbiB0aGUgU1RTIHNlcnZpY2UgcmVzcG9uZHMgKG9yIGZhaWxzKS4gV2hlblxuICAgKiAgIHRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggbm8gZXJyb3IsIGl0IG1lYW5zIHRoYXQgdGhlIGNyZWRlbnRpYWxzXG4gICAqICAgaW5mb3JtYXRpb24gaGFzIGJlZW4gbG9hZGVkIGludG8gdGhlIG9iamVjdCAoYXMgdGhlIGBhY2Nlc3NLZXlJZGAsXG4gICAqICAgYHNlY3JldEFjY2Vzc0tleWAsIGFuZCBgc2Vzc2lvblRva2VuYCBwcm9wZXJ0aWVzKS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogQHNlZSBnZXRcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvYWxlc2NlUmVmcmVzaChjYWxsYmFjayB8fCBBV1MudXRpbC5mbi5jYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZDogZnVuY3Rpb24gbG9hZChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmNyZWF0ZUNsaWVudHMoKTtcbiAgICBzZWxmLnNlcnZpY2UuYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eShmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICBzZWxmLmRhdGEgPSBudWxsO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgc2VsZi5kYXRhID0gZGF0YTtcbiAgICAgICAgc2VsZi5zZXJ2aWNlLmNyZWRlbnRpYWxzRnJvbShkYXRhLCBzZWxmKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlQ2xpZW50czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2UpIHtcbiAgICAgIHZhciBzdHNDb25maWcgPSBBV1MudXRpbC5tZXJnZSh7fSwgdGhpcy5fY2xpZW50Q29uZmlnKTtcbiAgICAgIHN0c0NvbmZpZy5wYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMuc2VydmljZSA9IG5ldyBTVFMoc3RzQ29uZmlnKTtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZEVudnMgPSBbJ0FXU19FTkFCTEVfRU5EUE9JTlRfRElTQ09WRVJZJywgJ0FXU19FTkRQT0lOVF9ESVNDT1ZFUllfRU5BQkxFRCddO1xuXG4vKipcbiAqIEdlbmVyYXRlIGtleSAoZXhjZXB0IHJlc291cmNlcyBhbmQgb3BlcmF0aW9uIHBhcnQpIHRvIGluZGV4IHRoZSBlbmRwb2ludHMgaW4gdGhlIGNhY2hlXG4gKiBJZiBpbnB1dCBzaGFwZSBoYXMgZW5kcG9pbnRkaXNjb3ZlcnlpZCB0cmFpdCB0aGVuIHVzZVxuICogICBhY2Nlc3NLZXkgKyBvcGVyYXRpb24gKyByZXNvdXJjZXMgKyByZWdpb24gKyBzZXJ2aWNlIGFzIGNhY2hlIGtleVxuICogSWYgaW5wdXQgc2hhcGUgZG9lc24ndCBoYXZlIGVuZHBvaW50ZGlzY292ZXJ5aWQgdHJhaXQgdGhlbiB1c2VcbiAqICAgYWNjZXNzS2V5ICsgcmVnaW9uICsgc2VydmljZSBhcyBjYWNoZSBrZXlcbiAqIEByZXR1cm4gW21hcDxTdHJpbmcsU3RyaW5nPl0gb2JqZWN0IHdpdGgga2V5cyB0byBpbmRleCBlbmRwb2ludHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2FjaGVLZXkocmVxdWVzdCkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZTtcbiAgdmFyIGFwaSA9IHNlcnZpY2UuYXBpIHx8IHt9O1xuICB2YXIgb3BlcmF0aW9ucyA9IGFwaS5vcGVyYXRpb25zO1xuICB2YXIgaWRlbnRpZmllcnMgPSB7fTtcbiAgaWYgKHNlcnZpY2UuY29uZmlnLnJlZ2lvbikge1xuICAgIGlkZW50aWZpZXJzLnJlZ2lvbiA9IHNlcnZpY2UuY29uZmlnLnJlZ2lvbjtcbiAgfVxuICBpZiAoYXBpLnNlcnZpY2VJZCkge1xuICAgIGlkZW50aWZpZXJzLnNlcnZpY2VJZCA9IGFwaS5zZXJ2aWNlSWQ7XG4gIH1cbiAgaWYgKHNlcnZpY2UuY29uZmlnLmNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkKSB7XG4gICAgaWRlbnRpZmllcnMuYWNjZXNzS2V5SWQgPSBzZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZDtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlIGhlbHBlciBmb3IgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycygpLlxuICogTG9va3MgZm9yIHJlcXVpcmVkIHN0cmluZyBpbnB1dCBtZW1iZXJzIHRoYXQgaGF2ZSAnZW5kcG9pbnRkaXNjb3ZlcnlpZCcgdHJhaXQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihyZXN1bHQsIHBhcmFtcywgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSB8fCBwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMgPT09IG51bGwpIHJldHVybjtcbiAgaWYgKHNoYXBlLnR5cGUgPT09ICdzdHJ1Y3R1cmUnICYmIHNoYXBlLnJlcXVpcmVkICYmIHNoYXBlLnJlcXVpcmVkLmxlbmd0aCA+IDApIHtcbiAgICB1dGlsLmFycmF5RWFjaChzaGFwZS5yZXF1aXJlZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1tuYW1lXTtcbiAgICAgIGlmIChtZW1iZXJTaGFwZS5lbmRwb2ludERpc2NvdmVyeUlkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgICAgICByZXN1bHRbbG9jYXRpb25OYW1lXSA9IFN0cmluZyhwYXJhbXNbbmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyc0hlbHBlcihyZXN1bHQsIHBhcmFtc1tuYW1lXSwgbWVtYmVyU2hhcGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGN1c3RvbSBpZGVudGlmaWVycyBmb3IgY2FjaGUga2V5LlxuICogSWRlbnRpZmllcyBjdXN0b20gaWRlbnRpZmllcnMgYnkgY2hlY2tpbmcgZWFjaCBzaGFwZSdzIGBlbmRwb2ludERpc2NvdmVyeUlkYCB0cmFpdC5cbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIFtvYmplY3RdIGlucHV0IHNoYXBlIG9mIHRoZSBnaXZlbiBvcGVyYXRpb24ncyBhcGlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIHNoYXBlKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IHt9O1xuICBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzSGVscGVyKGlkZW50aWZpZXJzLCByZXF1ZXN0LnBhcmFtcywgc2hhcGUpO1xuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbi8qKlxuICogQ2FsbCBlbmRwb2ludCBkaXNjb3Zlcnkgb3BlcmF0aW9uIHdoZW4gaXQncyBvcHRpb25hbC5cbiAqIFdoZW4gZW5kcG9pbnQgaXMgYXZhaWxhYmxlIGluIGNhY2hlIHRoZW4gdXNlIHRoZSBjYWNoZWQgZW5kcG9pbnRzLiBJZiBlbmRwb2ludHNcbiAqIGFyZSB1bmF2YWlsYWJsZSB0aGVuIHVzZSByZWdpb25hbCBlbmRwb2ludHMgYW5kIGNhbGwgZW5kcG9pbnQgZGlzY292ZXJ5IG9wZXJhdGlvblxuICogYXN5bmNocm9ub3VzbHkuIFRoaXMgaXMgdHVybmVkIG9mZiBieSBkZWZhdWx0LlxuICogQHBhcmFtIFtvYmplY3RdIHJlcXVlc3Qgb2JqZWN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWxEaXNjb3ZlckVuZHBvaW50KHJlcXVlc3QpIHtcbiAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gIHZhciBhcGkgPSBzZXJ2aWNlLmFwaTtcbiAgdmFyIG9wZXJhdGlvbk1vZGVsID0gYXBpLm9wZXJhdGlvbnMgPyBhcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0gOiB1bmRlZmluZWQ7XG4gIHZhciBpbnB1dFNoYXBlID0gb3BlcmF0aW9uTW9kZWwgPyBvcGVyYXRpb25Nb2RlbC5pbnB1dCA6IHVuZGVmaW5lZDtcblxuICB2YXIgaWRlbnRpZmllcnMgPSBtYXJzaGFsbEN1c3RvbUlkZW50aWZpZXJzKHJlcXVlc3QsIGlucHV0U2hhcGUpO1xuICB2YXIgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShyZXF1ZXN0KTtcbiAgaWYgKE9iamVjdC5rZXlzKGlkZW50aWZpZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgY2FjaGVLZXkgPSB1dGlsLnVwZGF0ZShjYWNoZUtleSwgaWRlbnRpZmllcnMpO1xuICAgIGlmIChvcGVyYXRpb25Nb2RlbCkgY2FjaGVLZXkub3BlcmF0aW9uID0gb3BlcmF0aW9uTW9kZWwubmFtZTtcbiAgfVxuICB2YXIgZW5kcG9pbnRzID0gQVdTLmVuZHBvaW50Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKGVuZHBvaW50cyAmJiBlbmRwb2ludHMubGVuZ3RoID09PSAxICYmIGVuZHBvaW50c1swXS5BZGRyZXNzID09PSAnJykge1xuICAgIC8vZW5kcG9pbnQgb3BlcmF0aW9uIGlzIGJlaW5nIG1hZGUgYnV0IHJlc3BvbnNlIG5vdCB5ZXQgcmVjZWl2ZWRcbiAgICAvL29yIGVuZHBvaW50IG9wZXJhdGlvbiBqdXN0IGZhaWxlZCBpbiAxIG1pbnV0ZVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAvL2ZvdW5kIGVuZHBvaW50IHJlY29yZCBmcm9tIGNhY2hlXG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChlbmRwb2ludHNbMF0uQWRkcmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgLy9lbmRwb2ludCByZWNvcmQgbm90IGluIGNhY2hlIG9yIG91dGRhdGVkLiBtYWtlIGRpc2NvdmVyeSBvcGVyYXRpb25cbiAgICB2YXIgZW5kcG9pbnRSZXF1ZXN0ID0gc2VydmljZS5tYWtlUmVxdWVzdChhcGkuZW5kcG9pbnRPcGVyYXRpb24sIHtcbiAgICAgIE9wZXJhdGlvbjogb3BlcmF0aW9uTW9kZWwubmFtZSxcbiAgICAgIElkZW50aWZpZXJzOiBpZGVudGlmaWVycyxcbiAgICB9KTtcbiAgICBhZGRBcGlWZXJzaW9uSGVhZGVyKGVuZHBvaW50UmVxdWVzdCk7XG4gICAgZW5kcG9pbnRSZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLlZBTElEQVRFX1BBUkFNRVRFUlMpO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmV0cnknLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5SRVRSWV9DSEVDSyk7XG4gICAgLy9wdXQgaW4gYSBwbGFjZWhvbGRlciBmb3IgZW5kcG9pbnRzIGFscmVhZHkgcmVxdWVzdGVkLCBwcmV2ZW50XG4gICAgLy90b28gbXVjaCBpbi1mbGlnaHQgY2FsbHNcbiAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXksIFt7XG4gICAgICBBZGRyZXNzOiAnJyxcbiAgICAgIENhY2hlUGVyaW9kSW5NaW51dGVzOiAxXG4gICAgfV0pO1xuICAgIGVuZHBvaW50UmVxdWVzdC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5FbmRwb2ludHMpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5LCBkYXRhLkVuZHBvaW50cyk7XG4gICAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgICBBV1MuZW5kcG9pbnRDYWNoZS5wdXQoY2FjaGVLZXksIFt7XG4gICAgICAgICAgQWRkcmVzczogJycsXG4gICAgICAgICAgQ2FjaGVQZXJpb2RJbk1pbnV0ZXM6IDEgLy9ub3QgdG8gbWFrZSBtb3JlIGVuZHBvaW50IG9wZXJhdGlvbiBpbiBuZXh0IDEgbWludXRlXG4gICAgICAgIH1dKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG52YXIgcmVxdWVzdFF1ZXVlID0ge307XG5cbi8qKlxuICogQ2FsbCBlbmRwb2ludCBkaXNjb3Zlcnkgb3BlcmF0aW9uIHdoZW4gaXQncyByZXF1aXJlZC5cbiAqIFdoZW4gZW5kcG9pbnQgaXMgYXZhaWxhYmxlIGluIGNhY2hlIHRoZW4gdXNlIGNhY2hlZCBvbmVzLiBJZiBlbmRwb2ludHMgYXJlXG4gKiB1bmF2YWlsYWJsZSB0aGVuIFNESyBzaG91bGQgY2FsbCBlbmRwb2ludCBvcGVyYXRpb24gdGhlbiB1c2UgcmV0dXJuZWQgbmV3XG4gKiBlbmRwb2ludCBmb3IgdGhlIGFwaSBjYWxsLiBTREsgd2lsbCBhdXRvbWF0aWNhbGx5IGF0dGVtcHQgdG8gZG8gZW5kcG9pbnRcbiAqIGRpc2NvdmVyeS4gVGhpcyBpcyB0dXJuZWQgb2ZmIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSBbb2JqZWN0XSByZXF1ZXN0IG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0LCBkb25lKSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICB2YXIgYXBpID0gc2VydmljZS5hcGk7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IGFwaS5vcGVyYXRpb25zID8gYXBpLm9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIDogdW5kZWZpbmVkO1xuICB2YXIgaW5wdXRTaGFwZSA9IG9wZXJhdGlvbk1vZGVsID8gb3BlcmF0aW9uTW9kZWwuaW5wdXQgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlkZW50aWZpZXJzID0gbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyhyZXF1ZXN0LCBpbnB1dFNoYXBlKTtcbiAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gIGlmIChPYmplY3Qua2V5cyhpZGVudGlmaWVycykubGVuZ3RoID4gMCkge1xuICAgIGNhY2hlS2V5ID0gdXRpbC51cGRhdGUoY2FjaGVLZXksIGlkZW50aWZpZXJzKTtcbiAgICBpZiAob3BlcmF0aW9uTW9kZWwpIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLm5hbWU7XG4gIH1cbiAgdmFyIGNhY2hlS2V5U3RyID0gQVdTLkVuZHBvaW50Q2FjaGUuZ2V0S2V5U3RyaW5nKGNhY2hlS2V5KTtcbiAgdmFyIGVuZHBvaW50cyA9IEFXUy5lbmRwb2ludENhY2hlLmdldChjYWNoZUtleVN0cik7IC8vZW5kcG9pbnQgY2FjaGUgYWxzbyBhY2NlcHRzIHN0cmluZyBrZXlzXG4gIGlmIChlbmRwb2ludHMgJiYgZW5kcG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBlbmRwb2ludHNbMF0uQWRkcmVzcyA9PT0gJycpIHtcbiAgICAvL2VuZHBvaW50IG9wZXJhdGlvbiBpcyBiZWluZyBtYWRlIGJ1dCByZXNwb25zZSBub3QgeWV0IHJlY2VpdmVkXG4gICAgLy9wdXNoIHJlcXVlc3Qgb2JqZWN0IHRvIGEgcGVuZGluZyBxdWV1ZVxuICAgIGlmICghcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSkgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXSA9IFtdO1xuICAgIHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0ucHVzaCh7cmVxdWVzdDogcmVxdWVzdCwgY2FsbGJhY2s6IGRvbmV9KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZW5kcG9pbnRzICYmIGVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChlbmRwb2ludHNbMF0uQWRkcmVzcyk7XG4gICAgZG9uZSgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbmRwb2ludFJlcXVlc3QgPSBzZXJ2aWNlLm1ha2VSZXF1ZXN0KGFwaS5lbmRwb2ludE9wZXJhdGlvbiwge1xuICAgICAgT3BlcmF0aW9uOiBvcGVyYXRpb25Nb2RlbC5uYW1lLFxuICAgICAgSWRlbnRpZmllcnM6IGlkZW50aWZpZXJzLFxuICAgIH0pO1xuICAgIGVuZHBvaW50UmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICBhZGRBcGlWZXJzaW9uSGVhZGVyKGVuZHBvaW50UmVxdWVzdCk7XG5cbiAgICAvL3B1dCBpbiBhIHBsYWNlaG9sZGVyIGZvciBlbmRwb2ludHMgYWxyZWFkeSByZXF1ZXN0ZWQsIHByZXZlbnRcbiAgICAvL3RvbyBtdWNoIGluLWZsaWdodCBjYWxsc1xuICAgIEFXUy5lbmRwb2ludENhY2hlLnB1dChjYWNoZUtleVN0ciwgW3tcbiAgICAgIEFkZHJlc3M6ICcnLFxuICAgICAgQ2FjaGVQZXJpb2RJbk1pbnV0ZXM6IDYwIC8vbG9uZy1saXZlIGNhY2hlXG4gICAgfV0pO1xuICAgIGVuZHBvaW50UmVxdWVzdC5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlLmVycm9yID0gdXRpbC5lcnJvcihlcnIsIHsgcmV0cnlhYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucmVtb3ZlKGNhY2hlS2V5KTtcblxuICAgICAgICAvL2ZhaWwgYWxsIHRoZSBwZW5kaW5nIHJlcXVlc3RzIGluIGJhdGNoXG4gICAgICAgIGlmIChyZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdKSB7XG4gICAgICAgICAgdmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl07XG4gICAgICAgICAgdXRpbC5hcnJheUVhY2gocGVuZGluZ1JlcXVlc3RzLCBmdW5jdGlvbihyZXF1ZXN0Q29udGV4dCkge1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQucmVxdWVzdC5yZXNwb25zZS5lcnJvciA9IHV0aWwuZXJyb3IoZXJyLCB7IHJldHJ5YWJsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dC5jYWxsYmFjaygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0UXVldWVbY2FjaGVLZXlTdHJdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgQVdTLmVuZHBvaW50Q2FjaGUucHV0KGNhY2hlS2V5U3RyLCBkYXRhLkVuZHBvaW50cyk7XG4gICAgICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQoZGF0YS5FbmRwb2ludHNbMF0uQWRkcmVzcyk7XG5cbiAgICAgICAgLy91cGRhdGUgdGhlIGVuZHBvaW50IGZvciBhbGwgdGhlIHBlbmRpbmcgcmVxdWVzdHMgaW4gYmF0Y2hcbiAgICAgICAgaWYgKHJlcXVlc3RRdWV1ZVtjYWNoZUtleVN0cl0pIHtcbiAgICAgICAgICB2YXIgcGVuZGluZ1JlcXVlc3RzID0gcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgICB1dGlsLmFycmF5RWFjaChwZW5kaW5nUmVxdWVzdHMsIGZ1bmN0aW9uKHJlcXVlc3RDb250ZXh0KSB7XG4gICAgICAgICAgICByZXF1ZXN0Q29udGV4dC5yZXF1ZXN0Lmh0dHBSZXF1ZXN0LnVwZGF0ZUVuZHBvaW50KGRhdGEuRW5kcG9pbnRzWzBdLkFkZHJlc3MpO1xuICAgICAgICAgICAgcmVxdWVzdENvbnRleHQuY2FsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdFF1ZXVlW2NhY2hlS2V5U3RyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogYWRkIGFwaSB2ZXJzaW9uIGhlYWRlciB0byBlbmRwb2ludCBvcGVyYXRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRBcGlWZXJzaW9uSGVhZGVyKGVuZHBvaW50UmVxdWVzdCkge1xuICB2YXIgYXBpID0gZW5kcG9pbnRSZXF1ZXN0LnNlcnZpY2UuYXBpO1xuICB2YXIgYXBpVmVyc2lvbiA9IGFwaS5hcGlWZXJzaW9uO1xuICBpZiAoYXBpVmVyc2lvbiAmJiAhZW5kcG9pbnRSZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LWFwaS12ZXJzaW9uJ10pIHtcbiAgICBlbmRwb2ludFJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1sneC1hbXotYXBpLXZlcnNpb24nXSA9IGFwaVZlcnNpb247XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBhcGkgY2FsbCBnZXRzIGludmFsaWQgZW5kcG9pbnQgZXhjZXB0aW9uLCBTREsgc2hvdWxkIGF0dGVtcHQgdG8gcmVtb3ZlIHRoZSBpbnZhbGlkXG4gKiBlbmRwb2ludCBmcm9tIGNhY2hlLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMocmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG4gIHZhciBodHRwUmVzcG9uc2UgPSByZXNwb25zZS5odHRwUmVzcG9uc2U7XG4gIGlmIChlcnJvciAmJlxuICAgIChlcnJvci5jb2RlID09PSAnSW52YWxpZEVuZHBvaW50RXhjZXB0aW9uJyB8fCBodHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDIxKVxuICApIHtcbiAgICB2YXIgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSByZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gICAgdmFyIGlucHV0U2hhcGUgPSBvcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXSA/IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dLmlucHV0IDogdW5kZWZpbmVkO1xuICAgIHZhciBpZGVudGlmaWVycyA9IG1hcnNoYWxsQ3VzdG9tSWRlbnRpZmllcnMocmVxdWVzdCwgaW5wdXRTaGFwZSk7XG4gICAgdmFyIGNhY2hlS2V5ID0gZ2V0Q2FjaGVLZXkocmVxdWVzdCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKGlkZW50aWZpZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICBjYWNoZUtleSA9IHV0aWwudXBkYXRlKGNhY2hlS2V5LCBpZGVudGlmaWVycyk7XG4gICAgICBpZiAob3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl0pIGNhY2hlS2V5Lm9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dLm5hbWU7XG4gICAgfVxuICAgIEFXUy5lbmRwb2ludENhY2hlLnJlbW92ZShjYWNoZUtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBlbmRwb2ludCBpcyBleHBsaWNpdGx5IGNvbmZpZ3VyZWQsIFNESyBzaG91bGQgbm90IGRvIGVuZHBvaW50IGRpc2NvdmVyeSBpbiBhbnl0aW1lLlxuICogQHBhcmFtIFtvYmplY3RdIGNsaWVudCBTZXJ2aWNlIGNsaWVudCBvYmplY3QuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFzQ3VzdG9tRW5kcG9pbnQoY2xpZW50KSB7XG4gIC8vaWYgc2V0IGVuZHBvaW50IGlzIHNldCBmb3Igc3BlY2lmaWMgY2xpZW50LCBlbmFibGUgZW5kcG9pbnQgZGlzY292ZXJ5IHdpbGwgcmFpc2UgYW4gZXJyb3IuXG4gIGlmIChjbGllbnQuX29yaWdpbmFsQ29uZmlnICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnQgJiYgY2xpZW50Ll9vcmlnaW5hbENvbmZpZy5lbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICBtZXNzYWdlOiAnQ3VzdG9tIGVuZHBvaW50IGlzIHN1cHBsaWVkOyBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWQgbXVzdCBub3QgYmUgdHJ1ZS4nXG4gICAgfSk7XG4gIH07XG4gIHZhciBzdmNDb25maWcgPSBBV1MuY29uZmlnW2NsaWVudC5zZXJ2aWNlSWRlbnRpZmllcl0gfHwge307XG4gIHJldHVybiBCb29sZWFuKEFXUy5jb25maWcuZW5kcG9pbnQgfHwgc3ZjQ29uZmlnLmVuZHBvaW50IHx8IChjbGllbnQuX29yaWdpbmFsQ29uZmlnICYmIGNsaWVudC5fb3JpZ2luYWxDb25maWcuZW5kcG9pbnQpKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNGYWxzeSh2YWx1ZSkge1xuICByZXR1cm4gWydmYWxzZScsICcwJ10uaW5kZXhPZih2YWx1ZSkgPj0gMDtcbn1cblxuLyoqXG4gKiBJZiBlbmRwb2ludCBkaXNjb3Zlcnkgc2hvdWxkIHBlcmZvcm0gZm9yIHRoaXMgcmVxdWVzdCB3aGVuIG5vIG9wZXJhdGlvbiByZXF1aXJlcyBlbmRwb2ludFxuICogZGlzY292ZXJ5IGZvciB0aGUgZ2l2ZW4gc2VydmljZS5cbiAqIFNESyBwZXJmb3JtcyBjb25maWcgcmVzb2x1dGlvbiBpbiBvcmRlciBsaWtlIGJlbG93OlxuICogMS4gSWYgc2V0IGluIGNsaWVudCBjb25maWd1cmF0aW9uLlxuICogMi4gSWYgc2V0IGluIGVudiBBV1NfRU5BQkxFX0VORFBPSU5UX0RJU0NPVkVSWS5cbiAqIDMuIElmIHNldCBpbiBzaGFyZWQgaW5pIGNvbmZpZyBmaWxlIHdpdGgga2V5ICdlbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCcuXG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdCByZXF1ZXN0IG9iamVjdC5cbiAqIEByZXR1cm5zIFtib29sZWFufHVuZGVmaW5lZF0gaWYgZW5kcG9pbnQgZGlzY292ZXJ5IGNvbmZpZyBpcyBub3Qgc2V0IGluIGFueSBzb3VyY2UsIHRoaXNcbiAqICBmdW5jdGlvbiByZXR1cm5zIHVuZGVmaW5lZFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVFbmRwb2ludERpc2NvdmVyeUNvbmZpZyhyZXF1ZXN0KSB7XG4gIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlIHx8IHt9O1xuICBpZiAoc2VydmljZS5jb25maWcuZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2VydmljZS5jb25maWcuZW5kcG9pbnREaXNjb3ZlcnlFbmFibGVkO1xuICB9XG5cbiAgLy9zaGFyZWQgaW5pIGZpbGUgaXMgb25seSBhdmFpbGFibGUgaW4gTm9kZVxuICAvL25vdCB0byBjaGVjayBlbnYgaW4gYnJvd3NlclxuICBpZiAodXRpbC5pc0Jyb3dzZXIoKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAvLyBJZiBhbnkgb2YgcmVjb2duaXplZCBlbmRwb2ludCBkaXNjb3ZlcnkgY29uZmlnIGVudiBpcyBzZXRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmRwb2ludERpc2NvdmVyeUVuYWJsZWRFbnZzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVudiA9IGVuZHBvaW50RGlzY292ZXJ5RW5hYmxlZEVudnNbaV07XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzLmVudiwgZW52KSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52W2Vudl0gPT09ICcnIHx8IHByb2Nlc3MuZW52W2Vudl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgY29kZTogJ0NvbmZpZ3VyYXRpb25FeGNlcHRpb24nLFxuICAgICAgICAgIG1lc3NhZ2U6ICdlbnZpcm9ubWVudGFsIHZhcmlhYmxlICcgKyBlbnYgKyAnIGNhbm5vdCBiZSBzZXQgdG8gbm90aGluZydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWlzRmFsc3kocHJvY2Vzcy5lbnZbZW52XSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbmZpZ0ZpbGUgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25maWdGaWxlID0gQVdTLnV0aWwuaW5pTG9hZGVyID8gQVdTLnV0aWwuaW5pTG9hZGVyLmxvYWRGcm9tKHtcbiAgICAgIGlzQ29uZmlnOiB0cnVlLFxuICAgICAgZmlsZW5hbWU6IHByb2Nlc3MuZW52W0FXUy51dGlsLnNoYXJlZENvbmZpZ0ZpbGVFbnZdXG4gICAgfSkgOiB7fTtcbiAgfSBjYXRjaCAoZSkge31cbiAgdmFyIHNoYXJlZEZpbGVDb25maWcgPSBjb25maWdGaWxlW1xuICAgIHByb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlXG4gIF0gfHwge307XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2hhcmVkRmlsZUNvbmZpZywgJ2VuZHBvaW50X2Rpc2NvdmVyeV9lbmFibGVkJykpIHtcbiAgICBpZiAoc2hhcmVkRmlsZUNvbmZpZy5lbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdDb25maWd1cmF0aW9uRXhjZXB0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ2NvbmZpZyBmaWxlIGVudHJ5IFxcJ2VuZHBvaW50X2Rpc2NvdmVyeV9lbmFibGVkXFwnIGNhbm5vdCBiZSBzZXQgdG8gbm90aGluZydcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gIWlzRmFsc3koc2hhcmVkRmlsZUNvbmZpZy5lbmRwb2ludF9kaXNjb3ZlcnlfZW5hYmxlZCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBhdHRhY2ggZW5kcG9pbnQgZGlzY292ZXJ5IGxvZ2ljIHRvIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0gW29iamVjdF0gcmVxdWVzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSkge1xuICB2YXIgc2VydmljZSA9IHJlcXVlc3Quc2VydmljZSB8fCB7fTtcbiAgaWYgKGhhc0N1c3RvbUVuZHBvaW50KHNlcnZpY2UpIHx8IHJlcXVlc3QuaXNQcmVzaWduZWQoKSkgcmV0dXJuIGRvbmUoKTtcblxuICB2YXIgb3BlcmF0aW9ucyA9IHNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgfHwge307XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dO1xuICB2YXIgaXNFbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkID0gb3BlcmF0aW9uTW9kZWwgPyBvcGVyYXRpb25Nb2RlbC5lbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkIDogJ05VTEwnO1xuICB2YXIgaXNFbmFibGVkID0gcmVzb2x2ZUVuZHBvaW50RGlzY292ZXJ5Q29uZmlnKHJlcXVlc3QpO1xuICB2YXIgaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSA9IHNlcnZpY2UuYXBpLmhhc1JlcXVpcmVkRW5kcG9pbnREaXNjb3Zlcnk7XG4gIGlmIChpc0VuYWJsZWQgfHwgaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSkge1xuICAgIC8vIE9uY2UgYSBjdXN0b21lciBlbmFibGVzIGVuZHBvaW50IGRpc2NvdmVyeSwgdGhlIFNESyBzaG91bGQgc3RhcnQgYXBwZW5kaW5nXG4gICAgLy8gdGhlIHN0cmluZyBlbmRwb2ludC1kaXNjb3ZlcnkgdG8gdGhlIHVzZXItYWdlbnQgb24gYWxsIHJlcXVlc3RzLlxuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoJ2VuZHBvaW50LWRpc2NvdmVyeScpO1xuICB9XG4gIHN3aXRjaCAoaXNFbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkKSB7XG4gICAgY2FzZSAnT1BUSU9OQUwnOlxuICAgICAgaWYgKGlzRW5hYmxlZCB8fCBoYXNSZXF1aXJlZEVuZHBvaW50RGlzY292ZXJ5KSB7XG4gICAgICAgIC8vIEZvciBhIGdpdmVuIHNlcnZpY2U7IGlmIGF0IGxlYXN0IG9uZSBvcGVyYXRpb24gcmVxdWlyZXMgZW5kcG9pbnQgZGlzY292ZXJ5IHRoZW4gdGhlIFNESyBtdXN0IGVuYWJsZSBlbmRwb2ludCBkaXNjb3ZlcnlcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBmb3IgYWxsIG9wZXJhdGlvbnMgb2YgdGhhdCBzZXJ2aWNlLCBpbmNsdWRpbmcgb3BlcmF0aW9ucyB3aGVyZSBlbmRwb2ludCBkaXNjb3ZlcnkgaXMgb3B0aW9uYWwuXG4gICAgICAgIG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludChyZXF1ZXN0KTtcbiAgICAgICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdJTlZBTElEQVRFX0NBQ0hFRF9FTkRQT0lOVFMnLCAnZXh0cmFjdEVycm9yJywgaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50cyk7XG4gICAgICB9XG4gICAgICBkb25lKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdSRVFVSVJFRCc6XG4gICAgICBpZiAoaXNFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAvLyBGb3IgYSBnaXZlbiBvcGVyYXRpb247IGlmIGVuZHBvaW50IGRpc2NvdmVyeSBpcyByZXF1aXJlZCBhbmQgaXQgaGFzIGJlZW4gZGlzYWJsZWQgb24gdGhlIFNESyBjbGllbnQsXG4gICAgICAgIC8vIHRoZW4gdGhlIFNESyBtdXN0IHJldHVybiBhIGNsZWFyIGFuZCBhY3Rpb25hYmxlIGV4Y2VwdGlvbi5cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZS5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgICBjb2RlOiAnQ29uZmlndXJhdGlvbkV4Y2VwdGlvbicsXG4gICAgICAgICAgbWVzc2FnZTogJ0VuZHBvaW50IERpc2NvdmVyeSBpcyBkaXNhYmxlZCBidXQgJyArIHNlcnZpY2UuYXBpLmNsYXNzTmFtZSArICcuJyArIHJlcXVlc3Qub3BlcmF0aW9uICtcbiAgICAgICAgICAgICAgICAgICAgJygpIHJlcXVpcmVzIGl0LiBQbGVhc2UgY2hlY2sgeW91ciBjb25maWd1cmF0aW9ucy4nXG4gICAgICAgIH0pO1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5hZGROYW1lZExpc3RlbmVyKCdJTlZBTElEQVRFX0NBQ0hFRF9FTkRQT0lOVFMnLCAnZXh0cmFjdEVycm9yJywgaW52YWxpZGF0ZUNhY2hlZEVuZHBvaW50cyk7XG4gICAgICByZXF1aXJlZERpc2NvdmVyRW5kcG9pbnQocmVxdWVzdCwgZG9uZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdOVUxMJzpcbiAgICBkZWZhdWx0OlxuICAgICAgZG9uZSgpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRpc2NvdmVyRW5kcG9pbnQ6IGRpc2NvdmVyRW5kcG9pbnQsXG4gIHJlcXVpcmVkRGlzY292ZXJFbmRwb2ludDogcmVxdWlyZWREaXNjb3ZlckVuZHBvaW50LFxuICBvcHRpb25hbERpc2NvdmVyRW5kcG9pbnQ6IG9wdGlvbmFsRGlzY292ZXJFbmRwb2ludCxcbiAgbWFyc2hhbGxDdXN0b21JZGVudGlmaWVyczogbWFyc2hhbGxDdXN0b21JZGVudGlmaWVycyxcbiAgZ2V0Q2FjaGVLZXk6IGdldENhY2hlS2V5LFxuICBpbnZhbGlkYXRlQ2FjaGVkRW5kcG9pbnQ6IGludmFsaWRhdGVDYWNoZWRFbmRwb2ludHMsXG59O1xuIiwidmFyIGV2ZW50TWVzc2FnZUNodW5rZXIgPSByZXF1aXJlKCcuLi9ldmVudC1zdHJlYW0vZXZlbnQtbWVzc2FnZS1jaHVua2VyJykuZXZlbnRNZXNzYWdlQ2h1bmtlcjtcbnZhciBwYXJzZUV2ZW50ID0gcmVxdWlyZSgnLi9wYXJzZS1ldmVudCcpLnBhcnNlRXZlbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtKGJvZHksIHBhcnNlciwgbW9kZWwpIHtcbiAgICB2YXIgZXZlbnRNZXNzYWdlcyA9IGV2ZW50TWVzc2FnZUNodW5rZXIoYm9keSk7XG5cbiAgICB2YXIgZXZlbnRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnRzLnB1c2gocGFyc2VFdmVudChwYXJzZXIsIGV2ZW50TWVzc2FnZXNbaV0sIG1vZGVsKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlRXZlbnRTdHJlYW06IGNyZWF0ZUV2ZW50U3RyZWFtXG59O1xuIiwiLyoqXG4gKiBUYWtlcyBpbiBhIGJ1ZmZlciBvZiBldmVudCBtZXNzYWdlcyBhbmQgc3BsaXRzIHRoZW0gaW50byBpbmRpdmlkdWFsIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50TWVzc2FnZUNodW5rZXIoYnVmZmVyKSB7XG4gICAgLyoqIEB0eXBlIEJ1ZmZlcltdICovXG4gICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSBidWZmZXIucmVhZEludDMyQkUob2Zmc2V0KTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IGJ1ZmZlciBmb3IgaW5kaXZpZHVhbCBtZXNzYWdlIChzaGFyZXMgbWVtb3J5IHdpdGggb3JpZ2luYWwpXG4gICAgICAgIHZhciBtZXNzYWdlID0gYnVmZmVyLnNsaWNlKG9mZnNldCwgdG90YWxMZW5ndGggKyBvZmZzZXQpO1xuICAgICAgICAvLyBpbmNyZW1lbnQgb2Zmc2V0IHRvIGl0IHN0YXJ0cyBhdCB0aGUgbmV4dCBtZXNzYWdlXG4gICAgICAgIG9mZnNldCArPSB0b3RhbExlbmd0aDtcblxuICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlcztcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXZlbnRNZXNzYWdlQ2h1bmtlcjogZXZlbnRNZXNzYWdlQ2h1bmtlclxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZScpLnV0aWw7XG52YXIgdG9CdWZmZXIgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcjtcblxuLyoqXG4gKiBBIGxvc3NsZXNzIHJlcHJlc2VudGF0aW9uIG9mIGEgc2lnbmVkLCA2NC1iaXQgaW50ZWdlci4gSW5zdGFuY2VzIG9mIHRoaXNcbiAqIGNsYXNzIG1heSBiZSB1c2VkIGluIGFyaXRobWV0aWMgZXhwcmVzc2lvbnMgYXMgaWYgdGhleSB3ZXJlIG51bWVyaWNcbiAqIHByaW1pdGl2ZXMsIGJ1dCB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIHdpbGwgYmUgcHJlc2VydmVkIHVuY2hhbmdlZCBhcyB0aGVcbiAqIGBieXRlc2AgcHJvcGVydHkgb2YgdGhlIG9iamVjdC4gVGhlIGJ5dGVzIHNob3VsZCBiZSBlbmNvZGVkIGFzIGJpZy1lbmRpYW4sXG4gKiB0d28ncyBjb21wbGVtZW50IGludGVnZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ5dGVzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEludDY0KGJ5dGVzKSB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludDY0IGJ1ZmZlcnMgbXVzdCBiZSBleGFjdGx5IDggYnl0ZXMnKTtcbiAgICB9XG4gICAgaWYgKCF1dGlsLkJ1ZmZlci5pc0J1ZmZlcihieXRlcykpIGJ5dGVzID0gdG9CdWZmZXIoYnl0ZXMpO1xuXG4gICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAqIEByZXR1cm5zIHtJbnQ2NH1cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuSW50NjQuZnJvbU51bWJlciA9IGZ1bmN0aW9uKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPiA5MjIzMzcyMDM2ODU0Nzc1ODA3IHx8IG51bWJlciA8IC05MjIzMzcyMDM2ODU0Nzc1ODA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIG51bWJlciArICcgaXMgdG9vIGxhcmdlIChvciwgaWYgbmVnYXRpdmUsIHRvbyBzbWFsbCkgdG8gcmVwcmVzZW50IGFzIGFuIEludDY0J1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGZvciAoXG4gICAgICAgIHZhciBpID0gNywgcmVtYWluaW5nID0gTWF0aC5hYnMoTWF0aC5yb3VuZChudW1iZXIpKTtcbiAgICAgICAgaSA+IC0xICYmIHJlbWFpbmluZyA+IDA7XG4gICAgICAgIGktLSwgcmVtYWluaW5nIC89IDI1NlxuICAgICkge1xuICAgICAgICBieXRlc1tpXSA9IHJlbWFpbmluZztcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICBuZWdhdGUoYnl0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSW50NjQoYnl0ZXMpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5JbnQ2NC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMuc2xpY2UoMCk7XG4gICAgdmFyIG5lZ2F0aXZlID0gYnl0ZXNbMF0gJiAxMjg7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG5lZ2F0ZShieXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KGJ5dGVzLnRvU3RyaW5nKCdoZXgnKSwgMTYpICogKG5lZ2F0aXZlID8gLTEgOiAxKTtcbn07XG5cbkludDY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZU9mKCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnl0ZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGJ5dGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gXj0gMHhGRjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDc7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgIGJ5dGVzW2ldKys7XG4gICAgICAgIGlmIChieXRlc1tpXSAhPT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEludDY0OiBJbnQ2NFxufTtcbiIsInZhciBwYXJzZU1lc3NhZ2UgPSByZXF1aXJlKCcuL3BhcnNlLW1lc3NhZ2UnKS5wYXJzZU1lc3NhZ2U7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gcGFyc2VyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHsqfSBzaGFwZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnQocGFyc2VyLCBtZXNzYWdlLCBzaGFwZSkge1xuICAgIHZhciBwYXJzZWRNZXNzYWdlID0gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpO1xuXG4gICAgLy8gY2hlY2sgaWYgbWVzc2FnZSBpcyBhbiBldmVudCBvciBlcnJvclxuICAgIHZhciBtZXNzYWdlVHlwZSA9IHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1snOm1lc3NhZ2UtdHlwZSddO1xuICAgIGlmIChtZXNzYWdlVHlwZSkge1xuICAgICAgICBpZiAobWVzc2FnZVR5cGUudmFsdWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IHBhcnNlRXJyb3IocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZVR5cGUudmFsdWUgIT09ICdldmVudCcpIHtcbiAgICAgICAgICAgIC8vIG5vdCBzdXJlIGhvdyB0byBwYXJzZSBub24tZXZlbnRzL25vbi1lcnJvcnMsIGlnbm9yZSBmb3Igbm93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgZXZlbnQgdHlwZVxuICAgIHZhciBldmVudFR5cGUgPSBwYXJzZWRNZXNzYWdlLmhlYWRlcnNbJzpldmVudC10eXBlJ107XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgZXZlbnQgdHlwZSBpcyBtb2RlbGVkXG4gICAgdmFyIGV2ZW50TW9kZWwgPSBzaGFwZS5tZW1iZXJzW2V2ZW50VHlwZS52YWx1ZV07XG4gICAgaWYgKCFldmVudE1vZGVsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgLy8gY2hlY2sgaWYgYW4gZXZlbnQgcGF5bG9hZCBleGlzdHNcbiAgICB2YXIgZXZlbnRQYXlsb2FkTWVtYmVyTmFtZSA9IGV2ZW50TW9kZWwuZXZlbnRQYXlsb2FkTWVtYmVyTmFtZTtcbiAgICBpZiAoZXZlbnRQYXlsb2FkTWVtYmVyTmFtZSkge1xuICAgICAgICB2YXIgcGF5bG9hZFNoYXBlID0gZXZlbnRNb2RlbC5tZW1iZXJzW2V2ZW50UGF5bG9hZE1lbWJlck5hbWVdO1xuICAgICAgICAvLyBpZiB0aGUgc2hhcGUgaXMgYmluYXJ5LCByZXR1cm4gdGhlIGJ5dGUgYXJyYXlcbiAgICAgICAgaWYgKHBheWxvYWRTaGFwZS50eXBlID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgICAgcmVzdWx0W2V2ZW50UGF5bG9hZE1lbWJlck5hbWVdID0gcGFyc2VkTWVzc2FnZS5ib2R5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2V2ZW50UGF5bG9hZE1lbWJlck5hbWVdID0gcGFyc2VyLnBhcnNlKHBhcnNlZE1lc3NhZ2UuYm9keS50b1N0cmluZygpLCBwYXlsb2FkU2hhcGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVhZCBldmVudCBoZWFkZXJzXG4gICAgdmFyIGV2ZW50SGVhZGVyTmFtZXMgPSBldmVudE1vZGVsLmV2ZW50SGVhZGVyTWVtYmVyTmFtZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudEhlYWRlck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gZXZlbnRIZWFkZXJOYW1lc1tpXTtcbiAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIGhlYWRlciFcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IGV2ZW50TW9kZWwubWVtYmVyc1tuYW1lXS50b1R5cGUocGFyc2VkTWVzc2FnZS5oZWFkZXJzW25hbWVdLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBvdXRwdXRbZXZlbnRUeXBlLnZhbHVlXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyb3JDb2RlID0gbWVzc2FnZS5oZWFkZXJzWyc6ZXJyb3ItY29kZSddO1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlLmhlYWRlcnNbJzplcnJvci1tZXNzYWdlJ107XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZS52YWx1ZSB8fCBlcnJvck1lc3NhZ2UpO1xuICAgIGVycm9yLmNvZGUgPSBlcnJvci5uYW1lID0gZXJyb3JDb2RlLnZhbHVlIHx8IGVycm9yQ29kZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhcnNlRXZlbnQ6IHBhcnNlRXZlbnRcbn07XG4iLCJ2YXIgSW50NjQgPSByZXF1aXJlKCcuL2ludDY0JykuSW50NjQ7XG5cbnZhciBzcGxpdE1lc3NhZ2UgPSByZXF1aXJlKCcuL3NwbGl0LW1lc3NhZ2UnKS5zcGxpdE1lc3NhZ2U7XG5cbnZhciBCT09MRUFOX1RBRyA9ICdib29sZWFuJztcbnZhciBCWVRFX1RBRyA9ICdieXRlJztcbnZhciBTSE9SVF9UQUcgPSAnc2hvcnQnO1xudmFyIElOVF9UQUcgPSAnaW50ZWdlcic7XG52YXIgTE9OR19UQUcgPSAnbG9uZyc7XG52YXIgQklOQVJZX1RBRyA9ICdiaW5hcnknO1xudmFyIFNUUklOR19UQUcgPSAnc3RyaW5nJztcbnZhciBUSU1FU1RBTVBfVEFHID0gJ3RpbWVzdGFtcCc7XG52YXIgVVVJRF9UQUcgPSAndXVpZCc7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGhlYWRlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB2YXIgb3V0ID0ge307XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB3aGlsZSAocG9zaXRpb24gPCBoZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmFtZUxlbmd0aCA9IGhlYWRlcnMucmVhZFVJbnQ4KHBvc2l0aW9uKyspO1xuICAgICAgICB2YXIgbmFtZSA9IGhlYWRlcnMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgbmFtZUxlbmd0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgcG9zaXRpb24gKz0gbmFtZUxlbmd0aDtcbiAgICAgICAgc3dpdGNoIChoZWFkZXJzLnJlYWRVSW50OChwb3NpdGlvbisrKSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIGJvb2xUcnVlICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQk9PTEVBTl9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMSAvKiBib29sRmFsc2UgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCT09MRUFOX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBieXRlICovOlxuICAgICAgICAgICAgICAgIG91dFtuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQllURV9UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnJlYWRJbnQ4KHBvc2l0aW9uKyspXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMyAvKiBzaG9ydCAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNIT1JUX1RBRyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlYWRlcnMucmVhZEludDE2QkUocG9zaXRpb24pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0IC8qIGludGVnZXIgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJTlRfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5yZWFkSW50MzJCRShwb3NpdGlvbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDUgLyogbG9uZyAqLzpcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IExPTkdfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IEludDY0KGhlYWRlcnMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgOCkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2IC8qIGJ5dGVBcnJheSAqLzpcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5TGVuZ3RoID0gaGVhZGVycy5yZWFkVUludDE2QkUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDI7XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCSU5BUllfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBiaW5hcnlMZW5ndGgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBiaW5hcnlMZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDcgLyogc3RyaW5nICovOlxuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdMZW5ndGggPSBoZWFkZXJzLnJlYWRVSW50MTZCRShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gMjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNUUklOR19UQUcsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBoZWFkZXJzLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArIHN0cmluZ0xlbmd0aFxuICAgICAgICAgICAgICAgICAgICApLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmluZ0xlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOCAvKiB0aW1lc3RhbXAgKi86XG4gICAgICAgICAgICAgICAgb3V0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBUSU1FU1RBTVBfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgSW50NjQoaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyA4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWVPZigpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkgLyogdXVpZCAqLzpcbiAgICAgICAgICAgICAgICB2YXIgdXVpZENoYXJzID0gaGVhZGVycy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAxNilcbiAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSAxNjtcbiAgICAgICAgICAgICAgICBvdXRbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFVVSURfVEFHLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXVpZENoYXJzLnN1YnN0cigwLCA4KSArICctJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB1dWlkQ2hhcnMuc3Vic3RyKDgsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoMTIsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoMTYsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV1aWRDaGFycy5zdWJzdHIoMjApXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgaGVhZGVyIHR5cGUgdGFnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB2YXIgcGFyc2VkID0gc3BsaXRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB7IGhlYWRlcnM6IHBhcnNlSGVhZGVycyhwYXJzZWQuaGVhZGVycyksIGJvZHk6IHBhcnNlZC5ib2R5IH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhcnNlTWVzc2FnZTogcGFyc2VNZXNzYWdlXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlJykudXRpbDtcbnZhciB0b0J1ZmZlciA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyO1xuXG4vLyBBbGwgcHJlbHVkZSBjb21wb25lbnRzIGFyZSB1bnNpZ25lZCwgMzItYml0IGludGVnZXJzXG52YXIgUFJFTFVERV9NRU1CRVJfTEVOR1RIID0gNDtcbi8vIFRoZSBwcmVsdWRlIGNvbnNpc3RzIG9mIHR3byBjb21wb25lbnRzXG52YXIgUFJFTFVERV9MRU5HVEggPSBQUkVMVURFX01FTUJFUl9MRU5HVEggKiAyO1xuLy8gQ2hlY2tzdW1zIGFyZSBhbHdheXMgQ1JDMzIgaGFzaGVzLlxudmFyIENIRUNLU1VNX0xFTkdUSCA9IDQ7XG4vLyBNZXNzYWdlcyBtdXN0IGluY2x1ZGUgYSBmdWxsIHByZWx1ZGUsIGEgcHJlbHVkZSBjaGVja3N1bSwgYW5kIGEgbWVzc2FnZSBjaGVja3N1bVxudmFyIE1JTklNVU1fTUVTU0FHRV9MRU5HVEggPSBQUkVMVURFX0xFTkdUSCArIENIRUNLU1VNX0xFTkdUSCAqIDI7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gc3BsaXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXV0aWwuQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSBtZXNzYWdlID0gdG9CdWZmZXIobWVzc2FnZSk7XG5cbiAgICBpZiAobWVzc2FnZS5sZW5ndGggPCBNSU5JTVVNX01FU1NBR0VfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgbWVzc2FnZSB0b28gc2hvcnQgdG8gYWNjb21tb2RhdGUgZXZlbnQgc3RyZWFtIG1lc3NhZ2Ugb3ZlcmhlYWQnKTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5sZW5ndGggIT09IG1lc3NhZ2UucmVhZFVJbnQzMkJFKDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVwb3J0ZWQgbWVzc2FnZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggcmVjZWl2ZWQgbWVzc2FnZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwZWN0ZWRQcmVsdWRlQ2hlY2tzdW0gPSBtZXNzYWdlLnJlYWRVSW50MzJCRShQUkVMVURFX0xFTkdUSCk7XG5cbiAgICBpZiAoXG4gICAgICAgIGV4cGVjdGVkUHJlbHVkZUNoZWNrc3VtICE9PSB1dGlsLmNyeXB0by5jcmMzMihcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2xpY2UoMCwgUFJFTFVERV9MRU5HVEgpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBwcmVsdWRlIGNoZWNrc3VtIHNwZWNpZmllZCBpbiB0aGUgbWVzc2FnZSAoJyArXG4gICAgICAgICAgICBleHBlY3RlZFByZWx1ZGVDaGVja3N1bSArXG4gICAgICAgICAgICAnKSBkb2VzIG5vdCBtYXRjaCB0aGUgY2FsY3VsYXRlZCBDUkMzMiBjaGVja3N1bS4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGVjdGVkTWVzc2FnZUNoZWNrc3VtID0gbWVzc2FnZS5yZWFkVUludDMyQkUobWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpO1xuXG4gICAgaWYgKFxuICAgICAgICBleHBlY3RlZE1lc3NhZ2VDaGVja3N1bSAhPT0gdXRpbC5jcnlwdG8uY3JjMzIoXG4gICAgICAgICAgICBtZXNzYWdlLnNsaWNlKDAsIG1lc3NhZ2UubGVuZ3RoIC0gQ0hFQ0tTVU1fTEVOR1RIKVxuICAgICAgICApXG4gICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgbWVzc2FnZSBjaGVja3N1bSBkaWQgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB2YWx1ZSBvZiAnICtcbiAgICAgICAgICAgICAgICBleHBlY3RlZE1lc3NhZ2VDaGVja3N1bVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBoZWFkZXJzU3RhcnQgPSBQUkVMVURFX0xFTkdUSCArIENIRUNLU1VNX0xFTkdUSDtcbiAgICB2YXIgaGVhZGVyc0VuZCA9IGhlYWRlcnNTdGFydCArIG1lc3NhZ2UucmVhZFVJbnQzMkJFKFBSRUxVREVfTUVNQkVSX0xFTkdUSCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXJzOiBtZXNzYWdlLnNsaWNlKGhlYWRlcnNTdGFydCwgaGVhZGVyc0VuZCksXG4gICAgICAgIGJvZHk6IG1lc3NhZ2Uuc2xpY2UoaGVhZGVyc0VuZCwgbWVzc2FnZS5sZW5ndGggLSBDSEVDS1NVTV9MRU5HVEgpLFxuICAgIH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNwbGl0TWVzc2FnZTogc3BsaXRNZXNzYWdlXG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4vY29yZScpO1xudmFyIFNlcXVlbnRpYWxFeGVjdXRvciA9IHJlcXVpcmUoJy4vc2VxdWVudGlhbF9leGVjdXRvcicpO1xudmFyIERJU0NPVkVSX0VORFBPSU5UID0gcmVxdWlyZSgnLi9kaXNjb3Zlcl9lbmRwb2ludCcpLmRpc2NvdmVyRW5kcG9pbnQ7XG4vKipcbiAqIFRoZSBuYW1lc3BhY2UgdXNlZCB0byByZWdpc3RlciBnbG9iYWwgZXZlbnQgbGlzdGVuZXJzIGZvciByZXF1ZXN0IGJ1aWxkaW5nXG4gKiBhbmQgc2VuZGluZy5cbiAqL1xuQVdTLkV2ZW50TGlzdGVuZXJzID0ge1xuICAvKipcbiAgICogQCFhdHRyaWJ1dGUgVkFMSURBVEVfQ1JFREVOVElBTFNcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCB2YWxpZGF0ZXMgd2hldGhlciB0aGUgcmVxdWVzdCBpcyBiZWluZ1xuICAgKiAgIHNlbnQgd2l0aCBjcmVkZW50aWFscy5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+dmFsaWRhdGUgJ3ZhbGlkYXRlJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgdmFsaWRhdGluZyBjcmVkZW50aWFsc1xuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfQ1JFREVOVElBTFM7XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIGxpc3RlbmVyKTtcbiAgICogICBAcmVhZG9ubHlcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogQCFhdHRyaWJ1dGUgVkFMSURBVEVfUkVHSU9OXG4gICAqICAgQSByZXF1ZXN0IGxpc3RlbmVyIHRoYXQgdmFsaWRhdGVzIHdoZXRoZXIgdGhlIHJlZ2lvbiBpcyBzZXRcbiAgICogICBmb3IgYSByZXF1ZXN0LlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH52YWxpZGF0ZSAndmFsaWRhdGUnIFJlcXVlc3QgZXZlbnR9XG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aG91dCB2YWxpZGF0aW5nIHJlZ2lvbiBjb25maWd1cmF0aW9uXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT047XG4gICAqICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsIGxpc3RlbmVyKTtcbiAgICogICBAcmVhZG9ubHlcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogQCFhdHRyaWJ1dGUgVkFMSURBVEVfUEFSQU1FVEVSU1xuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IHZhbGlkYXRlcyBpbnB1dCBwYXJhbWV0ZXJzIGluIGEgcmVxdWVzdC5cbiAgICogICBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+dmFsaWRhdGUgJ3ZhbGlkYXRlJyBSZXF1ZXN0IGV2ZW50fVxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgdmFsaWRhdGluZyBwYXJhbWV0ZXJzXG4gICAqICAgICB2YXIgbGlzdGVuZXIgPSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLCBsaXN0ZW5lcik7XG4gICAqICAgQGV4YW1wbGUgRGlzYWJsZSBwYXJhbWV0ZXIgdmFsaWRhdGlvbiBnbG9iYWxseVxuICAgKiAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJyxcbiAgICogICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfUkVHSU9OKTtcbiAgICogICBAcmVhZG9ubHlcbiAgICogICBAcmV0dXJuIFtGdW5jdGlvbl1cbiAgICogQCFhdHRyaWJ1dGUgU0VORFxuICAgKiAgIEEgcmVxdWVzdCBsaXN0ZW5lciB0aGF0IGluaXRpYXRlcyB0aGUgSFRUUCBjb25uZWN0aW9uIGZvciBhXG4gICAqICAgcmVxdWVzdCBiZWluZyBzZW50LiBIYW5kbGVzIHRoZSB7QVdTLlJlcXVlc3R+c2VuZCAnc2VuZCcgUmVxdWVzdCBldmVudH1cbiAgICogICBAZXhhbXBsZSBSZXBsYWNpbmcgdGhlIEhUVFAgaGFuZGxlclxuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VORDtcbiAgICogICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3NlbmQnLCBsaXN0ZW5lcik7XG4gICAqICAgICByZXF1ZXN0Lm9uKCdzZW5kJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICogICAgICAgY3VzdG9tSGFuZGxlci5zZW5kKHJlc3BvbnNlKTtcbiAgICogICAgIH0pO1xuICAgKiAgIEByZXR1cm4gW0Z1bmN0aW9uXVxuICAgKiAgIEByZWFkb25seVxuICAgKiBAIWF0dHJpYnV0ZSBIVFRQX0RBVEFcbiAgICogICBBIHJlcXVlc3QgbGlzdGVuZXIgdGhhdCByZWFkcyBkYXRhIGZyb20gdGhlIEhUVFAgY29ubmVjdGlvbiBpbiBvcmRlclxuICAgKiAgIHRvIGJ1aWxkIHRoZSByZXNwb25zZSBkYXRhLlxuICAgKiAgIEhhbmRsZXMgdGhlIHtBV1MuUmVxdWVzdH5odHRwRGF0YSAnaHR0cERhdGEnIFJlcXVlc3QgZXZlbnR9LlxuICAgKiAgIFJlbW92ZSB0aGlzIGhhbmRsZXIgaWYgeW91IGFyZSBvdmVycmlkaW5nIHRoZSAnaHR0cERhdGEnIGV2ZW50IGFuZFxuICAgKiAgIGRvIG5vdCB3YW50IGV4dHJhIGRhdGEgcHJvY2Vzc2luZyBhbmQgYnVmZmVyaW5nIG92ZXJoZWFkLlxuICAgKiAgIEBleGFtcGxlIERpc2FibGluZyBkZWZhdWx0IGRhdGEgcHJvY2Vzc2luZ1xuICAgKiAgICAgdmFyIGxpc3RlbmVyID0gQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuSFRUUF9EQVRBO1xuICAgKiAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignaHR0cERhdGEnLCBsaXN0ZW5lcik7XG4gICAqICAgQHJldHVybiBbRnVuY3Rpb25dXG4gICAqICAgQHJlYWRvbmx5XG4gICAqL1xuICBDb3JlOiB7fSAvKiBkb2MgaGFjayAqL1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uQXV0aHR5cGUocmVxKSB7XG4gIGlmICghcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICByZXR1cm4gb3BlcmF0aW9uID8gb3BlcmF0aW9uLmF1dGh0eXBlIDogJyc7XG59XG5cbkFXUy5FdmVudExpc3RlbmVycyA9IHtcbiAgQ29yZTogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCwgYWRkQXN5bmMpIHtcbiAgICBhZGRBc3luYygnVkFMSURBVEVfQ1JFREVOVElBTFMnLCAndmFsaWRhdGUnLFxuICAgICAgICBmdW5jdGlvbiBWQUxJREFURV9DUkVERU5USUFMUyhyZXEsIGRvbmUpIHtcbiAgICAgIGlmICghcmVxLnNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb24gJiYgIXJlcS5zZXJ2aWNlLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSByZXR1cm4gZG9uZSgpOyAvLyBub25lXG4gICAgICByZXEuc2VydmljZS5jb25maWcuZ2V0Q3JlZGVudGlhbHMoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnIsXG4gICAgICAgICAgICB7Y29kZTogJ0NyZWRlbnRpYWxzRXJyb3InLCBtZXNzYWdlOiAnTWlzc2luZyBjcmVkZW50aWFscyBpbiBjb25maWcsIGlmIHVzaW5nIEFXU19DT05GSUdfRklMRSwgc2V0IEFXU19TREtfTE9BRF9DT05GSUc9MSd9KTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFkZCgnVkFMSURBVEVfUkVHSU9OJywgJ3ZhbGlkYXRlJywgZnVuY3Rpb24gVkFMSURBVEVfUkVHSU9OKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5pc0dsb2JhbEVuZHBvaW50KSB7XG4gICAgICAgIHZhciBkbnNIb3N0UmVnZXggPSBuZXcgUmVnRXhwKC9eKFthLXpBLVowLTldfFthLXpBLVowLTldW2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pJC8pO1xuICAgICAgICBpZiAoIXJlcS5zZXJ2aWNlLmNvbmZpZy5yZWdpb24pIHtcbiAgICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICAgIHtjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiAnTWlzc2luZyByZWdpb24gaW4gY29uZmlnJ30pO1xuICAgICAgICB9IGVsc2UgaWYgKCFkbnNIb3N0UmVnZXgudGVzdChyZXEuc2VydmljZS5jb25maWcucmVnaW9uKSkge1xuICAgICAgICAgIHJlcS5yZXNwb25zZS5lcnJvciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICAgICAge2NvZGU6ICdDb25maWdFcnJvcicsIG1lc3NhZ2U6ICdJbnZhbGlkIHJlZ2lvbiBpbiBjb25maWcnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnQlVJTERfSURFTVBPVEVOQ1lfVE9LRU5TJywgJ3ZhbGlkYXRlJywgZnVuY3Rpb24gQlVJTERfSURFTVBPVEVOQ1lfVE9LRU5TKHJlcSkge1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaWRlbXBvdGVudE1lbWJlcnMgPSBvcGVyYXRpb24uaWRlbXBvdGVudE1lbWJlcnM7XG4gICAgICBpZiAoIWlkZW1wb3RlbnRNZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBjcmVhdGVzIGEgY29weSBvZiBwYXJhbXMgc28gdXNlcidzIHBhcmFtIG9iamVjdCBpc24ndCBtdXRhdGVkXG4gICAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weShyZXEucGFyYW1zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gaWRlbXBvdGVudE1lbWJlcnMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghcGFyYW1zW2lkZW1wb3RlbnRNZW1iZXJzW2ldXSkge1xuICAgICAgICAgIC8vIGFkZCB0aGUgbWVtYmVyXG4gICAgICAgICAgcGFyYW1zW2lkZW1wb3RlbnRNZW1iZXJzW2ldXSA9IEFXUy51dGlsLnV1aWQudjQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVxLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9KTtcblxuICAgIGFkZCgnVkFMSURBVEVfUEFSQU1FVEVSUycsICd2YWxpZGF0ZScsIGZ1bmN0aW9uIFZBTElEQVRFX1BBUkFNRVRFUlMocmVxKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLmlucHV0O1xuICAgICAgdmFyIHZhbGlkYXRpb24gPSByZXEuc2VydmljZS5jb25maWcucGFyYW1WYWxpZGF0aW9uO1xuICAgICAgbmV3IEFXUy5QYXJhbVZhbGlkYXRvcih2YWxpZGF0aW9uKS52YWxpZGF0ZShydWxlcywgcmVxLnBhcmFtcyk7XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NPTVBVVEVfQ0hFQ0tTVU0nLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIENPTVBVVEVfQ0hFQ0tTVU0ocmVxKSB7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIGlmICghb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBib2R5ID0gcmVxLmh0dHBSZXF1ZXN0LmJvZHk7XG4gICAgICB2YXIgaXNOb25TdHJlYW1pbmdQYXlsb2FkID0gYm9keSAmJiAoQVdTLnV0aWwuQnVmZmVyLmlzQnVmZmVyKGJvZHkpIHx8IHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyk7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzO1xuICAgICAgaWYgKFxuICAgICAgICBvcGVyYXRpb24uaHR0cENoZWNrc3VtUmVxdWlyZWQgJiZcbiAgICAgICAgcmVxLnNlcnZpY2UuY29uZmlnLmNvbXB1dGVDaGVja3N1bXMgJiZcbiAgICAgICAgaXNOb25TdHJlYW1pbmdQYXlsb2FkICYmXG4gICAgICAgICFoZWFkZXJzWydDb250ZW50LU1ENSddXG4gICAgICApIHtcbiAgICAgICAgdmFyIG1kNSA9IEFXUy51dGlsLmNyeXB0by5tZDUoYm9keSwgJ2Jhc2U2NCcpO1xuICAgICAgICBoZWFkZXJzWydDb250ZW50LU1ENSddID0gbWQ1O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkQXN5bmMoJ0NPTVBVVEVfU0hBMjU2JywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBDT01QVVRFX1NIQTI1NihyZXEsIGRvbmUpIHtcbiAgICAgIHJlcS5oYWx0SGFuZGxlcnNPbkVycm9yKCk7XG4gICAgICBpZiAoIXJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgICAgIHZhciBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgICAgaWYgKCFyZXEuc2VydmljZS5hcGkuc2lnbmF0dXJlVmVyc2lvbiAmJiAhYXV0aHR5cGUgJiYgIXJlcS5zZXJ2aWNlLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSByZXR1cm4gZG9uZSgpOyAvLyBub25lXG4gICAgICBpZiAocmVxLnNlcnZpY2UuZ2V0U2lnbmVyQ2xhc3MocmVxKSA9PT0gQVdTLlNpZ25lcnMuVjQpIHtcbiAgICAgICAgdmFyIGJvZHkgPSByZXEuaHR0cFJlcXVlc3QuYm9keSB8fCAnJztcbiAgICAgICAgaWYgKGF1dGh0eXBlLmluZGV4T2YoJ3Vuc2lnbmVkLWJvZHknKSA+PSAwKSB7XG4gICAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LUNvbnRlbnQtU2hhMjU2J10gPSAnVU5TSUdORUQtUEFZTE9BRCc7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBBV1MudXRpbC5jb21wdXRlU2hhMjU2KGJvZHksIGZ1bmN0aW9uKGVyciwgc2hhKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydYLUFtei1Db250ZW50LVNoYTI1NiddID0gc2hhO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ1NFVF9DT05URU5UX0xFTkdUSCcsICdhZnRlckJ1aWxkJywgZnVuY3Rpb24gU0VUX0NPTlRFTlRfTEVOR1RIKHJlcSkge1xuICAgICAgdmFyIGF1dGh0eXBlID0gZ2V0T3BlcmF0aW9uQXV0aHR5cGUocmVxKTtcbiAgICAgIHZhciBwYXlsb2FkTWVtYmVyID0gQVdTLnV0aWwuZ2V0UmVxdWVzdFBheWxvYWRTaGFwZShyZXEpO1xuICAgICAgaWYgKHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gQVdTLnV0aWwuc3RyaW5nLmJ5dGVMZW5ndGgocmVxLmh0dHBSZXF1ZXN0LmJvZHkpO1xuICAgICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gbGVuZ3RoO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAocGF5bG9hZE1lbWJlciAmJiBwYXlsb2FkTWVtYmVyLmlzU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZE1lbWJlci5yZXF1aXJlc0xlbmd0aCkge1xuICAgICAgICAgICAgICAvL3N0cmVhbWluZyBwYXlsb2FkIHJlcXVpcmVzIGxlbmd0aChzMywgZ2xhY2llcilcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdXRodHlwZS5pbmRleE9mKCd1bnNpZ25lZC1ib2R5JykgPj0gMCkge1xuICAgICAgICAgICAgICAvL3VuYm91bmRlZCBzdHJlYW1pbmcgcGF5bG9hZChsZXgsIG1lZGlhc3RvcmUpXG4gICAgICAgICAgICAgIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydUcmFuc2Zlci1FbmNvZGluZyddID0gJ2NodW5rZWQnO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdTRVRfSFRUUF9IT1NUJywgJ2FmdGVyQnVpbGQnLCBmdW5jdGlvbiBTRVRfSFRUUF9IT1NUKHJlcSkge1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0hvc3QnXSA9IHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0O1xuICAgIH0pO1xuXG4gICAgYWRkKCdTRVRfVFJBQ0VfSUQnLCAnYWZ0ZXJCdWlsZCcsIGZ1bmN0aW9uIFNFVF9UUkFDRV9JRChyZXEpIHtcbiAgICAgIHZhciB0cmFjZUlkSGVhZGVyTmFtZSA9ICdYLUFtem4tVHJhY2UtSWQnO1xuICAgICAgaWYgKEFXUy51dGlsLmlzTm9kZSgpICYmICFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXEuaHR0cFJlcXVlc3QuaGVhZGVycywgdHJhY2VJZEhlYWRlck5hbWUpKSB7XG4gICAgICAgIHZhciBFTlZfTEFNQkRBX0ZVTkNUSU9OX05BTUUgPSAnQVdTX0xBTUJEQV9GVU5DVElPTl9OQU1FJztcbiAgICAgICAgdmFyIEVOVl9UUkFDRV9JRCA9ICdfWF9BTVpOX1RSQUNFX0lEJztcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHByb2Nlc3MuZW52W0VOVl9MQU1CREFfRlVOQ1RJT05fTkFNRV07XG4gICAgICAgIHZhciB0cmFjZUlkID0gcHJvY2Vzcy5lbnZbRU5WX1RSQUNFX0lEXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBmdW5jdGlvbk5hbWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgZnVuY3Rpb25OYW1lLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICB0eXBlb2YgdHJhY2VJZCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICB0cmFjZUlkLmxlbmd0aCA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbdHJhY2VJZEhlYWRlck5hbWVdID0gdHJhY2VJZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdSRVNUQVJUJywgJ3Jlc3RhcnQnLCBmdW5jdGlvbiBSRVNUQVJUKCkge1xuICAgICAgdmFyIGVyciA9IHRoaXMucmVzcG9uc2UuZXJyb3I7XG4gICAgICBpZiAoIWVyciB8fCAhZXJyLnJldHJ5YWJsZSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gbmV3IEFXUy5IdHRwUmVxdWVzdChcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmVuZHBvaW50LFxuICAgICAgICB0aGlzLnNlcnZpY2UucmVnaW9uXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5yZXNwb25zZS5yZXRyeUNvdW50IDwgdGhpcy5zZXJ2aWNlLmNvbmZpZy5tYXhSZXRyaWVzKSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2UucmV0cnlDb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZS5lcnJvciA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgYWRkVG9IZWFkID0gdHJ1ZTtcbiAgICBhZGRBc3luYygnRElTQ09WRVJfRU5EUE9JTlQnLCAnc2lnbicsIERJU0NPVkVSX0VORFBPSU5ULCBhZGRUb0hlYWQpO1xuXG4gICAgYWRkQXN5bmMoJ1NJR04nLCAnc2lnbicsIGZ1bmN0aW9uIFNJR04ocmVxLCBkb25lKSB7XG4gICAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgICAgdmFyIG9wZXJhdGlvbnMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICAgICAgdmFyIGF1dGh0eXBlID0gb3BlcmF0aW9uID8gb3BlcmF0aW9uLmF1dGh0eXBlIDogJyc7XG4gICAgICBpZiAoIXNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb24gJiYgIWF1dGh0eXBlICYmICFzZXJ2aWNlLmNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSByZXR1cm4gZG9uZSgpOyAvLyBub25lXG5cbiAgICAgIGlmIChhdXRodHlwZSA9PT0gJ2JlYXJlcicgfHwgc2VydmljZS5jb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9PT0gJ2JlYXJlcicpIHtcbiAgICAgICAgc2VydmljZS5jb25maWcuZ2V0VG9rZW4oZnVuY3Rpb24gKGVyciwgdG9rZW4pIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXEucmVzcG9uc2UuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgU2lnbmVyQ2xhc3MgPSBzZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSk7XG4gICAgICAgICAgICB2YXIgc2lnbmVyID0gbmV3IFNpZ25lckNsYXNzKHJlcS5odHRwUmVxdWVzdCk7XG4gICAgICAgICAgICBzaWduZXIuYWRkQXV0aG9yaXphdGlvbih0b2tlbik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcnZpY2UuY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uIChlcnIsIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBzZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCk7XG4gICAgICAgICAgICB2YXIgU2lnbmVyQ2xhc3MgPSBzZXJ2aWNlLmdldFNpZ25lckNsYXNzKHJlcSk7XG4gICAgICAgICAgICB2YXIgc2lnbmVyID0gbmV3IFNpZ25lckNsYXNzKHJlcS5odHRwUmVxdWVzdCxcbiAgICAgICAgICAgICAgc2VydmljZS5nZXRTaWduaW5nTmFtZShyZXEpLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlQ2FjaGU6IHNlcnZpY2UuY29uZmlnLnNpZ25hdHVyZUNhY2hlLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZVZlcnNpb246IHNlcnZpY2UuYXBpLnNpZ25hdHVyZVZlcnNpb25cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzaWduZXIuc2V0U2VydmljZUNsaWVudElkKHNlcnZpY2UuX2NsaWVudElkKTtcblxuICAgICAgICAgICAgLy8gY2xlYXIgb2xkIGF1dGhvcml6YXRpb24gaGVhZGVyc1xuICAgICAgICAgICAgZGVsZXRlIHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ107XG4gICAgICAgICAgICBkZWxldGUgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0RhdGUnXTtcbiAgICAgICAgICAgIGRlbGV0ZSByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddO1xuXG4gICAgICAgICAgICAvLyBhZGQgbmV3IGF1dGhvcml6YXRpb25cbiAgICAgICAgICAgIHNpZ25lci5hZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKTtcbiAgICAgICAgICAgIHJlcS5zaWduZWRBdCA9IGRhdGU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVxLnJlc3BvbnNlLmVycm9yID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdWQUxJREFURV9SRVNQT05TRScsICd2YWxpZGF0ZVJlc3BvbnNlJywgZnVuY3Rpb24gVkFMSURBVEVfUkVTUE9OU0UocmVzcCkge1xuICAgICAgaWYgKHRoaXMuc2VydmljZS5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcCwgdGhpcykpIHtcbiAgICAgICAgcmVzcC5kYXRhID0ge307XG4gICAgICAgIHJlc3AuZXJyb3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcC5kYXRhID0gbnVsbDtcbiAgICAgICAgcmVzcC5lcnJvciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICAgIHtjb2RlOiAnVW5rbm93bkVycm9yJywgbWVzc2FnZTogJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQuJ30pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdFUlJPUicsICdlcnJvcicsIGZ1bmN0aW9uIEVSUk9SKGVyciwgcmVzcCkge1xuICAgICAgdmFyIGVycm9yQ29kZU1hcHBpbmcgPSByZXNwLnJlcXVlc3Quc2VydmljZS5hcGkuZXJyb3JDb2RlTWFwcGluZztcbiAgICAgIGlmIChlcnJvckNvZGVNYXBwaW5nICYmIGVyciAmJiBlcnIuY29kZSkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IGVycm9yQ29kZU1hcHBpbmdbZXJyLmNvZGVdO1xuICAgICAgICBpZiAobWFwcGluZykge1xuICAgICAgICAgIHJlc3AuZXJyb3IuY29kZSA9IG1hcHBpbmcuY29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRydWUpO1xuXG4gICAgYWRkQXN5bmMoJ1NFTkQnLCAnc2VuZCcsIGZ1bmN0aW9uIFNFTkQocmVzcCwgZG9uZSkge1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuX2Fib3J0Q2FsbGJhY2sgPSBkb25lO1xuICAgICAgcmVzcC5lcnJvciA9IG51bGw7XG4gICAgICByZXNwLmRhdGEgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsYmFjayhodHRwUmVzcCkge1xuICAgICAgICByZXNwLmh0dHBSZXNwb25zZS5zdHJlYW0gPSBodHRwUmVzcDtcbiAgICAgICAgdmFyIHN0cmVhbSA9IHJlc3AucmVxdWVzdC5odHRwUmVxdWVzdC5zdHJlYW07XG4gICAgICAgIHZhciBzZXJ2aWNlID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2U7XG4gICAgICAgIHZhciBhcGkgPSBzZXJ2aWNlLmFwaTtcbiAgICAgICAgdmFyIG9wZXJhdGlvbk5hbWUgPSByZXNwLnJlcXVlc3Qub3BlcmF0aW9uO1xuICAgICAgICB2YXIgb3BlcmF0aW9uID0gYXBpLm9wZXJhdGlvbnNbb3BlcmF0aW9uTmFtZV0gfHwge307XG5cbiAgICAgICAgaHR0cFJlc3Aub24oJ2hlYWRlcnMnLCBmdW5jdGlvbiBvbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzTWVzc2FnZSkge1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KFxuICAgICAgICAgICAgJ2h0dHBIZWFkZXJzJyxcbiAgICAgICAgICAgIFtzdGF0dXNDb2RlLCBoZWFkZXJzLCByZXNwLCBzdGF0dXNNZXNzYWdlXVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoIXJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbWluZykge1xuICAgICAgICAgICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7IC8vIHN0cmVhbXMyIEFQSSBjaGVja1xuICAgICAgICAgICAgICAvLyBpZiB3ZSBkZXRlY3QgZXZlbnQgc3RyZWFtcywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0b1xuICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHN0cmVhbSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0ICYmIHNlcnZpY2Uuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCByZWFkaW5nIHRoZSBJbmNvbWluZ1N0cmVhbVxuICAgICAgICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRG9uZScpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBodHRwUmVzcC5vbigncmVhZGFibGUnLCBmdW5jdGlvbiBvblJlYWRhYmxlKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gaHR0cFJlc3AucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXNwLnJlcXVlc3QuZW1pdCgnaHR0cERhdGEnLCBbZGF0YSwgcmVzcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBsZWdhY3kgc3RyZWFtcyBBUElcbiAgICAgICAgICAgICAgaHR0cFJlc3Aub24oJ2RhdGEnLCBmdW5jdGlvbiBvbkRhdGEoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRGF0YScsIFtkYXRhLCByZXNwXSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaHR0cFJlc3Aub24oJ2VuZCcsIGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgICAgICAgIGlmICghc3RyZWFtIHx8ICFzdHJlYW0uZGlkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMiAmJiAob3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0ICYmIHNlcnZpY2Uuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3ApKSkge1xuICAgICAgICAgICAgICAvLyBkb24ndCBjb25jYXRlbmF0ZSByZXNwb25zZSBjaHVua3Mgd2hlbiBzdHJlYW1pbmcgZXZlbnQgc3RyZWFtIGRhdGEgd2hlbiByZXNwb25zZSBpcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRG9uZScpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHByb2dyZXNzKGh0dHBSZXNwKSB7XG4gICAgICAgIGh0dHBSZXNwLm9uKCdzZW5kUHJvZ3Jlc3MnLCBmdW5jdGlvbiBvblNlbmRQcm9ncmVzcyh2YWx1ZSkge1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwVXBsb2FkUHJvZ3Jlc3MnLCBbdmFsdWUsIHJlc3BdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaHR0cFJlc3Aub24oJ3JlY2VpdmVQcm9ncmVzcycsIGZ1bmN0aW9uIG9uUmVjZWl2ZVByb2dyZXNzKHZhbHVlKSB7XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb3dubG9hZFByb2dyZXNzJywgW3ZhbHVlLCByZXNwXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnUmVxdWVzdEFib3J0ZWRFcnJvcicpIHtcbiAgICAgICAgICB2YXIgZXJyQ29kZSA9IGVyci5jb2RlID09PSAnVGltZW91dEVycm9yJyA/IGVyci5jb2RlIDogJ05ldHdvcmtpbmdFcnJvcic7XG4gICAgICAgICAgZXJyID0gQVdTLnV0aWwuZXJyb3IoZXJyLCB7XG4gICAgICAgICAgICBjb2RlOiBlcnJDb2RlLFxuICAgICAgICAgICAgcmVnaW9uOiByZXNwLnJlcXVlc3QuaHR0cFJlcXVlc3QucmVnaW9uLFxuICAgICAgICAgICAgaG9zdG5hbWU6IHJlc3AucmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3AuZXJyb3IgPSBlcnI7XG4gICAgICAgIHJlc3AucmVxdWVzdC5lbWl0KCdodHRwRXJyb3InLCBbcmVzcC5lcnJvciwgcmVzcF0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVTZW5kKCkge1xuICAgICAgICB2YXIgaHR0cCA9IEFXUy5IdHRwQ2xpZW50LmdldEluc3RhbmNlKCk7XG4gICAgICAgIHZhciBodHRwT3B0aW9ucyA9IHJlc3AucmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5odHRwT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgc3RyZWFtID0gaHR0cC5oYW5kbGVSZXF1ZXN0KHJlc3AucmVxdWVzdC5odHRwUmVxdWVzdCwgaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaywgZXJyb3IpO1xuICAgICAgICAgIHByb2dyZXNzKHN0cmVhbSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB0aW1lRGlmZiA9IChyZXNwLnJlcXVlc3Quc2VydmljZS5nZXRTa2V3Q29ycmVjdGVkRGF0ZSgpIC0gdGhpcy5zaWduZWRBdCkgLyAxMDAwO1xuICAgICAgaWYgKHRpbWVEaWZmID49IDYwICogMTApIHsgLy8gaWYgd2Ugc2lnbmVkIDEwbWluIGFnbywgcmUtc2lnblxuICAgICAgICB0aGlzLmVtaXQoJ3NpZ24nLCBbdGhpc10sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICBlbHNlIGV4ZWN1dGVTZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY3V0ZVNlbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSFRUUF9IRUFERVJTJywgJ2h0dHBIZWFkZXJzJyxcbiAgICAgICAgZnVuY3Rpb24gSFRUUF9IRUFERVJTKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3AsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSA9IHN0YXR1c01lc3NhZ2U7XG4gICAgICByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkgPSBBV1MudXRpbC5idWZmZXIudG9CdWZmZXIoJycpO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycyA9IFtdO1xuICAgICAgcmVzcC5odHRwUmVzcG9uc2UubnVtQnl0ZXMgPSAwO1xuICAgICAgdmFyIGRhdGVIZWFkZXIgPSBoZWFkZXJzLmRhdGUgfHwgaGVhZGVycy5EYXRlO1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXNwLnJlcXVlc3Quc2VydmljZTtcbiAgICAgIGlmIChkYXRlSGVhZGVyKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJUaW1lID0gRGF0ZS5wYXJzZShkYXRlSGVhZGVyKTtcbiAgICAgICAgaWYgKHNlcnZpY2UuY29uZmlnLmNvcnJlY3RDbG9ja1NrZXdcbiAgICAgICAgICAgICYmIHNlcnZpY2UuaXNDbG9ja1NrZXdlZChzZXJ2ZXJUaW1lKSkge1xuICAgICAgICAgIHNlcnZpY2UuYXBwbHlDbG9ja09mZnNldChzZXJ2ZXJUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdIVFRQX0RBVEEnLCAnaHR0cERhdGEnLCBmdW5jdGlvbiBIVFRQX0RBVEEoY2h1bmssIHJlc3ApIHtcbiAgICAgIGlmIChjaHVuaykge1xuICAgICAgICBpZiAoQVdTLnV0aWwuaXNOb2RlKCkpIHtcbiAgICAgICAgICByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgICB2YXIgdG90YWwgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgICAgICAgIHZhciBwcm9ncmVzcyA9IHsgbG9hZGVkOiByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcywgdG90YWw6IHRvdGFsIH07XG4gICAgICAgICAgcmVzcC5yZXF1ZXN0LmVtaXQoJ2h0dHBEb3dubG9hZFByb2dyZXNzJywgW3Byb2dyZXNzLCByZXNwXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzLnB1c2goQVdTLnV0aWwuYnVmZmVyLnRvQnVmZmVyKGNodW5rKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0hUVFBfRE9ORScsICdodHRwRG9uZScsIGZ1bmN0aW9uIEhUVFBfRE9ORShyZXNwKSB7XG4gICAgICAvLyBjb252ZXJ0IGJ1ZmZlcnMgYXJyYXkgaW50byBzaW5nbGUgYnVmZmVyXG4gICAgICBpZiAocmVzcC5odHRwUmVzcG9uc2UuYnVmZmVycyAmJiByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGJvZHkgPSBBV1MudXRpbC5idWZmZXIuY29uY2F0KHJlc3AuaHR0cFJlc3BvbnNlLmJ1ZmZlcnMpO1xuICAgICAgICByZXNwLmh0dHBSZXNwb25zZS5ib2R5ID0gYm9keTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSByZXNwLmh0dHBSZXNwb25zZS5udW1CeXRlcztcbiAgICAgIGRlbGV0ZSByZXNwLmh0dHBSZXNwb25zZS5idWZmZXJzO1xuICAgIH0pO1xuXG4gICAgYWRkKCdGSU5BTElaRV9FUlJPUicsICdyZXRyeScsIGZ1bmN0aW9uIEZJTkFMSVpFX0VSUk9SKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgICAgIHJlc3AuZXJyb3Iuc3RhdHVzQ29kZSA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChyZXNwLmVycm9yLnJldHJ5YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0aGlzLnNlcnZpY2UucmV0cnlhYmxlRXJyb3IocmVzcC5lcnJvciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnSU5WQUxJREFURV9DUkVERU5USUFMUycsICdyZXRyeScsIGZ1bmN0aW9uIElOVkFMSURBVEVfQ1JFREVOVElBTFMocmVzcCkge1xuICAgICAgaWYgKCFyZXNwLmVycm9yKSByZXR1cm47XG4gICAgICBzd2l0Y2ggKHJlc3AuZXJyb3IuY29kZSkge1xuICAgICAgICBjYXNlICdSZXF1ZXN0RXhwaXJlZCc6IC8vIEVDMiBvbmx5XG4gICAgICAgIGNhc2UgJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbic6XG4gICAgICAgIGNhc2UgJ0V4cGlyZWRUb2tlbic6XG4gICAgICAgICAgcmVzcC5lcnJvci5yZXRyeWFibGUgPSB0cnVlO1xuICAgICAgICAgIHJlc3AucmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5leHBpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnRVhQSVJFRF9TSUdOQVRVUkUnLCAncmV0cnknLCBmdW5jdGlvbiBFWFBJUkVEX1NJR05BVFVSRShyZXNwKSB7XG4gICAgICB2YXIgZXJyID0gcmVzcC5lcnJvcjtcbiAgICAgIGlmICghZXJyKSByZXR1cm47XG4gICAgICBpZiAodHlwZW9mIGVyci5jb2RlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChlcnIuY29kZS5tYXRjaCgvU2lnbmF0dXJlLykgJiYgZXJyLm1lc3NhZ2UubWF0Y2goL2V4cGlyZWQvKSkge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkKCdDTE9DS19TS0VXRUQnLCAncmV0cnknLCBmdW5jdGlvbiBDTE9DS19TS0VXRUQocmVzcCkge1xuICAgICAgaWYgKCFyZXNwLmVycm9yKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlLmNsb2NrU2tld0Vycm9yKHJlc3AuZXJyb3IpXG4gICAgICAgICAgJiYgdGhpcy5zZXJ2aWNlLmNvbmZpZy5jb3JyZWN0Q2xvY2tTa2V3KSB7XG4gICAgICAgIHJlc3AuZXJyb3IucmV0cnlhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZCgnUkVESVJFQ1QnLCAncmV0cnknLCBmdW5jdGlvbiBSRURJUkVDVChyZXNwKSB7XG4gICAgICBpZiAocmVzcC5lcnJvciAmJiByZXNwLmVycm9yLnN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICAgICAgcmVzcC5lcnJvci5zdGF0dXNDb2RlIDwgNDAwICYmIHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ2xvY2F0aW9uJ10pIHtcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdC5lbmRwb2ludCA9XG4gICAgICAgICAgbmV3IEFXUy5FbmRwb2ludChyZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWydsb2NhdGlvbiddKTtcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdC5oZWFkZXJzWydIb3N0J10gPSB0aGlzLmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3Q7XG4gICAgICAgIHJlc3AuZXJyb3IucmVkaXJlY3QgPSB0cnVlO1xuICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ1JFVFJZX0NIRUNLJywgJ3JldHJ5JywgZnVuY3Rpb24gUkVUUllfQ0hFQ0socmVzcCkge1xuICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IucmVkaXJlY3QgJiYgcmVzcC5yZWRpcmVjdENvdW50IDwgcmVzcC5tYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5RGVsYXkgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3AucmV0cnlDb3VudCA8IHJlc3AubWF4UmV0cmllcykge1xuICAgICAgICAgIHJlc3AuZXJyb3IucmV0cnlEZWxheSA9IHRoaXMuc2VydmljZS5yZXRyeURlbGF5cyhyZXNwLnJldHJ5Q291bnQsIHJlc3AuZXJyb3IpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZEFzeW5jKCdSRVNFVF9SRVRSWV9TVEFURScsICdhZnRlclJldHJ5JywgZnVuY3Rpb24gUkVTRVRfUkVUUllfU1RBVEUocmVzcCwgZG9uZSkge1xuICAgICAgdmFyIGRlbGF5LCB3aWxsUmV0cnkgPSBmYWxzZTtcblxuICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgZGVsYXkgPSByZXNwLmVycm9yLnJldHJ5RGVsYXkgfHwgMDtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IucmV0cnlhYmxlICYmIHJlc3AucmV0cnlDb3VudCA8IHJlc3AubWF4UmV0cmllcykge1xuICAgICAgICAgIHJlc3AucmV0cnlDb3VudCsrO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5lcnJvci5yZWRpcmVjdCAmJiByZXNwLnJlZGlyZWN0Q291bnQgPCByZXNwLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgIHJlc3AucmVkaXJlY3RDb3VudCsrO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGVsYXkgPCAwIGlzIGEgc2lnbmFsIGZyb20gY3VzdG9tQmFja29mZiB0byBza2lwIHJldHJpZXNcbiAgICAgIGlmICh3aWxsUmV0cnkgJiYgZGVsYXkgPj0gMCkge1xuICAgICAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICAgICAgc2V0VGltZW91dChkb25lLCBkZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLFxuXG4gIENvcmVQb3N0OiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgYWRkKCdFWFRSQUNUX1JFUVVFU1RfSUQnLCAnZXh0cmFjdERhdGEnLCBBV1MudXRpbC5leHRyYWN0UmVxdWVzdElkKTtcbiAgICBhZGQoJ0VYVFJBQ1RfUkVRVUVTVF9JRCcsICdleHRyYWN0RXJyb3InLCBBV1MudXRpbC5leHRyYWN0UmVxdWVzdElkKTtcblxuICAgIGFkZCgnRU5PVEZPVU5EX0VSUk9SJywgJ2h0dHBFcnJvcicsIGZ1bmN0aW9uIEVOT1RGT1VORF9FUlJPUihlcnIpIHtcbiAgICAgIGZ1bmN0aW9uIGlzRE5TRXJyb3IoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIuZXJybm8gPT09ICdFTk9URk9VTkQnIHx8XG4gICAgICAgICAgdHlwZW9mIGVyci5lcnJubyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICB0eXBlb2YgQVdTLnV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgWydFQUlfTk9OQU1FJywgJ0VBSV9OT0RBVEEnXS5pbmRleE9mKEFXUy51dGlsLmdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pID49IDApO1xuICAgICAgfVxuICAgICAgaWYgKGVyci5jb2RlID09PSAnTmV0d29ya2luZ0Vycm9yJyAmJiBpc0ROU0Vycm9yKGVycikpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnSW5hY2Nlc3NpYmxlIGhvc3Q6IGAnICsgZXJyLmhvc3RuYW1lICsgJ1xcJyBhdCBwb3J0IGAnICsgZXJyLnBvcnQgK1xuICAgICAgICAgICdcXCcuIFRoaXMgc2VydmljZSBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiB0aGUgYCcgKyBlcnIucmVnaW9uICtcbiAgICAgICAgICAnXFwnIHJlZ2lvbi4nO1xuICAgICAgICB0aGlzLnJlc3BvbnNlLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpLCB7XG4gICAgICAgICAgY29kZTogJ1Vua25vd25FbmRwb2ludCcsXG4gICAgICAgICAgcmVnaW9uOiBlcnIucmVnaW9uLFxuICAgICAgICAgIGhvc3RuYW1lOiBlcnIuaG9zdG5hbWUsXG4gICAgICAgICAgcmV0cnlhYmxlOiB0cnVlLFxuICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IGVyclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgTG9nZ2VyOiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgYWRkKCdMT0dfUkVRVUVTVCcsICdjb21wbGV0ZScsIGZ1bmN0aW9uIExPR19SRVFVRVNUKHJlc3ApIHtcbiAgICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgICB2YXIgbG9nZ2VyID0gcmVxLnNlcnZpY2UuY29uZmlnLmxvZ2dlcjtcbiAgICAgIGlmICghbG9nZ2VyKSByZXR1cm47XG4gICAgICBmdW5jdGlvbiBmaWx0ZXJTZW5zaXRpdmVMb2coaW5wdXRTaGFwZSwgc2hhcGUpIHtcbiAgICAgICAgaWYgKCFzaGFwZSkge1xuICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRTaGFwZS5pc1NlbnNpdGl2ZSkge1xuICAgICAgICAgIHJldHVybiAnKioqU2Vuc2l0aXZlSW5mb3JtYXRpb24qKionO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoaW5wdXRTaGFwZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3RydWN0dXJlJzpcbiAgICAgICAgICAgIHZhciBzdHJ1Y3QgPSB7fTtcbiAgICAgICAgICAgIEFXUy51dGlsLmVhY2goc2hhcGUsIGZ1bmN0aW9uKHN1YlNoYXBlTmFtZSwgc3ViU2hhcGUpIHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnB1dFNoYXBlLm1lbWJlcnMsIHN1YlNoYXBlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3Rbc3ViU2hhcGVOYW1lXSA9IGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLm1lbWJlcnNbc3ViU2hhcGVOYW1lXSwgc3ViU2hhcGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cnVjdFtzdWJTaGFwZU5hbWVdID0gc3ViU2hhcGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgICAgICBBV1MudXRpbC5hcnJheUVhY2goc2hhcGUsIGZ1bmN0aW9uKHN1YlNoYXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICBsaXN0LnB1c2goZmlsdGVyU2Vuc2l0aXZlTG9nKGlucHV0U2hhcGUubWVtYmVyLCBzdWJTaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICAgICAgQVdTLnV0aWwuZWFjaChzaGFwZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICBtYXBba2V5XSA9IGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoKSB7XG4gICAgICAgIHZhciB0aW1lID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuZ2V0U2tld0NvcnJlY3RlZERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciBkZWx0YSA9ICh0aW1lIC0gcmVxLnN0YXJ0VGltZS5nZXRUaW1lKCkpIC8gMTAwMDtcbiAgICAgICAgdmFyIGFuc2kgPSBsb2dnZXIuaXNUVFkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHZhciBzdGF0dXMgPSByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICB2YXIgY2Vuc29yZWRQYXJhbXMgPSByZXEucGFyYW1zO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnMgJiZcbiAgICAgICAgICAgICAgcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0gJiZcbiAgICAgICAgICAgICAgcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgICAgICAgICBjZW5zb3JlZFBhcmFtcyA9IGZpbHRlclNlbnNpdGl2ZUxvZyhpbnB1dFNoYXBlLCByZXEucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zID0gcmVxdWlyZSgndXRpbCcpLmluc3BlY3QoY2Vuc29yZWRQYXJhbXMsIHRydWUsIG51bGwpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnO1xuICAgICAgICBpZiAoYW5zaSkgbWVzc2FnZSArPSAnXFx4MUJbMzNtJztcbiAgICAgICAgbWVzc2FnZSArPSAnW0FXUyAnICsgcmVxLnNlcnZpY2Uuc2VydmljZUlkZW50aWZpZXIgKyAnICcgKyBzdGF0dXM7XG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnICsgZGVsdGEudG9TdHJpbmcoKSArICdzICcgKyByZXNwLnJldHJ5Q291bnQgKyAnIHJldHJpZXNdJztcbiAgICAgICAgaWYgKGFuc2kpIG1lc3NhZ2UgKz0gJ1xceDFCWzA7MW0nO1xuICAgICAgICBtZXNzYWdlICs9ICcgJyArIEFXUy51dGlsLnN0cmluZy5sb3dlckZpcnN0KHJlcS5vcGVyYXRpb24pO1xuICAgICAgICBtZXNzYWdlICs9ICcoJyArIHBhcmFtcyArICcpJztcbiAgICAgICAgaWYgKGFuc2kpIG1lc3NhZ2UgKz0gJ1xceDFCWzBtJztcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gYnVpbGRNZXNzYWdlKCk7XG4gICAgICBpZiAodHlwZW9mIGxvZ2dlci5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhsaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvZ2dlci53cml0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsb2dnZXIud3JpdGUobGluZSArICdcXG4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksXG5cbiAgSnNvbjogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL2pzb24nKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUmVzdDogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3QnKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUmVzdEpzb246IG5ldyBTZXF1ZW50aWFsRXhlY3V0b3IoKS5hZGROYW1lZExpc3RlbmVycyhmdW5jdGlvbihhZGQpIHtcbiAgICB2YXIgc3ZjID0gcmVxdWlyZSgnLi9wcm90b2NvbC9yZXN0X2pzb24nKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSksXG5cbiAgUmVzdFhtbDogbmV3IFNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIHZhciBzdmMgPSByZXF1aXJlKCcuL3Byb3RvY29sL3Jlc3RfeG1sJyk7XG4gICAgYWRkKCdCVUlMRCcsICdidWlsZCcsIHN2Yy5idWlsZFJlcXVlc3QpO1xuICAgIGFkZCgnRVhUUkFDVF9EQVRBJywgJ2V4dHJhY3REYXRhJywgc3ZjLmV4dHJhY3REYXRhKTtcbiAgICBhZGQoJ0VYVFJBQ1RfRVJST1InLCAnZXh0cmFjdEVycm9yJywgc3ZjLmV4dHJhY3RFcnJvcik7XG4gIH0pLFxuXG4gIFF1ZXJ5OiBuZXcgU2VxdWVudGlhbEV4ZWN1dG9yKCkuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAgdmFyIHN2YyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wvcXVlcnknKTtcbiAgICBhZGQoJ0JVSUxEJywgJ2J1aWxkJywgc3ZjLmJ1aWxkUmVxdWVzdCk7XG4gICAgYWRkKCdFWFRSQUNUX0RBVEEnLCAnZXh0cmFjdERhdGEnLCBzdmMuZXh0cmFjdERhdGEpO1xuICAgIGFkZCgnRVhUUkFDVF9FUlJPUicsICdleHRyYWN0RXJyb3InLCBzdmMuZXh0cmFjdEVycm9yKTtcbiAgfSlcbn07XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogVGhlIGVuZHBvaW50IHRoYXQgYSBzZXJ2aWNlIHdpbGwgdGFsayB0bywgZm9yIGV4YW1wbGUsXG4gKiBgJ2h0dHBzOi8vZWMyLmFwLXNvdXRoZWFzdC0xLmFtYXpvbmF3cy5jb20nYC4gSWZcbiAqIHlvdSBuZWVkIHRvIG92ZXJyaWRlIGFuIGVuZHBvaW50IGZvciBhIHNlcnZpY2UsIHlvdSBjYW5cbiAqIHNldCB0aGUgZW5kcG9pbnQgb24gYSBzZXJ2aWNlIGJ5IHBhc3NpbmcgdGhlIGVuZHBvaW50XG4gKiBvYmplY3Qgd2l0aCB0aGUgYGVuZHBvaW50YCBvcHRpb24ga2V5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBlcCA9IG5ldyBBV1MuRW5kcG9pbnQoJ2F3c3Byb3h5LmV4YW1wbGUuY29tJyk7XG4gKiB2YXIgczMgPSBuZXcgQVdTLlMzKHtlbmRwb2ludDogZXB9KTtcbiAqIHMzLnNlcnZpY2UuZW5kcG9pbnQuaG9zdG5hbWUgPT0gJ2F3c3Byb3h5LmV4YW1wbGUuY29tJ1xuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IGlmIHlvdSBkbyBub3Qgc3BlY2lmeSBhIHByb3RvY29sLCB0aGUgcHJvdG9jb2wgd2lsbFxuICogYmUgc2VsZWN0ZWQgYmFzZWQgb24geW91ciBjdXJyZW50IHtBV1MuY29uZmlnfSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEAhYXR0cmlidXRlIHByb3RvY29sXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIHByb3RvY29sIChodHRwIG9yIGh0dHBzKSBvZiB0aGUgZW5kcG9pbnRcbiAqICAgICBVUkxcbiAqIEAhYXR0cmlidXRlIGhvc3RuYW1lXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIGhvc3QgcG9ydGlvbiBvZiB0aGUgZW5kcG9pbnQsIGUuZy4sXG4gKiAgICAgZXhhbXBsZS5jb21cbiAqIEAhYXR0cmlidXRlIGhvc3RcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoZSBlbmRwb2ludCBpbmNsdWRpbmdcbiAqICAgICB0aGUgcG9ydCwgZS5nLiwgZXhhbXBsZS5jb206ODBcbiAqIEAhYXR0cmlidXRlIHBvcnRcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIHBvcnQgb2YgdGhlIGVuZHBvaW50XG4gKiBAIWF0dHJpYnV0ZSBocmVmXG4gKiAgIEByZXR1cm4gW1N0cmluZ10gdGhlIGZ1bGwgVVJMIG9mIHRoZSBlbmRwb2ludFxuICovXG5BV1MuRW5kcG9pbnQgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQG92ZXJsb2FkIEVuZHBvaW50KGVuZHBvaW50KVxuICAgKiAgIENvbnN0cnVjdHMgYSBuZXcgZW5kcG9pbnQgZ2l2ZW4gYW4gZW5kcG9pbnQgVVJMLiBJZiB0aGVcbiAgICogICBVUkwgb21pdHMgYSBwcm90b2NvbCAoaHR0cCBvciBodHRwcyksIHRoZSBkZWZhdWx0IHByb3RvY29sXG4gICAqICAgc2V0IGluIHRoZSBnbG9iYWwge0FXUy5jb25maWd9IHdpbGwgYmUgdXNlZC5cbiAgICogICBAcGFyYW0gZW5kcG9pbnQgW1N0cmluZ10gdGhlIFVSTCB0byBjb25zdHJ1Y3QgYW4gZW5kcG9pbnQgZnJvbVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEVuZHBvaW50KGVuZHBvaW50LCBjb25maWcpIHtcbiAgICBBV1MudXRpbC5oaWRlUHJvcGVydGllcyh0aGlzLCBbJ3NsYXNoZXMnLCAnYXV0aCcsICdoYXNoJywgJ3NlYXJjaCcsICdxdWVyeSddKTtcblxuICAgIGlmICh0eXBlb2YgZW5kcG9pbnQgPT09ICd1bmRlZmluZWQnIHx8IGVuZHBvaW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5kcG9pbnQ6ICcgKyBlbmRwb2ludCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kcG9pbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQVdTLnV0aWwuY29weShlbmRwb2ludCk7XG4gICAgfVxuXG4gICAgaWYgKCFlbmRwb2ludC5tYXRjaCgvXmh0dHAvKSkge1xuICAgICAgdmFyIHVzZVNTTCA9IGNvbmZpZyAmJiBjb25maWcuc3NsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgY29uZmlnLnNzbEVuYWJsZWQgOiBBV1MuY29uZmlnLnNzbEVuYWJsZWQ7XG4gICAgICBlbmRwb2ludCA9ICh1c2VTU0wgPyAnaHR0cHMnIDogJ2h0dHAnKSArICc6Ly8nICsgZW5kcG9pbnQ7XG4gICAgfVxuXG4gICAgQVdTLnV0aWwudXBkYXRlKHRoaXMsIEFXUy51dGlsLnVybFBhcnNlKGVuZHBvaW50KSk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIHBvcnQgcHJvcGVydHkgaXMgc2V0IGFzIGFuIGludGVnZXJcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICB0aGlzLnBvcnQgPSBwYXJzZUludCh0aGlzLnBvcnQsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3J0ID0gdGhpcy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MDtcbiAgICB9XG4gIH1cblxufSk7XG5cbi8qKlxuICogVGhlIGxvdyBsZXZlbCBIVFRQIHJlcXVlc3Qgb2JqZWN0LCBlbmNhcHN1bGF0aW5nIGFsbCBIVFRQIGhlYWRlclxuICogYW5kIGJvZHkgZGF0YSBzZW50IGJ5IGEgc2VydmljZSByZXF1ZXN0LlxuICpcbiAqIEAhYXR0cmlidXRlIG1ldGhvZFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBIVFRQIG1ldGhvZCBvZiB0aGUgcmVxdWVzdFxuICogQCFhdHRyaWJ1dGUgcGF0aFxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIFVSSSwgZS5nLixcbiAqICAgICBcIi9saXN0Lz9zdGFydD01Jm51bT0xMFwiXG4gKiBAIWF0dHJpYnV0ZSBoZWFkZXJzXG4gKiAgIEByZXR1cm4gW21hcDxTdHJpbmcsU3RyaW5nPl1cbiAqICAgICBhIG1hcCBvZiBoZWFkZXIga2V5cyBhbmQgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZXNcbiAqIEAhYXR0cmlidXRlIGJvZHlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVxdWVzdCBib2R5IHBheWxvYWRcbiAqIEAhYXR0cmlidXRlIGVuZHBvaW50XG4gKiAgIEByZXR1cm4gW0FXUy5FbmRwb2ludF0gdGhlIGVuZHBvaW50IGZvciB0aGUgcmVxdWVzdFxuICogQCFhdHRyaWJ1dGUgcmVnaW9uXG4gKiAgIEBhcGkgcHJpdmF0ZVxuICogICBAcmV0dXJuIFtTdHJpbmddIHRoZSByZWdpb24sIGZvciBzaWduaW5nIHB1cnBvc2VzIG9ubHkuXG4gKi9cbkFXUy5IdHRwUmVxdWVzdCA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBIdHRwUmVxdWVzdChlbmRwb2ludCwgcmVnaW9uKSB7XG4gICAgZW5kcG9pbnQgPSBuZXcgQVdTLkVuZHBvaW50KGVuZHBvaW50KTtcbiAgICB0aGlzLm1ldGhvZCA9ICdQT1NUJztcbiAgICB0aGlzLnBhdGggPSBlbmRwb2ludC5wYXRoIHx8ICcvJztcbiAgICB0aGlzLmhlYWRlcnMgPSB7fTtcbiAgICB0aGlzLmJvZHkgPSAnJztcbiAgICB0aGlzLmVuZHBvaW50ID0gZW5kcG9pbnQ7XG4gICAgdGhpcy5yZWdpb24gPSByZWdpb247XG4gICAgdGhpcy5fdXNlckFnZW50ID0gJyc7XG4gICAgdGhpcy5zZXRVc2VyQWdlbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRVc2VyQWdlbnQ6IGZ1bmN0aW9uIHNldFVzZXJBZ2VudCgpIHtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSB0aGlzLmhlYWRlcnNbdGhpcy5nZXRVc2VyQWdlbnRIZWFkZXJOYW1lKCldID0gQVdTLnV0aWwudXNlckFnZW50KCk7XG4gIH0sXG5cbiAgZ2V0VXNlckFnZW50SGVhZGVyTmFtZTogZnVuY3Rpb24gZ2V0VXNlckFnZW50SGVhZGVyTmFtZSgpIHtcbiAgICB2YXIgcHJlZml4ID0gQVdTLnV0aWwuaXNCcm93c2VyKCkgPyAnWC1BbXotJyA6ICcnO1xuICAgIHJldHVybiBwcmVmaXggKyAnVXNlci1BZ2VudCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXBwZW5kVG9Vc2VyQWdlbnQ6IGZ1bmN0aW9uIGFwcGVuZFRvVXNlckFnZW50KGFnZW50UGFydGlhbCkge1xuICAgIGlmICh0eXBlb2YgYWdlbnRQYXJ0aWFsID09PSAnc3RyaW5nJyAmJiBhZ2VudFBhcnRpYWwpIHtcbiAgICAgIHRoaXMuX3VzZXJBZ2VudCArPSAnICcgKyBhZ2VudFBhcnRpYWw7XG4gICAgfVxuICAgIHRoaXMuaGVhZGVyc1t0aGlzLmdldFVzZXJBZ2VudEhlYWRlck5hbWUoKV0gPSB0aGlzLl91c2VyQWdlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VXNlckFnZW50OiBmdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJBZ2VudDtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgcGFydCBvZiB0aGUge3BhdGh9IGV4Y2x1ZGluZyB0aGVcbiAgICogICBxdWVyeSBzdHJpbmdcbiAgICovXG4gIHBhdGhuYW1lOiBmdW5jdGlvbiBwYXRobmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoLnNwbGl0KCc/JywgMSlbMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW1N0cmluZ10gdGhlIHF1ZXJ5IHN0cmluZyBwb3J0aW9uIG9mIHRoZSB7cGF0aH1cbiAgICovXG4gIHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKCkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMucGF0aC5zcGxpdCgnPycsIDIpWzFdO1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgcXVlcnkgPSBBV1MudXRpbC5xdWVyeVN0cmluZ1BhcnNlKHF1ZXJ5KTtcbiAgICAgIHJldHVybiBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHF1ZXJ5KTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogdXBkYXRlIGh0dHBSZXF1ZXN0IGVuZHBvaW50IHdpdGggZW5kcG9pbnQgc3RyaW5nXG4gICAqL1xuICB1cGRhdGVFbmRwb2ludDogZnVuY3Rpb24gdXBkYXRlRW5kcG9pbnQoZW5kcG9pbnRTdHIpIHtcbiAgICB2YXIgbmV3RW5kcG9pbnQgPSBuZXcgQVdTLkVuZHBvaW50KGVuZHBvaW50U3RyKTtcbiAgICB0aGlzLmVuZHBvaW50ID0gbmV3RW5kcG9pbnQ7XG4gICAgdGhpcy5wYXRoID0gbmV3RW5kcG9pbnQucGF0aCB8fCAnLyc7XG4gICAgaWYgKHRoaXMuaGVhZGVyc1snSG9zdCddKSB7XG4gICAgICB0aGlzLmhlYWRlcnNbJ0hvc3QnXSA9IG5ld0VuZHBvaW50Lmhvc3Q7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBUaGUgbG93IGxldmVsIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBlbmNhcHN1bGF0aW5nIGFsbCBIVFRQIGhlYWRlclxuICogYW5kIGJvZHkgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICpcbiAqIEAhYXR0cmlidXRlIHN0YXR1c0NvZGVcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIEhUVFAgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlIChlLmcuLCAyMDAsIDQwNClcbiAqIEAhYXR0cmlidXRlIGhlYWRlcnNcbiAqICAgQHJldHVybiBbbWFwPFN0cmluZyxTdHJpbmc+XVxuICogICAgICBhIG1hcCBvZiByZXNwb25zZSBoZWFkZXIga2V5cyBhbmQgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZXNcbiAqIEAhYXR0cmlidXRlIGJvZHlcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgcmVzcG9uc2UgYm9keSBwYXlsb2FkXG4gKiBAIWF0dHJpYnV0ZSBbcl0gc3RyZWFtaW5nXG4gKiAgIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhpcyByZXNwb25zZSBpcyBiZWluZyBzdHJlYW1lZCBhdCBhIGxvdy1sZXZlbC5cbiAqICAgICBEZWZhdWx0cyB0byBgZmFsc2VgIChidWZmZXJlZCByZWFkcykuIERvIG5vdCBtb2RpZnkgdGhpcyBtYW51YWxseSwgdXNlXG4gKiAgICAge2NyZWF0ZVVuYnVmZmVyZWRTdHJlYW19IHRvIGNvbnZlcnQgdGhlIHN0cmVhbSB0byB1bmJ1ZmZlcmVkIG1vZGVcbiAqICAgICBpbnN0ZWFkLlxuICovXG5BV1MuSHR0cFJlc3BvbnNlID0gaW5oZXJpdCh7XG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEh0dHBSZXNwb25zZSgpIHtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RyZWFtaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNhYmxlcyBidWZmZXJpbmcgb24gdGhlIEhUVFAgcmVzcG9uc2UgYW5kIHJldHVybnMgdGhlIHN0cmVhbSBmb3IgcmVhZGluZy5cbiAgICogQHJldHVybiBbU3RyZWFtLCBYTUxIdHRwUmVxdWVzdCwgbnVsbF0gdGhlIHVuZGVybHlpbmcgc3RyZWFtIG9iamVjdC5cbiAgICogICBVc2UgdGhpcyBvYmplY3QgdG8gZGlyZWN0bHkgcmVhZCBkYXRhIG9mZiBvZiB0aGUgc3RyZWFtLlxuICAgKiBAbm90ZSBUaGlzIG9iamVjdCBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciB0aGUge0FXUy5SZXF1ZXN0fmh0dHBIZWFkZXJzfVxuICAgKiAgIGV2ZW50IGhhcyBmaXJlZC4gVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG9cbiAgICogICB7QVdTLlJlcXVlc3R+aHR0cERhdGF9LlxuICAgKiBAZXhhbXBsZSBUYWtpbmcgY29udHJvbCBvZiBhIHN0cmVhbVxuICAgKiAgIHJlcXVlc3Qub24oJ2h0dHBIZWFkZXJzJywgZnVuY3Rpb24oc3RhdHVzQ29kZSwgaGVhZGVycykge1xuICAgKiAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICogICAgICAgaWYgKGhlYWRlcnMuZXRhZyA9PT0gJ3h5eicpIHtcbiAgICogICAgICAgICAvLyBwaXBlIHRoZSBzdHJlYW0sIGRpc2FibGluZyBidWZmZXJpbmdcbiAgICogICAgICAgICB2YXIgc3RyZWFtID0gdGhpcy5yZXNwb25zZS5odHRwUmVzcG9uc2UuY3JlYXRlVW5idWZmZXJlZFN0cmVhbSgpO1xuICAgKiAgICAgICAgIHN0cmVhbS5waXBlKHByb2Nlc3Muc3Rkb3V0KTtcbiAgICogICAgICAgfSBlbHNlIHsgLy8gYWJvcnQgdGhpcyByZXF1ZXN0IGFuZCBzZXQgYSBiZXR0ZXIgZXJyb3IgbWVzc2FnZVxuICAgKiAgICAgICAgIHRoaXMuYWJvcnQoKTtcbiAgICogICAgICAgICB0aGlzLnJlc3BvbnNlLmVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkIEVUYWcnKTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAgKiAgIH0pLnNlbmQoY29uc29sZS5sb2cpO1xuICAgKi9cbiAgY3JlYXRlVW5idWZmZXJlZFN0cmVhbTogZnVuY3Rpb24gY3JlYXRlVW5idWZmZXJlZFN0cmVhbSgpIHtcbiAgICB0aGlzLnN0cmVhbWluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtO1xuICB9XG59KTtcblxuXG5BV1MuSHR0cENsaWVudCA9IGluaGVyaXQoe30pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICBpZiAodGhpcy5zaW5nbGV0b24gPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc2luZ2xldG9uID0gbmV3IHRoaXMoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5zaW5nbGV0b247XG59O1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5yZXF1aXJlKCcuLi9odHRwJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5YSFJDbGllbnQgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgaGFuZGxlUmVxdWVzdDogZnVuY3Rpb24gaGFuZGxlUmVxdWVzdChodHRwUmVxdWVzdCwgaHR0cE9wdGlvbnMsIGNhbGxiYWNrLCBlcnJDYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZW5kcG9pbnQgPSBodHRwUmVxdWVzdC5lbmRwb2ludDtcbiAgICB2YXIgZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB2YXIgaHJlZiA9IGVuZHBvaW50LnByb3RvY29sICsgJy8vJyArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICAgIGlmIChlbmRwb2ludC5wb3J0ICE9PSA4MCAmJiBlbmRwb2ludC5wb3J0ICE9PSA0NDMpIHtcbiAgICAgIGhyZWYgKz0gJzonICsgZW5kcG9pbnQucG9ydDtcbiAgICB9XG4gICAgaHJlZiArPSBodHRwUmVxdWVzdC5wYXRoO1xuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCBoZWFkZXJzRW1pdHRlZCA9IGZhbHNlO1xuICAgIGh0dHBSZXF1ZXN0LnN0cmVhbSA9IHhocjtcblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCkgcmV0dXJuOyAvLyAwIGNvZGUgaXMgaW52YWxpZFxuICAgICAgfSBjYXRjaCAoZSkgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA+PSB0aGlzLkhFQURFUlNfUkVDRUlWRUQgJiYgIWhlYWRlcnNFbWl0dGVkKSB7XG4gICAgICAgIGVtaXR0ZXIuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG4gICAgICAgIGVtaXR0ZXIuaGVhZGVycyA9IHNlbGYucGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gICAgICAgIGVtaXR0ZXIuZW1pdChcbiAgICAgICAgICAnaGVhZGVycycsXG4gICAgICAgICAgZW1pdHRlci5zdGF0dXNDb2RlLFxuICAgICAgICAgIGVtaXR0ZXIuaGVhZGVycyxcbiAgICAgICAgICB4aHIuc3RhdHVzVGV4dFxuICAgICAgICApO1xuICAgICAgICBoZWFkZXJzRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgc2VsZi5maW5pc2hSZXF1ZXN0KHhociwgZW1pdHRlcik7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBlbWl0dGVyLmVtaXQoJ3NlbmRQcm9ncmVzcycsIGV2dCk7XG4gICAgfSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgZW1pdHRlci5lbWl0KCdyZWNlaXZlUHJvZ3Jlc3MnLCBldnQpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignVGltZW91dCcpLCB7Y29kZTogJ1RpbWVvdXRFcnJvcid9KSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVyckNhbGxiYWNrKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignTmV0d29yayBGYWlsdXJlJyksIHtcbiAgICAgICAgY29kZTogJ05ldHdvcmtpbmdFcnJvcidcbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgZXJyQ2FsbGJhY2soQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSwge1xuICAgICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcidcbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBjYWxsYmFjayhlbWl0dGVyKTtcbiAgICB4aHIub3BlbihodHRwUmVxdWVzdC5tZXRob2QsIGhyZWYsIGh0dHBPcHRpb25zLnhockFzeW5jICE9PSBmYWxzZSk7XG4gICAgQVdTLnV0aWwuZWFjaChodHRwUmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAhPT0gJ0NvbnRlbnQtTGVuZ3RoJyAmJiBrZXkgIT09ICdVc2VyLUFnZW50JyAmJiBrZXkgIT09ICdIb3N0Jykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIGh0dHBPcHRpb25zLnhockFzeW5jICE9PSBmYWxzZSkge1xuICAgICAgeGhyLnRpbWVvdXQgPSBodHRwT3B0aW9ucy50aW1lb3V0O1xuICAgIH1cblxuICAgIGlmIChodHRwT3B0aW9ucy54aHJXaXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cbiAgICB0cnkgeyB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJzsgfSBjYXRjaCAoZSkge31cblxuICAgIHRyeSB7XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuYm9keSkge1xuICAgICAgICB4aHIuc2VuZChodHRwUmVxdWVzdC5ib2R5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoaHR0cFJlcXVlc3QuYm9keSAmJiB0eXBlb2YgaHR0cFJlcXVlc3QuYm9keS5idWZmZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHhoci5zZW5kKGh0dHBSZXF1ZXN0LmJvZHkuYnVmZmVyKTsgLy8gc2VuZCBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbWl0dGVyO1xuICB9LFxuXG4gIHBhcnNlSGVhZGVyczogZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIEFXUy51dGlsLmFycmF5RWFjaChyYXdIZWFkZXJzLnNwbGl0KC9cXHI/XFxuLyksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIga2V5ID0gbGluZS5zcGxpdCgnOicsIDEpWzBdO1xuICAgICAgdmFyIHZhbHVlID0gbGluZS5zdWJzdHJpbmcoa2V5Lmxlbmd0aCArIDIpO1xuICAgICAgaWYgKGtleS5sZW5ndGggPiAwKSBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9LFxuXG4gIGZpbmlzaFJlcXVlc3Q6IGZ1bmN0aW9uIGZpbmlzaFJlcXVlc3QoeGhyLCBlbWl0dGVyKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJyAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgIHZhciBhYiA9IHhoci5yZXNwb25zZTtcbiAgICAgIGJ1ZmZlciA9IG5ldyBBV1MudXRpbC5CdWZmZXIoYWIuYnl0ZUxlbmd0aCk7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghYnVmZmVyICYmIHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXIgPSBuZXcgQVdTLnV0aWwuQnVmZmVyKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBpZiAoYnVmZmVyKSBlbWl0dGVyLmVtaXQoJ2RhdGEnLCBidWZmZXIpO1xuICAgIGVtaXR0ZXIuZW1pdCgnZW5kJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuSHR0cENsaWVudC5wcm90b3R5cGUgPSBBV1MuWEhSQ2xpZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPSAxO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25CdWlsZGVyKCkgeyB9XG5cbkpzb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHZhbHVlLCBzaGFwZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkpO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgY2FzZSAnc3RydWN0dXJlJzogcmV0dXJuIHRyYW5zbGF0ZVN0cnVjdHVyZSh2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiB0cmFuc2xhdGVNYXAodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdsaXN0JzogcmV0dXJuIHRyYW5zbGF0ZUxpc3QodmFsdWUsIHNoYXBlKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU3RydWN0dXJlKHN0cnVjdHVyZSwgc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmlzRG9jdW1lbnQpIHtcbiAgICByZXR1cm4gc3RydWN0dXJlO1xuICB9XG4gIHZhciBzdHJ1Y3QgPSB7fTtcbiAgdXRpbC5lYWNoKHN0cnVjdHVyZSwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbWVtYmVyU2hhcGUgPSBzaGFwZS5tZW1iZXJzW25hbWVdO1xuICAgIGlmIChtZW1iZXJTaGFwZSkge1xuICAgICAgaWYgKG1lbWJlclNoYXBlLmxvY2F0aW9uICE9PSAnYm9keScpIHJldHVybjtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBtZW1iZXJTaGFwZS5pc0xvY2F0aW9uTmFtZSA/IG1lbWJlclNoYXBlLm5hbWUgOiBuYW1lO1xuICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgbWVtYmVyU2hhcGUpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBzdHJ1Y3RbbG9jYXRpb25OYW1lXSA9IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3RydWN0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMaXN0KGxpc3QsIHNoYXBlKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdXRpbC5hcnJheUVhY2gobGlzdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgb3V0LnB1c2gocmVzdWx0KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZU1hcChtYXAsIHNoYXBlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdXRpbC5lYWNoKG1hcCwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLnZhbHVlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIG91dFtrZXldID0gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU2NhbGFyKHZhbHVlLCBzaGFwZSkge1xuICByZXR1cm4gc2hhcGUudG9XaXJlRm9ybWF0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKc29uQnVpbGRlcjtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBKc29uUGFyc2VyKCkgeyB9XG5cbkpzb25QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoSlNPTi5wYXJzZSh2YWx1ZSksIHNoYXBlKTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUpIHtcbiAgaWYgKCFzaGFwZSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiB0cmFuc2xhdGVTdHJ1Y3R1cmUodmFsdWUsIHNoYXBlKTtcbiAgICBjYXNlICdtYXAnOiByZXR1cm4gdHJhbnNsYXRlTWFwKHZhbHVlLCBzaGFwZSk7XG4gICAgY2FzZSAnbGlzdCc6IHJldHVybiB0cmFuc2xhdGVMaXN0KHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHRyYW5zbGF0ZVNjYWxhcih2YWx1ZSwgc2hhcGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVN0cnVjdHVyZShzdHJ1Y3R1cmUsIHNoYXBlKSB7XG4gIGlmIChzdHJ1Y3R1cmUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHNoYXBlLmlzRG9jdW1lbnQpIHJldHVybiBzdHJ1Y3R1cmU7XG5cbiAgdmFyIHN0cnVjdCA9IHt9O1xuICB2YXIgc2hhcGVNZW1iZXJzID0gc2hhcGUubWVtYmVycztcbiAgdXRpbC5lYWNoKHNoYXBlTWVtYmVycywgZnVuY3Rpb24obmFtZSwgbWVtYmVyU2hhcGUpIHtcbiAgICB2YXIgbG9jYXRpb25OYW1lID0gbWVtYmVyU2hhcGUuaXNMb2NhdGlvbk5hbWUgPyBtZW1iZXJTaGFwZS5uYW1lIDogbmFtZTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0cnVjdHVyZSwgbG9jYXRpb25OYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gc3RydWN0dXJlW2xvY2F0aW9uTmFtZV07XG4gICAgICB2YXIgcmVzdWx0ID0gdHJhbnNsYXRlKHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHN0cnVjdFtuYW1lXSA9IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3RydWN0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMaXN0KGxpc3QsIHNoYXBlKSB7XG4gIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgdmFyIG91dCA9IFtdO1xuICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2xhdGUodmFsdWUsIHNoYXBlLm1lbWJlcik7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBvdXQucHVzaChudWxsKTtcbiAgICBlbHNlIG91dC5wdXNoKHJlc3VsdCk7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVNYXAobWFwLCBzaGFwZSkge1xuICBpZiAobWFwID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgdmFyIG91dCA9IHt9O1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zbGF0ZSh2YWx1ZSwgc2hhcGUudmFsdWUpO1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgb3V0W2tleV0gPSBudWxsO1xuICAgIGVsc2Ugb3V0W2tleV0gPSByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVTY2FsYXIodmFsdWUsIHNoYXBlKSB7XG4gIHJldHVybiBzaGFwZS50b1R5cGUodmFsdWUpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QYXJzZXI7XG4iLCJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xudmFyIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL3NoYXBlJyk7XG52YXIgUGFnaW5hdG9yID0gcmVxdWlyZSgnLi9wYWdpbmF0b3InKTtcbnZhciBSZXNvdXJjZVdhaXRlciA9IHJlcXVpcmUoJy4vcmVzb3VyY2Vfd2FpdGVyJyk7XG52YXIgbWV0YWRhdGEgPSByZXF1aXJlKCcuLi8uLi9hcGlzL21ldGFkYXRhLmpzb24nKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgcHJvcGVydHkgPSB1dGlsLnByb3BlcnR5O1xudmFyIG1lbW9pemVkUHJvcGVydHkgPSB1dGlsLm1lbW9pemVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIEFwaShhcGksIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBhcGkgPSBhcGkgfHwge307XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmFwaSA9IHRoaXM7XG5cbiAgYXBpLm1ldGFkYXRhID0gYXBpLm1ldGFkYXRhIHx8IHt9O1xuXG4gIHZhciBzZXJ2aWNlSWRlbnRpZmllciA9IG9wdGlvbnMuc2VydmljZUlkZW50aWZpZXI7XG4gIGRlbGV0ZSBvcHRpb25zLnNlcnZpY2VJZGVudGlmaWVyO1xuXG4gIHByb3BlcnR5KHRoaXMsICdpc0FwaScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaVZlcnNpb24nLCBhcGkubWV0YWRhdGEuYXBpVmVyc2lvbik7XG4gIHByb3BlcnR5KHRoaXMsICdlbmRwb2ludFByZWZpeCcsIGFwaS5tZXRhZGF0YS5lbmRwb2ludFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduaW5nTmFtZScsIGFwaS5tZXRhZGF0YS5zaWduaW5nTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdnbG9iYWxFbmRwb2ludCcsIGFwaS5tZXRhZGF0YS5nbG9iYWxFbmRwb2ludCk7XG4gIHByb3BlcnR5KHRoaXMsICdzaWduYXR1cmVWZXJzaW9uJywgYXBpLm1ldGFkYXRhLnNpZ25hdHVyZVZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnanNvblZlcnNpb24nLCBhcGkubWV0YWRhdGEuanNvblZlcnNpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAndGFyZ2V0UHJlZml4JywgYXBpLm1ldGFkYXRhLnRhcmdldFByZWZpeCk7XG4gIHByb3BlcnR5KHRoaXMsICdwcm90b2NvbCcsIGFwaS5tZXRhZGF0YS5wcm90b2NvbCk7XG4gIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBhcGkubWV0YWRhdGEudGltZXN0YW1wRm9ybWF0KTtcbiAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIGFwaS5tZXRhZGF0YS54bWxOYW1lc3BhY2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYWJicmV2aWF0aW9uJywgYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24pO1xuICBwcm9wZXJ0eSh0aGlzLCAnZnVsbE5hbWUnLCBhcGkubWV0YWRhdGEuc2VydmljZUZ1bGxOYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ3NlcnZpY2VJZCcsIGFwaS5tZXRhZGF0YS5zZXJ2aWNlSWQpO1xuICBpZiAoc2VydmljZUlkZW50aWZpZXIgJiYgbWV0YWRhdGFbc2VydmljZUlkZW50aWZpZXJdKSB7XG4gICAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTm9EZWZhdWx0TGlzdHMnLCBtZXRhZGF0YVtzZXJ2aWNlSWRlbnRpZmllcl0ueG1sTm9EZWZhdWx0TGlzdHMsIGZhbHNlKTtcbiAgfVxuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2NsYXNzTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gYXBpLm1ldGFkYXRhLnNlcnZpY2VBYmJyZXZpYXRpb24gfHwgYXBpLm1ldGFkYXRhLnNlcnZpY2VGdWxsTmFtZTtcbiAgICBpZiAoIW5hbWUpIHJldHVybiBudWxsO1xuXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXkFtYXpvbnxBV1NcXHMqfFxcKC4qfFxccyt8XFxXKy9nLCAnJyk7XG4gICAgaWYgKG5hbWUgPT09ICdFbGFzdGljTG9hZEJhbGFuY2luZycpIG5hbWUgPSAnRUxCJztcbiAgICByZXR1cm4gbmFtZTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gYWRkRW5kcG9pbnRPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5lbmRwb2ludG9wZXJhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgcHJvcGVydHkoc2VsZiwgJ2VuZHBvaW50T3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdChuYW1lKSk7XG4gICAgfVxuICAgIGlmIChvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkgJiYgIXNlbGYuaGFzUmVxdWlyZWRFbmRwb2ludERpc2NvdmVyeSkge1xuICAgICAgcHJvcGVydHkoXG4gICAgICAgIHNlbGYsXG4gICAgICAgICdoYXNSZXF1aXJlZEVuZHBvaW50RGlzY292ZXJ5JyxcbiAgICAgICAgb3BlcmF0aW9uLmVuZHBvaW50ZGlzY292ZXJ5LnJlcXVpcmVkID09PSB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByb3BlcnR5KHRoaXMsICdvcGVyYXRpb25zJywgbmV3IENvbGxlY3Rpb24oYXBpLm9wZXJhdGlvbnMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIG9wZXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgT3BlcmF0aW9uKG5hbWUsIG9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gIH0sIHV0aWwuc3RyaW5nLmxvd2VyRmlyc3QsIGFkZEVuZHBvaW50T3BlcmF0aW9uKSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3NoYXBlcycsIG5ldyBDb2xsZWN0aW9uKGFwaS5zaGFwZXMsIG9wdGlvbnMsIGZ1bmN0aW9uKG5hbWUsIHNoYXBlKSB7XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZSwgb3B0aW9ucyk7XG4gIH0pKTtcblxuICBwcm9wZXJ0eSh0aGlzLCAncGFnaW5hdG9ycycsIG5ldyBDb2xsZWN0aW9uKGFwaS5wYWdpbmF0b3JzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBwYWdpbmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFBhZ2luYXRvcihuYW1lLCBwYWdpbmF0b3IsIG9wdGlvbnMpO1xuICB9KSk7XG5cbiAgcHJvcGVydHkodGhpcywgJ3dhaXRlcnMnLCBuZXcgQ29sbGVjdGlvbihhcGkud2FpdGVycywgb3B0aW9ucywgZnVuY3Rpb24obmFtZSwgd2FpdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBSZXNvdXJjZVdhaXRlcihuYW1lLCB3YWl0ZXIsIG9wdGlvbnMpO1xuICB9LCB1dGlsLnN0cmluZy5sb3dlckZpcnN0KSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgYXBpLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgYXBpLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG4gIHByb3BlcnR5KHRoaXMsICdlcnJvckNvZGVNYXBwaW5nJywgYXBpLmF3c1F1ZXJ5Q29tcGF0aWJsZSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQXBpO1xuIiwidmFyIG1lbW9pemVkUHJvcGVydHkgPSByZXF1aXJlKCcuLi91dGlsJykubWVtb2l6ZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gbWVtb2l6ZShuYW1lLCB2YWx1ZSwgZmFjdG9yeSwgbmFtZVRyKSB7XG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgbmFtZVRyKG5hbWUpLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFjdG9yeShuYW1lLCB2YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKGl0ZXJhYmxlLCBvcHRpb25zLCBmYWN0b3J5LCBuYW1lVHIsIGNhbGxiYWNrKSB7XG4gIG5hbWVUciA9IG5hbWVUciB8fCBTdHJpbmc7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmb3IgKHZhciBpZCBpbiBpdGVyYWJsZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaXRlcmFibGUsIGlkKSkge1xuICAgICAgbWVtb2l6ZS5jYWxsKHNlbGYsIGlkLCBpdGVyYWJsZVtpZF0sIGZhY3RvcnksIG5hbWVUcik7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGlkLCBpdGVyYWJsZVtpZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuL3NoYXBlJyk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHByb3BlcnR5ID0gdXRpbC5wcm9wZXJ0eTtcbnZhciBtZW1vaXplZFByb3BlcnR5ID0gdXRpbC5tZW1vaXplZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBPcGVyYXRpb24obmFtZSwgb3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBvcGVyYXRpb24ubmFtZSB8fCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgb3BlcmF0aW9uLmh0dHAgPSBvcGVyYXRpb24uaHR0cCB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ2VuZHBvaW50Jywgb3BlcmF0aW9uLmVuZHBvaW50KTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBNZXRob2QnLCBvcGVyYXRpb24uaHR0cC5tZXRob2QgfHwgJ1BPU1QnKTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBQYXRoJywgb3BlcmF0aW9uLmh0dHAucmVxdWVzdFVyaSB8fCAnLycpO1xuICBwcm9wZXJ0eSh0aGlzLCAnYXV0aHR5cGUnLCBvcGVyYXRpb24uYXV0aHR5cGUgfHwgJycpO1xuICBwcm9wZXJ0eShcbiAgICB0aGlzLFxuICAgICdlbmRwb2ludERpc2NvdmVyeVJlcXVpcmVkJyxcbiAgICBvcGVyYXRpb24uZW5kcG9pbnRkaXNjb3ZlcnkgP1xuICAgICAgKG9wZXJhdGlvbi5lbmRwb2ludGRpc2NvdmVyeS5yZXF1aXJlZCA/ICdSRVFVSVJFRCcgOiAnT1BUSU9OQUwnKSA6XG4gICAgJ05VTEwnXG4gICk7XG5cbiAgLy8gaHR0cENoZWNrc3VtIHJlcGxhY2VzIHVzYWdlIG9mIGh0dHBDaGVja3N1bVJlcXVpcmVkLCBidXQgc29tZSBBUElzXG4gIC8vIChzM2NvbnRyb2wpIHN0aWxsIHVzZXMgb2xkIHRyYWl0LlxuICB2YXIgaHR0cENoZWNrc3VtUmVxdWlyZWQgPSBvcGVyYXRpb24uaHR0cENoZWNrc3VtUmVxdWlyZWRcbiAgICB8fCAob3BlcmF0aW9uLmh0dHBDaGVja3N1bSAmJiBvcGVyYXRpb24uaHR0cENoZWNrc3VtLnJlcXVlc3RDaGVja3N1bVJlcXVpcmVkKTtcbiAgcHJvcGVydHkodGhpcywgJ2h0dHBDaGVja3N1bVJlcXVpcmVkJywgaHR0cENoZWNrc3VtUmVxdWlyZWQsIGZhbHNlKTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdpbnB1dCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICghb3BlcmF0aW9uLmlucHV0KSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLmNyZWF0ZSh7dHlwZTogJ3N0cnVjdHVyZSd9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShvcGVyYXRpb24uaW5wdXQsIG9wdGlvbnMpO1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdvdXRwdXQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoIW9wZXJhdGlvbi5vdXRwdXQpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGUuY3JlYXRlKG9wZXJhdGlvbi5vdXRwdXQsIG9wdGlvbnMpO1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdlcnJvcnMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIGlmICghb3BlcmF0aW9uLmVycm9ycykgcmV0dXJuIG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wZXJhdGlvbi5lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3QucHVzaChTaGFwZS5jcmVhdGUob3BlcmF0aW9uLmVycm9yc1tpXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9KTtcblxuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdwYWdpbmF0b3InLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5hcGkucGFnaW5hdG9yc1tuYW1lXTtcbiAgfSk7XG5cbiAgaWYgKG9wdGlvbnMuZG9jdW1lbnRhdGlvbikge1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uJywgb3BlcmF0aW9uLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgb3BlcmF0aW9uLmRvY3VtZW50YXRpb25VcmwpO1xuICB9XG5cbiAgLy8gaWRlbXBvdGVudE1lbWJlcnMgb25seSB0cmFja3MgdG9wLWxldmVsIGlucHV0IHNoYXBlc1xuICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdpZGVtcG90ZW50TWVtYmVycycsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZGVtcG90ZW50TWVtYmVycyA9IFtdO1xuICAgIHZhciBpbnB1dCA9IHNlbGYuaW5wdXQ7XG4gICAgdmFyIG1lbWJlcnMgPSBpbnB1dC5tZW1iZXJzO1xuICAgIGlmICghaW5wdXQubWVtYmVycykge1xuICAgICAgcmV0dXJuIGlkZW1wb3RlbnRNZW1iZXJzO1xuICAgIH1cbiAgICBmb3IgKHZhciBuYW1lIGluIG1lbWJlcnMpIHtcbiAgICAgIGlmICghbWVtYmVycy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXJzW25hbWVdLmlzSWRlbXBvdGVudCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZGVtcG90ZW50TWVtYmVycy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWRlbXBvdGVudE1lbWJlcnM7XG4gIH0pO1xuXG4gIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2hhc0V2ZW50T3V0cHV0JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dHB1dCA9IHNlbGYub3V0cHV0O1xuICAgIHJldHVybiBoYXNFdmVudFN0cmVhbShvdXRwdXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFzRXZlbnRTdHJlYW0odG9wTGV2ZWxTaGFwZSkge1xuICB2YXIgbWVtYmVycyA9IHRvcExldmVsU2hhcGUubWVtYmVycztcbiAgdmFyIHBheWxvYWQgPSB0b3BMZXZlbFNoYXBlLnBheWxvYWQ7XG5cbiAgaWYgKCF0b3BMZXZlbFNoYXBlLm1lbWJlcnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gbWVtYmVyc1twYXlsb2FkXTtcbiAgICByZXR1cm4gcGF5bG9hZE1lbWJlci5pc0V2ZW50U3RyZWFtO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgYW55IG1lbWJlciBpcyBhbiBldmVudCBzdHJlYW1cbiAgZm9yICh2YXIgbmFtZSBpbiBtZW1iZXJzKSB7XG4gICAgaWYgKCFtZW1iZXJzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBpZiAobWVtYmVyc1tuYW1lXS5pc0V2ZW50U3RyZWFtID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uO1xuIiwidmFyIHByb3BlcnR5ID0gcmVxdWlyZSgnLi4vdXRpbCcpLnByb3BlcnR5O1xuXG5mdW5jdGlvbiBQYWdpbmF0b3IobmFtZSwgcGFnaW5hdG9yKSB7XG4gIHByb3BlcnR5KHRoaXMsICdpbnB1dFRva2VuJywgcGFnaW5hdG9yLmlucHV0X3Rva2VuKTtcbiAgcHJvcGVydHkodGhpcywgJ2xpbWl0S2V5JywgcGFnaW5hdG9yLmxpbWl0X2tleSk7XG4gIHByb3BlcnR5KHRoaXMsICdtb3JlUmVzdWx0cycsIHBhZ2luYXRvci5tb3JlX3Jlc3VsdHMpO1xuICBwcm9wZXJ0eSh0aGlzLCAnb3V0cHV0VG9rZW4nLCBwYWdpbmF0b3Iub3V0cHV0X3Rva2VuKTtcbiAgcHJvcGVydHkodGhpcywgJ3Jlc3VsdEtleScsIHBhZ2luYXRvci5yZXN1bHRfa2V5KTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBQYWdpbmF0b3I7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwcm9wZXJ0eSA9IHV0aWwucHJvcGVydHk7XG5cbmZ1bmN0aW9uIFJlc291cmNlV2FpdGVyKG5hbWUsIHdhaXRlciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCBuYW1lKTtcbiAgcHJvcGVydHkodGhpcywgJ2FwaScsIG9wdGlvbnMuYXBpLCBmYWxzZSk7XG5cbiAgaWYgKHdhaXRlci5vcGVyYXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnb3BlcmF0aW9uJywgdXRpbC5zdHJpbmcubG93ZXJGaXJzdCh3YWl0ZXIub3BlcmF0aW9uKSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBrZXlzID0gW1xuICAgICd0eXBlJyxcbiAgICAnZGVzY3JpcHRpb24nLFxuICAgICdkZWxheScsXG4gICAgJ21heEF0dGVtcHRzJyxcbiAgICAnYWNjZXB0b3JzJ1xuICBdO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgdmFsdWUgPSB3YWl0ZXJba2V5XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHByb3BlcnR5KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVzb3VyY2VXYWl0ZXI7XG4iLCJ2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vY29sbGVjdGlvbicpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gcHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHV0aWwucHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZW1vaXplZFByb3BlcnR5KG9iaiwgbmFtZSkge1xuICBpZiAoIW9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmFtZV0pIHtcbiAgICB1dGlsLm1lbW9pemVkUHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTaGFwZShzaGFwZSwgb3B0aW9ucywgbWVtYmVyTmFtZSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBwcm9wZXJ0eSh0aGlzLCAnc2hhcGUnLCBzaGFwZS5zaGFwZSk7XG4gIHByb3BlcnR5KHRoaXMsICdhcGknLCBvcHRpb25zLmFwaSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAndHlwZScsIHNoYXBlLnR5cGUpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW51bScsIHNoYXBlLmVudW0pO1xuICBwcm9wZXJ0eSh0aGlzLCAnbWluJywgc2hhcGUubWluKTtcbiAgcHJvcGVydHkodGhpcywgJ21heCcsIHNoYXBlLm1heCk7XG4gIHByb3BlcnR5KHRoaXMsICdwYXR0ZXJuJywgc2hhcGUucGF0dGVybik7XG4gIHByb3BlcnR5KHRoaXMsICdsb2NhdGlvbicsIHNoYXBlLmxvY2F0aW9uIHx8IHRoaXMubG9jYXRpb24gfHwgJ2JvZHknKTtcbiAgcHJvcGVydHkodGhpcywgJ25hbWUnLCB0aGlzLm5hbWUgfHwgc2hhcGUueG1sTmFtZSB8fCBzaGFwZS5xdWVyeU5hbWUgfHxcbiAgICBzaGFwZS5sb2NhdGlvbk5hbWUgfHwgbWVtYmVyTmFtZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1N0cmVhbWluZycsIHNoYXBlLnN0cmVhbWluZyB8fCB0aGlzLmlzU3RyZWFtaW5nIHx8IGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ3JlcXVpcmVzTGVuZ3RoJywgc2hhcGUucmVxdWlyZXNMZW5ndGgsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzQ29tcG9zaXRlJywgc2hhcGUuaXNDb21wb3NpdGUgfHwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNTaGFwZScsIHRydWUsIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzUXVlcnlOYW1lJywgQm9vbGVhbihzaGFwZS5xdWVyeU5hbWUpLCBmYWxzZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0xvY2F0aW9uTmFtZScsIEJvb2xlYW4oc2hhcGUubG9jYXRpb25OYW1lKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNJZGVtcG90ZW50Jywgc2hhcGUuaWRlbXBvdGVuY3lUb2tlbiA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0pzb25WYWx1ZScsIHNoYXBlLmpzb252YWx1ZSA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc1NlbnNpdGl2ZScsIHNoYXBlLnNlbnNpdGl2ZSA9PT0gdHJ1ZSB8fCBzaGFwZS5wcm90b3R5cGUgJiYgc2hhcGUucHJvdG90eXBlLnNlbnNpdGl2ZSA9PT0gdHJ1ZSk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0V2ZW50U3RyZWFtJywgQm9vbGVhbihzaGFwZS5ldmVudHN0cmVhbSksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnQnLCBCb29sZWFuKHNoYXBlLmV2ZW50KSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNFdmVudFBheWxvYWQnLCBCb29sZWFuKHNoYXBlLmV2ZW50cGF5bG9hZCksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2lzRXZlbnRIZWFkZXInLCBCb29sZWFuKHNoYXBlLmV2ZW50aGVhZGVyKSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnaXNUaW1lc3RhbXBGb3JtYXRTZXQnLCBCb29sZWFuKHNoYXBlLnRpbWVzdGFtcEZvcm1hdCkgfHwgc2hhcGUucHJvdG90eXBlICYmIHNoYXBlLnByb3RvdHlwZS5pc1RpbWVzdGFtcEZvcm1hdFNldCA9PT0gdHJ1ZSwgZmFsc2UpO1xuICBwcm9wZXJ0eSh0aGlzLCAnZW5kcG9pbnREaXNjb3ZlcnlJZCcsIEJvb2xlYW4oc2hhcGUuZW5kcG9pbnRkaXNjb3ZlcnlpZCksIGZhbHNlKTtcbiAgcHJvcGVydHkodGhpcywgJ2hvc3RMYWJlbCcsIEJvb2xlYW4oc2hhcGUuaG9zdExhYmVsKSwgZmFsc2UpO1xuXG4gIGlmIChvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZG9jdW1lbnRhdGlvbicsIHNoYXBlLmRvY3VtZW50YXRpb24pO1xuICAgIHByb3BlcnR5KHRoaXMsICdkb2N1bWVudGF0aW9uVXJsJywgc2hhcGUuZG9jdW1lbnRhdGlvblVybCk7XG4gIH1cblxuICBpZiAoc2hhcGUueG1sQXR0cmlidXRlKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzWG1sQXR0cmlidXRlJywgc2hhcGUueG1sQXR0cmlidXRlIHx8IGZhbHNlKTtcbiAgfVxuXG4gIC8vIHR5cGUgY29udmVyc2lvbiBhbmQgcGFyc2luZ1xuICBwcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdFZhbHVlJywgbnVsbCk7XG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLm5vcm1hbGl6ZWRUeXBlcyA9IHtcbiAgY2hhcmFjdGVyOiAnc3RyaW5nJyxcbiAgZG91YmxlOiAnZmxvYXQnLFxuICBsb25nOiAnaW50ZWdlcicsXG4gIHNob3J0OiAnaW50ZWdlcicsXG4gIGJpZ2ludGVnZXI6ICdpbnRlZ2VyJyxcbiAgYmlnZGVjaW1hbDogJ2Zsb2F0JyxcbiAgYmxvYjogJ2JpbmFyeSdcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNoYXBlLnR5cGVzID0ge1xuICAnc3RydWN0dXJlJzogU3RydWN0dXJlU2hhcGUsXG4gICdsaXN0JzogTGlzdFNoYXBlLFxuICAnbWFwJzogTWFwU2hhcGUsXG4gICdib29sZWFuJzogQm9vbGVhblNoYXBlLFxuICAndGltZXN0YW1wJzogVGltZXN0YW1wU2hhcGUsXG4gICdmbG9hdCc6IEZsb2F0U2hhcGUsXG4gICdpbnRlZ2VyJzogSW50ZWdlclNoYXBlLFxuICAnc3RyaW5nJzogU3RyaW5nU2hhcGUsXG4gICdiYXNlNjQnOiBCYXNlNjRTaGFwZSxcbiAgJ2JpbmFyeSc6IEJpbmFyeVNoYXBlXG59O1xuXG5TaGFwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShzaGFwZSwgb3B0aW9ucykge1xuICBpZiAoc2hhcGUuc2hhcGUpIHtcbiAgICB2YXIgcmVmU2hhcGUgPSBvcHRpb25zLmFwaS5zaGFwZXNbc2hhcGUuc2hhcGVdO1xuICAgIGlmICghcmVmU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc2hhcGUgcmVmZXJlbmNlOiAnICsgc2hhcGUuc2hhcGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZTaGFwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuU2hhcGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKSB7XG4gIGlmIChzaGFwZS5pc1NoYXBlKSByZXR1cm4gc2hhcGU7XG5cbiAgdmFyIHJlZlNoYXBlID0gU2hhcGUucmVzb2x2ZShzaGFwZSwgb3B0aW9ucyk7XG4gIGlmIChyZWZTaGFwZSkge1xuICAgIHZhciBmaWx0ZXJlZEtleXMgPSBPYmplY3Qua2V5cyhzaGFwZSk7XG4gICAgaWYgKCFvcHRpb25zLmRvY3VtZW50YXRpb24pIHtcbiAgICAgIGZpbHRlcmVkS2V5cyA9IGZpbHRlcmVkS2V5cy5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gIW5hbWUubWF0Y2goL2RvY3VtZW50YXRpb24vKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbiBpbmxpbmUgc2hhcGUgd2l0aCBleHRyYSBtZW1iZXJzXG4gICAgdmFyIElubGluZVNoYXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWZTaGFwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKTtcbiAgICB9O1xuICAgIElubGluZVNoYXBlLnByb3RvdHlwZSA9IHJlZlNoYXBlO1xuICAgIHJldHVybiBuZXcgSW5saW5lU2hhcGUoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzZXQgdHlwZSBpZiBub3Qgc2V0XG4gICAgaWYgKCFzaGFwZS50eXBlKSB7XG4gICAgICBpZiAoc2hhcGUubWVtYmVycykgc2hhcGUudHlwZSA9ICdzdHJ1Y3R1cmUnO1xuICAgICAgZWxzZSBpZiAoc2hhcGUubWVtYmVyKSBzaGFwZS50eXBlID0gJ2xpc3QnO1xuICAgICAgZWxzZSBpZiAoc2hhcGUua2V5KSBzaGFwZS50eXBlID0gJ21hcCc7XG4gICAgICBlbHNlIHNoYXBlLnR5cGUgPSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgdHlwZXNcbiAgICB2YXIgb3JpZ1R5cGUgPSBzaGFwZS50eXBlO1xuICAgIGlmIChTaGFwZS5ub3JtYWxpemVkVHlwZXNbc2hhcGUudHlwZV0pIHtcbiAgICAgIHNoYXBlLnR5cGUgPSBTaGFwZS5ub3JtYWxpemVkVHlwZXNbc2hhcGUudHlwZV07XG4gICAgfVxuXG4gICAgaWYgKFNoYXBlLnR5cGVzW3NoYXBlLnR5cGVdKSB7XG4gICAgICByZXR1cm4gbmV3IFNoYXBlLnR5cGVzW3NoYXBlLnR5cGVdKHNoYXBlLCBvcHRpb25zLCBtZW1iZXJOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgc2hhcGUgdHlwZTogJyArIG9yaWdUeXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIENvbXBvc2l0ZVNoYXBlKHNoYXBlKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHByb3BlcnR5KHRoaXMsICdpc0NvbXBvc2l0ZScsIHRydWUpO1xuXG4gIGlmIChzaGFwZS5mbGF0dGVuZWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnZmxhdHRlbmVkJywgc2hhcGUuZmxhdHRlbmVkIHx8IGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBTdHJ1Y3R1cmVTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZXF1aXJlZE1hcCA9IG51bGwsIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG5cbiAgQ29tcG9zaXRlU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZmlyc3RJbml0KSB7XG4gICAgcHJvcGVydHkodGhpcywgJ2RlZmF1bHRWYWx1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4ge307IH0pO1xuICAgIHByb3BlcnR5KHRoaXMsICdtZW1iZXJzJywge30pO1xuICAgIHByb3BlcnR5KHRoaXMsICdtZW1iZXJOYW1lcycsIFtdKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZWQnLCBbXSk7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzUmVxdWlyZWQnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAnaXNEb2N1bWVudCcsIEJvb2xlYW4oc2hhcGUuZG9jdW1lbnQpKTtcbiAgfVxuXG4gIGlmIChzaGFwZS5tZW1iZXJzKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ21lbWJlcnMnLCBuZXcgQ29sbGVjdGlvbihzaGFwZS5tZW1iZXJzLCBvcHRpb25zLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUobWVtYmVyLCBvcHRpb25zLCBuYW1lKTtcbiAgICB9KSk7XG4gICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnbWVtYmVyTmFtZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzaGFwZS54bWxPcmRlciB8fCBPYmplY3Qua2V5cyhzaGFwZS5tZW1iZXJzKTtcbiAgICB9KTtcblxuICAgIGlmIChzaGFwZS5ldmVudCkge1xuICAgICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXZlbnRQYXlsb2FkTWVtYmVyTmFtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gc2VsZi5tZW1iZXJOYW1lcztcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIG1lbWJlcnMgdG8gZmluZCBvbmVzIHRoYXQgYXJlIGV2ZW50IHBheWxvYWRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gbWVtYmVyTmFtZXMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG1lbWJlcnNbbWVtYmVyTmFtZXNbaV1dLmlzRXZlbnRQYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVtYmVyTmFtZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbWVtb2l6ZWRQcm9wZXJ0eSh0aGlzLCAnZXZlbnRIZWFkZXJNZW1iZXJOYW1lcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcbiAgICAgICAgdmFyIG1lbWJlck5hbWVzID0gc2VsZi5tZW1iZXJOYW1lcztcbiAgICAgICAgdmFyIGV2ZW50SGVhZGVyTWVtYmVyTmFtZXMgPSBbXTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIG1lbWJlcnMgdG8gZmluZCBvbmVzIHRoYXQgYXJlIGV2ZW50IGhlYWRlcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBtZW1iZXJOYW1lcy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobWVtYmVyc1ttZW1iZXJOYW1lc1tpXV0uaXNFdmVudEhlYWRlcikge1xuICAgICAgICAgICAgZXZlbnRIZWFkZXJNZW1iZXJOYW1lcy5wdXNoKG1lbWJlck5hbWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50SGVhZGVyTWVtYmVyTmFtZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hhcGUucmVxdWlyZWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncmVxdWlyZWQnLCBzaGFwZS5yZXF1aXJlZCk7XG4gICAgcHJvcGVydHkodGhpcywgJ2lzUmVxdWlyZWQnLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAoIXJlcXVpcmVkTWFwKSB7XG4gICAgICAgIHJlcXVpcmVkTWFwID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGUucmVxdWlyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXF1aXJlZE1hcFtzaGFwZS5yZXF1aXJlZFtpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXF1aXJlZE1hcFtuYW1lXTtcbiAgICB9LCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICBwcm9wZXJ0eSh0aGlzLCAncmVzdWx0V3JhcHBlcicsIHNoYXBlLnJlc3VsdFdyYXBwZXIgfHwgbnVsbCk7XG5cbiAgaWYgKHNoYXBlLnBheWxvYWQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAncGF5bG9hZCcsIHNoYXBlLnBheWxvYWQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaGFwZS54bWxOYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIHNoYXBlLnhtbE5hbWVzcGFjZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNoYXBlLnhtbE5hbWVzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAneG1sTmFtZXNwYWNlUHJlZml4Jywgc2hhcGUueG1sTmFtZXNwYWNlLnByZWZpeCk7XG4gICAgcHJvcGVydHkodGhpcywgJ3htbE5hbWVzcGFjZVVyaScsIHNoYXBlLnhtbE5hbWVzcGFjZS51cmkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIExpc3RTaGFwZShzaGFwZSwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXMsIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG4gIENvbXBvc2l0ZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGZpcnN0SW5pdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgfVxuXG4gIGlmIChzaGFwZS5tZW1iZXIpIHtcbiAgICBtZW1vaXplZFByb3BlcnR5KHRoaXMsICdtZW1iZXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZS5jcmVhdGUoc2hhcGUubWVtYmVyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0aGlzLmZsYXR0ZW5lZCkge1xuICAgIHZhciBvbGROYW1lID0gdGhpcy5uYW1lO1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ25hbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZWxmLm1lbWJlci5uYW1lIHx8IG9sZE5hbWU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gTWFwU2hhcGUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgdmFyIGZpcnN0SW5pdCA9ICF0aGlzLmlzU2hhcGU7XG4gIENvbXBvc2l0ZVNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGZpcnN0SW5pdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICdkZWZhdWx0VmFsdWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9KTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAna2V5JywgU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RyaW5nJ30sIG9wdGlvbnMpKTtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndmFsdWUnLCBTaGFwZS5jcmVhdGUoe3R5cGU6ICdzdHJpbmcnfSwgb3B0aW9ucykpO1xuICB9XG5cbiAgaWYgKHNoYXBlLmtleSkge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ2tleScsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFNoYXBlLmNyZWF0ZShzaGFwZS5rZXksIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIGlmIChzaGFwZS52YWx1ZSkge1xuICAgIG1lbW9pemVkUHJvcGVydHkodGhpcywgJ3ZhbHVlJywgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGUuY3JlYXRlKHNoYXBlLnZhbHVlLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUaW1lc3RhbXBTaGFwZShzaGFwZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKHNoYXBlLnRpbWVzdGFtcEZvcm1hdCkge1xuICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCBzaGFwZS50aW1lc3RhbXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHNlbGYuaXNUaW1lc3RhbXBGb3JtYXRTZXQgJiYgdGhpcy50aW1lc3RhbXBGb3JtYXQpIHtcbiAgICBwcm9wZXJ0eSh0aGlzLCAndGltZXN0YW1wRm9ybWF0JywgdGhpcy50aW1lc3RhbXBGb3JtYXQpO1xuICB9IGVsc2UgaWYgKHRoaXMubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdyZmM4MjInKTtcbiAgfSBlbHNlIGlmICh0aGlzLmxvY2F0aW9uID09PSAncXVlcnlzdHJpbmcnKSB7XG4gICAgcHJvcGVydHkodGhpcywgJ3RpbWVzdGFtcEZvcm1hdCcsICdpc284NjAxJyk7XG4gIH0gZWxzZSBpZiAodGhpcy5hcGkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYXBpLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgIGNhc2UgJ3Jlc3QtanNvbic6XG4gICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAndW5peFRpbWVzdGFtcCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3QteG1sJzpcbiAgICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGNhc2UgJ2VjMic6XG4gICAgICAgIHByb3BlcnR5KHRoaXMsICd0aW1lc3RhbXBGb3JtYXQnLCAnaXNvODYwMScpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnRvVHlwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2YgdmFsdWUudG9VVENTdHJpbmcgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID9cbiAgICAgICAgICAgdXRpbC5kYXRlLnBhcnNlVGltZXN0YW1wKHZhbHVlKSA6IG51bGw7XG4gIH07XG5cbiAgdGhpcy50b1dpcmVGb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLmRhdGUuZm9ybWF0KHZhbHVlLCBzZWxmLnRpbWVzdGFtcEZvcm1hdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFN0cmluZ1NoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHZhciBudWxsTGVzc1Byb3RvY29scyA9IFsncmVzdC14bWwnLCAncXVlcnknLCAnZWMyJ107XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRoaXMuYXBpICYmIG51bGxMZXNzUHJvdG9jb2xzLmluZGV4T2YodGhpcy5hcGkucHJvdG9jb2wpID4gLTEgP1xuICAgICAgdmFsdWUgfHwgJycgOiB2YWx1ZTtcbiAgICBpZiAodGhpcy5pc0pzb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgP1xuICAgICAgdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuICB9O1xuXG4gIHRoaXMudG9XaXJlRm9ybWF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc0pzb25WYWx1ZSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBGbG9hdFNoYXBlKCkge1xuICBTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9O1xuICB0aGlzLnRvV2lyZUZvcm1hdCA9IHRoaXMudG9UeXBlO1xufVxuXG5mdW5jdGlvbiBJbnRlZ2VyU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSB0aGlzLnRvVHlwZTtcbn1cblxuZnVuY3Rpb24gQmluYXJ5U2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMudG9UeXBlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgYnVmID0gdXRpbC5iYXNlNjQuZGVjb2RlKHZhbHVlKTtcbiAgICBpZiAodGhpcy5pc1NlbnNpdGl2ZSAmJiB1dGlsLmlzTm9kZSgpICYmIHR5cGVvZiB1dGlsLkJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAvKiBOb2RlLmpzIGNhbiBjcmVhdGUgYSBCdWZmZXIgdGhhdCBpcyBub3QgaXNvbGF0ZWQuXG4gICAqIGkuZS4gYnVmLmJ5dGVMZW5ndGggIT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aFxuICAgKiBUaGlzIG1lYW5zIHRoYXQgdGhlIHNlbnNpdGl2ZSBkYXRhIGlzIGFjY2Vzc2libGUgdG8gYW55b25lIHdpdGggYWNjZXNzIHRvIGJ1Zi5idWZmZXIuXG4gICAqIElmIHRoaXMgaXMgdGhlIG5vZGUgc2hhcmVkIEJ1ZmZlciwgdGhlbiBvdGhlciBjb2RlIHdpdGhpbiB0aGlzIHByb2Nlc3MgX2NvdWxkXyBmaW5kIHRoaXMgc2VjcmV0LlxuICAgKiBDb3B5IHNlbnNpdGl2ZSBkYXRhIHRvIGFuIGlzb2xhdGVkIEJ1ZmZlciBhbmQgemVybyB0aGUgc2Vuc2l0aXZlIGRhdGEuXG4gICAqIFdoaWxlIHRoaXMgaXMgc2FmZSB0byBkbyBoZXJlLCBjb3B5aW5nIHRoaXMgY29kZSBzb21ld2hlcmUgZWxzZSBtYXkgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAqL1xuICAgICAgdmFyIHNlY3VyZUJ1ZiA9IHV0aWwuQnVmZmVyLmFsbG9jKGJ1Zi5sZW5ndGgsIGJ1Zik7XG4gICAgICBidWYuZmlsbCgwKTtcbiAgICAgIGJ1ZiA9IHNlY3VyZUJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcbiAgdGhpcy50b1dpcmVGb3JtYXQgPSB1dGlsLmJhc2U2NC5lbmNvZGU7XG59XG5cbmZ1bmN0aW9uIEJhc2U2NFNoYXBlKCkge1xuICBCaW5hcnlTaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBCb29sZWFuU2hhcGUoKSB7XG4gIFNoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b1R5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdmFsdWUgPT09ICd0cnVlJztcbiAgfTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2hhcGUuc2hhcGVzID0ge1xuICBTdHJ1Y3R1cmVTaGFwZTogU3RydWN0dXJlU2hhcGUsXG4gIExpc3RTaGFwZTogTGlzdFNoYXBlLFxuICBNYXBTaGFwZTogTWFwU2hhcGUsXG4gIFN0cmluZ1NoYXBlOiBTdHJpbmdTaGFwZSxcbiAgQm9vbGVhblNoYXBlOiBCb29sZWFuU2hhcGUsXG4gIEJhc2U2NFNoYXBlOiBCYXNlNjRTaGFwZVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlBhcmFtVmFsaWRhdG9yID0gQVdTLnV0aWwuaW5oZXJpdCh7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmFsaWRhdG9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHZhbGlkYXRpb24gW0Jvb2xlYW58bWFwXSB3aGV0aGVyIGlucHV0IHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgb3BlcmF0aW9uIGRlc2NyaXB0aW9uIGJlZm9yZSBzZW5kaW5nIHRoZVxuICAgKiAgICAgcmVxdWVzdC4gUGFzcyBhIG1hcCB0byBlbmFibGUgYW55IG9mIHRoZSBmb2xsb3dpbmcgc3BlY2lmaWNcbiAgICogICAgIHZhbGlkYXRpb24gZmVhdHVyZXM6XG4gICAqXG4gICAqICAgICAqICoqbWluKiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWluXG4gICAqICAgICAgIGNvbnN0cmFpbnQuIFRoaXMgaXMgZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gcGFyYW1WYWxpZGF0aW9uIGlzIHNldFxuICAgKiAgICAgICB0byBgdHJ1ZWAuXG4gICAqICAgICAqICoqbWF4KiogW0Jvb2xlYW5dICZtZGFzaDsgVmFsaWRhdGVzIHRoYXQgYSB2YWx1ZSBtZWV0cyB0aGUgbWF4XG4gICAqICAgICAgIGNvbnN0cmFpbnQuXG4gICAqICAgICAqICoqcGF0dGVybioqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgYVxuICAgKiAgICAgICByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqICAgICAqICoqZW51bSoqIFtCb29sZWFuXSAmbWRhc2g7IFZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHZhbHVlIG1hdGNoZXMgb25lXG4gICAqICAgICAgIG9mIHRoZSBhbGxvd2FibGUgZW51bSB2YWx1ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gUGFyYW1WYWxpZGF0b3IodmFsaWRhdGlvbikge1xuICAgIGlmICh2YWxpZGF0aW9uID09PSB0cnVlIHx8IHZhbGlkYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsaWRhdGlvbiA9IHsnbWluJzogdHJ1ZX07XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGlvbiA9IHZhbGlkYXRpb247XG4gIH0sXG5cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUsIHBhcmFtcyB8fCB7fSwgY29udGV4dCB8fCAncGFyYW1zJyk7XG5cbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIG1zZyA9IHRoaXMuZXJyb3JzLmpvaW4oJ1xcbiogJyk7XG4gICAgICBtc2cgPSAnVGhlcmUgd2VyZSAnICsgdGhpcy5lcnJvcnMubGVuZ3RoICtcbiAgICAgICAgJyB2YWxpZGF0aW9uIGVycm9yczpcXG4qICcgKyBtc2c7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobXNnKSxcbiAgICAgICAge2NvZGU6ICdNdWx0aXBsZVZhbGlkYXRpb25FcnJvcnMnLCBlcnJvcnM6IHRoaXMuZXJyb3JzfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZmFpbDogZnVuY3Rpb24gZmFpbChjb2RlLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5lcnJvcnMucHVzaChBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IobWVzc2FnZSksIHtjb2RlOiBjb2RlfSkpO1xuICB9LFxuXG4gIHZhbGlkYXRlU3RydWN0dXJlOiBmdW5jdGlvbiB2YWxpZGF0ZVN0cnVjdHVyZShzaGFwZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHNoYXBlLmlzRG9jdW1lbnQpIHJldHVybiB0cnVlO1xuXG4gICAgdGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbJ29iamVjdCddLCAnc3RydWN0dXJlJyk7XG4gICAgdmFyIHBhcmFtTmFtZTtcbiAgICBmb3IgKHZhciBpID0gMDsgc2hhcGUucmVxdWlyZWQgJiYgaSA8IHNoYXBlLnJlcXVpcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJhbU5hbWUgPSBzaGFwZS5yZXF1aXJlZFtpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNaXNzaW5nUmVxdWlyZWRQYXJhbWV0ZXInLFxuICAgICAgICAgICdNaXNzaW5nIHJlcXVpcmVkIGtleSBcXCcnICsgcGFyYW1OYW1lICsgJ1xcJyBpbiAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgaGFzaCBtZW1iZXJzXG4gICAgZm9yIChwYXJhbU5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtTmFtZSkpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtc1twYXJhbU5hbWVdLFxuICAgICAgICAgIG1lbWJlclNoYXBlID0gc2hhcGUubWVtYmVyc1twYXJhbU5hbWVdO1xuXG4gICAgICBpZiAobWVtYmVyU2hhcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbWVtYmVyQ29udGV4dCA9IFtjb250ZXh0LCBwYXJhbU5hbWVdLmpvaW4oJy4nKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihtZW1iZXJTaGFwZSwgcGFyYW1WYWx1ZSwgbWVtYmVyQ29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwYXJhbVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnVW5leHBlY3RlZFBhcmFtZXRlcicsXG4gICAgICAgICAgJ1VuZXhwZWN0ZWQga2V5IFxcJycgKyBwYXJhbU5hbWUgKyAnXFwnIGZvdW5kIGluICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICB2YWxpZGF0ZU1lbWJlcjogZnVuY3Rpb24gdmFsaWRhdGVNZW1iZXIoc2hhcGUsIHBhcmFtLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChzaGFwZS50eXBlKSB7XG4gICAgICBjYXNlICdzdHJ1Y3R1cmUnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cnVjdHVyZShzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlTGlzdChzaGFwZSwgcGFyYW0sIGNvbnRleHQpO1xuICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVNYXAoc2hhcGUsIHBhcmFtLCBjb250ZXh0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2NhbGFyKHNoYXBlLCBwYXJhbSwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlTGlzdDogZnVuY3Rpb24gdmFsaWRhdGVMaXN0KHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbQXJyYXldKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBwYXJhbXMubGVuZ3RoLCBjb250ZXh0LCAnbGlzdCBtZW1iZXIgY291bnQnKTtcbiAgICAgIC8vIHZhbGlkYXRlIGFycmF5IG1lbWJlcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUubWVtYmVyLCBwYXJhbXNbaV0sIGNvbnRleHQgKyAnWycgKyBpICsgJ10nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVNYXA6IGZ1bmN0aW9uIHZhbGlkYXRlTWFwKHNoYXBlLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy52YWxpZGF0ZVR5cGUocGFyYW1zLCBjb250ZXh0LCBbJ29iamVjdCddLCAnbWFwJykpIHtcbiAgICAgIC8vIEJ1aWxkIHVwIGEgY291bnQgb2YgbWFwIG1lbWJlcnMgdG8gdmFsaWRhdGUgcmFuZ2UgdHJhaXRzLlxuICAgICAgdmFyIG1hcENvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsIHBhcmFtKSkgY29udGludWU7XG4gICAgICAgIC8vIFZhbGlkYXRlIGFueSBtYXAga2V5IHRyYWl0IGNvbnN0cmFpbnRzXG4gICAgICAgIHRoaXMudmFsaWRhdGVNZW1iZXIoc2hhcGUua2V5LCBwYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1trZXk9XFwnJyArIHBhcmFtICsgJ1xcJ10nKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lbWJlcihzaGFwZS52YWx1ZSwgcGFyYW1zW3BhcmFtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ICsgJ1tcXCcnICsgcGFyYW0gKyAnXFwnXScpO1xuICAgICAgICBtYXBDb3VudCsrO1xuICAgICAgfVxuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCBtYXBDb3VudCwgY29udGV4dCwgJ21hcCBtZW1iZXIgY291bnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVTY2FsYXI6IGZ1bmN0aW9uIHZhbGlkYXRlU2NhbGFyKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVN0cmluZyhzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUGF5bG9hZCh2YWx1ZSwgY29udGV4dCk7XG4gICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVOdW1iZXIoc2hhcGUsIHZhbHVlLCBjb250ZXh0KTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIFsnYm9vbGVhbiddKTtcbiAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgW0RhdGUsXG4gICAgICAgICAgL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT9aJC8sICdudW1iZXInXSxcbiAgICAgICAgICAnRGF0ZSBvYmplY3QsIElTTy04NjAxIHN0cmluZywgb3IgYSBVTklYIHRpbWVzdGFtcCcpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbCgnVW5rb3duVHlwZScsICdVbmhhbmRsZWQgdHlwZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS50eXBlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVN0cmluZzogZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbGlkVHlwZXMgPSBbJ3N0cmluZyddO1xuICAgIGlmIChzaGFwZS5pc0pzb25WYWx1ZSkge1xuICAgICAgdmFsaWRUeXBlcyA9IHZhbGlkVHlwZXMuY29uY2F0KFsnbnVtYmVyJywgJ29iamVjdCcsICdib29sZWFuJ10pO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy52YWxpZGF0ZVR5cGUodmFsdWUsIGNvbnRleHQsIHZhbGlkVHlwZXMpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlRW51bShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZS5sZW5ndGgsIGNvbnRleHQsICdzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICB0aGlzLnZhbGlkYXRlUGF0dGVybihzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgICAgdGhpcy52YWxpZGF0ZVVyaShzaGFwZSwgdmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVVyaTogZnVuY3Rpb24gdmFsaWRhdGVVcmkoc2hhcGUsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgaWYgKHNoYXBlWydsb2NhdGlvbiddID09PSAndXJpJykge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmZhaWwoJ1VyaVBhcmFtZXRlckVycm9yJywgJ0V4cGVjdGVkIHVyaSBwYXJhbWV0ZXIgdG8gaGF2ZSBsZW5ndGggPj0gMSwnXG4gICAgICAgICAgKyAnIGJ1dCBmb3VuZCBcIicgKyB2YWx1ZSArJ1wiIGZvciAnICsgY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHZhbGlkYXRlUGF0dGVybjogZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ3BhdHRlcm4nXSAmJiBzaGFwZVsncGF0dGVybiddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghKG5ldyBSZWdFeHAoc2hhcGVbJ3BhdHRlcm4nXSkpLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnUGF0dGVybk1hdGNoRXJyb3InLCAnUHJvdmlkZWQgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgJ1xuICAgICAgICAgICsgJ2RvZXMgbm90IG1hdGNoIHJlZ2V4IHBhdHRlcm4gLycgKyBzaGFwZVsncGF0dGVybiddICsgJy8gZm9yICdcbiAgICAgICAgICArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVJhbmdlOiBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCwgZGVzY3JpcHRvcikge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ21pbiddKSB7XG4gICAgICBpZiAoc2hhcGVbJ21pbiddICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBzaGFwZVsnbWluJ10pIHtcbiAgICAgICAgdGhpcy5mYWlsKCdNaW5SYW5nZUVycm9yJywgJ0V4cGVjdGVkICcgKyBkZXNjcmlwdG9yICsgJyA+PSAnXG4gICAgICAgICAgKyBzaGFwZVsnbWluJ10gKyAnLCBidXQgZm91bmQgJyArIHZhbHVlICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy52YWxpZGF0aW9uWydtYXgnXSkge1xuICAgICAgaWYgKHNoYXBlWydtYXgnXSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlID4gc2hhcGVbJ21heCddKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnTWF4UmFuZ2VFcnJvcicsICdFeHBlY3RlZCAnICsgZGVzY3JpcHRvciArICcgPD0gJ1xuICAgICAgICAgICsgc2hhcGVbJ21heCddICsgJywgYnV0IGZvdW5kICcgKyB2YWx1ZSArICcgZm9yICcgKyBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVFbnVtOiBmdW5jdGlvbiB2YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnZhbGlkYXRpb25bJ2VudW0nXSAmJiBzaGFwZVsnZW51bSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEZhaWwgaWYgdGhlIHN0cmluZyB2YWx1ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgZW51bSBsaXN0XG4gICAgICBpZiAoc2hhcGVbJ2VudW0nXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdFbnVtRXJyb3InLCAnRm91bmQgc3RyaW5nIHZhbHVlIG9mICcgKyB2YWx1ZSArICcsIGJ1dCAnXG4gICAgICAgICAgKyAnZXhwZWN0ZWQgJyArIHNoYXBlWydlbnVtJ10uam9pbignfCcpICsgJyBmb3IgJyArIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB2YWxpZGF0ZVR5cGU6IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh2YWx1ZSwgY29udGV4dCwgYWNjZXB0ZWRUeXBlcywgdHlwZSkge1xuICAgIC8vIFdlIHdpbGwgbm90IGxvZyBhbiBlcnJvciBmb3IgbnVsbCBvciB1bmRlZmluZWQsIGJ1dCB3ZSB3aWxsIHJldHVyblxuICAgIC8vIGZhbHNlIHNvIHRoYXQgY2FsbGVycyBrbm93IHRoYXQgdGhlIGV4cGVjdGVkIHR5cGUgd2FzIG5vdCBzdHJpY3RseSBtZXQuXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBmb3VuZEludmFsaWRUeXBlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFjY2VwdGVkVHlwZXNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IGFjY2VwdGVkVHlwZXNbaV0pIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChhY2NlcHRlZFR5cGVzW2ldIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmICgodmFsdWUgfHwgJycpLnRvU3RyaW5nKCkubWF0Y2goYWNjZXB0ZWRUeXBlc1tpXSkpIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgYWNjZXB0ZWRUeXBlc1tpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChBV1MudXRpbC5pc1R5cGUodmFsdWUsIGFjY2VwdGVkVHlwZXNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0eXBlICYmICFmb3VuZEludmFsaWRUeXBlKSBhY2NlcHRlZFR5cGVzID0gYWNjZXB0ZWRUeXBlcy5zbGljZSgpO1xuICAgICAgICBhY2NlcHRlZFR5cGVzW2ldID0gQVdTLnV0aWwudHlwZU5hbWUoYWNjZXB0ZWRUeXBlc1tpXSk7XG4gICAgICB9XG4gICAgICBmb3VuZEludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYWNjZXB0ZWRUeXBlID0gdHlwZTtcbiAgICBpZiAoIWFjY2VwdGVkVHlwZSkge1xuICAgICAgYWNjZXB0ZWRUeXBlID0gYWNjZXB0ZWRUeXBlcy5qb2luKCcsICcpLnJlcGxhY2UoLywoW14sXSspJC8sICcsIG9yJDEnKTtcbiAgICB9XG5cbiAgICB2YXIgdm93ZWwgPSBhY2NlcHRlZFR5cGUubWF0Y2goL15bYWVpb3VdL2kpID8gJ24nIDogJyc7XG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYScgK1xuICAgICAgICAgICAgICB2b3dlbCArICcgJyArIGFjY2VwdGVkVHlwZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHZhbGlkYXRlTnVtYmVyOiBmdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihzaGFwZSwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgY2FzdGVkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmIChjYXN0ZWRWYWx1ZS50b1N0cmluZygpID09PSB2YWx1ZSkgdmFsdWUgPSBjYXN0ZWRWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUeXBlKHZhbHVlLCBjb250ZXh0LCBbJ251bWJlciddKSkge1xuICAgICAgdGhpcy52YWxpZGF0ZVJhbmdlKHNoYXBlLCB2YWx1ZSwgY29udGV4dCwgJ251bWVyaWMgdmFsdWUnKTtcbiAgICB9XG4gIH0sXG5cbiAgdmFsaWRhdGVQYXlsb2FkOiBmdW5jdGlvbiB2YWxpZGF0ZVBheWxvYWQodmFsdWUsIGNvbnRleHQpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykgcmV0dXJuOyAvLyB0eXBlZCBhcnJheXNcbiAgICBpZiAoQVdTLnV0aWwuaXNOb2RlKCkpIHsgLy8gc3BlY2lhbCBjaGVjayBmb3IgYnVmZmVyL3N0cmVhbSBpbiBOb2RlLmpzXG4gICAgICB2YXIgU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlN0cmVhbTtcbiAgICAgIGlmIChBV1MudXRpbC5CdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyZWFtKSByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gdm9pZCAwICYmIHZhbHVlIGluc3RhbmNlb2YgQmxvYikgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlcyA9IFsnQnVmZmVyJywgJ1N0cmVhbScsICdGaWxlJywgJ0Jsb2InLCAnQXJyYXlCdWZmZXInLCAnRGF0YVZpZXcnXTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzVHlwZSh2YWx1ZSwgdHlwZXNbaV0pKSByZXR1cm47XG4gICAgICAgIGlmIChBV1MudXRpbC50eXBlTmFtZSh2YWx1ZS5jb25zdHJ1Y3RvcikgPT09IHR5cGVzW2ldKSByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mYWlsKCdJbnZhbGlkUGFyYW1ldGVyVHlwZScsICdFeHBlY3RlZCAnICsgY29udGV4dCArICcgdG8gYmUgYSAnICtcbiAgICAgICdzdHJpbmcsIEJ1ZmZlciwgU3RyZWFtLCBCbG9iLCBvciB0eXBlZCBhcnJheSBvYmplY3QnKTtcbiAgfVxufSk7XG4iLCJ2YXIgdXRpbCA9ICByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIFByZXBlbmQgcHJlZml4IGRlZmluZWQgYnkgQVBJIG1vZGVsIHRvIGVuZHBvaW50IHRoYXQncyBhbHJlYWR5XG4gKiBjb25zdHJ1Y3RlZC4gVGhpcyBmZWF0dXJlIGRvZXMgbm90IGFwcGx5IHRvIG9wZXJhdGlvbnMgdXNpbmdcbiAqIGVuZHBvaW50IGRpc2NvdmVyeSBhbmQgY2FuIGJlIGRpc2FibGVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlSG9zdFByZWZpeChyZXF1ZXN0KSAge1xuICB2YXIgZW5hYmxlZCA9IHJlcXVlc3Quc2VydmljZS5jb25maWcuaG9zdFByZWZpeEVuYWJsZWQ7XG4gIGlmICghZW5hYmxlZCkgcmV0dXJuIHJlcXVlc3Q7XG4gIHZhciBvcGVyYXRpb25Nb2RlbCA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIC8vZG9uJ3QgbWFyc2hhbCBob3N0IHByZWZpeCB3aGVuIG9wZXJhdGlvbiBoYXMgZW5kcG9pbnQgZGlzY292ZXJ5IHRyYWl0c1xuICBpZiAoaGFzRW5kcG9pbnREaXNjb3ZlcihyZXF1ZXN0KSkgcmV0dXJuIHJlcXVlc3Q7XG4gIGlmIChvcGVyYXRpb25Nb2RlbC5lbmRwb2ludCAmJiBvcGVyYXRpb25Nb2RlbC5lbmRwb2ludC5ob3N0UHJlZml4KSB7XG4gICAgdmFyIGhvc3RQcmVmaXhOb3RhdGlvbiA9IG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50Lmhvc3RQcmVmaXg7XG4gICAgdmFyIGhvc3RQcmVmaXggPSBleHBhbmRIb3N0UHJlZml4KGhvc3RQcmVmaXhOb3RhdGlvbiwgcmVxdWVzdC5wYXJhbXMsIG9wZXJhdGlvbk1vZGVsLmlucHV0KTtcbiAgICBwcmVwZW5kRW5kcG9pbnRQcmVmaXgocmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCwgaG9zdFByZWZpeCk7XG4gICAgdmFsaWRhdGVIb3N0bmFtZShyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3RuYW1lKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFzRW5kcG9pbnREaXNjb3ZlcihyZXF1ZXN0KSB7XG4gIHZhciBhcGkgPSByZXF1ZXN0LnNlcnZpY2UuYXBpO1xuICB2YXIgb3BlcmF0aW9uTW9kZWwgPSBhcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gIHZhciBpc0VuZHBvaW50T3BlcmF0aW9uID0gYXBpLmVuZHBvaW50T3BlcmF0aW9uICYmIChhcGkuZW5kcG9pbnRPcGVyYXRpb24gPT09IHV0aWwuc3RyaW5nLmxvd2VyRmlyc3Qob3BlcmF0aW9uTW9kZWwubmFtZSkpO1xuICByZXR1cm4gKG9wZXJhdGlvbk1vZGVsLmVuZHBvaW50RGlzY292ZXJ5UmVxdWlyZWQgIT09ICdOVUxMJyB8fCBpc0VuZHBvaW50T3BlcmF0aW9uID09PSB0cnVlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXhwYW5kSG9zdFByZWZpeChob3N0UHJlZml4Tm90YXRpb24sIHBhcmFtcywgc2hhcGUpIHtcbiAgdXRpbC5lYWNoKHNoYXBlLm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIGlmIChtZW1iZXIuaG9zdExhYmVsID09PSB0cnVlKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtc1tuYW1lXSAhPT0gJ3N0cmluZycgfHwgcGFyYW1zW25hbWVdID09PSAnJykge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgbWVzc2FnZTogJ1BhcmFtZXRlciAnICsgbmFtZSArICcgc2hvdWxkIGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nLFxuICAgICAgICAgIGNvZGU6ICdJbnZhbGlkUGFyYW1ldGVyJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG5hbWUgKyAnXFxcXH0nLCAnZycpO1xuICAgICAgaG9zdFByZWZpeE5vdGF0aW9uID0gaG9zdFByZWZpeE5vdGF0aW9uLnJlcGxhY2UocmVnZXgsIHBhcmFtc1tuYW1lXSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGhvc3RQcmVmaXhOb3RhdGlvbjtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcGVuZEVuZHBvaW50UHJlZml4KGVuZHBvaW50LCBwcmVmaXgpIHtcbiAgaWYgKGVuZHBvaW50Lmhvc3QpIHtcbiAgICBlbmRwb2ludC5ob3N0ID0gcHJlZml4ICsgZW5kcG9pbnQuaG9zdDtcbiAgfVxuICBpZiAoZW5kcG9pbnQuaG9zdG5hbWUpIHtcbiAgICBlbmRwb2ludC5ob3N0bmFtZSA9IHByZWZpeCArIGVuZHBvaW50Lmhvc3RuYW1lO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgdmFyIGxhYmVscyA9IGhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gIC8vUmVmZXJlbmNlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTEyMyNzZWN0aW9uLTJcbiAgdmFyIGhvc3RQYXR0ZXJuID0gL15bYS16QS1aMC05XXsxfSR8XlthLXpBLVowLTldW2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0kLztcbiAgdXRpbC5hcnJheUVhY2gobGFiZWxzLCBmdW5jdGlvbihsYWJlbCkge1xuICAgIGlmICghbGFiZWwubGVuZ3RoIHx8IGxhYmVsLmxlbmd0aCA8IDEgfHwgbGFiZWwubGVuZ3RoID4gNjMpIHtcbiAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ1ZhbGlkYXRpb25FcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdIb3N0bmFtZSBsYWJlbCBsZW5ndGggc2hvdWxkIGJlIGJldHdlZW4gMSB0byA2MyBjaGFyYWN0ZXJzLCBpbmNsdXNpdmUuJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaG9zdFBhdHRlcm4udGVzdChsYWJlbCkpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLFxuICAgICAgICB7Y29kZTogJ1ZhbGlkYXRpb25FcnJvcicsIG1lc3NhZ2U6IGxhYmVsICsgJyBpcyBub3QgaG9zdG5hbWUgY29tcGF0aWJsZS4nfSk7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBvcHVsYXRlSG9zdFByZWZpeDogcG9wdWxhdGVIb3N0UHJlZml4XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgSnNvbkJ1aWxkZXIgPSByZXF1aXJlKCcuLi9qc29uL2J1aWxkZXInKTtcbnZhciBKc29uUGFyc2VyID0gcmVxdWlyZSgnLi4vanNvbi9wYXJzZXInKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICB2YXIgYXBpID0gcmVxLnNlcnZpY2UuYXBpO1xuICB2YXIgdGFyZ2V0ID0gYXBpLnRhcmdldFByZWZpeCArICcuJyArIGFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm5hbWU7XG4gIHZhciB2ZXJzaW9uID0gYXBpLmpzb25WZXJzaW9uIHx8ICcxLjAnO1xuICB2YXIgaW5wdXQgPSBhcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dDtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcblxuICBpZiAodmVyc2lvbiA9PT0gMSkgdmVyc2lvbiA9ICcxLjAnO1xuICBodHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zIHx8IHt9LCBpbnB1dCk7XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtYW16LWpzb24tJyArIHZlcnNpb247XG4gIGh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVRhcmdldCddID0gdGFyZ2V0O1xuXG4gIHBvcHVsYXRlSG9zdFByZWZpeChyZXEpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXJyb3IocmVzcCkge1xuICB2YXIgZXJyb3IgPSB7fTtcbiAgdmFyIGh0dHBSZXNwb25zZSA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuXG4gIGVycm9yLmNvZGUgPSBodHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXpuLWVycm9ydHlwZSddIHx8ICdVbmtub3duRXJyb3InO1xuICBpZiAodHlwZW9mIGVycm9yLmNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yLmNvZGUuc3BsaXQoJzonKVswXTtcbiAgfVxuXG4gIGlmIChodHRwUmVzcG9uc2UuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlID0gSlNPTi5wYXJzZShodHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpKTtcbiAgICAgIHZhciBjb2RlID0gZS5fX3R5cGUgfHwgZS5jb2RlIHx8IGUuQ29kZTtcbiAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlLnNwbGl0KCcjJykucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ1JlcXVlc3RFbnRpdHlUb29MYXJnZScpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9ICdSZXF1ZXN0IGJvZHkgbXVzdCBiZSBsZXNzIHRoYW4gMSBNQic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gKGUubWVzc2FnZSB8fCBlLk1lc3NhZ2UgfHwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgZXJyb3IubWVzc2FnZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCk7XG4gIH1cblxuICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwgZXJyb3IpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keS50b1N0cmluZygpIHx8ICd7fSc7XG4gIGlmIChyZXNwLnJlcXVlc3Quc2VydmljZS5jb25maWcuY29udmVydFJlc3BvbnNlVHlwZXMgPT09IGZhbHNlKSB7XG4gICAgcmVzcC5kYXRhID0gSlNPTi5wYXJzZShib2R5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVzcC5yZXF1ZXN0LnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIHNoYXBlID0gb3BlcmF0aW9uLm91dHB1dCB8fCB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICByZXNwLmRhdGEgPSBwYXJzZXIucGFyc2UoYm9keSwgc2hhcGUpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBRdWVyeVBhcmFtU2VyaWFsaXplciA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3F1ZXJ5X3BhcmFtX3NlcmlhbGl6ZXInKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL21vZGVsL3NoYXBlJyk7XG52YXIgcG9wdWxhdGVIb3N0UHJlZml4ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykucG9wdWxhdGVIb3N0UHJlZml4O1xuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXTtcbiAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxLmh0dHBSZXF1ZXN0O1xuICBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSA9XG4gICAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD11dGYtOCc7XG4gIGh0dHBSZXF1ZXN0LnBhcmFtcyA9IHtcbiAgICBWZXJzaW9uOiByZXEuc2VydmljZS5hcGkuYXBpVmVyc2lvbixcbiAgICBBY3Rpb246IG9wZXJhdGlvbi5uYW1lXG4gIH07XG5cbiAgLy8gY29udmVydCB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzIGludG8gYSBsaXN0IG9mIHF1ZXJ5IHBhcmFtcyxcbiAgLy8gZS5nLiBEZWVwbHkuTmVzdGVkUGFyYW0uMC5OYW1lPXZhbHVlXG4gIHZhciBidWlsZGVyID0gbmV3IFF1ZXJ5UGFyYW1TZXJpYWxpemVyKCk7XG4gIGJ1aWxkZXIuc2VyaWFsaXplKHJlcS5wYXJhbXMsIG9wZXJhdGlvbi5pbnB1dCwgZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBodHRwUmVxdWVzdC5wYXJhbXNbbmFtZV0gPSB2YWx1ZTtcbiAgfSk7XG4gIGh0dHBSZXF1ZXN0LmJvZHkgPSB1dGlsLnF1ZXJ5UGFyYW1zVG9TdHJpbmcoaHR0cFJlcXVlc3QucGFyYW1zKTtcblxuICBwb3B1bGF0ZUhvc3RQcmVmaXgocmVxKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgdmFyIGRhdGEsIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCk7XG4gIGlmIChib2R5Lm1hdGNoKCc8VW5rbm93bk9wZXJhdGlvbkV4Y2VwdGlvbicpKSB7XG4gICAgZGF0YSA9IHtcbiAgICAgIENvZGU6ICdVbmtub3duT3BlcmF0aW9uJyxcbiAgICAgIE1lc3NhZ2U6ICdVbmtub3duIG9wZXJhdGlvbiAnICsgcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvblxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKS5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICBDb2RlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICBNZXNzYWdlOiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNNZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRhLnJlcXVlc3RJZCAmJiAhcmVzcC5yZXF1ZXN0SWQpIHJlc3AucmVxdWVzdElkID0gZGF0YS5yZXF1ZXN0SWQ7XG4gIGlmIChkYXRhLkVycm9ycykgZGF0YSA9IGRhdGEuRXJyb3JzO1xuICBpZiAoZGF0YS5FcnJvcikgZGF0YSA9IGRhdGEuRXJyb3I7XG4gIGlmIChkYXRhLkNvZGUpIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogZGF0YS5Db2RlLFxuICAgICAgbWVzc2FnZTogZGF0YS5NZXNzYWdlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcC5lcnJvciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIGNvZGU6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICBtZXNzYWdlOiBudWxsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBzaGFwZSA9IG9wZXJhdGlvbi5vdXRwdXQgfHwge307XG4gIHZhciBvcmlnUnVsZXMgPSBzaGFwZTtcblxuICBpZiAob3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXIpIHtcbiAgICB2YXIgdG1wID0gU2hhcGUuY3JlYXRlKHt0eXBlOiAnc3RydWN0dXJlJ30pO1xuICAgIHRtcC5tZW1iZXJzW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXSA9IHNoYXBlO1xuICAgIHRtcC5tZW1iZXJOYW1lcyA9IFtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl07XG4gICAgdXRpbC5wcm9wZXJ0eShzaGFwZSwgJ25hbWUnLCBzaGFwZS5yZXN1bHRXcmFwcGVyKTtcbiAgICBzaGFwZSA9IHRtcDtcbiAgfVxuXG4gIHZhciBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcblxuICAvLyBUT0RPOiBSZWZhY3RvciBYTUwgUGFyc2VyIHRvIHBhcnNlIFJlcXVlc3RJZCBmcm9tIHJlc3BvbnNlLlxuICBpZiAoc2hhcGUgJiYgc2hhcGUubWVtYmVycyAmJiAhc2hhcGUubWVtYmVycy5fWEFNWlJlcXVlc3RJZCkge1xuICAgIHZhciByZXF1ZXN0SWRTaGFwZSA9IFNoYXBlLmNyZWF0ZShcbiAgICAgIHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgIHsgYXBpOiB7IHByb3RvY29sOiAncXVlcnknIH0gfSxcbiAgICAgICdyZXF1ZXN0SWQnXG4gICAgKTtcbiAgICBzaGFwZS5tZW1iZXJzLl9YQU1aUmVxdWVzdElkID0gcmVxdWVzdElkU2hhcGU7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhcnNlci5wYXJzZShyZXNwLmh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCksIHNoYXBlKTtcbiAgcmVzcC5yZXF1ZXN0SWQgPSBkYXRhLl9YQU1aUmVxdWVzdElkIHx8IGRhdGEucmVxdWVzdElkO1xuXG4gIGlmIChkYXRhLl9YQU1aUmVxdWVzdElkKSBkZWxldGUgZGF0YS5fWEFNWlJlcXVlc3RJZDtcblxuICBpZiAob3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXIpIHtcbiAgICBpZiAoZGF0YVtvcmlnUnVsZXMucmVzdWx0V3JhcHBlcl0pIHtcbiAgICAgIHV0aWwudXBkYXRlKGRhdGEsIGRhdGFbb3JpZ1J1bGVzLnJlc3VsdFdyYXBwZXJdKTtcbiAgICAgIGRlbGV0ZSBkYXRhW29yaWdSdWxlcy5yZXN1bHRXcmFwcGVyXTtcbiAgICB9XG4gIH1cblxuICByZXNwLmRhdGEgPSBkYXRhO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBwb3B1bGF0ZUhvc3RQcmVmaXggPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wb3B1bGF0ZUhvc3RQcmVmaXg7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWV0aG9kKHJlcSkge1xuICByZXEuaHR0cFJlcXVlc3QubWV0aG9kID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaHR0cE1ldGhvZDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVUkkoZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoLCBpbnB1dCwgcGFyYW1zKSB7XG4gIHZhciB1cmkgPSBbZW5kcG9pbnRQYXRoLCBvcGVyYXRpb25QYXRoXS5qb2luKCcvJyk7XG4gIHVyaSA9IHVyaS5yZXBsYWNlKC9cXC8rL2csICcvJyk7XG5cbiAgdmFyIHF1ZXJ5U3RyaW5nID0ge30sIHF1ZXJ5U3RyaW5nU2V0ID0gZmFsc2U7XG4gIHV0aWwuZWFjaChpbnB1dC5tZW1iZXJzLCBmdW5jdGlvbiAobmFtZSwgbWVtYmVyKSB7XG4gICAgdmFyIHBhcmFtVmFsdWUgPSBwYXJhbXNbbmFtZV07XG4gICAgaWYgKHBhcmFtVmFsdWUgPT09IG51bGwgfHwgcGFyYW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3VyaScpIHtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIG1lbWJlci5uYW1lICsgJyhcXFxcKyk/XFxcXH0nKTtcbiAgICAgIHVyaSA9IHVyaS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihfLCBwbHVzKSB7XG4gICAgICAgIHZhciBmbiA9IHBsdXMgPyB1dGlsLnVyaUVzY2FwZVBhdGggOiB1dGlsLnVyaUVzY2FwZTtcbiAgICAgICAgcmV0dXJuIGZuKFN0cmluZyhwYXJhbVZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ3F1ZXJ5c3RyaW5nJykge1xuICAgICAgcXVlcnlTdHJpbmdTZXQgPSB0cnVlO1xuXG4gICAgICBpZiAobWVtYmVyLnR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgICBxdWVyeVN0cmluZ1ttZW1iZXIubmFtZV0gPSBwYXJhbVZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC51cmlFc2NhcGUobWVtYmVyLm1lbWJlci50b1dpcmVGb3JtYXQodmFsKS50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgICB1dGlsLmVhY2gocGFyYW1WYWx1ZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IHZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHV0aWwudXJpRXNjYXBlKFN0cmluZyh2YWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZ1trZXldID0gdXRpbC51cmlFc2NhcGUoU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5U3RyaW5nW21lbWJlci5uYW1lXSA9IHV0aWwudXJpRXNjYXBlKG1lbWJlci50b1dpcmVGb3JtYXQocGFyYW1WYWx1ZSkudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAocXVlcnlTdHJpbmdTZXQpIHtcbiAgICB1cmkgKz0gKHVyaS5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/Jyk7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdXRpbC5hcnJheUVhY2goT2JqZWN0LmtleXMocXVlcnlTdHJpbmcpLnNvcnQoKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocXVlcnlTdHJpbmdba2V5XSkpIHtcbiAgICAgICAgcXVlcnlTdHJpbmdba2V5XSA9IFtxdWVyeVN0cmluZ1trZXldXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcnlTdHJpbmdba2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKHV0aWwudXJpRXNjYXBlKFN0cmluZyhrZXkpKSArICc9JyArIHF1ZXJ5U3RyaW5nW2tleV1baV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVyaSArPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICByZXR1cm4gdXJpO1xufVxuXG5mdW5jdGlvbiBwb3B1bGF0ZVVSSShyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB2YXIgaW5wdXQgPSBvcGVyYXRpb24uaW5wdXQ7XG5cbiAgdmFyIHVyaSA9IGdlbmVyYXRlVVJJKHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5wYXRoLCBvcGVyYXRpb24uaHR0cFBhdGgsIGlucHV0LCByZXEucGFyYW1zKTtcbiAgcmVxLmh0dHBSZXF1ZXN0LnBhdGggPSB1cmk7XG59XG5cbmZ1bmN0aW9uIHBvcHVsYXRlSGVhZGVycyhyZXEpIHtcbiAgdmFyIG9wZXJhdGlvbiA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dO1xuICB1dGlsLmVhY2gob3BlcmF0aW9uLmlucHV0Lm1lbWJlcnMsIGZ1bmN0aW9uIChuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgdmFsdWUgPSByZXEucGFyYW1zW25hbWVdO1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBpZiAobWVtYmVyLmxvY2F0aW9uID09PSAnaGVhZGVycycgJiYgbWVtYmVyLnR5cGUgPT09ICdtYXAnKSB7XG4gICAgICB1dGlsLmVhY2godmFsdWUsIGZ1bmN0aW9uKGtleSwgbWVtYmVyVmFsdWUpIHtcbiAgICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbbWVtYmVyLm5hbWUgKyBrZXldID0gbWVtYmVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcicpIHtcbiAgICAgIHZhbHVlID0gbWVtYmVyLnRvV2lyZUZvcm1hdCh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtZW1iZXIuaXNKc29uVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB1dGlsLmJhc2U2NC5lbmNvZGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbbWVtYmVyLm5hbWVdID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcSkge1xuICBwb3B1bGF0ZU1ldGhvZChyZXEpO1xuICBwb3B1bGF0ZVVSSShyZXEpO1xuICBwb3B1bGF0ZUhlYWRlcnMocmVxKTtcbiAgcG9wdWxhdGVIb3N0UHJlZml4KHJlcSk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvcigpIHtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgciA9IHJlc3AuaHR0cFJlc3BvbnNlO1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuXG4gIC8vIG5vcm1hbGl6ZSBoZWFkZXJzIG5hbWVzIHRvIGxvd2VyLWNhc2VkIGtleXMgZm9yIG1hdGNoaW5nXG4gIHZhciBoZWFkZXJzID0ge307XG4gIHV0aWwuZWFjaChyLmhlYWRlcnMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaGVhZGVyc1trLnRvTG93ZXJDYXNlKCldID0gdjtcbiAgfSk7XG5cbiAgdXRpbC5lYWNoKG91dHB1dC5tZW1iZXJzLCBmdW5jdGlvbihuYW1lLCBtZW1iZXIpIHtcbiAgICB2YXIgaGVhZGVyID0gKG1lbWJlci5uYW1lIHx8IG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG1lbWJlci5sb2NhdGlvbiA9PT0gJ2hlYWRlcnMnICYmIG1lbWJlci50eXBlID09PSAnbWFwJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHt9O1xuICAgICAgdmFyIGxvY2F0aW9uID0gbWVtYmVyLmlzTG9jYXRpb25OYW1lID8gbWVtYmVyLm5hbWUgOiAnJztcbiAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXicgKyBsb2NhdGlvbiArICcoLispJywgJ2knKTtcbiAgICAgIHV0aWwuZWFjaChyLmhlYWRlcnMsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBrLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgZGF0YVtuYW1lXVtyZXN1bHRbMV1dID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdoZWFkZXInKSB7XG4gICAgICBpZiAoaGVhZGVyc1toZWFkZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbWVtYmVyLmlzSnNvblZhbHVlID9cbiAgICAgICAgICB1dGlsLmJhc2U2NC5kZWNvZGUoaGVhZGVyc1toZWFkZXJdKSA6XG4gICAgICAgICAgaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICBkYXRhW25hbWVdID0gbWVtYmVyLnRvVHlwZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZW1iZXIubG9jYXRpb24gPT09ICdzdGF0dXNDb2RlJykge1xuICAgICAgZGF0YVtuYW1lXSA9IHBhcnNlSW50KHIuc3RhdHVzQ29kZSwgMTApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVzcC5kYXRhID0gZGF0YTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJ1aWxkUmVxdWVzdDogYnVpbGRSZXF1ZXN0LFxuICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvcixcbiAgZXh0cmFjdERhdGE6IGV4dHJhY3REYXRhLFxuICBnZW5lcmF0ZVVSSTogZ2VuZXJhdGVVUklcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSZXN0ID0gcmVxdWlyZSgnLi9yZXN0Jyk7XG52YXIgSnNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xudmFyIEpzb25CdWlsZGVyID0gcmVxdWlyZSgnLi4vanNvbi9idWlsZGVyJyk7XG52YXIgSnNvblBhcnNlciA9IHJlcXVpcmUoJy4uL2pzb24vcGFyc2VyJyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQm9keShyZXEpIHtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgSnNvbkJ1aWxkZXIoKTtcbiAgdmFyIGlucHV0ID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG5cbiAgaWYgKGlucHV0LnBheWxvYWQpIHtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgdmFyIHBheWxvYWRTaGFwZSA9IGlucHV0Lm1lbWJlcnNbaW5wdXQucGF5bG9hZF07XG4gICAgcGFyYW1zID0gcmVxLnBhcmFtc1tpbnB1dC5wYXlsb2FkXTtcblxuICAgIGlmIChwYXlsb2FkU2hhcGUudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChwYXJhbXMgfHwge30sIHBheWxvYWRTaGFwZSk7XG4gICAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gbm9uLUpTT04gcGF5bG9hZFxuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBwYXJhbXM7XG4gICAgICBpZiAocGF5bG9hZFNoYXBlLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRTaGFwZS5pc1N0cmVhbWluZykge1xuICAgICAgICBhcHBseUNvbnRlbnRUeXBlSGVhZGVyKHJlcSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcS5odHRwUmVxdWVzdC5ib2R5ID0gYnVpbGRlci5idWlsZChyZXEucGFyYW1zLCBpbnB1dCk7XG4gICAgYXBwbHlDb250ZW50VHlwZUhlYWRlcihyZXEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29udGVudFR5cGVIZWFkZXIocmVxLCBpc0JpbmFyeSkge1xuICBpZiAoIXJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkge1xuICAgIHZhciB0eXBlID0gaXNCaW5hcnkgPyAnYmluYXJ5L29jdGV0LXN0cmVhbScgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3QocmVxKSB7XG4gIFJlc3QuYnVpbGRSZXF1ZXN0KHJlcSk7XG5cbiAgLy8gbmV2ZXIgc2VuZCBib2R5IHBheWxvYWQgb24gR0VUL0hFQUQvREVMRVRFXG4gIGlmIChbJ0dFVCcsICdIRUFEJywgJ0RFTEVURSddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgSnNvbi5leHRyYWN0RXJyb3IocmVzcCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3REYXRhKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RGF0YShyZXNwKTtcblxuICB2YXIgcmVxID0gcmVzcC5yZXF1ZXN0O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBydWxlcyA9IHJlcS5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcS5vcGVyYXRpb25dLm91dHB1dCB8fCB7fTtcbiAgdmFyIHBhcnNlcjtcbiAgdmFyIGhhc0V2ZW50T3V0cHV0ID0gb3BlcmF0aW9uLmhhc0V2ZW50T3V0cHV0O1xuXG4gIGlmIChydWxlcy5wYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBydWxlcy5tZW1iZXJzW3J1bGVzLnBheWxvYWRdO1xuICAgIHZhciBib2R5ID0gcmVzcC5odHRwUmVzcG9uc2UuYm9keTtcbiAgICBpZiAocGF5bG9hZE1lbWJlci5pc0V2ZW50U3RyZWFtKSB7XG4gICAgICBwYXJzZXIgPSBuZXcgSnNvblBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gdXRpbC5jcmVhdGVFdmVudFN0cmVhbShcbiAgICAgICAgQVdTLkh0dHBDbGllbnQuc3RyZWFtc0FwaVZlcnNpb24gPT09IDIgPyByZXNwLmh0dHBSZXNwb25zZS5zdHJlYW0gOiBib2R5LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHBheWxvYWRNZW1iZXJcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnIHx8IHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IEpzb25QYXJzZXIoKTtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHBhcnNlci5wYXJzZShib2R5LCBwYXlsb2FkTWVtYmVyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ2JpbmFyeScgfHwgcGF5bG9hZE1lbWJlci5pc1N0cmVhbWluZykge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcC5kYXRhW3J1bGVzLnBheWxvYWRdID0gcGF5bG9hZE1lbWJlci50b1R5cGUoYm9keSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkYXRhID0gcmVzcC5kYXRhO1xuICAgIEpzb24uZXh0cmFjdERhdGEocmVzcCk7XG4gICAgcmVzcC5kYXRhID0gdXRpbC5tZXJnZShkYXRhLCByZXNwLmRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBidWlsZFJlcXVlc3Q6IGJ1aWxkUmVxdWVzdCxcbiAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IsXG4gIGV4dHJhY3REYXRhOiBleHRyYWN0RGF0YVxufTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSZXN0ID0gcmVxdWlyZSgnLi9yZXN0Jyk7XG5cbmZ1bmN0aW9uIHBvcHVsYXRlQm9keShyZXEpIHtcbiAgdmFyIGlucHV0ID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl0uaW5wdXQ7XG4gIHZhciBidWlsZGVyID0gbmV3IEFXUy5YTUwuQnVpbGRlcigpO1xuICB2YXIgcGFyYW1zID0gcmVxLnBhcmFtcztcblxuICB2YXIgcGF5bG9hZCA9IGlucHV0LnBheWxvYWQ7XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRNZW1iZXIgPSBpbnB1dC5tZW1iZXJzW3BheWxvYWRdO1xuICAgIHBhcmFtcyA9IHBhcmFtc1twYXlsb2FkXTtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBwYXlsb2FkTWVtYmVyLm5hbWU7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IGJ1aWxkZXIudG9YTUwocGFyYW1zLCBwYXlsb2FkTWVtYmVyLCByb290RWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHsgLy8gbm9uLXhtbCBwYXlsb2FkXG4gICAgICByZXEuaHR0cFJlcXVlc3QuYm9keSA9IHBhcmFtcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPSBidWlsZGVyLnRvWE1MKHBhcmFtcywgaW5wdXQsIGlucHV0Lm5hbWUgfHxcbiAgICAgIGlucHV0LnNoYXBlIHx8IHV0aWwuc3RyaW5nLnVwcGVyRmlyc3QocmVxLm9wZXJhdGlvbikgKyAnUmVxdWVzdCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdChyZXEpIHtcbiAgUmVzdC5idWlsZFJlcXVlc3QocmVxKTtcblxuICAvLyBuZXZlciBzZW5kIGJvZHkgcGF5bG9hZCBvbiBHRVQvSEVBRFxuICBpZiAoWydHRVQnLCAnSEVBRCddLmluZGV4T2YocmVxLmh0dHBSZXF1ZXN0Lm1ldGhvZCkgPCAwKSB7XG4gICAgcG9wdWxhdGVCb2R5KHJlcSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgUmVzdC5leHRyYWN0RXJyb3IocmVzcCk7XG5cbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkYXRhID0ge1xuICAgICAgQ29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIE1lc3NhZ2U6IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c01lc3NhZ2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKGRhdGEuRXJyb3JzKSBkYXRhID0gZGF0YS5FcnJvcnM7XG4gIGlmIChkYXRhLkVycm9yKSBkYXRhID0gZGF0YS5FcnJvcjtcbiAgaWYgKGRhdGEuQ29kZSkge1xuICAgIHJlc3AuZXJyb3IgPSB1dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICBjb2RlOiBkYXRhLkNvZGUsXG4gICAgICBtZXNzYWdlOiBkYXRhLk1lc3NhZ2VcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXNwLmVycm9yID0gdXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgIG1lc3NhZ2U6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwKSB7XG4gIFJlc3QuZXh0cmFjdERhdGEocmVzcCk7XG5cbiAgdmFyIHBhcnNlcjtcbiAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5O1xuICB2YXIgb3BlcmF0aW9uID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnNbcmVxLm9wZXJhdGlvbl07XG4gIHZhciBvdXRwdXQgPSBvcGVyYXRpb24ub3V0cHV0O1xuXG4gIHZhciBoYXNFdmVudE91dHB1dCA9IG9wZXJhdGlvbi5oYXNFdmVudE91dHB1dDtcblxuICB2YXIgcGF5bG9hZCA9IG91dHB1dC5wYXlsb2FkO1xuICBpZiAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkTWVtYmVyID0gb3V0cHV0Lm1lbWJlcnNbcGF5bG9hZF07XG4gICAgaWYgKHBheWxvYWRNZW1iZXIuaXNFdmVudFN0cmVhbSkge1xuICAgICAgcGFyc2VyID0gbmV3IEFXUy5YTUwuUGFyc2VyKCk7XG4gICAgICByZXNwLmRhdGFbcGF5bG9hZF0gPSB1dGlsLmNyZWF0ZUV2ZW50U3RyZWFtKFxuICAgICAgICBBV1MuSHR0cENsaWVudC5zdHJlYW1zQXBpVmVyc2lvbiA9PT0gMiA/IHJlc3AuaHR0cFJlc3BvbnNlLnN0cmVhbSA6IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHksXG4gICAgICAgIHBhcnNlcixcbiAgICAgICAgcGF5bG9hZE1lbWJlclxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRNZW1iZXIudHlwZSA9PT0gJ3N0cnVjdHVyZScpIHtcbiAgICAgIHBhcnNlciA9IG5ldyBBV1MuWE1MLlBhcnNlcigpO1xuICAgICAgcmVzcC5kYXRhW3BheWxvYWRdID0gcGFyc2VyLnBhcnNlKGJvZHkudG9TdHJpbmcoKSwgcGF5bG9hZE1lbWJlcik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdiaW5hcnknIHx8IHBheWxvYWRNZW1iZXIuaXNTdHJlYW1pbmcpIHtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IGJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3AuZGF0YVtwYXlsb2FkXSA9IHBheWxvYWRNZW1iZXIudG9UeXBlKGJvZHkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChib2R5Lmxlbmd0aCA+IDApIHtcbiAgICBwYXJzZXIgPSBuZXcgQVdTLlhNTC5QYXJzZXIoKTtcbiAgICB2YXIgZGF0YSA9IHBhcnNlci5wYXJzZShib2R5LnRvU3RyaW5nKCksIG91dHB1dCk7XG4gICAgdXRpbC51cGRhdGUocmVzcC5kYXRhLCBkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYnVpbGRSZXF1ZXN0OiBidWlsZFJlcXVlc3QsXG4gIGV4dHJhY3RFcnJvcjogZXh0cmFjdEVycm9yLFxuICBleHRyYWN0RGF0YTogZXh0cmFjdERhdGFcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuZnVuY3Rpb24gUXVlcnlQYXJhbVNlcmlhbGl6ZXIoKSB7XG59XG5cblF1ZXJ5UGFyYW1TZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbihwYXJhbXMsIHNoYXBlLCBmbikge1xuICBzZXJpYWxpemVTdHJ1Y3R1cmUoJycsIHBhcmFtcywgc2hhcGUsIGZuKTtcbn07XG5cbmZ1bmN0aW9uIHVjZmlyc3Qoc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmlzUXVlcnlOYW1lIHx8IHNoYXBlLmFwaS5wcm90b2NvbCAhPT0gJ2VjMicpIHtcbiAgICByZXR1cm4gc2hhcGUubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2hhcGUubmFtZVswXS50b1VwcGVyQ2FzZSgpICsgc2hhcGUubmFtZS5zdWJzdHIoMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0dXJlKHByZWZpeCwgc3RydWN0LCBydWxlcywgZm4pIHtcbiAgdXRpbC5lYWNoKHJ1bGVzLm1lbWJlcnMsIGZ1bmN0aW9uKG5hbWUsIG1lbWJlcikge1xuICAgIHZhciB2YWx1ZSA9IHN0cnVjdFtuYW1lXTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIG1lbWJlck5hbWUgPSB1Y2ZpcnN0KG1lbWJlcik7XG4gICAgbWVtYmVyTmFtZSA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIG1lbWJlck5hbWUgOiBtZW1iZXJOYW1lO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihtZW1iZXJOYW1lLCB2YWx1ZSwgbWVtYmVyLCBmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAobmFtZSwgbWFwLCBydWxlcywgZm4pIHtcbiAgdmFyIGkgPSAxO1xuICB1dGlsLmVhY2gobWFwLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBwcmVmaXggPSBydWxlcy5mbGF0dGVuZWQgPyAnLicgOiAnLmVudHJ5Lic7XG4gICAgdmFyIHBvc2l0aW9uID0gcHJlZml4ICsgKGkrKykgKyAnLic7XG4gICAgdmFyIGtleU5hbWUgPSBwb3NpdGlvbiArIChydWxlcy5rZXkubmFtZSB8fCAna2V5Jyk7XG4gICAgdmFyIHZhbHVlTmFtZSA9IHBvc2l0aW9uICsgKHJ1bGVzLnZhbHVlLm5hbWUgfHwgJ3ZhbHVlJyk7XG4gICAgc2VyaWFsaXplTWVtYmVyKG5hbWUgKyBrZXlOYW1lLCBrZXksIHJ1bGVzLmtleSwgZm4pO1xuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsgdmFsdWVOYW1lLCB2YWx1ZSwgcnVsZXMudmFsdWUsIGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUxpc3QobmFtZSwgbGlzdCwgcnVsZXMsIGZuKSB7XG4gIHZhciBtZW1iZXJSdWxlcyA9IHJ1bGVzLm1lbWJlciB8fCB7fTtcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICBmbi5jYWxsKHRoaXMsIG5hbWUsIG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uICh2LCBuKSB7XG4gICAgdmFyIHN1ZmZpeCA9ICcuJyArIChuICsgMSk7XG4gICAgaWYgKHJ1bGVzLmFwaS5wcm90b2NvbCA9PT0gJ2VjMicpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgZm9yIEVDMlxuICAgICAgc3VmZml4ID0gc3VmZml4ICsgJyc7IC8vIG1ha2UgbGludGVyIGhhcHB5XG4gICAgfSBlbHNlIGlmIChydWxlcy5mbGF0dGVuZWQpIHtcbiAgICAgIGlmIChtZW1iZXJSdWxlcy5uYW1lKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgIHBhcnRzLnB1c2godWNmaXJzdChtZW1iZXJSdWxlcykpO1xuICAgICAgICBuYW1lID0gcGFydHMuam9pbignLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdWZmaXggPSAnLicgKyAobWVtYmVyUnVsZXMubmFtZSA/IG1lbWJlclJ1bGVzLm5hbWUgOiAnbWVtYmVyJykgKyBzdWZmaXg7XG4gICAgfVxuICAgIHNlcmlhbGl6ZU1lbWJlcihuYW1lICsgc3VmZml4LCB2LCBtZW1iZXJSdWxlcywgZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplTWVtYmVyKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHJ1bGVzLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgc2VyaWFsaXplU3RydWN0dXJlKG5hbWUsIHZhbHVlLCBydWxlcywgZm4pO1xuICB9IGVsc2UgaWYgKHJ1bGVzLnR5cGUgPT09ICdsaXN0Jykge1xuICAgIHNlcmlhbGl6ZUxpc3QobmFtZSwgdmFsdWUsIHJ1bGVzLCBmbik7XG4gIH0gZWxzZSBpZiAocnVsZXMudHlwZSA9PT0gJ21hcCcpIHtcbiAgICBzZXJpYWxpemVNYXAobmFtZSwgdmFsdWUsIHJ1bGVzLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgZm4obmFtZSwgcnVsZXMudG9XaXJlRm9ybWF0KHZhbHVlKS50b1N0cmluZygpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5UGFyYW1TZXJpYWxpemVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vcHJvdmlkZSByZWFsdGltZSBjbG9jayBmb3IgcGVyZm9ybWFuY2UgbWVhc3VyZW1lbnRcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfVxufTtcbiIsImZ1bmN0aW9uIGlzRmlwc1JlZ2lvbihyZWdpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiByZWdpb24gPT09ICdzdHJpbmcnICYmIChyZWdpb24uc3RhcnRzV2l0aCgnZmlwcy0nKSB8fCByZWdpb24uZW5kc1dpdGgoJy1maXBzJykpO1xufVxuXG5mdW5jdGlvbiBpc0dsb2JhbFJlZ2lvbihyZWdpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiByZWdpb24gPT09ICdzdHJpbmcnICYmIFsnYXdzLWdsb2JhbCcsICdhd3MtdXMtZ292LWdsb2JhbCddLmluY2x1ZGVzKHJlZ2lvbik7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWxSZWdpb24ocmVnaW9uKSB7XG4gIHJldHVybiBbJ2ZpcHMtYXdzLWdsb2JhbCcsICdhd3MtZmlwcycsICdhd3MtZ2xvYmFsJ10uaW5jbHVkZXMocmVnaW9uKVxuICAgICAgPyAndXMtZWFzdC0xJ1xuICAgICAgOiBbJ2ZpcHMtYXdzLXVzLWdvdi1nbG9iYWwnLCAnYXdzLXVzLWdvdi1nbG9iYWwnXS5pbmNsdWRlcyhyZWdpb24pXG4gICAgICA/ICd1cy1nb3Ytd2VzdC0xJ1xuICAgICAgOiByZWdpb24ucmVwbGFjZSgvZmlwcy0oZGtyLXxwcm9kLSk/fC1maXBzLywgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNGaXBzUmVnaW9uOiBpc0ZpcHNSZWdpb24sXG4gIGlzR2xvYmFsUmVnaW9uOiBpc0dsb2JhbFJlZ2lvbixcbiAgZ2V0UmVhbFJlZ2lvbjogZ2V0UmVhbFJlZ2lvblxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgcmVnaW9uQ29uZmlnID0gcmVxdWlyZSgnLi9yZWdpb25fY29uZmlnX2RhdGEuanNvbicpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVJlZ2lvblByZWZpeChyZWdpb24pIHtcbiAgaWYgKCFyZWdpb24pIHJldHVybiBudWxsO1xuICB2YXIgcGFydHMgPSByZWdpb24uc3BsaXQoJy0nKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA8IDMpIHJldHVybiBudWxsO1xuICByZXR1cm4gcGFydHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoIC0gMikuam9pbignLScpICsgJy0qJztcbn1cblxuZnVuY3Rpb24gZGVyaXZlZEtleXMoc2VydmljZSkge1xuICB2YXIgcmVnaW9uID0gc2VydmljZS5jb25maWcucmVnaW9uO1xuICB2YXIgcmVnaW9uUHJlZml4ID0gZ2VuZXJhdGVSZWdpb25QcmVmaXgocmVnaW9uKTtcbiAgdmFyIGVuZHBvaW50UHJlZml4ID0gc2VydmljZS5hcGkuZW5kcG9pbnRQcmVmaXg7XG5cbiAgcmV0dXJuIFtcbiAgICBbcmVnaW9uLCBlbmRwb2ludFByZWZpeF0sXG4gICAgW3JlZ2lvblByZWZpeCwgZW5kcG9pbnRQcmVmaXhdLFxuICAgIFtyZWdpb24sICcqJ10sXG4gICAgW3JlZ2lvblByZWZpeCwgJyonXSxcbiAgICBbJyonLCBlbmRwb2ludFByZWZpeF0sXG4gICAgWycqJywgJyonXVxuICBdLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW1bMF0gJiYgaXRlbVsxXSA/IGl0ZW0uam9pbignLycpIDogbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29uZmlnKHNlcnZpY2UsIGNvbmZpZykge1xuICB1dGlsLmVhY2goY29uZmlnLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2dsb2JhbEVuZHBvaW50JykgcmV0dXJuO1xuICAgIGlmIChzZXJ2aWNlLmNvbmZpZ1trZXldID09PSB1bmRlZmluZWQgfHwgc2VydmljZS5jb25maWdba2V5XSA9PT0gbnVsbCkge1xuICAgICAgc2VydmljZS5jb25maWdba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZUVuZHBvaW50KHNlcnZpY2UpIHtcbiAgdmFyIGtleXMgPSBkZXJpdmVkS2V5cyhzZXJ2aWNlKTtcbiAgdmFyIHVzZUZpcHNFbmRwb2ludCA9IHNlcnZpY2UuY29uZmlnLnVzZUZpcHNFbmRwb2ludDtcbiAgdmFyIHVzZUR1YWxzdGFja0VuZHBvaW50ID0gc2VydmljZS5jb25maWcudXNlRHVhbHN0YWNrRW5kcG9pbnQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICgha2V5KSBjb250aW51ZTtcblxuICAgIHZhciBydWxlcyA9IHVzZUZpcHNFbmRwb2ludFxuICAgICAgPyB1c2VEdWFsc3RhY2tFbmRwb2ludFxuICAgICAgICA/IHJlZ2lvbkNvbmZpZy5kdWFsc3RhY2tGaXBzUnVsZXNcbiAgICAgICAgOiByZWdpb25Db25maWcuZmlwc1J1bGVzXG4gICAgICA6IHVzZUR1YWxzdGFja0VuZHBvaW50XG4gICAgICA/IHJlZ2lvbkNvbmZpZy5kdWFsc3RhY2tSdWxlc1xuICAgICAgOiByZWdpb25Db25maWcucnVsZXM7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJ1bGVzLCBrZXkpKSB7XG4gICAgICB2YXIgY29uZmlnID0gcnVsZXNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcgPSByZWdpb25Db25maWcucGF0dGVybnNbY29uZmlnXTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGdsb2JhbCBlbmRwb2ludFxuICAgICAgc2VydmljZS5pc0dsb2JhbEVuZHBvaW50ID0gISFjb25maWcuZ2xvYmFsRW5kcG9pbnQ7XG4gICAgICBpZiAoY29uZmlnLnNpZ25pbmdSZWdpb24pIHtcbiAgICAgICAgc2VydmljZS5zaWduaW5nUmVnaW9uID0gY29uZmlnLnNpZ25pbmdSZWdpb247XG4gICAgICB9XG5cbiAgICAgIC8vIHNpZ25hdHVyZSB2ZXJzaW9uXG4gICAgICBpZiAoIWNvbmZpZy5zaWduYXR1cmVWZXJzaW9uKSBjb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9ICd2NCc7XG5cbiAgICAgIC8vIG1lcmdlIGNvbmZpZ1xuICAgICAgYXBwbHlDb25maWcoc2VydmljZSwgY29uZmlnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uKSB7XG4gIHZhciByZWdpb25SZWdleGVzID0ge1xuICAgICdeKHVzfGV1fGFwfHNhfGNhfG1lKVxcXFwtXFxcXHcrXFxcXC1cXFxcZCskJzogJ2FtYXpvbmF3cy5jb20nLFxuICAgICdeY25cXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdhbWF6b25hd3MuY29tLmNuJyxcbiAgICAnXnVzXFxcXC1nb3ZcXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdhbWF6b25hd3MuY29tJyxcbiAgICAnXnVzXFxcXC1pc29cXFxcLVxcXFx3K1xcXFwtXFxcXGQrJCc6ICdjMnMuaWMuZ292JyxcbiAgICAnXnVzXFxcXC1pc29iXFxcXC1cXFxcdytcXFxcLVxcXFxkKyQnOiAnc2Mycy5zZ292LmdvdidcbiAgfTtcbiAgdmFyIGRlZmF1bHRTdWZmaXggPSAnYW1hem9uYXdzLmNvbSc7XG4gIHZhciByZWdleGVzID0gT2JqZWN0LmtleXMocmVnaW9uUmVnZXhlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWdpb25QYXR0ZXJuID0gUmVnRXhwKHJlZ2V4ZXNbaV0pO1xuICAgIHZhciBkbnNTdWZmaXggPSByZWdpb25SZWdleGVzW3JlZ2V4ZXNbaV1dO1xuICAgIGlmIChyZWdpb25QYXR0ZXJuLnRlc3QocmVnaW9uKSkgcmV0dXJuIGRuc1N1ZmZpeDtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN1ZmZpeDtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbmZpZ3VyZUVuZHBvaW50OiBjb25maWd1cmVFbmRwb2ludCxcbiAgZ2V0RW5kcG9pbnRTdWZmaXg6IGdldEVuZHBvaW50U3VmZml4LFxufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJydWxlc1wiOiB7XG4gICAgXCIqLypcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tXCJcbiAgICB9LFxuICAgIFwiY24tKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0ue3JlZ2lvbn0uYW1hem9uYXdzLmNvbS5jblwiXG4gICAgfSxcbiAgICBcInVzLWlzby0qLypcIjogXCJ1c0lzb1wiLFxuICAgIFwidXMtaXNvYi0qLypcIjogXCJ1c0lzb2JcIixcbiAgICBcIiovYnVkZ2V0c1wiOiBcImdsb2JhbFNTTFwiLFxuICAgIFwiKi9jbG91ZGZyb250XCI6IFwiZ2xvYmFsU1NMXCIsXG4gICAgXCIqL3N0c1wiOiBcImdsb2JhbFNTTFwiLFxuICAgIFwiKi9pbXBvcnRleHBvcnRcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS5hbWF6b25hd3MuY29tXCIsXG4gICAgICBcInNpZ25hdHVyZVZlcnNpb25cIjogXCJ2MlwiLFxuICAgICAgXCJnbG9iYWxFbmRwb2ludFwiOiB0cnVlXG4gICAgfSxcblxuICAgIFwiKi9yb3V0ZTUzXCI6IFwiZ2xvYmFsU1NMXCIsXG4gICAgXCJjbi0qL3JvdXRlNTNcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS5hbWF6b25hd3MuY29tLmNuXCIsXG4gICAgICBcImdsb2JhbEVuZHBvaW50XCI6IHRydWUsXG4gICAgICBcInNpZ25pbmdSZWdpb25cIjogXCJjbi1ub3J0aHdlc3QtMVwiXG4gICAgfSxcbiAgICBcInVzLWdvdi0qL3JvdXRlNTNcIjogXCJnbG9iYWxHb3ZDbG91ZFwiLFxuICAgIFwidXMtaXNvLSovcm91dGU1M1wiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LmMycy5pYy5nb3ZcIixcbiAgICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogdHJ1ZSxcbiAgICAgIFwic2lnbmluZ1JlZ2lvblwiOiBcInVzLWlzby1lYXN0LTFcIlxuICAgIH0sXG4gICAgXCJ1cy1pc29iLSovcm91dGU1M1wiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LnNjMnMuc2dvdi5nb3ZcIixcbiAgICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogdHJ1ZSxcbiAgICAgIFwic2lnbmluZ1JlZ2lvblwiOiBcInVzLWlzb2ItZWFzdC0xXCJcbiAgICB9LFxuXG4gICAgXCIqL3dhZlwiOiBcImdsb2JhbFNTTFwiLFxuXG4gICAgXCIqL2lhbVwiOiBcImdsb2JhbFNTTFwiLFxuICAgIFwiY24tKi9pYW1cIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS5jbi1ub3J0aC0xLmFtYXpvbmF3cy5jb20uY25cIixcbiAgICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogdHJ1ZSxcbiAgICAgIFwic2lnbmluZ1JlZ2lvblwiOiBcImNuLW5vcnRoLTFcIlxuICAgIH0sXG4gICAgXCJ1cy1nb3YtKi9pYW1cIjogXCJnbG9iYWxHb3ZDbG91ZFwiLFxuXG4gICAgXCJ1cy1nb3YtKi9zdHNcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5hbWF6b25hd3MuY29tXCJcbiAgICB9LFxuICAgIFwidXMtZ292LXdlc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJ1cy13ZXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwidXMtd2VzdC0yL3MzXCI6IFwiczNzaWduYXR1cmVcIixcbiAgICBcImV1LXdlc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJhcC1zb3V0aGVhc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJhcC1zb3V0aGVhc3QtMi9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJhcC1ub3J0aGVhc3QtMS9zM1wiOiBcInMzc2lnbmF0dXJlXCIsXG4gICAgXCJzYS1lYXN0LTEvczNcIjogXCJzM3NpZ25hdHVyZVwiLFxuICAgIFwidXMtZWFzdC0xL3MzXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0uYW1hem9uYXdzLmNvbVwiLFxuICAgICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwiczNcIlxuICAgIH0sXG4gICAgXCJ1cy1lYXN0LTEvc2RiXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0uYW1hem9uYXdzLmNvbVwiLFxuICAgICAgXCJzaWduYXR1cmVWZXJzaW9uXCI6IFwidjJcIlxuICAgIH0sXG4gICAgXCIqL3NkYlwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInYyXCJcbiAgICB9XG4gIH0sXG5cbiAgXCJmaXBzUnVsZXNcIjoge1xuICAgIFwiKi8qXCI6IFwiZmlwc1N0YW5kYXJkXCIsXG4gICAgXCJ1cy1nb3YtKi8qXCI6IFwiZmlwc1N0YW5kYXJkXCIsXG4gICAgXCJ1cy1pc28tKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0tZmlwcy57cmVnaW9ufS5jMnMuaWMuZ292XCJcbiAgICB9LFxuICAgIFwidXMtaXNvLSovZG1zXCI6IFwidXNJc29cIixcbiAgICBcInVzLWlzb2ItKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0tZmlwcy57cmVnaW9ufS5zYzJzLnNnb3YuZ292XCJcbiAgICB9LFxuICAgIFwidXMtaXNvYi0qL2Rtc1wiOiBcInVzSXNvYlwiLFxuICAgIFwiY24tKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0tZmlwcy57cmVnaW9ufS5hbWF6b25hd3MuY29tLmNuXCJcbiAgICB9LFxuICAgIFwiKi9hcGkuZWNyXCI6IFwiZmlwcy5hcGkuZWNyXCIsXG4gICAgXCIqL2FwaS5zYWdlbWFrZXJcIjogXCJmaXBzLmFwaS5zYWdlbWFrZXJcIixcbiAgICBcIiovYmF0Y2hcIjogXCJmaXBzRG90UHJlZml4XCIsXG4gICAgXCIqL2Vrc1wiOiBcImZpcHNEb3RQcmVmaXhcIixcbiAgICBcIiovbW9kZWxzLmxleFwiOiBcImZpcHMubW9kZWxzLmxleFwiLFxuICAgIFwiKi9ydW50aW1lLmxleFwiOiBcImZpcHMucnVudGltZS5sZXhcIixcbiAgICBcIiovcnVudGltZS5zYWdlbWFrZXJcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcInJ1bnRpbWUtZmlwcy5zYWdlbWFrZXIue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcIiovaWFtXCI6IFwiZmlwc1dpdGhvdXRSZWdpb25cIixcbiAgICBcIiovcm91dGU1M1wiOiBcImZpcHNXaXRob3V0UmVnaW9uXCIsXG4gICAgXCIqL3RyYW5zY3JpYmVcIjogXCJmaXBzRG90UHJlZml4XCIsXG4gICAgXCIqL3dhZlwiOiBcImZpcHNXaXRob3V0UmVnaW9uXCIsXG5cbiAgICBcInVzLWdvdi0qL3RyYW5zY3JpYmVcIjogXCJmaXBzRG90UHJlZml4XCIsXG4gICAgXCJ1cy1nb3YtKi9hcGkuZWNyXCI6IFwiZmlwcy5hcGkuZWNyXCIsXG4gICAgXCJ1cy1nb3YtKi9hcGkuc2FnZW1ha2VyXCI6IFwiZmlwcy5hcGkuc2FnZW1ha2VyXCIsXG4gICAgXCJ1cy1nb3YtKi9tb2RlbHMubGV4XCI6IFwiZmlwcy5tb2RlbHMubGV4XCIsXG4gICAgXCJ1cy1nb3YtKi9ydW50aW1lLmxleFwiOiBcImZpcHMucnVudGltZS5sZXhcIixcbiAgICBcInVzLWdvdi0qL2FjbS1wY2FcIjogXCJmaXBzV2l0aFNlcnZpY2VPbmx5XCIsXG4gICAgXCJ1cy1nb3YtKi9iYXRjaFwiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL2NvbmZpZ1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL2Vrc1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL2VsYXN0aWNtYXByZWR1Y2VcIjogXCJmaXBzV2l0aFNlcnZpY2VPbmx5XCIsXG4gICAgXCJ1cy1nb3YtKi9pZGVudGl0eXN0b3JlXCI6IFwiZmlwc1dpdGhTZXJ2aWNlT25seVwiLFxuICAgIFwidXMtZ292LSovZHluYW1vZGJcIjogXCJmaXBzV2l0aFNlcnZpY2VPbmx5XCIsXG4gICAgXCJ1cy1nb3YtKi9lbGFzdGljbG9hZGJhbGFuY2luZ1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL2d1YXJkZHV0eVwiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL21vbml0b3JpbmdcIjogXCJmaXBzV2l0aFNlcnZpY2VPbmx5XCIsXG4gICAgXCJ1cy1nb3YtKi9yZXNvdXJjZS1ncm91cHNcIjogXCJmaXBzV2l0aFNlcnZpY2VPbmx5XCIsXG4gICAgXCJ1cy1nb3YtKi9ydW50aW1lLnNhZ2VtYWtlclwiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL3NlcnZpY2VjYXRhbG9nLWFwcHJlZ2lzdHJ5XCI6IFwiZmlwc1dpdGhTZXJ2aWNlT25seVwiLFxuICAgIFwidXMtZ292LSovc2VydmljZXF1b3Rhc1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL3NzbVwiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL3N0c1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi0qL3N1cHBvcnRcIjogXCJmaXBzV2l0aFNlcnZpY2VPbmx5XCIsXG4gICAgXCJ1cy1nb3Ytd2VzdC0xL3N0YXRlc1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWlzby1lYXN0LTEvZWxhc3RpY2ZpbGVzeXN0ZW1cIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcImVsYXN0aWNmaWxlc3lzdGVtLWZpcHMue3JlZ2lvbn0uYzJzLmljLmdvdlwiXG4gICAgfSxcbiAgICBcInVzLWdvdi13ZXN0LTEvb3JnYW5pemF0aW9uc1wiOiBcImZpcHNXaXRoU2VydmljZU9ubHlcIixcbiAgICBcInVzLWdvdi13ZXN0LTEvcm91dGU1M1wiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwicm91dGU1My51cy1nb3YuYW1hem9uYXdzLmNvbVwiXG4gICAgfVxuICB9LFxuXG4gIFwiZHVhbHN0YWNrUnVsZXNcIjoge1xuICAgIFwiKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0ue3JlZ2lvbn0uYXBpLmF3c1wiXG4gICAgfSxcbiAgICBcImNuLSovKlwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFwaS5hbWF6b253ZWJzZXJ2aWNlcy5jb20uY25cIlxuICAgIH0sXG5cbiAgICBcIiovczNcIjogXCJkdWFsc3RhY2tMZWdhY3lcIixcbiAgICBcImNuLSovczNcIjogXCJkdWFsc3RhY2tMZWdhY3lDblwiLFxuICAgIFwiKi9zMy1jb250cm9sXCI6IFwiZHVhbHN0YWNrTGVnYWN5XCIsXG4gICAgXCJjbi0qL3MzLWNvbnRyb2xcIjogXCJkdWFsc3RhY2tMZWdhY3lDblwiLFxuXG4gICAgXCJhcC1zb3V0aC0xL2VjMlwiOiBcImR1YWxzdGFja0xlZ2FjeUVjMlwiLFxuICAgIFwiZXUtd2VzdC0xL2VjMlwiOiBcImR1YWxzdGFja0xlZ2FjeUVjMlwiLFxuICAgIFwic2EtZWFzdC0xL2VjMlwiOiBcImR1YWxzdGFja0xlZ2FjeUVjMlwiLFxuICAgIFwidXMtZWFzdC0xL2VjMlwiOiBcImR1YWxzdGFja0xlZ2FjeUVjMlwiLFxuICAgIFwidXMtZWFzdC0yL2VjMlwiOiBcImR1YWxzdGFja0xlZ2FjeUVjMlwiLFxuICAgIFwidXMtd2VzdC0yL2VjMlwiOiBcImR1YWxzdGFja0xlZ2FjeUVjMlwiXG4gIH0sXG5cbiAgXCJkdWFsc3RhY2tGaXBzUnVsZXNcIjoge1xuICAgIFwiKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0tZmlwcy57cmVnaW9ufS5hcGkuYXdzXCJcbiAgICB9LFxuICAgIFwiY24tKi8qXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0tZmlwcy57cmVnaW9ufS5hcGkuYW1hem9ud2Vic2VydmljZXMuY29tLmNuXCJcbiAgICB9LFxuICAgIFwiKi9zM1wiOiBcImR1YWxzdGFja0ZpcHNMZWdhY3lcIixcbiAgICBcImNuLSovczNcIjogXCJkdWFsc3RhY2tGaXBzTGVnYWN5Q25cIixcbiAgICBcIiovczMtY29udHJvbFwiOiBcImR1YWxzdGFja0ZpcHNMZWdhY3lcIixcbiAgICBcImNuLSovczMtY29udHJvbFwiOiBcImR1YWxzdGFja0ZpcHNMZWdhY3lDblwiXG4gIH0sXG5cbiAgXCJwYXR0ZXJuc1wiOiB7XG4gICAgXCJnbG9iYWxTU0xcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcImh0dHBzOi8ve3NlcnZpY2V9LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogdHJ1ZSxcbiAgICAgIFwic2lnbmluZ1JlZ2lvblwiOiBcInVzLWVhc3QtMVwiXG4gICAgfSxcbiAgICBcImdsb2JhbEdvdkNsb3VkXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0udXMtZ292LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwiZ2xvYmFsRW5kcG9pbnRcIjogdHJ1ZSxcbiAgICAgIFwic2lnbmluZ1JlZ2lvblwiOiBcInVzLWdvdi13ZXN0LTFcIlxuICAgIH0sXG4gICAgXCJzM3NpZ25hdHVyZVwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIixcbiAgICAgIFwic2lnbmF0dXJlVmVyc2lvblwiOiBcInMzXCJcbiAgICB9LFxuICAgIFwidXNJc29cIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS57cmVnaW9ufS5jMnMuaWMuZ292XCJcbiAgICB9LFxuICAgIFwidXNJc29iXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0ue3JlZ2lvbn0uc2Mycy5zZ292LmdvdlwiXG4gICAgfSxcbiAgICBcImZpcHNTdGFuZGFyZFwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LWZpcHMue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcImZpcHNEb3RQcmVmaXhcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcImZpcHMue3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIlxuICAgIH0sXG4gICAgXCJmaXBzV2l0aG91dFJlZ2lvblwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LWZpcHMuYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcImZpcHMuYXBpLmVjclwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwiZWNyLWZpcHMue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcImZpcHMuYXBpLnNhZ2VtYWtlclwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwiYXBpLWZpcHMuc2FnZW1ha2VyLntyZWdpb259LmFtYXpvbmF3cy5jb21cIlxuICAgIH0sXG4gICAgXCJmaXBzLm1vZGVscy5sZXhcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIm1vZGVscy1maXBzLmxleC57cmVnaW9ufS5hbWF6b25hd3MuY29tXCJcbiAgICB9LFxuICAgIFwiZmlwcy5ydW50aW1lLmxleFwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwicnVudGltZS1maXBzLmxleC57cmVnaW9ufS5hbWF6b25hd3MuY29tXCJcbiAgICB9LFxuICAgIFwiZmlwc1dpdGhTZXJ2aWNlT25seVwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LntyZWdpb259LmFtYXpvbmF3cy5jb21cIlxuICAgIH0sXG4gICAgXCJkdWFsc3RhY2tMZWdhY3lcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcIntzZXJ2aWNlfS5kdWFsc3RhY2sue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcImR1YWxzdGFja0xlZ2FjeUNuXCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0uZHVhbHN0YWNrLntyZWdpb259LmFtYXpvbmF3cy5jb20uY25cIlxuICAgIH0sXG4gICAgXCJkdWFsc3RhY2tGaXBzTGVnYWN5XCI6IHtcbiAgICAgIFwiZW5kcG9pbnRcIjogXCJ7c2VydmljZX0tZmlwcy5kdWFsc3RhY2sue3JlZ2lvbn0uYW1hem9uYXdzLmNvbVwiXG4gICAgfSxcbiAgICBcImR1YWxzdGFja0ZpcHNMZWdhY3lDblwiOiB7XG4gICAgICBcImVuZHBvaW50XCI6IFwie3NlcnZpY2V9LWZpcHMuZHVhbHN0YWNrLntyZWdpb259LmFtYXpvbmF3cy5jb20uY25cIlxuICAgIH0sXG4gICAgXCJkdWFsc3RhY2tMZWdhY3lFYzJcIjoge1xuICAgICAgXCJlbmRwb2ludFwiOiBcImFwaS5lYzIue3JlZ2lvbn0uYXdzXCJcbiAgICB9XG4gIH1cbn1cbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBY2NlcHRvclN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4vc3RhdGVfbWFjaGluZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xudmFyIGRvbWFpbiA9IEFXUy51dGlsLmRvbWFpbjtcbnZhciBqbWVzcGF0aCA9IHJlcXVpcmUoJ2ptZXNwYXRoJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBoYXJkRXJyb3JTdGF0ZXMgPSB7c3VjY2VzczogMSwgZXJyb3I6IDEsIGNvbXBsZXRlOiAxfTtcblxuZnVuY3Rpb24gaXNUZXJtaW5hbFN0YXRlKG1hY2hpbmUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoYXJkRXJyb3JTdGF0ZXMsIG1hY2hpbmUuX2FzbS5jdXJyZW50U3RhdGUpO1xufVxuXG52YXIgZnNtID0gbmV3IEFjY2VwdG9yU3RhdGVNYWNoaW5lKCk7XG5mc20uc2V0dXBTdGF0ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRyYW5zaXRpb24gPSBmdW5jdGlvbihfLCBkb25lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX2hhbHRIYW5kbGVyc09uRXJyb3IgPSBmYWxzZTtcblxuICAgIHNlbGYuZW1pdChzZWxmLl9hc20uY3VycmVudFN0YXRlLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGlzVGVybWluYWxTdGF0ZShzZWxmKSkge1xuICAgICAgICAgIGlmIChkb21haW4gJiYgc2VsZi5kb21haW4gaW5zdGFuY2VvZiBkb21haW4uRG9tYWluKSB7XG4gICAgICAgICAgICBlcnIuZG9tYWluRW1pdHRlciA9IHNlbGY7XG4gICAgICAgICAgICBlcnIuZG9tYWluID0gc2VsZi5kb21haW47XG4gICAgICAgICAgICBlcnIuZG9tYWluVGhyb3duID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmRvbWFpbi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5yZXNwb25zZS5lcnJvciA9IGVycjtcbiAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbmUoc2VsZi5yZXNwb25zZS5lcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfTtcblxuICB0aGlzLmFkZFN0YXRlKCd2YWxpZGF0ZScsICdidWlsZCcsICdlcnJvcicsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdidWlsZCcsICdhZnRlckJ1aWxkJywgJ3Jlc3RhcnQnLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnYWZ0ZXJCdWlsZCcsICdzaWduJywgJ3Jlc3RhcnQnLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnc2lnbicsICdzZW5kJywgJ3JldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3JldHJ5JywgJ2FmdGVyUmV0cnknLCAnYWZ0ZXJSZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdhZnRlclJldHJ5JywgJ3NpZ24nLCAnZXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnc2VuZCcsICd2YWxpZGF0ZVJlc3BvbnNlJywgJ3JldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3ZhbGlkYXRlUmVzcG9uc2UnLCAnZXh0cmFjdERhdGEnLCAnZXh0cmFjdEVycm9yJywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ2V4dHJhY3RFcnJvcicsICdleHRyYWN0RGF0YScsICdyZXRyeScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdleHRyYWN0RGF0YScsICdzdWNjZXNzJywgJ3JldHJ5JywgdHJhbnNpdGlvbik7XG4gIHRoaXMuYWRkU3RhdGUoJ3Jlc3RhcnQnLCAnYnVpbGQnLCAnZXJyb3InLCB0cmFuc2l0aW9uKTtcbiAgdGhpcy5hZGRTdGF0ZSgnc3VjY2VzcycsICdjb21wbGV0ZScsICdjb21wbGV0ZScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdlcnJvcicsICdjb21wbGV0ZScsICdjb21wbGV0ZScsIHRyYW5zaXRpb24pO1xuICB0aGlzLmFkZFN0YXRlKCdjb21wbGV0ZScsIG51bGwsIG51bGwsIHRyYW5zaXRpb24pO1xufTtcbmZzbS5zZXR1cFN0YXRlcygpO1xuXG4vKipcbiAqICMjIEFzeW5jaHJvbm91cyBSZXF1ZXN0c1xuICpcbiAqIEFsbCByZXF1ZXN0cyBtYWRlIHRocm91Z2ggdGhlIFNESyBhcmUgYXN5bmNocm9ub3VzIGFuZCB1c2UgYVxuICogY2FsbGJhY2sgaW50ZXJmYWNlLiBFYWNoIHNlcnZpY2UgbWV0aG9kIHRoYXQga2lja3Mgb2ZmIGEgcmVxdWVzdFxuICogcmV0dXJucyBhbiBgQVdTLlJlcXVlc3RgIG9iamVjdCB0aGF0IHlvdSBjYW4gdXNlIHRvIHJlZ2lzdGVyXG4gKiBjYWxsYmFja3MuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgc2VydmljZSBtZXRob2QgcmV0dXJucyB0aGUgcmVxdWVzdFxuICogb2JqZWN0IGFzIFwicmVxdWVzdFwiLCB3aGljaCBjYW4gYmUgdXNlZCB0byByZWdpc3RlciBjYWxsYmFja3M6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogLy8gcmVxdWVzdCBpcyBhbiBBV1MuUmVxdWVzdCBvYmplY3RcbiAqIHZhciByZXF1ZXN0ID0gZWMyLmRlc2NyaWJlSW5zdGFuY2VzKCk7XG4gKlxuICogLy8gcmVnaXN0ZXIgY2FsbGJhY2tzIG9uIHJlcXVlc3QgdG8gcmV0cmlldmUgcmVzcG9uc2UgZGF0YVxuICogcmVxdWVzdC5vbignc3VjY2VzcycsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLmRhdGEpO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBXaGVuIGEgcmVxdWVzdCBpcyByZWFkeSB0byBiZSBzZW50LCB0aGUge3NlbmR9IG1ldGhvZCBzaG91bGRcbiAqIGJlIGNhbGxlZDpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiByZXF1ZXN0LnNlbmQoKTtcbiAqIGBgYFxuICpcbiAqIFNpbmNlIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIG1heSBvciBtYXkgbm90IGJlIGlkZW1wb3RlbnQsIHJlcXVlc3RzIHNob3VsZCBvbmx5XG4gKiBiZSBzZW50IG9uY2UuIFRvIHBlcmZvcm0gdGhlIHNhbWUgb3BlcmF0aW9uIG11bHRpcGxlIHRpbWVzLCB5b3Ugd2lsbCBuZWVkIHRvXG4gKiBjcmVhdGUgbXVsdGlwbGUgcmVxdWVzdCBvYmplY3RzLCBlYWNoIHdpdGggaXRzIG93biByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiAjIyBSZW1vdmluZyBEZWZhdWx0IExpc3RlbmVycyBmb3IgRXZlbnRzXG4gKlxuICogUmVxdWVzdCBvYmplY3RzIGFyZSBidWlsdCB3aXRoIGRlZmF1bHQgbGlzdGVuZXJzIGZvciB0aGUgdmFyaW91cyBldmVudHMsXG4gKiBkZXBlbmRpbmcgb24gdGhlIHNlcnZpY2UgdHlwZS4gSW4gc29tZSBjYXNlcywgeW91IG1heSB3YW50IHRvIHJlbW92ZVxuICogc29tZSBidWlsdC1pbiBsaXN0ZW5lcnMgdG8gY3VzdG9taXplIGJlaGF2aW91ci4gRG9pbmcgdGhpcyByZXF1aXJlc1xuICogYWNjZXNzIHRvIHRoZSBidWlsdC1pbiBsaXN0ZW5lciBmdW5jdGlvbnMsIHdoaWNoIGFyZSBleHBvc2VkIHRocm91Z2hcbiAqIHRoZSB7QVdTLkV2ZW50TGlzdGVuZXJzLkNvcmV9IG5hbWVzcGFjZS4gRm9yIGluc3RhbmNlLCB5b3UgbWF5XG4gKiB3YW50IHRvIGN1c3RvbWl6ZSB0aGUgSFRUUCBoYW5kbGVyIHVzZWQgd2hlbiBzZW5kaW5nIGEgcmVxdWVzdC4gSW4gdGhpc1xuICogY2FzZSwgeW91IGNhbiByZW1vdmUgdGhlIGJ1aWx0LWluIGxpc3RlbmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgJ3NlbmQnXG4gKiBldmVudCwgdGhlIHtBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TRU5EfSBsaXN0ZW5lciBhbmQgYWRkIHlvdXIgb3duLlxuICpcbiAqICMjIE11bHRpcGxlIENhbGxiYWNrcyBhbmQgQ2hhaW5pbmdcbiAqXG4gKiBZb3UgY2FuIHJlZ2lzdGVyIG11bHRpcGxlIGNhbGxiYWNrcyBvbiBhbnkgcmVxdWVzdCBvYmplY3QuIFRoZVxuICogY2FsbGJhY2tzIGNhbiBiZSByZWdpc3RlcmVkIGZvciBkaWZmZXJlbnQgZXZlbnRzLCBvciBhbGwgZm9yIHRoZVxuICogc2FtZSBldmVudC4gSW4gYWRkaXRpb24sIHlvdSBjYW4gY2hhaW4gY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBmb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcmVxdWVzdC5cbiAqICAgb24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICogICAgIGNvbnNvbGUubG9nKFwiU3VjY2VzcyFcIik7XG4gKiAgIH0pLlxuICogICBvbignZXJyb3InLCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIVwiKTtcbiAqICAgfSkuXG4gKiAgIG9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJBbHdheXMhXCIpO1xuICogICB9KS5cbiAqICAgc2VuZCgpO1xuICogYGBgXG4gKlxuICogVGhlIGFib3ZlIGV4YW1wbGUgd2lsbCBwcmludCBlaXRoZXIgXCJTdWNjZXNzISBBbHdheXMhXCIsIG9yIFwiRXJyb3IhIEFsd2F5cyFcIixcbiAqIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSByZXF1ZXN0IHN1Y2NlZWRlZCBvciBub3QuXG4gKlxuICogQCFhdHRyaWJ1dGUgaHR0cFJlcXVlc3RcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgSFRUUCBQcm9wZXJ0aWVzXG4gKiAgIEByZXR1cm4gW0FXUy5IdHRwUmVxdWVzdF0gdGhlIHJhdyBIVFRQIHJlcXVlc3Qgb2JqZWN0XG4gKiAgICAgY29udGFpbmluZyByZXF1ZXN0IGhlYWRlcnMgYW5kIGJvZHkgaW5mb3JtYXRpb25cbiAqICAgICBzZW50IGJ5IHRoZSBzZXJ2aWNlLlxuICpcbiAqIEAhYXR0cmlidXRlIHN0YXJ0VGltZVxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBPcGVyYXRpb24gUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtEYXRlXSB0aGUgdGltZSB0aGF0IHRoZSByZXF1ZXN0IHN0YXJ0ZWRcbiAqXG4gKiBAIWdyb3VwIFJlcXVlc3QgQnVpbGRpbmcgRXZlbnRzXG4gKlxuICogQCFldmVudCB2YWxpZGF0ZShyZXF1ZXN0KVxuICogICBUcmlnZ2VyZWQgd2hlbiBhIHJlcXVlc3QgaXMgYmVpbmcgdmFsaWRhdGVkLiBMaXN0ZW5lcnNcbiAqICAgc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHRoZSByZXF1ZXN0IHNob3VsZCBub3QgYmUgc2VudC5cbiAqICAgQHBhcmFtIHJlcXVlc3QgW1JlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCBiZWluZyBzZW50XG4gKiAgIEBzZWUgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfQ1JFREVOVElBTFNcbiAqICAgQHNlZSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT05cbiAqICAgQGV4YW1wbGUgRW5zdXJpbmcgdGhhdCBhIGNlcnRhaW4gcGFyYW1ldGVyIGlzIHNldCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3RcbiAqICAgICB2YXIgcmVxID0gczMucHV0T2JqZWN0KHBhcmFtcyk7XG4gKiAgICAgcmVxLm9uKCd2YWxpZGF0ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgaWYgKCFyZXEucGFyYW1zLkJvZHkubWF0Y2goL15IZWxsb1xccy8pKSB7XG4gKiAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm9keSBtdXN0IHN0YXJ0IHdpdGggXCJIZWxsbyBcIicpO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIHJlcS5zZW5kKGZ1bmN0aW9uKGVyciwgZGF0YSkgeyAuLi4gfSk7XG4gKlxuICogQCFldmVudCBidWlsZChyZXF1ZXN0KVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgcmVxdWVzdCBwYXlsb2FkIGlzIGJlaW5nIGJ1aWx0LiBMaXN0ZW5lcnNcbiAqICAgc2hvdWxkIGZpbGwgdGhlIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiB0byBzZW5kIHRoZSByZXF1ZXN0XG4gKiAgIG92ZXIgSFRUUC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+dmFsaWRhdGUpXG4gKiAgIEBleGFtcGxlIEFkZCBhIGN1c3RvbSBIVFRQIGhlYWRlciB0byBhIHJlcXVlc3RcbiAqICAgICB2YXIgcmVxID0gczMucHV0T2JqZWN0KHBhcmFtcyk7XG4gKiAgICAgcmVxLm9uKCdidWlsZCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0N1c3RvbS1IZWFkZXInXSA9ICd2YWx1ZSc7XG4gKiAgICAgfSk7XG4gKiAgICAgcmVxLnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IC4uLiB9KTtcbiAqXG4gKiBAIWV2ZW50IHNpZ24ocmVxdWVzdClcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgaXMgYmVpbmcgc2lnbmVkLiBMaXN0ZW5lcnMgc2hvdWxkXG4gKiAgIGFkZCB0aGUgY29ycmVjdCBhdXRoZW50aWNhdGlvbiBoZWFkZXJzIGFuZC9vciBhZGp1c3QgdGhlIGJvZHksXG4gKiAgIGRlcGVuZGluZyBvbiB0aGUgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIGJlaW5nIHVzZWQuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnZhbGlkYXRlKVxuICpcbiAqIEAhZ3JvdXAgUmVxdWVzdCBTZW5kaW5nIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgc2VuZChyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHJlcXVlc3QgaXMgcmVhZHkgdG8gYmUgc2VudC4gTGlzdGVuZXJzXG4gKiAgIHNob3VsZCBjYWxsIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBsYXllciB0byBpbml0aWF0ZVxuICogICB0aGUgc2VuZGluZyBvZiB0aGUgcmVxdWVzdC5cbiAqICAgQHBhcmFtIHJlc3BvbnNlIFtSZXNwb25zZV0gdGhlIHJlc3BvbnNlIG9iamVjdFxuICogICBAY29udGV4dCBbUmVxdWVzdF0gdGhlIHJlcXVlc3Qgb2JqZWN0IHRoYXQgd2FzIHNlbnRcbiAqICAgQHNlZSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TRU5EXG4gKlxuICogQCFldmVudCByZXRyeShyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gYSByZXF1ZXN0IGZhaWxlZCBhbmQgbWlnaHQgbmVlZCB0byBiZSByZXRyaWVkIG9yIHJlZGlyZWN0ZWQuXG4gKiAgIElmIHRoZSByZXNwb25zZSBpcyByZXRyeWFibGUsIHRoZSBsaXN0ZW5lciBzaG91bGQgc2V0IHRoZVxuICogICBgcmVzcG9uc2UuZXJyb3IucmV0cnlhYmxlYCBwcm9wZXJ0eSB0byBgdHJ1ZWAsIGFuZCBvcHRpb25hbGx5IHNldFxuICogICBgcmVzcG9uc2UuZXJyb3IucmV0cnlEZWxheWAgdG8gdGhlIG1pbGxpc2Vjb25kIGRlbGF5IGZvciB0aGUgbmV4dCBhdHRlbXB0LlxuICogICBJbiB0aGUgY2FzZSBvZiBhIHJlZGlyZWN0LCBgcmVzcG9uc2UuZXJyb3IucmVkaXJlY3RgIHNob3VsZCBiZSBzZXQgdG9cbiAqICAgYHRydWVgIHdpdGggYHJldHJ5RGVsYXlgIHNldCB0byBhbiBvcHRpb25hbCBkZWxheSBvbiB0aGUgbmV4dCByZXF1ZXN0LlxuICpcbiAqICAgSWYgYSBsaXN0ZW5lciBkZWNpZGVzIHRoYXQgYSByZXF1ZXN0IHNob3VsZCBub3QgYmUgcmV0cmllZCxcbiAqICAgaXQgc2hvdWxkIHNldCBib3RoIGByZXRyeWFibGVgIGFuZCBgcmVkaXJlY3RgIHRvIGZhbHNlLlxuICpcbiAqICAgTm90ZSB0aGF0IGEgcmV0cnlhYmxlIGVycm9yIHdpbGwgYmUgcmV0cmllZCBhdCBtb3N0XG4gKiAgIHtBV1MuQ29uZmlnLm1heFJldHJpZXN9IHRpbWVzIChiYXNlZCBvbiB0aGUgc2VydmljZSBvYmplY3QncyBjb25maWcpLlxuICogICBTaW1pbGFybHksIGEgcmVxdWVzdCB0aGF0IGlzIHJlZGlyZWN0ZWQgd2lsbCBvbmx5IHJlZGlyZWN0IGF0IG1vc3RcbiAqICAge0FXUy5Db25maWcubWF4UmVkaXJlY3RzfSB0aW1lcy5cbiAqXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGV4YW1wbGUgQWRkaW5nIGEgY3VzdG9tIHJldHJ5IGZvciBhIDQwNCByZXNwb25zZVxuICogICAgIHJlcXVlc3Qub24oJ3JldHJ5JywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAqICAgICAgIC8vIHRoaXMgcmVzb3VyY2UgaXMgbm90IHlldCBhdmFpbGFibGUsIHdhaXQgMTAgc2Vjb25kcyB0byBnZXQgaXQgYWdhaW5cbiAqICAgICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0ICYmIHJlc3BvbnNlLmVycm9yKSB7XG4gKiAgICAgICAgIHJlc3BvbnNlLmVycm9yLnJldHJ5YWJsZSA9IHRydWU7ICAgLy8gcmV0cnkgdGhpcyBlcnJvclxuICogICAgICAgICByZXNwb25zZS5lcnJvci5yZXRyeURlbGF5ID0gMTAwMDA7IC8vIHdhaXQgMTAgc2Vjb25kc1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIEAhZ3JvdXAgRGF0YSBQYXJzaW5nIEV2ZW50c1xuICpcbiAqIEAhZXZlbnQgZXh0cmFjdEVycm9yKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgb24gYWxsIG5vbi0yeHggcmVxdWVzdHMgc28gdGhhdCBsaXN0ZW5lcnMgY2FuIGV4dHJhY3RcbiAqICAgZXJyb3IgZGV0YWlscyBmcm9tIHRoZSByZXNwb25zZSBib2R5LiBMaXN0ZW5lcnMgdG8gdGhpcyBldmVudFxuICogICBzaG91bGQgc2V0IHRoZSBgcmVzcG9uc2UuZXJyb3JgIHByb3BlcnR5LlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBleHRyYWN0RGF0YShyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIGluIHN1Y2Nlc3NmdWwgcmVxdWVzdHMgdG8gYWxsb3cgbGlzdGVuZXJzIHRvXG4gKiAgIGRlLXNlcmlhbGl6ZSB0aGUgcmVzcG9uc2UgYm9keSBpbnRvIGByZXNwb25zZS5kYXRhYC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZ3JvdXAgQ29tcGxldGlvbiBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IHN1Y2Nlc3MocmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSByZXF1ZXN0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gKiAgIGByZXNwb25zZS5kYXRhYCB3aWxsIGNvbnRhaW4gdGhlIHJlc3BvbnNlIGRhdGEgYW5kXG4gKiAgIGByZXNwb25zZS5lcnJvcmAgd2lsbCBiZSBudWxsLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBlcnJvcihlcnJvciwgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBhdCBhbnkgcG9pbnQgZHVyaW5nIHRoZVxuICogICByZXF1ZXN0LiBgcmVzcG9uc2UuZXJyb3JgIHdpbGwgY29udGFpbiBkZXRhaWxzIGFib3V0IHRoZSBlcnJvclxuICogICB0aGF0IG9jY3VycmVkLiBgcmVzcG9uc2UuZGF0YWAgd2lsbCBiZSBudWxsLlxuICogICBAcGFyYW0gZXJyb3IgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dFxuICogICAgIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkLlxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQCFldmVudCBjb21wbGV0ZShyZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW5ldmVyIGEgcmVxdWVzdCBjeWNsZSBjb21wbGV0ZXMuIGByZXNwb25zZS5lcnJvcmBcbiAqICAgc2hvdWxkIGJlIGNoZWNrZWQsIHNpbmNlIHRoZSByZXF1ZXN0IG1heSBoYXZlIGZhaWxlZC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICpcbiAqIEAhZ3JvdXAgSFRUUCBFdmVudHNcbiAqXG4gKiBAIWV2ZW50IGh0dHBIZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3BvbnNlLCBzdGF0dXNNZXNzYWdlKVxuICogICBUcmlnZ2VyZWQgd2hlbiBoZWFkZXJzIGFyZSBzZW50IGJ5IHRoZSByZW1vdGUgc2VydmVyXG4gKiAgIEBwYXJhbSBzdGF0dXNDb2RlIFtJbnRlZ2VyXSB0aGUgSFRUUCByZXNwb25zZSBjb2RlXG4gKiAgIEBwYXJhbSBoZWFkZXJzIFttYXA8U3RyaW5nLFN0cmluZz5dIHRoZSByZXNwb25zZSBoZWFkZXJzXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBwYXJhbSBzdGF0dXNNZXNzYWdlIFtTdHJpbmddIEEgc3RhdHVzIG1lc3NhZ2UgY29ycmVzcG9uZGluZyB0byB0aGUgSFRUUFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSBjb2RlXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGh0dHBEYXRhKGNodW5rLCByZXNwb25zZSlcbiAqICAgVHJpZ2dlcmVkIHdoZW4gZGF0YSBpcyBzZW50IGJ5IHRoZSByZW1vdGUgc2VydmVyXG4gKiAgIEBwYXJhbSBjaHVuayBbQnVmZmVyXSB0aGUgYnVmZmVyIGRhdGEgY29udGFpbmluZyB0aGUgbmV4dCBkYXRhIGNodW5rXG4gKiAgICAgZnJvbSB0aGUgc2VydmVyXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQHNlZSBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5IVFRQX0RBVEFcbiAqXG4gKiBAIWV2ZW50IGh0dHBVcGxvYWRQcm9ncmVzcyhwcm9ncmVzcywgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSBIVFRQIHJlcXVlc3QgaGFzIHVwbG9hZGVkIG1vcmUgZGF0YVxuICogICBAcGFyYW0gcHJvZ3Jlc3MgW21hcF0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBsb2FkZWRgIGFuZCBgdG90YWxgIGJ5dGVzXG4gKiAgICAgb2YgdGhlIHJlcXVlc3QuXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQG5vdGUgVGhpcyBldmVudCB3aWxsIG5vdCBiZSBlbWl0dGVkIGluIE5vZGUuanMgMC44LnguXG4gKlxuICogQCFldmVudCBodHRwRG93bmxvYWRQcm9ncmVzcyhwcm9ncmVzcywgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSBIVFRQIHJlcXVlc3QgaGFzIGRvd25sb2FkZWQgbW9yZSBkYXRhXG4gKiAgIEBwYXJhbSBwcm9ncmVzcyBbbWFwXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgYGxvYWRlZGAgYW5kIGB0b3RhbGAgYnl0ZXNcbiAqICAgICBvZiB0aGUgcmVxdWVzdC5cbiAqICAgQHBhcmFtIChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqICAgQGNvbnRleHQgKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAbm90ZSBUaGlzIGV2ZW50IHdpbGwgbm90IGJlIGVtaXR0ZWQgaW4gTm9kZS5qcyAwLjgueC5cbiAqXG4gKiBAIWV2ZW50IGh0dHBFcnJvcihlcnJvciwgcmVzcG9uc2UpXG4gKiAgIFRyaWdnZXJlZCB3aGVuIHRoZSBIVFRQIHJlcXVlc3QgZmFpbGVkXG4gKiAgIEBwYXJhbSBlcnJvciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgdGhhdCB3YXMgdGhyb3duXG4gKiAgIEBwYXJhbSAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqXG4gKiBAIWV2ZW50IGh0dHBEb25lKHJlc3BvbnNlKVxuICogICBUcmlnZ2VyZWQgd2hlbiB0aGUgc2VydmVyIGlzIGZpbmlzaGVkIHNlbmRpbmcgZGF0YVxuICogICBAcGFyYW0gKHNlZSBBV1MuUmVxdWVzdH5zZW5kKVxuICogICBAY29udGV4dCAoc2VlIEFXUy5SZXF1ZXN0fnNlbmQpXG4gKlxuICogQHNlZSBBV1MuUmVzcG9uc2VcbiAqL1xuQVdTLlJlcXVlc3QgPSBpbmhlcml0KHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlcXVlc3QgZm9yIGFuIG9wZXJhdGlvbiBvbiBhIGdpdmVuIHNlcnZpY2Ugd2l0aFxuICAgKiBhIHNldCBvZiBpbnB1dCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmljZSBbQVdTLlNlcnZpY2VdIHRoZSBzZXJ2aWNlIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBvblxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIFtTdHJpbmddIHRoZSBvcGVyYXRpb24gdG8gcGVyZm9ybSBvbiB0aGUgc2VydmljZVxuICAgKiBAcGFyYW0gcGFyYW1zIFtPYmplY3RdIHBhcmFtZXRlcnMgdG8gc2VuZCB0byB0aGUgb3BlcmF0aW9uLlxuICAgKiAgIFNlZSB0aGUgb3BlcmF0aW9uJ3MgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGZvcm1hdCBvZiB0aGVcbiAgICogICBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlcXVlc3Qoc2VydmljZSwgb3BlcmF0aW9uLCBwYXJhbXMpIHtcbiAgICB2YXIgZW5kcG9pbnQgPSBzZXJ2aWNlLmVuZHBvaW50O1xuICAgIHZhciByZWdpb24gPSBzZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gICAgdmFyIGN1c3RvbVVzZXJBZ2VudCA9IHNlcnZpY2UuY29uZmlnLmN1c3RvbVVzZXJBZ2VudDtcblxuICAgIGlmIChzZXJ2aWNlLnNpZ25pbmdSZWdpb24pIHtcbiAgICAgIHJlZ2lvbiA9IHNlcnZpY2Uuc2lnbmluZ1JlZ2lvbjtcbiAgICB9IGVsc2UgaWYgKHNlcnZpY2UuaXNHbG9iYWxFbmRwb2ludCkge1xuICAgICAgcmVnaW9uID0gJ3VzLWVhc3QtMSc7XG4gICAgfVxuXG4gICAgdGhpcy5kb21haW4gPSBkb21haW4gJiYgZG9tYWluLmFjdGl2ZTtcbiAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgQVdTLkh0dHBSZXF1ZXN0KGVuZHBvaW50LCByZWdpb24pO1xuICAgIHRoaXMuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHNlcnZpY2UuZ2V0U2tld0NvcnJlY3RlZERhdGUoKTtcblxuICAgIHRoaXMucmVzcG9uc2UgPSBuZXcgQVdTLlJlc3BvbnNlKHRoaXMpO1xuICAgIHRoaXMuX2FzbSA9IG5ldyBBY2NlcHRvclN0YXRlTWFjaGluZShmc20uc3RhdGVzLCAndmFsaWRhdGUnKTtcbiAgICB0aGlzLl9oYWx0SGFuZGxlcnNPbkVycm9yID0gZmFsc2U7XG5cbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lbWl0ID0gdGhpcy5lbWl0RXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEAhZ3JvdXAgU2VuZGluZyBhIFJlcXVlc3RcbiAgICovXG5cbiAgLyoqXG4gICAqIEBvdmVybG9hZCBzZW5kKGNhbGxiYWNrID0gbnVsbClcbiAgICogICBTZW5kcyB0aGUgcmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqICAgQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICAgIGZyb20gdGhlIHNlcnZpY2UuXG4gICAqICAgICBAY29udGV4dCBbQVdTLlJlcXVlc3RdIHRoZSByZXF1ZXN0IG9iamVjdCBiZWluZyBzZW50LlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcmVxdWVzdC5cbiAgICogICAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICAgIHRoZSByZXF1ZXN0LiBTZXQgdG8gYG51bGxgIGlmIGEgcmVxdWVzdCBlcnJvciBvY2N1cnMuXG4gICAqICAgQGV4YW1wbGUgU2VuZGluZyBhIHJlcXVlc3Qgd2l0aCBhIGNhbGxiYWNrXG4gICAqICAgICByZXF1ZXN0ID0gczMucHV0T2JqZWN0KHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfSk7XG4gICAqICAgICByZXF1ZXN0LnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7IGNvbnNvbGUubG9nKGVyciwgZGF0YSk7IH0pO1xuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHdpdGggbm8gY2FsbGJhY2sgKHVzaW5nIGV2ZW50IGhhbmRsZXJzKVxuICAgKiAgICAgcmVxdWVzdCA9IHMzLnB1dE9iamVjdCh7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J30pO1xuICAgKiAgICAgcmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihyZXNwb25zZSkgeyAuLi4gfSk7IC8vIHJlZ2lzdGVyIGEgY2FsbGJhY2tcbiAgICogICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24gc2VuZChjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgLy8gYXBwZW5kIHRvIHVzZXIgYWdlbnRcbiAgICAgIHRoaXMuaHR0cFJlcXVlc3QuYXBwZW5kVG9Vc2VyQWdlbnQoJ2NhbGxiYWNrJyk7XG4gICAgICB0aGlzLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChyZXNwKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwocmVzcCwgcmVzcC5lcnJvciwgcmVzcC5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJ1blRvKCk7XG5cbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZTtcbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIHByb21pc2UoKVxuICAgKiAgIFNlbmRzIHRoZSByZXF1ZXN0IGFuZCByZXR1cm5zIGEgJ3RoZW5hYmxlJyBwcm9taXNlLlxuICAgKlxuICAgKiAgIFR3byBjYWxsYmFja3MgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSBgdGhlbmAgbWV0aG9kIG9uIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICAgKiAgIFRoZSBmaXJzdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQsIGFuZCB0aGUgc2Vjb25kXG4gICAqICAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgQGNhbGxiYWNrIGZ1bGZpbGxlZENhbGxiYWNrIGZ1bmN0aW9uKGRhdGEpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICAgKiAgICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgIEBjYWxsYmFjayByZWplY3RlZENhbGxiYWNrIGZ1bmN0aW9uKGVycm9yKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVycm9yIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgIEByZXR1cm4gW1Byb21pc2VdIEEgcHJvbWlzZSB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSByZXF1ZXN0LlxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYSByZXF1ZXN0IHVzaW5nIHByb21pc2VzLlxuICAgKiAgICAgdmFyIHJlcXVlc3QgPSBzMy5wdXRPYmplY3Qoe0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9KTtcbiAgICogICAgIHZhciByZXN1bHQgPSByZXF1ZXN0LnByb21pc2UoKTtcbiAgICogICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKGRhdGEpIHsgLi4uIH0sIGZ1bmN0aW9uKGVycm9yKSB7IC4uLiB9KTtcbiAgICovXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucnVuVG8oJ3NlbmQnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcnVuVG86IGZ1bmN0aW9uIHJ1blRvKHN0YXRlLCBkb25lKSB7XG4gICAgdGhpcy5fYXNtLnJ1blRvKHN0YXRlLCBkb25lLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWJvcnRzIGEgcmVxdWVzdCwgZW1pdHRpbmcgdGhlIGVycm9yIGFuZCBjb21wbGV0ZSBldmVudHMuXG4gICAqXG4gICAqIEAhbWFjcm8gbm9icm93c2VyXG4gICAqIEBleGFtcGxlIEFib3J0aW5nIGEgcmVxdWVzdCBhZnRlciBzZW5kaW5nXG4gICAqICAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgIEJ1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsXG4gICAqICAgICBCb2R5OiBCdWZmZXIuYWxsb2MoMTAyNCAqIDEwMjQgKiA1KSAvLyA1TUIgcGF5bG9hZFxuICAgKiAgIH07XG4gICAqICAgdmFyIHJlcXVlc3QgPSBzMy5wdXRPYmplY3QocGFyYW1zKTtcbiAgICogICByZXF1ZXN0LnNlbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coXCJFcnJvcjpcIiwgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gYWJvcnQgcmVxdWVzdCBpbiAxIHNlY29uZFxuICAgKiAgIHNldFRpbWVvdXQocmVxdWVzdC5hYm9ydC5iaW5kKHJlcXVlc3QpLCAxMDAwKTtcbiAgICpcbiAgICogICAvLyBwcmludHMgXCJFcnJvcjogUmVxdWVzdEFib3J0ZWRFcnJvciBSZXF1ZXN0IGFib3J0ZWQgYnkgdXNlclwiXG4gICAqIEByZXR1cm4gW0FXUy5SZXF1ZXN0XSB0aGUgc2FtZSByZXF1ZXN0IG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ZhbGlkYXRlUmVzcG9uc2UnKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZXh0cmFjdEVycm9yJyk7XG4gICAgdGhpcy5vbigndmFsaWRhdGVSZXNwb25zZScsIGZ1bmN0aW9uIGFkZEFib3J0ZWRFcnJvcihyZXNwKSB7XG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQgYnkgdXNlcicpLCB7XG4gICAgICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaHR0cFJlcXVlc3Quc3RyZWFtICYmICF0aGlzLmh0dHBSZXF1ZXN0LnN0cmVhbS5kaWRDYWxsYmFjaykgeyAvLyBhYm9ydCBIVFRQIHN0cmVhbVxuICAgICAgdGhpcy5odHRwUmVxdWVzdC5zdHJlYW0uYWJvcnQoKTtcbiAgICAgIGlmICh0aGlzLmh0dHBSZXF1ZXN0Ll9hYm9ydENhbGxiYWNrKSB7XG4gICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0Ll9hYm9ydENhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnc2VuZCcpOyAvLyBoYXZlbid0IHNlbnQgeWV0LCBzbyBsZXQncyBub3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSXRlcmF0ZXMgb3ZlciBlYWNoIHBhZ2Ugb2YgcmVzdWx0cyBnaXZlbiBhIHBhZ2VhYmxlIHJlcXVlc3QsIGNhbGxpbmdcbiAgICogdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpdGggZWFjaCBwYWdlIG9mIGRhdGEuIEFmdGVyIGFsbCBwYWdlcyBoYXZlIGJlZW5cbiAgICogcmV0cmlldmVkLCB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggYG51bGxgIGRhdGEuXG4gICAqXG4gICAqIEBub3RlIFRoaXMgb3BlcmF0aW9uIGNhbiBnZW5lcmF0ZSBtdWx0aXBsZSByZXF1ZXN0cyB0byBhIHNlcnZpY2UuXG4gICAqIEBleGFtcGxlIEl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHBhZ2VzIG9mIG9iamVjdHMgaW4gYW4gUzMgYnVja2V0XG4gICAqICAgdmFyIHBhZ2VzID0gMTtcbiAgICogICBzMy5saXN0T2JqZWN0cygpLmVhY2hQYWdlKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgcmV0dXJuO1xuICAgKiAgICAgY29uc29sZS5sb2coXCJQYWdlXCIsIHBhZ2VzKyspO1xuICAgKiAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICAgfSk7XG4gICAqIEBleGFtcGxlIEl0ZXJhdGluZyBvdmVyIG11bHRpcGxlIHBhZ2VzIHdpdGggYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrXG4gICAqICAgczMubGlzdE9iamVjdHMocGFyYW1zKS5lYWNoUGFnZShmdW5jdGlvbihlcnIsIGRhdGEsIGRvbmUpIHtcbiAgICogICAgIGRvU29tZXRoaW5nQXN5bmNBbmRPckV4cGVuc2l2ZShmdW5jdGlvbigpIHtcbiAgICogICAgICAgLy8gVGhlIG5leHQgcGFnZSBvZiByZXN1bHRzIGlzbid0IGZldGNoZWQgdW50aWwgZG9uZSBpcyBjYWxsZWRcbiAgICogICAgICAgZG9uZSgpO1xuICAgKiAgICAgfSk7XG4gICAqICAgfSk7XG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEsIFtkb25lQ2FsbGJhY2tdKVxuICAgKiAgIENhbGxlZCB3aXRoIGVhY2ggcGFnZSBvZiByZXN1bHRpbmcgZGF0YSBmcm9tIHRoZSByZXF1ZXN0LiBJZiB0aGVcbiAgICogICBvcHRpb25hbCBgZG9uZUNhbGxiYWNrYCBpcyBwcm92aWRlZCBpbiB0aGUgZnVuY3Rpb24sIGl0IG11c3QgYmUgY2FsbGVkXG4gICAqICAgd2hlbiB0aGUgY2FsbGJhY2sgaXMgY29tcGxldGUuXG4gICAqXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9iamVjdCwgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gYSBzaW5nbGUgcGFnZSBvZiByZXNwb25zZSBkYXRhLiBJZiB0aGVyZSBpcyBub1xuICAgKiAgICAgbW9yZSBkYXRhLCB0aGlzIG9iamVjdCB3aWxsIGJlIGBudWxsYC5cbiAgICogICBAcGFyYW0gZG9uZUNhbGxiYWNrIFtGdW5jdGlvbl0gYW4gb3B0aW9uYWwgZG9uZSBjYWxsYmFjay4gSWYgdGhpc1xuICAgKiAgICAgYXJndW1lbnQgaXMgZGVmaW5lZCBpbiB0aGUgZnVuY3Rpb24gZGVjbGFyYXRpb24sIGl0IHNob3VsZCBiZSBjYWxsZWRcbiAgICogICAgIHdoZW4gdGhlIG5leHQgcGFnZSBpcyByZWFkeSB0byBiZSByZXRyaWV2ZWQuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgKiAgICAgY29udHJvbGxpbmcgc2VyaWFsIHBhZ2luYXRpb24gYWNyb3NzIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zLlxuICAgKiAgIEByZXR1cm4gW0Jvb2xlYW5dIGlmIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHBhZ2luYXRpb24gd2lsbFxuICAgKiAgICAgc3RvcC5cbiAgICpcbiAgICogQHNlZSBBV1MuUmVxdWVzdC5lYWNoSXRlbVxuICAgKiBAc2VlIEFXUy5SZXNwb25zZS5uZXh0UGFnZVxuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBlYWNoUGFnZTogZnVuY3Rpb24gZWFjaFBhZ2UoY2FsbGJhY2spIHtcbiAgICAvLyBNYWtlIGFsbCBjYWxsYmFja3MgYXN5bmMtaXNoXG4gICAgY2FsbGJhY2sgPSBBV1MudXRpbC5mbi5tYWtlQXN5bmMoY2FsbGJhY2ssIDMpO1xuXG4gICAgZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKHJlc3BvbnNlKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHJlc3BvbnNlLCByZXNwb25zZS5lcnJvciwgcmVzcG9uc2UuZGF0YSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgcmVzcG9uc2UubmV4dFBhZ2UoKS5vbignY29tcGxldGUnLCB3cmFwcGVkQ2FsbGJhY2spLnNlbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHJlc3BvbnNlLCBudWxsLCBudWxsLCBBV1MudXRpbC5mbi5ub29wKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5vbignY29tcGxldGUnLCB3cmFwcGVkQ2FsbGJhY2spLnNlbmQoKTtcbiAgfSxcblxuICAvKipcbiAgICogRW51bWVyYXRlcyBvdmVyIGluZGl2aWR1YWwgaXRlbXMgb2YgYSByZXF1ZXN0LCBwYWdpbmcgdGhlIHJlc3BvbnNlcyBpZlxuICAgKiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBhcGkgZXhwZXJpbWVudGFsXG4gICAqIEBzaW5jZSB2MS40LjBcbiAgICovXG4gIGVhY2hJdGVtOiBmdW5jdGlvbiBlYWNoSXRlbShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2soZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG5cbiAgICAgIHZhciBjb25maWcgPSBzZWxmLnNlcnZpY2UucGFnaW5hdGlvbkNvbmZpZyhzZWxmLm9wZXJhdGlvbik7XG4gICAgICB2YXIgcmVzdWx0S2V5ID0gY29uZmlnLnJlc3VsdEtleTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdEtleSkpIHJlc3VsdEtleSA9IHJlc3VsdEtleVswXTtcbiAgICAgIHZhciBpdGVtcyA9IGptZXNwYXRoLnNlYXJjaChkYXRhLCByZXN1bHRLZXkpO1xuICAgICAgdmFyIGNvbnRpbnVlSXRlcmF0aW9uID0gdHJ1ZTtcbiAgICAgIEFXUy51dGlsLmFycmF5RWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBjb250aW51ZUl0ZXJhdGlvbiA9IGNhbGxiYWNrKG51bGwsIGl0ZW0pO1xuICAgICAgICBpZiAoY29udGludWVJdGVyYXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIEFXUy51dGlsLmFib3J0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb250aW51ZUl0ZXJhdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLmVhY2hQYWdlKHdyYXBwZWRDYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBjYW4gcmV0dXJuIG11bHRpcGxlIHBhZ2VzIG9mXG4gICAqICAgcmVzcG9uc2UgZGF0YS5cbiAgICogQHNlZSBBV1MuUmVzcG9uc2UuZWFjaFBhZ2VcbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgaXNQYWdlYWJsZTogZnVuY3Rpb24gaXNQYWdlYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLnBhZ2luYXRpb25Db25maWcodGhpcy5vcGVyYXRpb24pID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kcyB0aGUgcmVxdWVzdCBhbmQgY29udmVydHMgdGhlIHJlcXVlc3Qgb2JqZWN0IGludG8gYSByZWFkYWJsZSBzdHJlYW1cbiAgICogdGhhdCBjYW4gYmUgcmVhZCBmcm9tIG9yIHBpcGVkIGludG8gYSB3cml0YWJsZSBzdHJlYW0uXG4gICAqXG4gICAqIEBub3RlIFRoZSBkYXRhIHJlYWQgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSBjb250YWlucyBvbmx5XG4gICAqICAgdGhlIHJhdyBIVFRQIGJvZHkgY29udGVudHMuXG4gICAqIEBleGFtcGxlIE1hbnVhbGx5IHJlYWRpbmcgZnJvbSBhIHN0cmVhbVxuICAgKiAgIHJlcXVlc3QuY3JlYXRlUmVhZFN0cmVhbSgpLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xuICAgKiAgICAgY29uc29sZS5sb2coXCJHb3QgZGF0YTpcIiwgZGF0YS50b1N0cmluZygpKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgUGlwaW5nIGEgcmVxdWVzdCBib2R5IGludG8gYSBmaWxlXG4gICAqICAgdmFyIG91dCA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKCcvcGF0aC90by9vdXRmaWxlLmpwZycpO1xuICAgKiAgIHMzLnNlcnZpY2UuZ2V0T2JqZWN0KHBhcmFtcykuY3JlYXRlUmVhZFN0cmVhbSgpLnBpcGUob3V0KTtcbiAgICogQHJldHVybiBbU3RyZWFtXSB0aGUgcmVhZGFibGUgc3RyZWFtIG9iamVjdCB0aGF0IGNhbiBiZSBwaXBlZFxuICAgKiAgIG9yIHJlYWQgZnJvbSAoYnkgcmVnaXN0ZXJpbmcgJ2RhdGEnIGV2ZW50IGxpc3RlbmVycykuXG4gICAqIEAhbWFjcm8gbm9icm93c2VyXG4gICAqL1xuICBjcmVhdGVSZWFkU3RyZWFtOiBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtKCkge1xuICAgIHZhciBzdHJlYW1zID0gQVdTLnV0aWwuc3RyZWFtO1xuICAgIHZhciByZXEgPSB0aGlzO1xuICAgIHZhciBzdHJlYW0gPSBudWxsO1xuXG4gICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7XG4gICAgICBzdHJlYW0gPSBuZXcgc3RyZWFtcy5QYXNzVGhyb3VnaCgpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgcmVxLnNlbmQoKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbSA9IG5ldyBzdHJlYW1zLlN0cmVhbSgpO1xuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcblxuICAgICAgc3RyZWFtLnNlbnQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIXN0cmVhbS5zZW50ICYmIGV2ZW50ID09PSAnZGF0YScpIHtcbiAgICAgICAgICBzdHJlYW0uc2VudCA9IHRydWU7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsgcmVxLnNlbmQoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vbignaHR0cEhlYWRlcnMnLCBmdW5jdGlvbiBzdHJlYW1IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3ApIHtcbiAgICAgIGlmIChzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignaHR0cERhdGEnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5IVFRQX0RBVEEpO1xuICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2h0dHBFcnJvcicsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkhUVFBfRVJST1IpO1xuICAgICAgICByZXEub24oJ2h0dHBFcnJvcicsIGZ1bmN0aW9uIHN0cmVhbUh0dHBFcnJvcihlcnJvcikge1xuICAgICAgICAgIHJlc3AuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICByZXNwLmVycm9yLnJldHJ5YWJsZSA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoID0gZmFsc2U7XG4gICAgICAgIHZhciBleHBlY3RlZExlbjtcbiAgICAgICAgaWYgKHJlcS5odHRwUmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJykge1xuICAgICAgICAgIGV4cGVjdGVkTGVuID0gcGFyc2VJbnQoaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZExlbiAhPT0gdW5kZWZpbmVkICYmICFpc05hTihleHBlY3RlZExlbikgJiYgZXhwZWN0ZWRMZW4gPj0gMCkge1xuICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IHRydWU7XG4gICAgICAgICAgdmFyIHJlY2VpdmVkTGVuID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGVja0NvbnRlbnRMZW5ndGhBbmRFbWl0ID0gZnVuY3Rpb24gY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCgpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQ2hlY2tDb250ZW50TGVuZ3RoICYmIHJlY2VpdmVkTGVuICE9PSBleHBlY3RlZExlbikge1xuICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgQVdTLnV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcignU3RyZWFtIGNvbnRlbnQgbGVuZ3RoIG1pc21hdGNoLiBSZWNlaXZlZCAnICtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbiArICcgb2YgJyArIGV4cGVjdGVkTGVuICsgJyBieXRlcy4nKSxcbiAgICAgICAgICAgICAgeyBjb2RlOiAnU3RyZWFtQ29udGVudExlbmd0aE1pc21hdGNoJyB9XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGh0dHBTdHJlYW0gPSByZXNwLmh0dHBSZXNwb25zZS5jcmVhdGVVbmJ1ZmZlcmVkU3RyZWFtKCk7XG5cbiAgICAgICAgaWYgKEFXUy5IdHRwQ2xpZW50LnN0cmVhbXNBcGlWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgaWYgKHNob3VsZENoZWNrQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aEFjY3VtdWxhdG9yID0gbmV3IHN0cmVhbXMuUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgIGxlbmd0aEFjY3VtdWxhdG9yLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgICAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbXMuUGFzc1Rocm91Z2gucHJvdG90eXBlLl93cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3Iub24oJ2VuZCcsIGNoZWNrQ29udGVudExlbmd0aEFuZEVtaXQpO1xuICAgICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBzaG91bGRDaGVja0NvbnRlbnRMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgICAgICAgaHR0cFN0cmVhbS51bnBpcGUobGVuZ3RoQWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICBsZW5ndGhBY2N1bXVsYXRvci5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgICAgbGVuZ3RoQWNjdW11bGF0b3IuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGh0dHBTdHJlYW0ucGlwZShsZW5ndGhBY2N1bXVsYXRvcikucGlwZShzdHJlYW0sIHsgZW5kOiBmYWxzZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKHNob3VsZENoZWNrQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgaHR0cFN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICBpZiAoYXJnICYmIGFyZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbiArPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodHRwU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGFyZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaHR0cFN0cmVhbS5vbignZW5kJywgY2hlY2tDb250ZW50TGVuZ3RoQW5kRW1pdCk7XG4gICAgICAgIH1cblxuICAgICAgICBodHRwU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHNob3VsZENoZWNrQ29udGVudExlbmd0aCA9IGZhbHNlO1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIFtBcnJheSxSZXNwb25zZV0gYXJncyBUaGlzIHNob3VsZCBiZSB0aGUgcmVzcG9uc2Ugb2JqZWN0LFxuICAgKiAgIG9yIGFuIGFycmF5IG9mIGFyZ3MgdG8gc2VuZCB0byB0aGUgZXZlbnQuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZW1pdEV2ZW50OiBmdW5jdGlvbiBlbWl0KGV2ZW50TmFtZSwgYXJncywgZG9uZSkge1xuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ2Z1bmN0aW9uJykgeyBkb25lID0gYXJnczsgYXJncyA9IG51bGw7IH1cbiAgICBpZiAoIWRvbmUpIGRvbmUgPSBmdW5jdGlvbigpIHsgfTtcbiAgICBpZiAoIWFyZ3MpIGFyZ3MgPSB0aGlzLmV2ZW50UGFyYW1ldGVycyhldmVudE5hbWUsIHRoaXMucmVzcG9uc2UpO1xuXG4gICAgdmFyIG9yaWdFbWl0ID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUuZW1pdDtcbiAgICBvcmlnRW1pdC5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgYXJncywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgdGhpcy5yZXNwb25zZS5lcnJvciA9IGVycjtcbiAgICAgIGRvbmUuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV2ZW50UGFyYW1ldGVyczogZnVuY3Rpb24gZXZlbnRQYXJhbWV0ZXJzKGV2ZW50TmFtZSkge1xuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICBjYXNlICdyZXN0YXJ0JzpcbiAgICAgIGNhc2UgJ3ZhbGlkYXRlJzpcbiAgICAgIGNhc2UgJ3NpZ24nOlxuICAgICAgY2FzZSAnYnVpbGQnOlxuICAgICAgY2FzZSAnYWZ0ZXJWYWxpZGF0ZSc6XG4gICAgICBjYXNlICdhZnRlckJ1aWxkJzpcbiAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgcmV0dXJuIFt0aGlzLnJlc3BvbnNlLmVycm9yLCB0aGlzLnJlc3BvbnNlXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbdGhpcy5yZXNwb25zZV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHByZXNpZ246IGZ1bmN0aW9uIHByZXNpZ24oZXhwaXJlcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBleHBpcmVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGV4cGlyZXM7XG4gICAgICBleHBpcmVzID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBV1MuU2lnbmVycy5QcmVzaWduKCkuc2lnbih0aGlzLnRvR2V0KCksIGV4cGlyZXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc1ByZXNpZ25lZDogZnVuY3Rpb24gaXNQcmVzaWduZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmh0dHBSZXF1ZXN0LmhlYWRlcnMsICdwcmVzaWduZWQtZXhwaXJlcycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvVW5hdXRoZW50aWNhdGVkOiBmdW5jdGlvbiB0b1VuYXV0aGVudGljYXRlZCgpIHtcbiAgICB0aGlzLl91bkF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuVkFMSURBVEVfQ1JFREVOVElBTFMpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3NpZ24nLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5TSUdOKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b0dldDogZnVuY3Rpb24gdG9HZXQoKSB7XG4gICAgaWYgKHRoaXMuc2VydmljZS5hcGkucHJvdG9jb2wgPT09ICdxdWVyeScgfHxcbiAgICAgICAgdGhpcy5zZXJ2aWNlLmFwaS5wcm90b2NvbCA9PT0gJ2VjMicpIHtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5idWlsZEFzR2V0KTtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5idWlsZEFzR2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYnVpbGRBc0dldDogZnVuY3Rpb24gYnVpbGRBc0dldChyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5tZXRob2QgPSAnR0VUJztcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnBhdGggPSByZXF1ZXN0LnNlcnZpY2UuZW5kcG9pbnQucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJz8nICsgcmVxdWVzdC5odHRwUmVxdWVzdC5ib2R5O1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuYm9keSA9ICcnO1xuXG4gICAgLy8gZG9uJ3QgbmVlZCB0aGVzZSBoZWFkZXJzIG9uIGEgR0VUIHJlcXVlc3RcbiAgICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhhbHRIYW5kbGVyc09uRXJyb3I6IGZ1bmN0aW9uIGhhbHRIYW5kbGVyc09uRXJyb3IoKSB7XG4gICAgdGhpcy5faGFsdEhhbmRsZXJzT25FcnJvciA9IHRydWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVxdWVzdC5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2UoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGFwcGVuZCB0byB1c2VyIGFnZW50XG4gICAgdGhpcy5odHRwUmVxdWVzdC5hcHBlbmRUb1VzZXJBZ2VudCgncHJvbWlzZScpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZURlcGVuZGVuY3koZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBzZWxmLm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocmVzcC5lcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmaW5lICRyZXNwb25zZSBwcm9wZXJ0eSBzbyB0aGF0IGl0IGlzIG5vdCBlbnVtZXJhYmxlXG4gICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBjaXJjdWxhciByZWZlcmVuY2UgZXJyb3JzIHdoZW4gc3RyaW5naWZ5aW5nIHRoZSBKU09OIG9iamVjdFxuICAgICAgICAgIHJlc29sdmUoT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgcmVzcC5kYXRhIHx8IHt9LFxuICAgICAgICAgICAgJyRyZXNwb25zZScsXG4gICAgICAgICAgICB7dmFsdWU6IHJlc3B9XG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2VsZi5ydW5UbygpO1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlJlcXVlc3QuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuUmVxdWVzdCk7XG5cbkFXUy51dGlsLm1peGluKEFXUy5SZXF1ZXN0LCBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTItMjAxMyBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuIFlvdVxuICogbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIEEgY29weSBvZlxuICogdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICpcbiAqICAgICBodHRwOi8vYXdzLmFtYXpvbi5jb20vYXBhY2hlMi4wL1xuICpcbiAqIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpc1xuICogZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRlxuICogQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljXG4gKiBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBqbWVzcGF0aCA9IHJlcXVpcmUoJ2ptZXNwYXRoJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIENIRUNLX0FDQ0VQVE9SUyhyZXNwKSB7XG4gIHZhciB3YWl0ZXIgPSByZXNwLnJlcXVlc3QuX3dhaXRlcjtcbiAgdmFyIGFjY2VwdG9ycyA9IHdhaXRlci5jb25maWcuYWNjZXB0b3JzO1xuICB2YXIgYWNjZXB0b3JNYXRjaGVkID0gZmFsc2U7XG4gIHZhciBzdGF0ZSA9ICdyZXRyeSc7XG5cbiAgYWNjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24oYWNjZXB0b3IpIHtcbiAgICBpZiAoIWFjY2VwdG9yTWF0Y2hlZCkge1xuICAgICAgdmFyIG1hdGNoZXIgPSB3YWl0ZXIubWF0Y2hlcnNbYWNjZXB0b3IubWF0Y2hlcl07XG4gICAgICBpZiAobWF0Y2hlciAmJiBtYXRjaGVyKHJlc3AsIGFjY2VwdG9yLmV4cGVjdGVkLCBhY2NlcHRvci5hcmd1bWVudCkpIHtcbiAgICAgICAgYWNjZXB0b3JNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUgPSBhY2NlcHRvci5zdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmICghYWNjZXB0b3JNYXRjaGVkICYmIHJlc3AuZXJyb3IpIHN0YXRlID0gJ2ZhaWx1cmUnO1xuXG4gIGlmIChzdGF0ZSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgd2FpdGVyLnNldFN1Y2Nlc3MocmVzcCk7XG4gIH0gZWxzZSB7XG4gICAgd2FpdGVyLnNldEVycm9yKHJlc3AsIHN0YXRlID09PSAncmV0cnknKTtcbiAgfVxufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuUmVzb3VyY2VXYWl0ZXIgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIGdpdmVuIHN0YXRlIG9uIGEgc2VydmljZSBvYmplY3RcbiAgICogQHBhcmFtIHNlcnZpY2UgW1NlcnZpY2VdIHRoZSBzZXJ2aWNlIG9iamVjdCB0byB3YWl0IG9uXG4gICAqIEBwYXJhbSBzdGF0ZSBbU3RyaW5nXSB0aGUgc3RhdGUgKGRlZmluZWQgaW4gd2FpdGVyIGNvbmZpZ3VyYXRpb24pIHRvIHdhaXRcbiAgICogICBmb3IuXG4gICAqIEBleGFtcGxlIENyZWF0ZSBhIHdhaXRlciBmb3IgcnVubmluZyBFQzIgaW5zdGFuY2VzXG4gICAqICAgdmFyIGVjMiA9IG5ldyBBV1MuRUMyO1xuICAgKiAgIHZhciB3YWl0ZXIgPSBuZXcgQVdTLlJlc291cmNlV2FpdGVyKGVjMiwgJ2luc3RhbmNlUnVubmluZycpO1xuICAgKi9cbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHN0YXRlKSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5sb2FkV2FpdGVyQ29uZmlnKHRoaXMuc3RhdGUpO1xuICB9LFxuXG4gIHNlcnZpY2U6IG51bGwsXG5cbiAgc3RhdGU6IG51bGwsXG5cbiAgY29uZmlnOiBudWxsLFxuXG4gIG1hdGNoZXJzOiB7XG4gICAgcGF0aDogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHQsZXhwZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBwYXRoQWxsOiBmdW5jdGlvbihyZXNwLCBleHBlY3RlZCwgYXJndW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gam1lc3BhdGguc2VhcmNoKHJlc3AuZGF0YSwgYXJndW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSByZXN1bHRzID0gW3Jlc3VsdHNdO1xuICAgICAgdmFyIG51bVJlc3VsdHMgPSByZXN1bHRzLmxlbmd0aDtcbiAgICAgIGlmICghbnVtUmVzdWx0cykgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaW5kID0gMCA7IGluZCA8IG51bVJlc3VsdHM7IGluZCsrKSB7XG4gICAgICAgIGlmICgham1lc3BhdGguc3RyaWN0RGVlcEVxdWFsKHJlc3VsdHNbaW5kXSwgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcGF0aEFueTogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQsIGFyZ3VtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IGptZXNwYXRoLnNlYXJjaChyZXNwLmRhdGEsIGFyZ3VtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHRzKSkgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICAgIHZhciBudW1SZXN1bHRzID0gcmVzdWx0cy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpbmQgPSAwIDsgaW5kIDwgbnVtUmVzdWx0czsgaW5kKyspIHtcbiAgICAgICAgaWYgKGptZXNwYXRoLnN0cmljdERlZXBFcXVhbChyZXN1bHRzW2luZF0sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHN0YXR1czogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcC5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIHJldHVybiAodHlwZW9mIHN0YXR1c0NvZGUgPT09ICdudW1iZXInKSAmJiAoc3RhdHVzQ29kZSA9PT0gZXhwZWN0ZWQpO1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24ocmVzcCwgZXhwZWN0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHJlc3AuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSByZXNwLmVycm9yLmNvZGU7XG4gICAgICB9XG4gICAgICAvLyBpZiBleHBlY3RlZCBpcyBub3Qgc3RyaW5nLCBjYW4gYmUgYm9vbGVhbiBpbmRpY2F0aW5nIHByZXNlbmNlIG9mIGVycm9yXG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09ICEhcmVzcC5lcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiBuZXcgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcigpLmFkZE5hbWVkTGlzdGVuZXJzKGZ1bmN0aW9uKGFkZCkge1xuICAgIGFkZCgnUkVUUllfQ0hFQ0snLCAncmV0cnknLCBmdW5jdGlvbihyZXNwKSB7XG4gICAgICB2YXIgd2FpdGVyID0gcmVzcC5yZXF1ZXN0Ll93YWl0ZXI7XG4gICAgICBpZiAocmVzcC5lcnJvciAmJiByZXNwLmVycm9yLmNvZGUgPT09ICdSZXNvdXJjZU5vdFJlYWR5Jykge1xuICAgICAgICByZXNwLmVycm9yLnJldHJ5RGVsYXkgPSAod2FpdGVyLmNvbmZpZy5kZWxheSB8fCAwKSAqIDEwMDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGQoJ0NIRUNLX09VVFBVVCcsICdleHRyYWN0RGF0YScsIENIRUNLX0FDQ0VQVE9SUyk7XG5cbiAgICBhZGQoJ0NIRUNLX0VSUk9SJywgJ2V4dHJhY3RFcnJvcicsIENIRUNLX0FDQ0VQVE9SUyk7XG4gIH0pLFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIFtBV1MuUmVxdWVzdF1cbiAgICovXG4gIHdhaXQ6IGZ1bmN0aW9uIHdhaXQocGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtczsgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLiR3YWl0ZXIpIHtcbiAgICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLiR3YWl0ZXIuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGF5ID0gcGFyYW1zLiR3YWl0ZXIuZGVsYXk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy4kd2FpdGVyLm1heEF0dGVtcHRzID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhBdHRlbXB0cyA9IHBhcmFtcy4kd2FpdGVyLm1heEF0dGVtcHRzO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHBhcmFtcy4kd2FpdGVyO1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KHRoaXMuY29uZmlnLm9wZXJhdGlvbiwgcGFyYW1zKTtcbiAgICByZXF1ZXN0Ll93YWl0ZXIgPSB0aGlzO1xuICAgIHJlcXVlc3QucmVzcG9uc2UubWF4UmV0cmllcyA9IHRoaXMuY29uZmlnLm1heEF0dGVtcHRzO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXJzKHRoaXMubGlzdGVuZXJzKTtcblxuICAgIGlmIChjYWxsYmFjaykgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICBzZXRTdWNjZXNzOiBmdW5jdGlvbiBzZXRTdWNjZXNzKHJlc3ApIHtcbiAgICByZXNwLmVycm9yID0gbnVsbDtcbiAgICByZXNwLmRhdGEgPSByZXNwLmRhdGEgfHwge307XG4gICAgcmVzcC5yZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygnZXh0cmFjdERhdGEnKTtcbiAgfSxcblxuICBzZXRFcnJvcjogZnVuY3Rpb24gc2V0RXJyb3IocmVzcCwgcmV0cnlhYmxlKSB7XG4gICAgcmVzcC5kYXRhID0gbnVsbDtcbiAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IocmVzcC5lcnJvciB8fCBuZXcgRXJyb3IoKSwge1xuICAgICAgY29kZTogJ1Jlc291cmNlTm90UmVhZHknLFxuICAgICAgbWVzc2FnZTogJ1Jlc291cmNlIGlzIG5vdCBpbiB0aGUgc3RhdGUgJyArIHRoaXMuc3RhdGUsXG4gICAgICByZXRyeWFibGU6IHJldHJ5YWJsZVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb2FkcyB3YWl0ZXIgY29uZmlndXJhdGlvbiBmcm9tIEFQSSBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbG9hZFdhaXRlckNvbmZpZzogZnVuY3Rpb24gbG9hZFdhaXRlckNvbmZpZyhzdGF0ZSkge1xuICAgIGlmICghdGhpcy5zZXJ2aWNlLmFwaS53YWl0ZXJzW3N0YXRlXSkge1xuICAgICAgdGhyb3cgbmV3IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdTdGF0ZU5vdEZvdW5kRXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnU3RhdGUgJyArIHN0YXRlICsgJyBub3QgZm91bmQuJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25maWcgPSBBV1MudXRpbC5jb3B5KHRoaXMuc2VydmljZS5hcGkud2FpdGVyc1tzdGF0ZV0pO1xuICB9XG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcbnZhciBqbWVzcGF0aCA9IHJlcXVpcmUoJ2ptZXNwYXRoJyk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIHJlc3BvbnNlIGluZm9ybWF0aW9uXG4gKiBmcm9tIGEgc2VydmljZSByZXF1ZXN0IG9wZXJhdGlvbiBzZW50IHRocm91Z2gge0FXUy5SZXF1ZXN0fS5cbiAqIFRoZSByZXNwb25zZSBvYmplY3QgaGFzIHR3byBtYWluIHByb3BlcnRpZXMgZm9yIGdldHRpbmcgaW5mb3JtYXRpb25cbiAqIGJhY2sgZnJvbSBhIHJlcXVlc3Q6XG4gKlxuICogIyMgVGhlIGBkYXRhYCBwcm9wZXJ0eVxuICpcbiAqIFRoZSBgcmVzcG9uc2UuZGF0YWAgcHJvcGVydHkgY29udGFpbnMgdGhlIHNlcmlhbGl6ZWQgb2JqZWN0IGRhdGFcbiAqIHJldHJpZXZlZCBmcm9tIHRoZSBzZXJ2aWNlIHJlcXVlc3QuIEZvciBpbnN0YW5jZSwgZm9yIGFuXG4gKiBBbWF6b24gRHluYW1vREIgYGxpc3RUYWJsZXNgIG1ldGhvZCBjYWxsLCB0aGUgcmVzcG9uc2UgZGF0YSBtaWdodFxuICogbG9vayBsaWtlOlxuICpcbiAqIGBgYFxuICogPiByZXNwLmRhdGFcbiAqIHsgVGFibGVOYW1lczpcbiAqICAgIFsgJ3RhYmxlMScsICd0YWJsZTInLCAuLi4gXSB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgYGRhdGFgIHByb3BlcnR5IGNhbiBiZSBudWxsIGlmIGFuIGVycm9yIG9jY3VycyAoc2VlIGJlbG93KS5cbiAqXG4gKiAjIyBUaGUgYGVycm9yYCBwcm9wZXJ0eVxuICpcbiAqIEluIHRoZSBldmVudCBvZiBhIHNlcnZpY2UgZXJyb3IgKG9yIHRyYW5zZmVyIGVycm9yKSwgdGhlXG4gKiBgcmVzcG9uc2UuZXJyb3JgIHByb3BlcnR5IHdpbGwgYmUgZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBlcnJvciBkYXRhIGluIHRoZSBmb3JtOlxuICpcbiAqIGBgYFxuICogeyBjb2RlOiAnU0hPUlRfVU5JUVVFX0VSUk9SX0NPREUnLFxuICogICBtZXNzYWdlOiAnU29tZSBodW1hbiByZWFkYWJsZSBlcnJvciBtZXNzYWdlJyB9XG4gKiBgYGBcbiAqXG4gKiBJbiB0aGUgY2FzZSBvZiBhbiBlcnJvciwgdGhlIGBkYXRhYCBwcm9wZXJ0eSB3aWxsIGJlIGBudWxsYC5cbiAqIE5vdGUgdGhhdCBpZiB5b3UgaGFuZGxlIGV2ZW50cyB0aGF0IGNhbiBiZSBpbiBhIGZhaWx1cmUgc3RhdGUsXG4gKiB5b3Ugc2hvdWxkIGFsd2F5cyBjaGVjayB3aGV0aGVyIGByZXNwb25zZS5lcnJvcmAgaXMgc2V0XG4gKiBiZWZvcmUgYXR0ZW1wdGluZyB0byBhY2Nlc3MgdGhlIGByZXNwb25zZS5kYXRhYCBwcm9wZXJ0eS5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBkYXRhXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIERhdGEgUHJvcGVydGllc1xuICogICBAbm90ZSBJbnNpZGUgb2YgYSB7QVdTLlJlcXVlc3R+aHR0cERhdGF9IGV2ZW50LCB0aGlzXG4gKiAgICAgcHJvcGVydHkgY29udGFpbnMgYSBzaW5nbGUgcmF3IHBhY2tldCBpbnN0ZWFkIG9mIHRoZVxuICogICAgIGZ1bGwgZGUtc2VyaWFsaXplZCBzZXJ2aWNlIHJlc3BvbnNlLlxuICogICBAcmV0dXJuIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIHJlc3BvbnNlIGRhdGFcbiAqICAgICBmcm9tIHRoZSBzZXJ2aWNlLlxuICpcbiAqIEAhYXR0cmlidXRlIGVycm9yXG4gKiAgIEFuIHN0cnVjdHVyZSBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGEgc2VydmljZVxuICogICBvciBuZXR3b3JraW5nIGVycm9yLlxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBEYXRhIFByb3BlcnRpZXNcbiAqICAgQG5vdGUgVGhpcyBhdHRyaWJ1dGUgaXMgb25seSBmaWxsZWQgaWYgYSBzZXJ2aWNlIG9yXG4gKiAgICAgbmV0d29ya2luZyBlcnJvciBvY2N1cnMuXG4gKiAgIEByZXR1cm4gW0Vycm9yXVxuICogICAgICogY29kZSBbU3RyaW5nXSBhIHVuaXF1ZSBzaG9ydCBjb2RlIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICAgIGVycm9yIHRoYXQgd2FzIGVtaXR0ZWQuXG4gKiAgICAgKiBtZXNzYWdlIFtTdHJpbmddIGEgbG9uZ2VyIGh1bWFuIHJlYWRhYmxlIGVycm9yIG1lc3NhZ2VcbiAqICAgICAqIHJldHJ5YWJsZSBbQm9vbGVhbl0gd2hldGhlciB0aGUgZXJyb3IgbWVzc2FnZSBpc1xuICogICAgICAgcmV0cnlhYmxlLlxuICogICAgICogc3RhdHVzQ29kZSBbTnVtZXJpY10gaW4gdGhlIGNhc2Ugb2YgYSByZXF1ZXN0IHRoYXQgcmVhY2hlZCB0aGUgc2VydmljZSxcbiAqICAgICAgIHRoaXMgdmFsdWUgY29udGFpbnMgdGhlIHJlc3BvbnNlIHN0YXR1cyBjb2RlLlxuICogICAgICogdGltZSBbRGF0ZV0gdGhlIGRhdGUgdGltZSBvYmplY3Qgd2hlbiB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKiAgICAgKiBob3N0bmFtZSBbU3RyaW5nXSBzZXQgd2hlbiBhIG5ldHdvcmtpbmcgZXJyb3Igb2NjdXJzIHRvIGVhc2lseVxuICogICAgICAgaWRlbnRpZnkgdGhlIGVuZHBvaW50IG9mIHRoZSByZXF1ZXN0LlxuICogICAgICogcmVnaW9uIFtTdHJpbmddIHNldCB3aGVuIGEgbmV0d29ya2luZyBlcnJvciBvY2N1cnMgdG8gZWFzaWx5XG4gKiAgICAgICBpZGVudGlmeSB0aGUgcmVnaW9uIG9mIHRoZSByZXF1ZXN0LlxuICpcbiAqIEAhYXR0cmlidXRlIHJlcXVlc3RJZFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBEYXRhIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbU3RyaW5nXSB0aGUgdW5pcXVlIHJlcXVlc3QgSUQgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXNwb25zZS5cbiAqICAgICBMb2cgdGhpcyB2YWx1ZSB3aGVuIGRlYnVnZ2luZyByZXF1ZXN0cyBmb3IgQVdTIHN1cHBvcnQuXG4gKlxuICogQCFhdHRyaWJ1dGUgcmV0cnlDb3VudFxuICogICBAcmVhZG9ubHlcbiAqICAgQCFncm91cCBPcGVyYXRpb24gUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtJbnRlZ2VyXSB0aGUgbnVtYmVyIG9mIHJldHJpZXMgdGhhdCB3ZXJlXG4gKiAgICAgYXR0ZW1wdGVkIGJlZm9yZSB0aGUgcmVxdWVzdCB3YXMgY29tcGxldGVkLlxuICpcbiAqIEAhYXR0cmlidXRlIHJlZGlyZWN0Q291bnRcbiAqICAgQHJlYWRvbmx5XG4gKiAgIEAhZ3JvdXAgT3BlcmF0aW9uIFByb3BlcnRpZXNcbiAqICAgQHJldHVybiBbSW50ZWdlcl0gdGhlIG51bWJlciBvZiByZWRpcmVjdHMgdGhhdCB3ZXJlXG4gKiAgICAgZm9sbG93ZWQgYmVmb3JlIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQuXG4gKlxuICogQCFhdHRyaWJ1dGUgaHR0cFJlc3BvbnNlXG4gKiAgIEByZWFkb25seVxuICogICBAIWdyb3VwIEhUVFAgUHJvcGVydGllc1xuICogICBAcmV0dXJuIFtBV1MuSHR0cFJlc3BvbnNlXSB0aGUgcmF3IEhUVFAgcmVzcG9uc2Ugb2JqZWN0XG4gKiAgICAgY29udGFpbmluZyB0aGUgcmVzcG9uc2UgaGVhZGVycyBhbmQgYm9keSBpbmZvcm1hdGlvblxuICogICAgIGZyb20gdGhlIHNlcnZlci5cbiAqXG4gKiBAc2VlIEFXUy5SZXF1ZXN0XG4gKi9cbkFXUy5SZXNwb25zZSA9IGluaGVyaXQoe1xuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBSZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIHRoaXMucmV0cnlDb3VudCA9IDA7XG4gICAgdGhpcy5yZWRpcmVjdENvdW50ID0gMDtcbiAgICB0aGlzLmh0dHBSZXNwb25zZSA9IG5ldyBBV1MuSHR0cFJlc3BvbnNlKCk7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHRoaXMubWF4UmV0cmllcyA9IHJlcXVlc3Quc2VydmljZS5udW1SZXRyaWVzKCk7XG4gICAgICB0aGlzLm1heFJlZGlyZWN0cyA9IHJlcXVlc3Quc2VydmljZS5jb25maWcubWF4UmVkaXJlY3RzO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByZXF1ZXN0IGZvciB0aGUgbmV4dCBwYWdlIG9mIHJlc3BvbnNlIGRhdGEsIGNhbGxpbmcgdGhlXG4gICAqIGNhbGxiYWNrIHdpdGggdGhlIHBhZ2UgZGF0YSBpZiBhIGNhbGxiYWNrIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIENhbGxlZCB3aGVuIGEgcGFnZSBvZiBkYXRhIGlzIHJldHVybmVkIGZyb20gdGhlIG5leHQgcmVxdWVzdC5cbiAgICpcbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gYW4gZXJyb3Igb2JqZWN0LCBpZiBhbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgcmVxdWVzdFxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBuZXh0IHBhZ2Ugb2YgZGF0YSwgb3IgbnVsbCwgaWYgdGhlcmUgYXJlIG5vXG4gICAqICAgICBtb3JlIHBhZ2VzIGxlZnQuXG4gICAqIEByZXR1cm4gW0FXUy5SZXF1ZXN0XSB0aGUgcmVxdWVzdCBvYmplY3QgZm9yIHRoZSBuZXh0IHBhZ2Ugb2YgZGF0YVxuICAgKiBAcmV0dXJuIFtudWxsXSBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCBhbmQgdGhlcmUgYXJlIG5vIHBhZ2VzIGxlZnRcbiAgICogICB0byByZXRyaWV2ZS5cbiAgICogQHNpbmNlIHYxLjQuMFxuICAgKi9cbiAgbmV4dFBhZ2U6IGZ1bmN0aW9uIG5leHRQYWdlKGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbmZpZztcbiAgICB2YXIgc2VydmljZSA9IHRoaXMucmVxdWVzdC5zZXJ2aWNlO1xuICAgIHZhciBvcGVyYXRpb24gPSB0aGlzLnJlcXVlc3Qub3BlcmF0aW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25maWcgPSBzZXJ2aWNlLnBhZ2luYXRpb25Db25maWcob3BlcmF0aW9uLCB0cnVlKTtcbiAgICB9IGNhdGNoIChlKSB7IHRoaXMuZXJyb3IgPSBlOyB9XG5cbiAgICBpZiAoIXRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aGlzLmVycm9yLCBudWxsKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gQVdTLnV0aWwuY29weSh0aGlzLnJlcXVlc3QucGFyYW1zKTtcbiAgICBpZiAoIXRoaXMubmV4dFBhZ2VUb2tlbnMpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayA/IGNhbGxiYWNrKG51bGwsIG51bGwpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlucHV0VG9rZW5zID0gY29uZmlnLmlucHV0VG9rZW47XG4gICAgICBpZiAodHlwZW9mIGlucHV0VG9rZW5zID09PSAnc3RyaW5nJykgaW5wdXRUb2tlbnMgPSBbaW5wdXRUb2tlbnNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dFRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJhbXNbaW5wdXRUb2tlbnNbaV1dID0gdGhpcy5uZXh0UGFnZVRva2Vuc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXJ2aWNlLm1ha2VSZXF1ZXN0KHRoaXMucmVxdWVzdC5vcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciBtb3JlIHBhZ2VzIG9mIGRhdGEgY2FuIGJlIHJldHVybmVkIGJ5IGZ1cnRoZXJcbiAgICogICByZXF1ZXN0c1xuICAgKiBAc2luY2UgdjEuNC4wXG4gICAqL1xuICBoYXNOZXh0UGFnZTogZnVuY3Rpb24gaGFzTmV4dFBhZ2UoKSB7XG4gICAgdGhpcy5jYWNoZU5leHRQYWdlVG9rZW5zKCk7XG4gICAgaWYgKHRoaXMubmV4dFBhZ2VUb2tlbnMpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLm5leHRQYWdlVG9rZW5zID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FjaGVOZXh0UGFnZVRva2VuczogZnVuY3Rpb24gY2FjaGVOZXh0UGFnZVRva2VucygpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICduZXh0UGFnZVRva2VucycpKSByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcbiAgICB0aGlzLm5leHRQYWdlVG9rZW5zID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbmZpZyA9IHRoaXMucmVxdWVzdC5zZXJ2aWNlLnBhZ2luYXRpb25Db25maWcodGhpcy5yZXF1ZXN0Lm9wZXJhdGlvbik7XG4gICAgaWYgKCFjb25maWcpIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuXG4gICAgdGhpcy5uZXh0UGFnZVRva2VucyA9IG51bGw7XG4gICAgaWYgKGNvbmZpZy5tb3JlUmVzdWx0cykge1xuICAgICAgaWYgKCFqbWVzcGF0aC5zZWFyY2godGhpcy5kYXRhLCBjb25maWcubW9yZVJlc3VsdHMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRQYWdlVG9rZW5zO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBleHBycyA9IGNvbmZpZy5vdXRwdXRUb2tlbjtcbiAgICBpZiAodHlwZW9mIGV4cHJzID09PSAnc3RyaW5nJykgZXhwcnMgPSBbZXhwcnNdO1xuICAgIEFXUy51dGlsLmFycmF5RWFjaC5jYWxsKHRoaXMsIGV4cHJzLCBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgdmFyIG91dHB1dCA9IGptZXNwYXRoLnNlYXJjaCh0aGlzLmRhdGEsIGV4cHIpO1xuICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICB0aGlzLm5leHRQYWdlVG9rZW5zID0gdGhpcy5uZXh0UGFnZVRva2VucyB8fCBbXTtcbiAgICAgICAgdGhpcy5uZXh0UGFnZVRva2Vucy5wdXNoKG91dHB1dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5uZXh0UGFnZVRva2VucztcbiAgfVxuXG59KTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgYnl0ZUxlbmd0aCA9IEFXUy51dGlsLnN0cmluZy5ieXRlTGVuZ3RoO1xudmFyIEJ1ZmZlciA9IEFXUy51dGlsLkJ1ZmZlcjtcblxuLyoqXG4gKiBUaGUgbWFuYWdlZCB1cGxvYWRlciBhbGxvd3MgZm9yIGVhc3kgYW5kIGVmZmljaWVudCB1cGxvYWRpbmcgb2YgYnVmZmVycyxcbiAqIGJsb2JzLCBvciBzdHJlYW1zLCB1c2luZyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgY29uY3VycmVuY3kgdG8gcGVyZm9ybVxuICogbXVsdGlwYXJ0IHVwbG9hZHMgd2hlcmUgcG9zc2libGUuIFRoaXMgYWJzdHJhY3Rpb24gYWxzbyBlbmFibGVzIHVwbG9hZGluZ1xuICogc3RyZWFtcyBvZiB1bmtub3duIHNpemUgZHVlIHRvIHRoZSB1c2Ugb2YgbXVsdGlwYXJ0IHVwbG9hZHMuXG4gKlxuICogVG8gY29uc3RydWN0IGEgbWFuYWdlZCB1cGxvYWQgb2JqZWN0LCBzZWUgdGhlIHtjb25zdHJ1Y3Rvcn0gZnVuY3Rpb24uXG4gKlxuICogIyMgVHJhY2tpbmcgdXBsb2FkIHByb2dyZXNzXG4gKlxuICogVGhlIG1hbmFnZWQgdXBsb2FkIG9iamVjdCBjYW4gYWxzbyB0cmFjayBwcm9ncmVzcyBieSBhdHRhY2hpbmcgYW5cbiAqICdodHRwVXBsb2FkUHJvZ3Jlc3MnIGxpc3RlbmVyIHRvIHRoZSB1cGxvYWQgbWFuYWdlci4gVGhpcyBldmVudCBpcyBzaW1pbGFyXG4gKiB0byB7QVdTLlJlcXVlc3R+aHR0cFVwbG9hZFByb2dyZXNzfSBidXQgZ3JvdXBzIGFsbCBjb25jdXJyZW50IHVwbG9hZCBwcm9ncmVzc1xuICogaW50byBhIHNpbmdsZSBldmVudC4gU2VlIHtBV1MuUzMuTWFuYWdlZFVwbG9hZH5odHRwVXBsb2FkUHJvZ3Jlc3N9IGZvciBtb3JlXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiAjIyBIYW5kbGluZyBNdWx0aXBhcnQgQ2xlYW51cFxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoaXMgY2xhc3Mgd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIGFueSBtdWx0aXBhcnQgdXBsb2Fkc1xuICogd2hlbiBhbiBpbmRpdmlkdWFsIHBhcnQgdXBsb2FkIGZhaWxzLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBkaXNhYmxlZCBpbiBvcmRlclxuICogdG8gbWFudWFsbHkgaGFuZGxlIGZhaWx1cmVzIGJ5IHNldHRpbmcgdGhlIGBsZWF2ZVBhcnRzT25FcnJvcmAgY29uZmlndXJhdGlvblxuICogb3B0aW9uIHRvIGB0cnVlYCB3aGVuIGluaXRpYWxpemluZyB0aGUgdXBsb2FkIG9iamVjdC5cbiAqXG4gKiBAIWV2ZW50IGh0dHBVcGxvYWRQcm9ncmVzcyhwcm9ncmVzcylcbiAqICAgVHJpZ2dlcmVkIHdoZW4gdGhlIHVwbG9hZGVyIGhhcyB1cGxvYWRlZCBtb3JlIGRhdGEuXG4gKiAgIEBub3RlIFRoZSBgdG90YWxgIHByb3BlcnR5IG1heSBub3QgYmUgc2V0IGlmIHRoZSBzdHJlYW0gYmVpbmcgdXBsb2FkZWQgaGFzXG4gKiAgICAgbm90IHlldCBmaW5pc2hlZCBjaHVua2luZy4gSW4gdGhpcyBjYXNlIHRoZSBgdG90YWxgIHdpbGwgYmUgdW5kZWZpbmVkXG4gKiAgICAgdW50aWwgdGhlIHRvdGFsIHN0cmVhbSBzaXplIGlzIGtub3duLlxuICogICBAbm90ZSBUaGlzIGV2ZW50IHdpbGwgbm90IGJlIGVtaXR0ZWQgaW4gTm9kZS5qcyAwLjgueC5cbiAqICAgQHBhcmFtIHByb2dyZXNzIFttYXBdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbG9hZGVkYCBhbmQgYHRvdGFsYCBieXRlc1xuICogICAgIG9mIHRoZSByZXF1ZXN0IGFuZCB0aGUgYGtleWAgb2YgdGhlIFMzIG9iamVjdC4gTm90ZSB0aGF0IGB0b3RhbGAgbWF5IGJlIHVuZGVmaW5lZCB1bnRpbCB0aGUgcGF5bG9hZFxuICogICAgIHNpemUgaXMga25vd24uXG4gKiAgIEBjb250ZXh0IChzZWUgQVdTLlJlcXVlc3R+c2VuZClcbiAqL1xuQVdTLlMzLk1hbmFnZWRVcGxvYWQgPSBBV1MudXRpbC5pbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtYW5hZ2VkIHVwbG9hZCBvYmplY3Qgd2l0aCBhIHNldCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIEBub3RlIEEgXCJCb2R5XCIgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHRvIGJlIHNldCBwcmlvciB0byBjYWxsaW5nIHtzZW5kfS5cbiAgICogQG5vdGUgSW4gTm9kZS5qcywgc2VuZGluZyBcIkJvZHlcIiBhcyB7aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV9vYmplY3RfbW9kZSBvYmplY3QtbW9kZSBzdHJlYW19XG4gICAqICAgbWF5IHJlc3VsdCBpbiB1cGxvYWQgaGFuZ3MuIFVzaW5nIGJ1ZmZlciBzdHJlYW0gaXMgcHJlZmVyYWJsZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIHVwbG9hZFxuICAgKiAgIHJlcXVlc3RzLiBUaGUgXCJCb2R5XCIgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIHRvIGJlIHNwZWNpZmllZCBlaXRoZXIgb25cbiAgICogICB0aGUgc2VydmljZSBvciBpbiB0aGUgcGFyYW1zIG9wdGlvbi5cbiAgICogQG5vdGUgQ29udGVudE1ENSBzaG91bGQgbm90IGJlIHByb3ZpZGVkIHdoZW4gdXNpbmcgdGhlIG1hbmFnZWQgdXBsb2FkIG9iamVjdC5cbiAgICogICBJbnN0ZWFkLCBzZXR0aW5nIFwiY29tcHV0ZUNoZWNrc3Vtc1wiIHRvIHRydWUgd2lsbCBlbmFibGUgYXV0b21hdGljIENvbnRlbnRNRDUgZ2VuZXJhdGlvblxuICAgKiAgIGJ5IHRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBxdWV1ZVNpemUgW051bWJlcl0gKDQpIHRoZSBzaXplIG9mIHRoZSBjb25jdXJyZW50IHF1ZXVlXG4gICAqICAgbWFuYWdlciB0byB1cGxvYWQgcGFydHMgaW4gcGFyYWxsZWwuIFNldCB0byAxIGZvciBzeW5jaHJvbm91cyB1cGxvYWRpbmdcbiAgICogICBvZiBwYXJ0cy4gTm90ZSB0aGF0IHRoZSB1cGxvYWRlciB3aWxsIGJ1ZmZlciBhdCBtb3N0IHF1ZXVlU2l6ZSAqIHBhcnRTaXplXG4gICAqICAgYnl0ZXMgaW50byBtZW1vcnkgYXQgYW55IGdpdmVuIHRpbWUuXG4gICAqIEBvcHRpb24gb3B0aW9ucyBwYXJ0U2l6ZSBbTnVtYmVyXSAoNW1iKSB0aGUgc2l6ZSBpbiBieXRlcyBmb3IgZWFjaFxuICAgKiAgIGluZGl2aWR1YWwgcGFydCB0byBiZSB1cGxvYWRlZC4gQWRqdXN0IHRoZSBwYXJ0IHNpemUgdG8gZW5zdXJlIHRoZSBudW1iZXJcbiAgICogICBvZiBwYXJ0cyBkb2VzIG5vdCBleGNlZWQge21heFRvdGFsUGFydHN9LiBTZWUge21pblBhcnRTaXplfSBmb3IgdGhlXG4gICAqICAgbWluaW11bSBhbGxvd2VkIHBhcnQgc2l6ZS5cbiAgICogQG9wdGlvbiBvcHRpb25zIGxlYXZlUGFydHNPbkVycm9yIFtCb29sZWFuXSAoZmFsc2UpIHdoZXRoZXIgdG8gYWJvcnQgdGhlXG4gICAqICAgbXVsdGlwYXJ0IHVwbG9hZCBpZiBhbiBlcnJvciBvY2N1cnMuIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGhhbmRsZVxuICAgKiAgIGZhaWx1cmVzIG1hbnVhbGx5LlxuICAgKiBAb3B0aW9uIG9wdGlvbnMgc2VydmljZSBbQVdTLlMzXSBhbiBvcHRpb25hbCBTMyBzZXJ2aWNlIG9iamVjdCB0byB1c2UgZm9yXG4gICAqICAgcmVxdWVzdHMuIFRoaXMgb2JqZWN0IG1pZ2h0IGhhdmUgYm91bmQgcGFyYW1ldGVycyB1c2VkIGJ5IHRoZSB1cGxvYWRlci5cbiAgICogQG9wdGlvbiBvcHRpb25zIHRhZ3MgW0FycmF5PG1hcD5dIFRoZSB0YWdzIHRvIGFwcGx5IHRvIHRoZSB1cGxvYWRlZCBvYmplY3QuXG4gICAqICAgRWFjaCB0YWcgc2hvdWxkIGhhdmUgYSBgS2V5YCBhbmQgYFZhbHVlYCBrZXlzLlxuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhIGRlZmF1bHQgdXBsb2FkZXIgZm9yIGEgc3RyZWFtIG9iamVjdFxuICAgKiAgIHZhciB1cGxvYWQgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQoe1xuICAgKiAgICAgcGFyYW1zOiB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfVxuICAgKiAgIH0pO1xuICAgKiBAZXhhbXBsZSBDcmVhdGluZyBhbiB1cGxvYWRlciB3aXRoIGNvbmN1cnJlbmN5IG9mIDEgYW5kIHBhcnRTaXplIG9mIDEwbWJcbiAgICogICB2YXIgdXBsb2FkID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKHtcbiAgICogICAgIHBhcnRTaXplOiAxMCAqIDEwMjQgKiAxMDI0LCBxdWV1ZVNpemU6IDEsXG4gICAqICAgICBwYXJhbXM6IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19XG4gICAqICAgfSk7XG4gICAqIEBleGFtcGxlIENyZWF0aW5nIGFuIHVwbG9hZGVyIHdpdGggdGFnc1xuICAgKiAgIHZhciB1cGxvYWQgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQoe1xuICAgKiAgICAgcGFyYW1zOiB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5JywgQm9keTogc3RyZWFtfSxcbiAgICogICAgIHRhZ3M6IFt7S2V5OiAndGFnMScsIFZhbHVlOiAndmFsdWUxJ30sIHtLZXk6ICd0YWcyJywgVmFsdWU6ICd2YWx1ZTInfV1cbiAgICogICB9KTtcbiAgICogQHNlZSBzZW5kXG4gICAqL1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gTWFuYWdlZFVwbG9hZChvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IuY2FsbChzZWxmKTtcbiAgICBzZWxmLmJvZHkgPSBudWxsO1xuICAgIHNlbGYuc2xpY2VGbiA9IG51bGw7XG4gICAgc2VsZi5jYWxsYmFjayA9IG51bGw7XG4gICAgc2VsZi5wYXJ0cyA9IHt9O1xuICAgIHNlbGYuY29tcGxldGVJbmZvID0gW107XG4gICAgc2VsZi5maWxsUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBib2R5IHBheWxvYWQgJyArIHR5cGVvZiBzZWxmLmJvZHkpKTtcbiAgICB9O1xuXG4gICAgc2VsZi5jb25maWd1cmUob3B0aW9ucyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlndXJlOiBmdW5jdGlvbiBjb25maWd1cmUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMucGFydFNpemUgPSB0aGlzLm1pblBhcnRTaXplO1xuXG4gICAgaWYgKG9wdGlvbnMucXVldWVTaXplKSB0aGlzLnF1ZXVlU2l6ZSA9IG9wdGlvbnMucXVldWVTaXplO1xuICAgIGlmIChvcHRpb25zLnBhcnRTaXplKSB0aGlzLnBhcnRTaXplID0gb3B0aW9ucy5wYXJ0U2l6ZTtcbiAgICBpZiAob3B0aW9ucy5sZWF2ZVBhcnRzT25FcnJvcikgdGhpcy5sZWF2ZVBhcnRzT25FcnJvciA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMudGFncykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMudGFncykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWdzIG11c3QgYmUgc3BlY2lmaWVkIGFzIGFuIGFycmF5OyAnICtcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy50YWdzICsgJyBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFncyA9IG9wdGlvbnMudGFncztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJ0U2l6ZSA8IHRoaXMubWluUGFydFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFydFNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5QYXJ0U2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXJ2aWNlID0gb3B0aW9ucy5zZXJ2aWNlO1xuICAgIHRoaXMuYmluZFNlcnZpY2VPYmplY3Qob3B0aW9ucy5wYXJhbXMpO1xuICAgIHRoaXMudmFsaWRhdGVCb2R5KCk7XG4gICAgdGhpcy5hZGp1c3RUb3RhbEJ5dGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbGVhdmVQYXJ0c09uRXJyb3I6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHF1ZXVlU2l6ZTogNCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0U2l6ZTogbnVsbCxcblxuICAvKipcbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm4gW051bWJlcl0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIGZvciBhbiBpbmRpdmlkdWFsIHBhcnRcbiAgICogICB1cGxvYWQuXG4gICAqL1xuICBtaW5QYXJ0U2l6ZTogMTAyNCAqIDEwMjQgKiA1LFxuXG4gIC8qKlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybiBbTnVtYmVyXSB0aGUgbWF4aW11bSBhbGxvd2VkIG51bWJlciBvZiBwYXJ0cyBpbiBhIG11bHRpcGFydCB1cGxvYWQuXG4gICAqL1xuICBtYXhUb3RhbFBhcnRzOiAxMDAwMCxcblxuICAvKipcbiAgICogSW5pdGlhdGVzIHRoZSBtYW5hZ2VkIHVwbG9hZCBmb3IgdGhlIHBheWxvYWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc3VjY2Vzc2Z1bCB1cGxvYWQ6XG4gICAqICAgICAqIGBMb2NhdGlvbmAgKFN0cmluZykgdGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAqIGBFVGFnYCAoU3RyaW5nKSB0aGUgRVRhZyBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgICAqIGBCdWNrZXRgIChTdHJpbmcpIHRoZSBidWNrZXQgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICogICAgICogYEtleWAgKFN0cmluZykgdGhlIGtleSB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiBAZXhhbXBsZSBTZW5kaW5nIGEgbWFuYWdlZCB1cGxvYWQgb2JqZWN0XG4gICAqICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19O1xuICAgKiAgIHZhciB1cGxvYWQgPSBuZXcgQVdTLlMzLk1hbmFnZWRVcGxvYWQoe3BhcmFtczogcGFyYW1zfSk7XG4gICAqICAgdXBsb2FkLnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhlcnIsIGRhdGEpO1xuICAgKiAgIH0pO1xuICAgKi9cbiAgc2VuZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5mYWlsZWQgPSBmYWxzZTtcbiAgICBzZWxmLmNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuICAgIHZhciBydW5GaWxsID0gdHJ1ZTtcbiAgICBpZiAoc2VsZi5zbGljZUZuKSB7XG4gICAgICBzZWxmLmZpbGxRdWV1ZSA9IHNlbGYuZmlsbEJ1ZmZlcjtcbiAgICB9IGVsc2UgaWYgKEFXUy51dGlsLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgU3RyZWFtID0gQVdTLnV0aWwuc3RyZWFtLlN0cmVhbTtcbiAgICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgcnVuRmlsbCA9IGZhbHNlO1xuICAgICAgICBzZWxmLmZpbGxRdWV1ZSA9IHNlbGYuZmlsbFN0cmVhbTtcbiAgICAgICAgc2VsZi5wYXJ0QnVmZmVycyA9IFtdO1xuICAgICAgICBzZWxmLmJvZHkuXG4gICAgICAgICAgb24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7IHNlbGYuY2xlYW51cChlcnIpOyB9KS5cbiAgICAgICAgICBvbigncmVhZGFibGUnLCBmdW5jdGlvbigpIHsgc2VsZi5maWxsUXVldWUoKTsgfSkuXG4gICAgICAgICAgb24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5pc0RvbmVDaHVua2luZyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLm51bVBhcnRzID0gc2VsZi50b3RhbFBhcnROdW1iZXJzO1xuICAgICAgICAgICAgc2VsZi5maWxsUXVldWUuY2FsbChzZWxmKTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaXNEb25lQ2h1bmtpbmcgJiYgc2VsZi50b3RhbFBhcnROdW1iZXJzID49IDEgJiYgc2VsZi5kb25lUGFydHMgPT09IHNlbGYubnVtUGFydHMpIHtcbiAgICAgICAgICAgICAgc2VsZi5maW5pc2hNdWx0aVBhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocnVuRmlsbCkgc2VsZi5maWxsUXVldWUuY2FsbChzZWxmKTtcbiAgfSxcblxuICAvKipcbiAgICogQCFtZXRob2QgIHByb21pc2UoKVxuICAgKiAgIFJldHVybnMgYSAndGhlbmFibGUnIHByb21pc2UuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24oZGF0YSlcbiAgICogICAgIENhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gICAqICAgICBAcGFyYW0gZGF0YSBbbWFwXSBUaGUgcmVzcG9uc2UgZGF0YSBmcm9tIHRoZSBzdWNjZXNzZnVsIHVwbG9hZDpcbiAgICogICAgICAgYExvY2F0aW9uYCAoU3RyaW5nKSB0aGUgVVJMIG9mIHRoZSB1cGxvYWRlZCBvYmplY3RcbiAgICogICAgICAgYEVUYWdgIChTdHJpbmcpIHRoZSBFVGFnIG9mIHRoZSB1cGxvYWRlZCBvYmplY3RcbiAgICogICAgICAgYEJ1Y2tldGAgKFN0cmluZykgdGhlIGJ1Y2tldCB0byB3aGljaCB0aGUgb2JqZWN0IHdhcyB1cGxvYWRlZFxuICAgKiAgICAgICBgS2V5YCAoU3RyaW5nKSB0aGUga2V5IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqICAgQGNhbGxiYWNrIHJlamVjdGVkQ2FsbGJhY2sgZnVuY3Rpb24oZXJyKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLlxuICAgKiAgICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHJldHVybiBbUHJvbWlzZV0gQSBwcm9taXNlIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgb2YgdGhlIHVwbG9hZCByZXF1ZXN0LlxuICAgKiAgIEBleGFtcGxlIFNlbmRpbmcgYW4gdXBsb2FkIHJlcXVlc3QgdXNpbmcgcHJvbWlzZXMuXG4gICAqICAgICB2YXIgdXBsb2FkID0gczMudXBsb2FkKHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19KTtcbiAgICogICAgIHZhciBwcm9taXNlID0gdXBsb2FkLnByb21pc2UoKTtcbiAgICogICAgIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7IC4uLiB9LCBmdW5jdGlvbihlcnIpIHsgLi4uIH0pO1xuICAgKi9cblxuICAvKipcbiAgICogQWJvcnRzIGEgbWFuYWdlZCB1cGxvYWQsIGluY2x1ZGluZyBhbGwgY29uY3VycmVudCB1cGxvYWQgcmVxdWVzdHMuXG4gICAqIEBub3RlIEJ5IGRlZmF1bHQsIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIGNsZWFudXAgYSBtdWx0aXBhcnQgdXBsb2FkXG4gICAqICAgaWYgb25lIHdhcyBjcmVhdGVkLiBUbyBsZWF2ZSB0aGUgbXVsdGlwYXJ0IHVwbG9hZCBhcm91bmQgYWZ0ZXIgYWJvcnRpbmdcbiAgICogICBhIHJlcXVlc3QsIGNvbmZpZ3VyZSBgbGVhdmVQYXJ0c09uRXJyb3JgIHRvIGB0cnVlYCBpbiB0aGUge2NvbnN0cnVjdG9yfS5cbiAgICogQG5vdGUgQ2FsbGluZyB7YWJvcnR9IGluIHRoZSBicm93c2VyIGVudmlyb25tZW50IHdpbGwgbm90IGFib3J0IGFueSByZXF1ZXN0c1xuICAgKiAgIHRoYXQgYXJlIGFscmVhZHkgaW4gZmxpZ2h0LiBJZiBhIG11bHRpcGFydCB1cGxvYWQgd2FzIGNyZWF0ZWQsIGFueSBwYXJ0c1xuICAgKiAgIG5vdCB5ZXQgdXBsb2FkZWQgd2lsbCBub3QgYmUgc2VudCwgYW5kIHRoZSBtdWx0aXBhcnQgdXBsb2FkIHdpbGwgYmUgY2xlYW5lZCB1cC5cbiAgICogQGV4YW1wbGUgQWJvcnRpbmcgYW4gdXBsb2FkXG4gICAqICAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgIEJ1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsXG4gICAqICAgICBCb2R5OiBCdWZmZXIuYWxsb2MoMTAyNCAqIDEwMjQgKiAyNSkgLy8gMjVNQiBwYXlsb2FkXG4gICAqICAgfTtcbiAgICogICB2YXIgdXBsb2FkID0gczMudXBsb2FkKHBhcmFtcyk7XG4gICAqICAgdXBsb2FkLnNlbmQoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikgY29uc29sZS5sb2coXCJFcnJvcjpcIiwgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgICogICAgIGVsc2UgY29uc29sZS5sb2coZGF0YSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gYWJvcnQgcmVxdWVzdCBpbiAxIHNlY29uZFxuICAgKiAgIHNldFRpbWVvdXQodXBsb2FkLmFib3J0LmJpbmQodXBsb2FkKSwgMTAwMCk7XG4gICAqL1xuICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vYWJvcnQgcHV0T2JqZWN0IHJlcXVlc3RcbiAgICBpZiAoc2VsZi5pc0RvbmVDaHVua2luZyA9PT0gdHJ1ZSAmJiBzZWxmLnRvdGFsUGFydE51bWJlcnMgPT09IDEgJiYgc2VsZi5zaW5nbGVQYXJ0KSB7XG4gICAgICBzZWxmLnNpbmdsZVBhcnQuYWJvcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jbGVhbnVwKEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcignUmVxdWVzdCBhYm9ydGVkIGJ5IHVzZXInKSwge1xuICAgICAgICBjb2RlOiAnUmVxdWVzdEFib3J0ZWRFcnJvcicsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVCb2R5OiBmdW5jdGlvbiB2YWxpZGF0ZUJvZHkoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuYm9keSA9IHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLkJvZHk7XG4gICAgaWYgKHR5cGVvZiBzZWxmLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxmLmJvZHkgPSBBV1MudXRpbC5idWZmZXIudG9CdWZmZXIoc2VsZi5ib2R5KTtcbiAgICB9IGVsc2UgaWYgKCFzZWxmLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW1zLkJvZHkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgc2VsZi5zbGljZUZuID0gQVdTLnV0aWwuYXJyYXlTbGljZUZuKHNlbGYuYm9keSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYmluZFNlcnZpY2VPYmplY3Q6IGZ1bmN0aW9uIGJpbmRTZXJ2aWNlT2JqZWN0KHBhcmFtcykge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gYmluZCBwYXJhbWV0ZXJzIHRvIG5ldyBzZXJ2aWNlIG9iamVjdFxuICAgIGlmICghc2VsZi5zZXJ2aWNlKSB7XG4gICAgICBzZWxmLnNlcnZpY2UgPSBuZXcgQVdTLlMzKHtwYXJhbXM6IHBhcmFtc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgUzMgY2xpZW50IGZyb20gdGhlIHN1cHBsaWVkIGNsaWVudCdzIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIHNlcnZpY2UgPSBzZWxmLnNlcnZpY2U7XG4gICAgICB2YXIgY29uZmlnID0gQVdTLnV0aWwuY29weShzZXJ2aWNlLmNvbmZpZyk7XG4gICAgICBjb25maWcuc2lnbmF0dXJlVmVyc2lvbiA9IHNlcnZpY2UuZ2V0U2lnbmF0dXJlVmVyc2lvbigpO1xuICAgICAgc2VsZi5zZXJ2aWNlID0gbmV3IHNlcnZpY2UuY29uc3RydWN0b3IuX19zdXBlcl9fKGNvbmZpZyk7XG4gICAgICBzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcyA9XG4gICAgICAgIEFXUy51dGlsLm1lcmdlKHNlbGYuc2VydmljZS5jb25maWcucGFyYW1zIHx8IHt9LCBwYXJhbXMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuc2VydmljZSwgJ19vcmlnaW5hbENvbmZpZycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHNlcnZpY2UuX29yaWdpbmFsQ29uZmlnOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRqdXN0VG90YWxCeXRlczogZnVuY3Rpb24gYWRqdXN0VG90YWxCeXRlcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHsgLy8gdHJ5IHRvIGdldCB0b3RhbEJ5dGVzXG4gICAgICBzZWxmLnRvdGFsQnl0ZXMgPSBieXRlTGVuZ3RoKHNlbGYuYm9keSk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICAvLyB0cnkgdG8gYWRqdXN0IHBhcnRTaXplIGlmIHdlIGtub3cgcGF5bG9hZCBsZW5ndGhcbiAgICBpZiAoc2VsZi50b3RhbEJ5dGVzKSB7XG4gICAgICB2YXIgbmV3UGFydFNpemUgPSBNYXRoLmNlaWwoc2VsZi50b3RhbEJ5dGVzIC8gc2VsZi5tYXhUb3RhbFBhcnRzKTtcbiAgICAgIGlmIChuZXdQYXJ0U2l6ZSA+IHNlbGYucGFydFNpemUpIHNlbGYucGFydFNpemUgPSBuZXdQYXJ0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi50b3RhbEJ5dGVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc0RvbmVDaHVua2luZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcGFydFBvczogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b3RhbENodW5rZWRCeXRlczogMCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b3RhbFVwbG9hZGVkQnl0ZXM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdG90YWxCeXRlczogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG51bVBhcnRzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvdGFsUGFydE51bWJlcnM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWN0aXZlUGFydHM6IDAsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZG9uZVBhcnRzOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhcnRzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXBsZXRlSW5mbzogbnVsbCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBmYWlsZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG11bHRpcGFydFJlcTogbnVsbCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0QnVmZmVyczogbnVsbCxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXJ0QnVmZmVyTGVuZ3RoOiAwLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbGxCdWZmZXI6IGZ1bmN0aW9uIGZpbGxCdWZmZXIoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBib2R5TGVuID0gYnl0ZUxlbmd0aChzZWxmLmJvZHkpO1xuXG4gICAgaWYgKGJvZHlMZW4gPT09IDApIHtcbiAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSB0cnVlO1xuICAgICAgc2VsZi5udW1QYXJ0cyA9IDE7XG4gICAgICBzZWxmLm5leHRDaHVuayhzZWxmLmJvZHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChzZWxmLmFjdGl2ZVBhcnRzIDwgc2VsZi5xdWV1ZVNpemUgJiYgc2VsZi5wYXJ0UG9zIDwgYm9keUxlbikge1xuICAgICAgdmFyIGVuZFBvcyA9IE1hdGgubWluKHNlbGYucGFydFBvcyArIHNlbGYucGFydFNpemUsIGJvZHlMZW4pO1xuICAgICAgdmFyIGJ1ZiA9IHNlbGYuc2xpY2VGbi5jYWxsKHNlbGYuYm9keSwgc2VsZi5wYXJ0UG9zLCBlbmRQb3MpO1xuICAgICAgc2VsZi5wYXJ0UG9zICs9IHNlbGYucGFydFNpemU7XG5cbiAgICAgIGlmIChieXRlTGVuZ3RoKGJ1ZikgPCBzZWxmLnBhcnRTaXplIHx8IHNlbGYucGFydFBvcyA9PT0gYm9keUxlbikge1xuICAgICAgICBzZWxmLmlzRG9uZUNodW5raW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5udW1QYXJ0cyA9IHNlbGYudG90YWxQYXJ0TnVtYmVycyArIDE7XG4gICAgICB9XG4gICAgICBzZWxmLm5leHRDaHVuayhidWYpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBmaWxsU3RyZWFtOiBmdW5jdGlvbiBmaWxsU3RyZWFtKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5hY3RpdmVQYXJ0cyA+PSBzZWxmLnF1ZXVlU2l6ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGJ1ZiA9IHNlbGYuYm9keS5yZWFkKHNlbGYucGFydFNpemUgLSBzZWxmLnBhcnRCdWZmZXJMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIHNlbGYuYm9keS5yZWFkKCk7XG4gICAgaWYgKGJ1Zikge1xuICAgICAgc2VsZi5wYXJ0QnVmZmVycy5wdXNoKGJ1Zik7XG4gICAgICBzZWxmLnBhcnRCdWZmZXJMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgIHNlbGYudG90YWxDaHVua2VkQnl0ZXMgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoID49IHNlbGYucGFydFNpemUpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgc2luZ2xlIGJ1ZmZlciB3ZSBhdm9pZCBjb3B5ZnVsbCBjb25jYXRcbiAgICAgIHZhciBwYnVmID0gc2VsZi5wYXJ0QnVmZmVycy5sZW5ndGggPT09IDEgP1xuICAgICAgICBzZWxmLnBhcnRCdWZmZXJzWzBdIDogQnVmZmVyLmNvbmNhdChzZWxmLnBhcnRCdWZmZXJzKTtcbiAgICAgIHNlbGYucGFydEJ1ZmZlcnMgPSBbXTtcbiAgICAgIHNlbGYucGFydEJ1ZmZlckxlbmd0aCA9IDA7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgbW9yZSB0aGFuIHBhcnRTaXplLCBwdXNoIHRoZSByZXN0IGJhY2sgb24gdGhlIHF1ZXVlXG4gICAgICBpZiAocGJ1Zi5sZW5ndGggPiBzZWxmLnBhcnRTaXplKSB7XG4gICAgICAgIHZhciByZXN0ID0gcGJ1Zi5zbGljZShzZWxmLnBhcnRTaXplKTtcbiAgICAgICAgc2VsZi5wYXJ0QnVmZmVycy5wdXNoKHJlc3QpO1xuICAgICAgICBzZWxmLnBhcnRCdWZmZXJMZW5ndGggKz0gcmVzdC5sZW5ndGg7XG4gICAgICAgIHBidWYgPSBwYnVmLnNsaWNlKDAsIHNlbGYucGFydFNpemUpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLm5leHRDaHVuayhwYnVmKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5pc0RvbmVDaHVua2luZyAmJiAhc2VsZi5pc0RvbmVTZW5kaW5nKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIHNpbmdsZSBidWZmZXIgd2UgYXZvaWQgY29weWZ1bGwgY29uY2F0XG4gICAgICBwYnVmID0gc2VsZi5wYXJ0QnVmZmVycy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgIHNlbGYucGFydEJ1ZmZlcnNbMF0gOiBCdWZmZXIuY29uY2F0KHNlbGYucGFydEJ1ZmZlcnMpO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVycyA9IFtdO1xuICAgICAgc2VsZi5wYXJ0QnVmZmVyTGVuZ3RoID0gMDtcbiAgICAgIHNlbGYudG90YWxCeXRlcyA9IHNlbGYudG90YWxDaHVua2VkQnl0ZXM7XG4gICAgICBzZWxmLmlzRG9uZVNlbmRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoc2VsZi5udW1QYXJ0cyA9PT0gMCB8fCBwYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2VsZi5udW1QYXJ0cysrO1xuICAgICAgICBzZWxmLm5leHRDaHVuayhwYnVmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmJvZHkucmVhZCgwKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBuZXh0Q2h1bms6IGZ1bmN0aW9uIG5leHRDaHVuayhjaHVuaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5mYWlsZWQpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHBhcnROdW1iZXIgPSArK3NlbGYudG90YWxQYXJ0TnVtYmVycztcbiAgICBpZiAoc2VsZi5pc0RvbmVDaHVua2luZyAmJiBwYXJ0TnVtYmVyID09PSAxKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge0JvZHk6IGNodW5rfTtcbiAgICAgIGlmICh0aGlzLnRhZ3MpIHtcbiAgICAgICAgcGFyYW1zLlRhZ2dpbmcgPSB0aGlzLmdldFRhZ2dpbmdIZWFkZXIoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXEgPSBzZWxmLnNlcnZpY2UucHV0T2JqZWN0KHBhcmFtcyk7XG4gICAgICByZXEuX21hbmFnZWRVcGxvYWQgPSBzZWxmO1xuICAgICAgcmVxLm9uKCdodHRwVXBsb2FkUHJvZ3Jlc3MnLCBzZWxmLnByb2dyZXNzKS5zZW5kKHNlbGYuZmluaXNoU2luZ2xlUGFydCk7XG4gICAgICBzZWxmLnNpbmdsZVBhcnQgPSByZXE7IC8vc2F2ZSB0aGUgc2luZ2xlIHBhcnQgcmVxdWVzdFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChzZWxmLnNlcnZpY2UuY29uZmlnLnBhcmFtcy5Db250ZW50TUQ1KSB7XG4gICAgICB2YXIgZXJyID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdUaGUgQ29udGVudC1NRDUgeW91IHNwZWNpZmllZCBpcyBpbnZhbGlkIGZvciBtdWx0aS1wYXJ0IHVwbG9hZHMuJyksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWREaWdlc3QnLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgc2VsZi5jbGVhbnVwKGVycik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5jb21wbGV0ZUluZm9bcGFydE51bWJlcl0gJiYgc2VsZi5jb21wbGV0ZUluZm9bcGFydE51bWJlcl0uRVRhZyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEFscmVhZHkgdXBsb2FkZWQgdGhpcyBwYXJ0LlxuICAgIH1cblxuICAgIHNlbGYuYWN0aXZlUGFydHMrKztcbiAgICBpZiAoIXNlbGYuc2VydmljZS5jb25maWcucGFyYW1zLlVwbG9hZElkKSB7XG5cbiAgICAgIGlmICghc2VsZi5tdWx0aXBhcnRSZXEpIHsgLy8gY3JlYXRlIG11bHRpcGFydFxuICAgICAgICBzZWxmLm11bHRpcGFydFJlcSA9IHNlbGYuc2VydmljZS5jcmVhdGVNdWx0aXBhcnRVcGxvYWQoKTtcbiAgICAgICAgc2VsZi5tdWx0aXBhcnRSZXEub24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuVXBsb2FkSWQgPSByZXNwLmRhdGEuVXBsb2FkSWQ7XG4gICAgICAgICAgc2VsZi5tdWx0aXBhcnRSZXEgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5xdWV1ZUNodW5rcyhjaHVuaywgcGFydE51bWJlcik7XG4gICAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHNlbGYuY2xlYW51cChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi5tdWx0aXBhcnRSZXEuc2VuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5xdWV1ZUNodW5rcyhjaHVuaywgcGFydE51bWJlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbXVsdGlwYXJ0IGlzIGNyZWF0ZWQsIGp1c3Qgc2VuZFxuICAgICAgc2VsZi51cGxvYWRQYXJ0KGNodW5rLCBwYXJ0TnVtYmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VGFnZ2luZ0hlYWRlcjogZnVuY3Rpb24gZ2V0VGFnZ2luZ0hlYWRlcigpIHtcbiAgICB2YXIga3ZQYWlyU3RyaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrdlBhaXJTdHJpbmdzLnB1c2goQVdTLnV0aWwudXJpRXNjYXBlKHRoaXMudGFnc1tpXS5LZXkpICsgJz0nICtcbiAgICAgICAgQVdTLnV0aWwudXJpRXNjYXBlKHRoaXMudGFnc1tpXS5WYWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBrdlBhaXJTdHJpbmdzLmpvaW4oJyYnKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB1cGxvYWRQYXJ0OiBmdW5jdGlvbiB1cGxvYWRQYXJ0KGNodW5rLCBwYXJ0TnVtYmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHBhcnRQYXJhbXMgPSB7XG4gICAgICBCb2R5OiBjaHVuayxcbiAgICAgIENvbnRlbnRMZW5ndGg6IEFXUy51dGlsLnN0cmluZy5ieXRlTGVuZ3RoKGNodW5rKSxcbiAgICAgIFBhcnROdW1iZXI6IHBhcnROdW1iZXJcbiAgICB9O1xuXG4gICAgdmFyIHBhcnRJbmZvID0ge0VUYWc6IG51bGwsIFBhcnROdW1iZXI6IHBhcnROdW1iZXJ9O1xuICAgIHNlbGYuY29tcGxldGVJbmZvW3BhcnROdW1iZXJdID0gcGFydEluZm87XG5cbiAgICB2YXIgcmVxID0gc2VsZi5zZXJ2aWNlLnVwbG9hZFBhcnQocGFydFBhcmFtcyk7XG4gICAgc2VsZi5wYXJ0c1twYXJ0TnVtYmVyXSA9IHJlcTtcbiAgICByZXEuX2xhc3RVcGxvYWRlZEJ5dGVzID0gMDtcbiAgICByZXEuX21hbmFnZWRVcGxvYWQgPSBzZWxmO1xuICAgIHJlcS5vbignaHR0cFVwbG9hZFByb2dyZXNzJywgc2VsZi5wcm9ncmVzcyk7XG4gICAgcmVxLnNlbmQoZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBkZWxldGUgc2VsZi5wYXJ0c1twYXJ0UGFyYW1zLlBhcnROdW1iZXJdO1xuICAgICAgc2VsZi5hY3RpdmVQYXJ0cy0tO1xuXG4gICAgICBpZiAoIWVyciAmJiAoIWRhdGEgfHwgIWRhdGEuRVRhZykpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnTm8gYWNjZXNzIHRvIEVUYWcgcHJvcGVydHkgb24gcmVzcG9uc2UuJztcbiAgICAgICAgaWYgKEFXUy51dGlsLmlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgbWVzc2FnZSArPSAnIENoZWNrIENPUlMgY29uZmlndXJhdGlvbiB0byBleHBvc2UgRVRhZyBoZWFkZXIuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVyciA9IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcihtZXNzYWdlKSwge1xuICAgICAgICAgIGNvZGU6ICdFVGFnTWlzc2luZycsIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyKSByZXR1cm4gc2VsZi5jbGVhbnVwKGVycik7XG4gICAgICAvL3ByZXZlbnQgc2VuZGluZyBwYXJ0IGJlaW5nIHJldHVybmVkIHR3aWNlIChodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1zZGstanMvaXNzdWVzLzIzMDQpXG4gICAgICBpZiAoc2VsZi5jb21wbGV0ZUluZm9bcGFydE51bWJlcl0gJiYgc2VsZi5jb21wbGV0ZUluZm9bcGFydE51bWJlcl0uRVRhZyAhPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICBwYXJ0SW5mby5FVGFnID0gZGF0YS5FVGFnO1xuICAgICAgc2VsZi5kb25lUGFydHMrKztcbiAgICAgIGlmIChzZWxmLmlzRG9uZUNodW5raW5nICYmIHNlbGYuZG9uZVBhcnRzID09PSBzZWxmLnRvdGFsUGFydE51bWJlcnMpIHtcbiAgICAgICAgc2VsZi5maW5pc2hNdWx0aVBhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZmlsbFF1ZXVlLmNhbGwoc2VsZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcXVldWVDaHVua3M6IGZ1bmN0aW9uIHF1ZXVlQ2h1bmtzKGNodW5rLCBwYXJ0TnVtYmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYubXVsdGlwYXJ0UmVxLm9uKCdzdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnVwbG9hZFBhcnQoY2h1bmssIHBhcnROdW1iZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsZWFudXA6IGZ1bmN0aW9uIGNsZWFudXAoZXJyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLmZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gY2xlYW4gdXAgc3RyZWFtXG4gICAgaWYgKHR5cGVvZiBzZWxmLmJvZHkucmVtb3ZlQWxsTGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBzZWxmLmJvZHkucmVzdW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLmJvZHkucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZWFkYWJsZScpO1xuICAgICAgc2VsZi5ib2R5LnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICBzZWxmLmJvZHkucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCBtdWx0aXBhcnRSZXEgbGlzdGVuZXJzXG4gICAgaWYgKHNlbGYubXVsdGlwYXJ0UmVxKSB7XG4gICAgICBzZWxmLm11bHRpcGFydFJlcS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3N1Y2Nlc3MnKTtcbiAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKTtcbiAgICAgIHNlbGYubXVsdGlwYXJ0UmVxLnJlbW92ZUFsbExpc3RlbmVycygnY29tcGxldGUnKTtcbiAgICAgIGRlbGV0ZSBzZWxmLm11bHRpcGFydFJlcTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5zZXJ2aWNlLmNvbmZpZy5wYXJhbXMuVXBsb2FkSWQgJiYgIXNlbGYubGVhdmVQYXJ0c09uRXJyb3IpIHtcbiAgICAgIHNlbGYuc2VydmljZS5hYm9ydE11bHRpcGFydFVwbG9hZCgpLnNlbmQoKTtcbiAgICB9IGVsc2UgaWYgKHNlbGYubGVhdmVQYXJ0c09uRXJyb3IpIHtcbiAgICAgIHNlbGYuaXNEb25lQ2h1bmtpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBBV1MudXRpbC5lYWNoKHNlbGYucGFydHMsIGZ1bmN0aW9uKHBhcnROdW1iZXIsIHBhcnQpIHtcbiAgICAgIHBhcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb21wbGV0ZScpO1xuICAgICAgcGFydC5hYm9ydCgpO1xuICAgIH0pO1xuXG4gICAgc2VsZi5hY3RpdmVQYXJ0cyA9IDA7XG4gICAgc2VsZi5wYXJ0UG9zID0gMDtcbiAgICBzZWxmLm51bVBhcnRzID0gMDtcbiAgICBzZWxmLnRvdGFsUGFydE51bWJlcnMgPSAwO1xuICAgIHNlbGYucGFydHMgPSB7fTtcbiAgICBzZWxmLmZhaWxlZCA9IHRydWU7XG4gICAgc2VsZi5jYWxsYmFjayhlcnIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGZpbmlzaE11bHRpUGFydDogZnVuY3Rpb24gZmluaXNoTXVsdGlQYXJ0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29tcGxldGVQYXJhbXMgPSB7IE11bHRpcGFydFVwbG9hZDogeyBQYXJ0czogc2VsZi5jb21wbGV0ZUluZm8uc2xpY2UoMSkgfSB9O1xuICAgIHNlbGYuc2VydmljZS5jb21wbGV0ZU11bHRpcGFydFVwbG9hZChjb21wbGV0ZVBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNsZWFudXAoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEuTG9jYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEuTG9jYXRpb24gPSBkYXRhLkxvY2F0aW9uLnJlcGxhY2UoLyUyRi9nLCAnLycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmLnRhZ3MpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi50YWdzW2ldLlZhbHVlID0gU3RyaW5nKHNlbGYudGFnc1tpXS5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5zZXJ2aWNlLnB1dE9iamVjdFRhZ2dpbmcoXG4gICAgICAgICAge1RhZ2dpbmc6IHtUYWdTZXQ6IHNlbGYudGFnc319LFxuICAgICAgICAgIGZ1bmN0aW9uKGUsIGQpIHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrKGUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBmaW5pc2hTaW5nbGVQYXJ0OiBmdW5jdGlvbiBmaW5pc2hTaW5nbGVQYXJ0KGVyciwgZGF0YSkge1xuICAgIHZhciB1cGxvYWQgPSB0aGlzLnJlcXVlc3QuX21hbmFnZWRVcGxvYWQ7XG4gICAgdmFyIGh0dHBSZXEgPSB0aGlzLnJlcXVlc3QuaHR0cFJlcXVlc3Q7XG4gICAgdmFyIGVuZHBvaW50ID0gaHR0cFJlcS5lbmRwb2ludDtcbiAgICBpZiAoZXJyKSByZXR1cm4gdXBsb2FkLmNhbGxiYWNrKGVycik7XG4gICAgZGF0YS5Mb2NhdGlvbiA9XG4gICAgICBbZW5kcG9pbnQucHJvdG9jb2wsICcvLycsIGVuZHBvaW50Lmhvc3QsIGh0dHBSZXEucGF0aF0uam9pbignJyk7XG4gICAgZGF0YS5rZXkgPSB0aGlzLnJlcXVlc3QucGFyYW1zLktleTsgLy8gd2lsbCBzdGF5IHVuZG9jdW1lbnRlZFxuICAgIGRhdGEuS2V5ID0gdGhpcy5yZXF1ZXN0LnBhcmFtcy5LZXk7XG4gICAgZGF0YS5CdWNrZXQgPSB0aGlzLnJlcXVlc3QucGFyYW1zLkJ1Y2tldDtcbiAgICB1cGxvYWQuY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoaW5mbykge1xuICAgIHZhciB1cGxvYWQgPSB0aGlzLl9tYW5hZ2VkVXBsb2FkO1xuICAgIGlmICh0aGlzLm9wZXJhdGlvbiA9PT0gJ3B1dE9iamVjdCcpIHtcbiAgICAgIGluZm8ucGFydCA9IDE7XG4gICAgICBpbmZvLmtleSA9IHRoaXMucGFyYW1zLktleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBsb2FkLnRvdGFsVXBsb2FkZWRCeXRlcyArPSBpbmZvLmxvYWRlZCAtIHRoaXMuX2xhc3RVcGxvYWRlZEJ5dGVzO1xuICAgICAgdGhpcy5fbGFzdFVwbG9hZGVkQnl0ZXMgPSBpbmZvLmxvYWRlZDtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGxvYWRlZDogdXBsb2FkLnRvdGFsVXBsb2FkZWRCeXRlcyxcbiAgICAgICAgdG90YWw6IHVwbG9hZC50b3RhbEJ5dGVzLFxuICAgICAgICBwYXJ0OiB0aGlzLnBhcmFtcy5QYXJ0TnVtYmVyLFxuICAgICAgICBrZXk6IHRoaXMucGFyYW1zLktleVxuICAgICAgfTtcbiAgICB9XG4gICAgdXBsb2FkLmVtaXQoJ2h0dHBVcGxvYWRQcm9ncmVzcycsIFtpbmZvXSk7XG4gIH1cbn0pO1xuXG5BV1MudXRpbC5taXhpbihBV1MuUzMuTWFuYWdlZFVwbG9hZCwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcik7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TMy5NYW5hZ2VkVXBsb2FkLmFkZFByb21pc2VzVG9DbGFzcyA9IGZ1bmN0aW9uIGFkZFByb21pc2VzVG9DbGFzcyhQcm9taXNlRGVwZW5kZW5jeSkge1xuICB0aGlzLnByb3RvdHlwZS5wcm9taXNlID0gQVdTLnV0aWwucHJvbWlzaWZ5TWV0aG9kKCdzZW5kJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlMzLk1hbmFnZWRVcGxvYWQuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MgPSBmdW5jdGlvbiBkZWxldGVQcm9taXNlc0Zyb21DbGFzcygpIHtcbiAgZGVsZXRlIHRoaXMucHJvdG90eXBlLnByb21pc2U7XG59O1xuXG5BV1MudXRpbC5hZGRQcm9taXNlcyhBV1MuUzMuTWFuYWdlZFVwbG9hZCk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlMzLk1hbmFnZWRVcGxvYWQ7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKiBAIW1ldGhvZCBvbihldmVudE5hbWUsIGNhbGxiYWNrKVxuICogICBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2sgZm9yIHRoZSBldmVudCBnaXZlbiBieSBgZXZlbnROYW1lYC5cbiAqICAgUGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGRlcGVuZCBvbiB0aGUgaW5kaXZpZHVhbCBldmVudFxuICogICBiZWluZyB0cmlnZ2VyZWQuIFNlZSB0aGUgZXZlbnQgZG9jdW1lbnRhdGlvbiBmb3IgdGhvc2UgcGFyYW1ldGVycy5cbiAqXG4gKiAgIEBwYXJhbSBldmVudE5hbWUgW1N0cmluZ10gdGhlIGV2ZW50IG5hbWUgdG8gcmVnaXN0ZXIgdGhlIGxpc3RlbmVyIGZvclxuICogICBAcGFyYW0gY2FsbGJhY2sgW0Z1bmN0aW9uXSB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgQHBhcmFtIHRvSGVhZCBbQm9vbGVhbl0gYXR0YWNoIHRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byB0aGUgaGVhZCBvZiBjYWxsYmFjayBhcnJheSBpZiBzZXQgdG8gdHJ1ZS5cbiAqICAgICBEZWZhdWx0IHRvIGJlIGZhbHNlLlxuICogICBAcmV0dXJuIFtBV1MuU2VxdWVudGlhbEV4ZWN1dG9yXSB0aGUgc2FtZSBvYmplY3QgZm9yIGNoYWluaW5nXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IgPSBBV1MudXRpbC5pbmhlcml0KHtcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gU2VxdWVudGlhbEV4ZWN1dG9yKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHNbZXZlbnROYW1lXSA/IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdLnNsaWNlKDApIDogW107XG4gIH0sXG5cbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCkge1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgdG9IZWFkID9cbiAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0udW5zaGlmdChsaXN0ZW5lcikgOlxuICAgICAgICB0aGlzLl9ldmVudHNbZXZlbnROYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBbbGlzdGVuZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbkFzeW5jOiBmdW5jdGlvbiBvbkFzeW5jKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRvSGVhZCkge1xuICAgIGxpc3RlbmVyLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyLCB0b0hlYWQpO1xuICB9LFxuXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgdmFyIHBvc2l0aW9uID0gLTE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPiAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudE5hbWUsIGV2ZW50QXJncywgZG9uZUNhbGxiYWNrKSB7XG4gICAgaWYgKCFkb25lQ2FsbGJhY2spIGRvbmVDYWxsYmFjayA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpO1xuICAgIHZhciBjb3VudCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgdGhpcy5jYWxsTGlzdGVuZXJzKGxpc3RlbmVycywgZXZlbnRBcmdzLCBkb25lQ2FsbGJhY2spO1xuICAgIHJldHVybiBjb3VudCA+IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FsbExpc3RlbmVyczogZnVuY3Rpb24gY2FsbExpc3RlbmVycyhsaXN0ZW5lcnMsIGFyZ3MsIGRvbmVDYWxsYmFjaywgcHJldkVycm9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlcnJvciA9IHByZXZFcnJvciB8fCBudWxsO1xuXG4gICAgZnVuY3Rpb24gY2FsbE5leHRMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwgZXJyKTtcbiAgICAgICAgaWYgKHNlbGYuX2hhbHRIYW5kbGVyc09uRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZWxmLmNhbGxMaXN0ZW5lcnMobGlzdGVuZXJzLCBhcmdzLCBkb25lQ2FsbGJhY2ssIGVycm9yKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVycy5zaGlmdCgpO1xuICAgICAgaWYgKGxpc3RlbmVyLl9pc0FzeW5jKSB7IC8vIGFzeW5jaHJvbm91cyBsaXN0ZW5lclxuICAgICAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChbY2FsbE5leHRMaXN0ZW5lcl0pKTtcbiAgICAgICAgcmV0dXJuOyAvLyBzdG9wIGhlcmUsIGNhbGxOZXh0TGlzdGVuZXIgd2lsbCBjb250aW51ZVxuICAgICAgfSBlbHNlIHsgLy8gc3luY2hyb25vdXMgbGlzdGVuZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBBV1MudXRpbC5lcnJvcihlcnJvciB8fCBuZXcgRXJyb3IoKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgc2VsZi5faGFsdEhhbmRsZXJzT25FcnJvcikge1xuICAgICAgICAgIGRvbmVDYWxsYmFjay5jYWxsKHNlbGYsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZG9uZUNhbGxiYWNrLmNhbGwoc2VsZiwgZXJyb3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIGNvcGllcyBhIHNldCBvZiBsaXN0ZW5lcnMgZnJvbSBhbm90aGVyIGxpc3Qgb2ZcbiAgICogbGlzdGVuZXJzIG9yIFNlcXVlbnRpYWxFeGVjdXRvciBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0ZW5lcnMgW21hcDxTdHJpbmcsQXJyYXk8RnVuY3Rpb24+PiwgQVdTLlNlcXVlbnRpYWxFeGVjdXRvcl1cbiAgICogICBhIGxpc3Qgb2YgZXZlbnRzIGFuZCBjYWxsYmFja3MsIG9yIGFuIGV2ZW50IGVtaXR0ZXIgb2JqZWN0XG4gICAqICAgY29udGFpbmluZyBsaXN0ZW5lcnMgdG8gYWRkIHRvIHRoaXMgZW1pdHRlciBvYmplY3QuXG4gICAqIEByZXR1cm4gW0FXUy5TZXF1ZW50aWFsRXhlY3V0b3JdIHRoZSBlbWl0dGVyIG9iamVjdCwgZm9yIGNoYWluaW5nLlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgbGlzdGVuZXJzIGZyb20gYSBtYXAgb2YgbGlzdGVuZXJzXG4gICAqICAgZW1pdHRlci5hZGRMaXN0ZW5lcnMoe1xuICAgKiAgICAgZXZlbnQxOiBbZnVuY3Rpb24oKSB7IC4uLiB9LCBmdW5jdGlvbigpIHsgLi4uIH1dLFxuICAgKiAgICAgZXZlbnQyOiBbZnVuY3Rpb24oKSB7IC4uLiB9XVxuICAgKiAgIH0pO1xuICAgKiAgIGVtaXR0ZXIuZW1pdCgnZXZlbnQxJyk7IC8vIGVtaXR0ZXIgaGFzIGV2ZW50MVxuICAgKiAgIGVtaXR0ZXIuZW1pdCgnZXZlbnQyJyk7IC8vIGVtaXR0ZXIgaGFzIGV2ZW50MlxuICAgKiBAZXhhbXBsZSBBZGRpbmcgbGlzdGVuZXJzIGZyb20gYW5vdGhlciBlbWl0dGVyIG9iamVjdFxuICAgKiAgIHZhciBlbWl0dGVyMSA9IG5ldyBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yKCk7XG4gICAqICAgZW1pdHRlcjEub24oJ2V2ZW50MScsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgZW1pdHRlcjEub24oJ2V2ZW50MicsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgdmFyIGVtaXR0ZXIyID0gbmV3IEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IoKTtcbiAgICogICBlbWl0dGVyMi5hZGRMaXN0ZW5lcnMoZW1pdHRlcjEpO1xuICAgKiAgIGVtaXR0ZXIyLmVtaXQoJ2V2ZW50MScpOyAvLyBlbWl0dGVyMiBoYXMgZXZlbnQxXG4gICAqICAgZW1pdHRlcjIuZW1pdCgnZXZlbnQyJyk7IC8vIGVtaXR0ZXIyIGhhcyBldmVudDJcbiAgICovXG4gIGFkZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGxpc3RlbmVycykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGlmIHBhcmFtZXRlciBpcyBhbiBTZXF1ZW50aWFsRXhlY3V0b3Igb2JqZWN0XG4gICAgaWYgKGxpc3RlbmVycy5fZXZlbnRzKSBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuX2V2ZW50cztcblxuICAgIEFXUy51dGlsLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihldmVudCwgY2FsbGJhY2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2tzID0gW2NhbGxiYWNrc107XG4gICAgICBBV1MudXRpbC5hcnJheUVhY2goY2FsbGJhY2tzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBzZWxmLm9uKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgd2l0aCB7b259IGFuZCBzYXZlcyB0aGUgY2FsbGJhY2sgaGFuZGxlIGZ1bmN0aW9uXG4gICAqIGFzIGEgcHJvcGVydHkgb24gdGhlIGVtaXR0ZXIgb2JqZWN0IHVzaW5nIGEgZ2l2ZW4gYG5hbWVgLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgcHJvcGVydHkgbmFtZSB0byBzZXQgb24gdGhpcyBvYmplY3QgY29udGFpbmluZ1xuICAgKiAgIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBoYW5kbGUgc28gdGhhdCB0aGUgbGlzdGVuZXIgY2FuIGJlIHJlbW92ZWQgaW5cbiAgICogICB0aGUgZnV0dXJlLlxuICAgKiBAcGFyYW0gKHNlZSBvbilcbiAgICogQHJldHVybiAoc2VlIG9uKVxuICAgKiBAZXhhbXBsZSBBZGRpbmcgYSBuYW1lZCBsaXN0ZW5lciBEQVRBX0NBTExCQUNLXG4gICAqICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7IGRvU29tZXRoaW5nKCk7IH07XG4gICAqICAgZW1pdHRlci5hZGROYW1lZExpc3RlbmVyKCdEQVRBX0NBTExCQUNLJywgJ2RhdGEnLCBsaXN0ZW5lcik7XG4gICAqXG4gICAqICAgLy8gdGhlIGZvbGxvd2luZyBwcmludHM6IHRydWVcbiAgICogICBjb25zb2xlLmxvZyhlbWl0dGVyLkRBVEFfQ0FMTEJBQ0sgPT0gbGlzdGVuZXIpO1xuICAgKi9cbiAgYWRkTmFtZWRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRMaXN0ZW5lcihuYW1lLCBldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpIHtcbiAgICB0aGlzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB0b0hlYWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZE5hbWVkQXN5bmNMaXN0ZW5lcjogZnVuY3Rpb24gYWRkTmFtZWRBc3luY0xpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCkge1xuICAgIGNhbGxiYWNrLl9pc0FzeW5jID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5hZGROYW1lZExpc3RlbmVyKG5hbWUsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHRvSGVhZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWRkIGEgc2V0IG9mIG5hbWVkIGxpc3RlbmVycyB1c2luZ1xuICAgKiB7YWRkTmFtZWRMaXN0ZW5lcn0uIFRoZSBjYWxsYmFjayBjb250YWlucyBhIHBhcmFtZXRlclxuICAgKiB3aXRoIGEgaGFuZGxlIHRvIHRoZSBgYWRkTmFtZWRMaXN0ZW5lcmAgbWV0aG9kLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oYWRkKVxuICAgKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgaW1tZWRpYXRlbHkgaW4gb3JkZXIgdG8gcHJvdmlkZVxuICAgKiAgIHRoZSBgYWRkYCBmdW5jdGlvbiB0byB0aGUgYmxvY2suIFRoaXMgc2ltcGxpZmllcyB0aGUgYWRkaXRpb24gb2ZcbiAgICogICBhIGxhcmdlIGdyb3VwIG9mIG5hbWVkIGxpc3RlbmVycy5cbiAgICogICBAcGFyYW0gYWRkIFtGdW5jdGlvbl0gdGhlIHthZGROYW1lZExpc3RlbmVyfSBmdW5jdGlvbiB0byBjYWxsXG4gICAqICAgICB3aGVuIHJlZ2lzdGVyaW5nIGxpc3RlbmVycy5cbiAgICogQGV4YW1wbGUgQWRkaW5nIGEgc2V0IG9mIG5hbWVkIGxpc3RlbmVyc1xuICAgKiAgIGVtaXR0ZXIuYWRkTmFtZWRMaXN0ZW5lcnMoZnVuY3Rpb24oYWRkKSB7XG4gICAqICAgICBhZGQoJ0RBVEFfQ0FMTEJBQ0snLCAnZGF0YScsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgICBhZGQoJ09USEVSJywgJ290aGVyRXZlbnQnLCBmdW5jdGlvbigpIHsgLi4uIH0pO1xuICAgKiAgICAgYWRkKCdMQVNUJywgJ2xhc3RFdmVudCcsIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgLy8gdGhlc2UgcHJvcGVydGllcyBhcmUgbm93IHNldDpcbiAgICogICBlbWl0dGVyLkRBVEFfQ0FMTEJBQ0s7XG4gICAqICAgZW1pdHRlci5PVEhFUjtcbiAgICogICBlbWl0dGVyLkxBU1Q7XG4gICAqL1xuICBhZGROYW1lZExpc3RlbmVyczogZnVuY3Rpb24gYWRkTmFtZWRMaXN0ZW5lcnMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgY2FsbGJhY2soXG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5hZGROYW1lZExpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuYWRkTmFtZWRBc3luY0xpc3RlbmVyLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qKlxuICoge29ufSBpcyB0aGUgcHJlZmVyZWQgbWV0aG9kLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TZXF1ZW50aWFsRXhlY3V0b3IucHJvdG90eXBlLmFkZExpc3RlbmVyID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5wcm90b3R5cGUub247XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNlcXVlbnRpYWxFeGVjdXRvcjtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBBcGkgPSByZXF1aXJlKCcuL21vZGVsL2FwaScpO1xudmFyIHJlZ2lvbkNvbmZpZyA9IHJlcXVpcmUoJy4vcmVnaW9uX2NvbmZpZycpO1xuXG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG52YXIgY2xpZW50Q291bnQgPSAwO1xudmFyIHJlZ2lvbl91dGlscyA9IHJlcXVpcmUoJy4vcmVnaW9uL3V0aWxzJyk7XG5cbi8qKlxuICogVGhlIHNlcnZpY2UgY2xhc3MgcmVwcmVzZW50aW5nIGFuIEFXUyBzZXJ2aWNlLlxuICpcbiAqIEBjbGFzc19hYnN0cmFjdCBUaGlzIGNsYXNzIGlzIGFuIGFic3RyYWN0IGNsYXNzLlxuICpcbiAqIEAhYXR0cmlidXRlIGFwaVZlcnNpb25zXG4gKiAgIEByZXR1cm4gW0FycmF5PFN0cmluZz5dIHRoZSBsaXN0IG9mIEFQSSB2ZXJzaW9ucyBzdXBwb3J0ZWQgYnkgdGhpcyBzZXJ2aWNlLlxuICogICBAcmVhZG9ubHlcbiAqL1xuQVdTLlNlcnZpY2UgPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJ2aWNlIG9iamVjdCB3aXRoIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZyBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBTZXJ2aWNlKGNvbmZpZykge1xuICAgIGlmICghdGhpcy5sb2FkU2VydmljZUNsYXNzKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgJ1NlcnZpY2UgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGBuZXdcXCcgb3BlcmF0b3InKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLnJlZ2lvbikge1xuICAgICAgICB2YXIgcmVnaW9uID0gY29uZmlnLnJlZ2lvbjtcbiAgICAgICAgaWYgKHJlZ2lvbl91dGlscy5pc0ZpcHNSZWdpb24ocmVnaW9uKSkge1xuICAgICAgICAgIGNvbmZpZy5yZWdpb24gPSByZWdpb25fdXRpbHMuZ2V0UmVhbFJlZ2lvbihyZWdpb24pO1xuICAgICAgICAgIGNvbmZpZy51c2VGaXBzRW5kcG9pbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpb25fdXRpbHMuaXNHbG9iYWxSZWdpb24ocmVnaW9uKSkge1xuICAgICAgICAgIGNvbmZpZy5yZWdpb24gPSByZWdpb25fdXRpbHMuZ2V0UmVhbFJlZ2lvbihyZWdpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy51c2VEdWFsc3RhY2sgPT09ICdib29sZWFuJ1xuICAgICAgICAmJiB0eXBlb2YgY29uZmlnLnVzZUR1YWxzdGFja0VuZHBvaW50ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgY29uZmlnLnVzZUR1YWxzdGFja0VuZHBvaW50ID0gY29uZmlnLnVzZUR1YWxzdGFjaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU2VydmljZUNsYXNzID0gdGhpcy5sb2FkU2VydmljZUNsYXNzKGNvbmZpZyB8fCB7fSk7XG4gICAgaWYgKFNlcnZpY2VDbGFzcykge1xuICAgICAgdmFyIG9yaWdpbmFsQ29uZmlnID0gQVdTLnV0aWwuY29weShjb25maWcpO1xuICAgICAgdmFyIHN2YyA9IG5ldyBTZXJ2aWNlQ2xhc3MoY29uZmlnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdmMsICdfb3JpZ2luYWxDb25maWcnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBvcmlnaW5hbENvbmZpZzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzdmMuX2NsaWVudElkID0gKytjbGllbnRDb3VudDtcbiAgICAgIHJldHVybiBzdmM7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoY29uZmlnKSB7XG4gICAgdmFyIHN2Y0NvbmZpZyA9IEFXUy5jb25maWdbdGhpcy5zZXJ2aWNlSWRlbnRpZmllcl07XG4gICAgdGhpcy5jb25maWcgPSBuZXcgQVdTLkNvbmZpZyhBV1MuY29uZmlnKTtcbiAgICBpZiAoc3ZjQ29uZmlnKSB0aGlzLmNvbmZpZy51cGRhdGUoc3ZjQ29uZmlnLCB0cnVlKTtcbiAgICBpZiAoY29uZmlnKSB0aGlzLmNvbmZpZy51cGRhdGUoY29uZmlnLCB0cnVlKTtcblxuICAgIHRoaXMudmFsaWRhdGVTZXJ2aWNlKCk7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmRwb2ludCkgcmVnaW9uQ29uZmlnLmNvbmZpZ3VyZUVuZHBvaW50KHRoaXMpO1xuXG4gICAgdGhpcy5jb25maWcuZW5kcG9pbnQgPSB0aGlzLmVuZHBvaW50RnJvbVRlbXBsYXRlKHRoaXMuY29uZmlnLmVuZHBvaW50KTtcbiAgICB0aGlzLnNldEVuZHBvaW50KHRoaXMuY29uZmlnLmVuZHBvaW50KTtcbiAgICAvL2VuYWJsZSBhdHRhY2hpbmcgbGlzdGVuZXJzIHRvIHNlcnZpY2UgY2xpZW50XG4gICAgQVdTLlNlcXVlbnRpYWxFeGVjdXRvci5jYWxsKHRoaXMpO1xuICAgIEFXUy5TZXJ2aWNlLmFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzKHRoaXMpO1xuICAgIGlmICgodGhpcy5jb25maWcuY2xpZW50U2lkZU1vbml0b3JpbmcgfHwgQVdTLlNlcnZpY2UuX2NsaWVudFNpZGVNb25pdG9yaW5nKSAmJiB0aGlzLnB1Ymxpc2hlcikge1xuICAgICAgdmFyIHB1Ymxpc2hlciA9IHRoaXMucHVibGlzaGVyO1xuICAgICAgdGhpcy5hZGROYW1lZExpc3RlbmVyKCdQVUJMSVNIX0FQSV9DQUxMJywgJ2FwaUNhbGwnLCBmdW5jdGlvbiBQVUJMSVNIX0FQSV9DQUxMKGV2ZW50KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7cHVibGlzaGVyLmV2ZW50SGFuZGxlcihldmVudCk7fSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkTmFtZWRMaXN0ZW5lcignUFVCTElTSF9BUElfQVRURU1QVCcsICdhcGlDYWxsQXR0ZW1wdCcsIGZ1bmN0aW9uIFBVQkxJU0hfQVBJX0FUVEVNUFQoZXZlbnQpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtwdWJsaXNoZXIuZXZlbnRIYW5kbGVyKGV2ZW50KTt9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZVNlcnZpY2U6IGZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZSgpIHtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBsb2FkU2VydmljZUNsYXNzOiBmdW5jdGlvbiBsb2FkU2VydmljZUNsYXNzKHNlcnZpY2VDb25maWcpIHtcbiAgICB2YXIgY29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICBpZiAoIUFXUy51dGlsLmlzRW1wdHkodGhpcy5hcGkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5hcGlDb25maWcpIHtcbiAgICAgIHJldHVybiBBV1MuU2VydmljZS5kZWZpbmVTZXJ2aWNlQXBpKHRoaXMuY29uc3RydWN0b3IsIGNvbmZpZy5hcGlDb25maWcpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcgPSBuZXcgQVdTLkNvbmZpZyhBV1MuY29uZmlnKTtcbiAgICAgIGNvbmZpZy51cGRhdGUoc2VydmljZUNvbmZpZywgdHJ1ZSk7XG4gICAgICB2YXIgdmVyc2lvbiA9IGNvbmZpZy5hcGlWZXJzaW9uc1t0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyXTtcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uIHx8IGNvbmZpZy5hcGlWZXJzaW9uO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0U2VydmljZUNsYXNzKHZlcnNpb24pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRMYXRlc3RTZXJ2aWNlQ2xhc3M6IGZ1bmN0aW9uIGdldExhdGVzdFNlcnZpY2VDbGFzcyh2ZXJzaW9uKSB7XG4gICAgdmVyc2lvbiA9IHRoaXMuZ2V0TGF0ZXN0U2VydmljZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXNbdmVyc2lvbl0gPT09IG51bGwpIHtcbiAgICAgIEFXUy5TZXJ2aWNlLmRlZmluZVNlcnZpY2VBcGkodGhpcy5jb25zdHJ1Y3RvciwgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc2VydmljZXNbdmVyc2lvbl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGF0ZXN0U2VydmljZVZlcnNpb246IGZ1bmN0aW9uIGdldExhdGVzdFNlcnZpY2VWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3Iuc2VydmljZXMgfHwgdGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VydmljZXMgZGVmaW5lZCBvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSAnbGF0ZXN0JztcbiAgICB9IGVsc2UgaWYgKEFXUy51dGlsLmlzVHlwZSh2ZXJzaW9uLCBEYXRlKSkge1xuICAgICAgdmVyc2lvbiA9IEFXUy51dGlsLmRhdGUuaXNvODYwMSh2ZXJzaW9uKS5zcGxpdCgnVCcpWzBdO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkodGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcywgdmVyc2lvbikpIHtcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5zZXJ2aWNlcykuc29ydCgpO1xuICAgIHZhciBzZWxlY3RlZFZlcnNpb24gPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAvLyB2ZXJzaW9ucyB0aGF0IGVuZCBpbiBcIipcIiBhcmUgbm90IGF2YWlsYWJsZSBvbiBkaXNrIGFuZCBjYW4gYmVcbiAgICAgIC8vIHNraXBwZWQsIHNvIGRvIG5vdCBjaG9vc2UgdGhlc2UgYXMgc2VsZWN0ZWRWZXJzaW9uc1xuICAgICAgaWYgKGtleXNbaV1ba2V5c1tpXS5sZW5ndGggLSAxXSAhPT0gJyonKSB7XG4gICAgICAgIHNlbGVjdGVkVmVyc2lvbiA9IGtleXNbaV07XG4gICAgICB9XG4gICAgICBpZiAoa2V5c1tpXS5zdWJzdHIoMCwgMTApIDw9IHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kICcgKyB0aGlzLmNvbnN0cnVjdG9yLnNlcnZpY2VJZGVudGlmaWVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBBUEkgdG8gc2F0aXNmeSB2ZXJzaW9uIGNvbnN0cmFpbnQgYCcgKyB2ZXJzaW9uICsgJ1xcJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaToge30sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZGVmYXVsdFJldHJ5Q291bnQ6IDMsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY3VzdG9taXplUmVxdWVzdHM6IGZ1bmN0aW9uIGN1c3RvbWl6ZVJlcXVlc3RzKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0SGFuZGxlciA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPSBjYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNhbGxiYWNrIHR5cGUgXFwnJyArIHR5cGVvZiBjYWxsYmFjayArICdcXCcgcHJvdmlkZWQgaW4gY3VzdG9taXplUmVxdWVzdHMnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxzIGFuIG9wZXJhdGlvbiBvbiBhIHNlcnZpY2Ugd2l0aCB0aGUgZ2l2ZW4gaW5wdXQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRvIGNhbGwgb24gdGhlIHNlcnZpY2UuXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gYSBtYXAgb2YgaW5wdXQgb3B0aW9ucyBmb3IgdGhlIG9wZXJhdGlvblxuICAgKiBAY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24oZXJyLCBkYXRhKVxuICAgKiAgIElmIGEgY2FsbGJhY2sgaXMgc3VwcGxpZWQsIGl0IGlzIGNhbGxlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmV0dXJuZWRcbiAgICogICBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgKiAgIEBwYXJhbSBlcnIgW0Vycm9yXSB0aGUgZXJyb3Igb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIHJlcXVlc3QuXG4gICAqICAgICBTZXQgdG8gYG51bGxgIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqICAgQHBhcmFtIGRhdGEgW09iamVjdF0gdGhlIGRlLXNlcmlhbGl6ZWQgZGF0YSByZXR1cm5lZCBmcm9tXG4gICAqICAgICB0aGUgcmVxdWVzdC4gU2V0IHRvIGBudWxsYCBpZiBhIHJlcXVlc3QgZXJyb3Igb2NjdXJzLlxuICAgKi9cbiAgbWFrZVJlcXVlc3Q6IGZ1bmN0aW9uIG1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgIGlmICh0aGlzLmNvbmZpZy5wYXJhbXMpIHsgLy8gY29weSBvbmx5IHRvcGxldmVsIGJvdW5kIHBhcmFtc1xuICAgICAgdmFyIHJ1bGVzID0gdGhpcy5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dO1xuICAgICAgaWYgKHJ1bGVzKSB7XG4gICAgICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcbiAgICAgICAgQVdTLnV0aWwuZWFjaCh0aGlzLmNvbmZpZy5wYXJhbXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAocnVsZXMuaW5wdXQubWVtYmVyc1trZXldKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zW2tleV0gPT09IHVuZGVmaW5lZCB8fCBwYXJhbXNba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgQVdTLlJlcXVlc3QodGhpcywgb3BlcmF0aW9uLCBwYXJhbXMpO1xuICAgIHRoaXMuYWRkQWxsUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KTtcbiAgICB0aGlzLmF0dGFjaE1vbml0b3JpbmdFbWl0dGVyKHJlcXVlc3QpO1xuICAgIGlmIChjYWxsYmFjaykgcmVxdWVzdC5zZW5kKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbHMgYW4gb3BlcmF0aW9uIG9uIGEgc2VydmljZSB3aXRoIHRoZSBnaXZlbiBpbnB1dCBwYXJhbWV0ZXJzLCB3aXRob3V0XG4gICAqIGFueSBhdXRoZW50aWNhdGlvbiBkYXRhLiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgZm9yIFwicHVibGljXCIgQVBJIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsIG9uIHRoZSBzZXJ2aWNlLlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdIGEgbWFwIG9mIGlucHV0IG9wdGlvbnMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIG1ha2VVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0OiBmdW5jdGlvbiBtYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3BlcmF0aW9uLCBwYXJhbXMpLnRvVW5hdXRoZW50aWNhdGVkKCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrID8gcmVxdWVzdC5zZW5kKGNhbGxiYWNrKSA6IHJlcXVlc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBhIGdpdmVuIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBbU3RyaW5nXSB0aGUgc3RhdGUgb24gdGhlIHNlcnZpY2UgdG8gd2FpdCBmb3JcbiAgICogQHBhcmFtIHBhcmFtcyBbbWFwXSBhIG1hcCBvZiBwYXJhbWV0ZXJzIHRvIHBhc3Mgd2l0aCBlYWNoIHJlcXVlc3RcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlciBbbWFwXSBhIG1hcCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSB3YWl0ZXJcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlci5kZWxheSBbTnVtYmVyXSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdHNcbiAgICogQG9wdGlvbiBwYXJhbXMgJHdhaXRlci5tYXhBdHRlbXB0cyBbTnVtYmVyXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVxdWVzdHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBzZW5kIHdoaWxlIHdhaXRpbmdcbiAgICogQGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uKGVyciwgZGF0YSlcbiAgICogICBJZiBhIGNhbGxiYWNrIGlzIHN1cHBsaWVkLCBpdCBpcyBjYWxsZWQgd2hlbiBhIHJlc3BvbnNlIGlzIHJldHVybmVkXG4gICAqICAgZnJvbSB0aGUgc2VydmljZS5cbiAgICogICBAcGFyYW0gZXJyIFtFcnJvcl0gdGhlIGVycm9yIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSByZXF1ZXN0LlxuICAgKiAgICAgU2V0IHRvIGBudWxsYCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICAgKiAgIEBwYXJhbSBkYXRhIFtPYmplY3RdIHRoZSBkZS1zZXJpYWxpemVkIGRhdGEgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhlIHJlcXVlc3QuIFNldCB0byBgbnVsbGAgaWYgYSByZXF1ZXN0IGVycm9yIG9jY3Vycy5cbiAgICovXG4gIHdhaXRGb3I6IGZ1bmN0aW9uIHdhaXRGb3Ioc3RhdGUsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgd2FpdGVyID0gbmV3IEFXUy5SZXNvdXJjZVdhaXRlcih0aGlzLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHdhaXRlci53YWl0KHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZEFsbFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIGFkZEFsbFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCkge1xuICAgIHZhciBsaXN0ID0gW0FXUy5ldmVudHMsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLCB0aGlzLnNlcnZpY2VJbnRlcmZhY2UoKSxcbiAgICAgICAgICAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZVBvc3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0pIHJlcXVlc3QuYWRkTGlzdGVuZXJzKGxpc3RbaV0pO1xuICAgIH1cblxuICAgIC8vIGRpc2FibGUgcGFyYW1ldGVyIHZhbGlkYXRpb25cbiAgICBpZiAoIXRoaXMuY29uZmlnLnBhcmFtVmFsaWRhdGlvbikge1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigndmFsaWRhdGUnLFxuICAgICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9QQVJBTUVURVJTKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcubG9nZ2VyKSB7IC8vIGFkZCBsb2dnaW5nIGV2ZW50c1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcnMoQVdTLkV2ZW50TGlzdGVuZXJzLkxvZ2dlcik7XG4gICAgfVxuXG4gICAgdGhpcy5zZXR1cFJlcXVlc3RMaXN0ZW5lcnMocmVxdWVzdCk7XG4gICAgLy8gY2FsbCBwcm90b3R5cGUncyBjdXN0b21SZXF1ZXN0SGFuZGxlclxuICAgIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY3VzdG9tUmVxdWVzdEhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmN1c3RvbVJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgIH1cbiAgICAvLyBjYWxsIGluc3RhbmNlJ3MgY3VzdG9tUmVxdWVzdEhhbmRsZXJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdjdXN0b21SZXF1ZXN0SGFuZGxlcicpICYmIHR5cGVvZiB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmN1c3RvbVJlcXVlc3RIYW5kbGVyKHJlcXVlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgcmVjb3JkaW5nIG1ldHJpY3MgZm9yIGEgd2hvbGUgQVBJIGNhbGwuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGEgc3Vic2V0IG9mIGFwaSBjYWxsIG1ldHJpY3NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcGlDYWxsRXZlbnQ6IGZ1bmN0aW9uIGFwaUNhbGxFdmVudChyZXF1ZXN0KSB7XG4gICAgdmFyIGFwaSA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXF1ZXN0Lm9wZXJhdGlvbl07XG4gICAgdmFyIG1vbml0b3JpbmdFdmVudCA9IHtcbiAgICAgIFR5cGU6ICdBcGlDYWxsJyxcbiAgICAgIEFwaTogYXBpID8gYXBpLm5hbWUgOiByZXF1ZXN0Lm9wZXJhdGlvbixcbiAgICAgIFZlcnNpb246IDEsXG4gICAgICBTZXJ2aWNlOiByZXF1ZXN0LnNlcnZpY2UuYXBpLnNlcnZpY2VJZCB8fCByZXF1ZXN0LnNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4LFxuICAgICAgUmVnaW9uOiByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbixcbiAgICAgIE1heFJldHJpZXNFeGNlZWRlZDogMCxcbiAgICAgIFVzZXJBZ2VudDogcmVxdWVzdC5odHRwUmVxdWVzdC5nZXRVc2VyQWdlbnQoKSxcbiAgICB9O1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuRmluYWxIdHRwU3RhdHVzQ29kZSA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIGlmIChzdGF0dXNDb2RlID4gMjk5KSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlKSBtb25pdG9yaW5nRXZlbnQuRmluYWxBd3NFeGNlcHRpb24gPSBlcnJvci5jb2RlO1xuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LkZpbmFsQXdzRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSB8fCBlcnJvci5uYW1lKSBtb25pdG9yaW5nRXZlbnQuRmluYWxTZGtFeGNlcHRpb24gPSBlcnJvci5jb2RlIHx8IGVycm9yLm5hbWU7XG4gICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSBtb25pdG9yaW5nRXZlbnQuRmluYWxTZGtFeGNlcHRpb25NZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vbml0b3JpbmdFdmVudDtcbiAgfSxcblxuICAvKipcbiAgICogRXZlbnQgcmVjb3JkaW5nIG1ldHJpY3MgZm9yIGFuIEFQSSBjYWxsIGF0dGVtcHQuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IGEgc3Vic2V0IG9mIGFwaSBjYWxsIGF0dGVtcHQgbWV0cmljc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFwaUF0dGVtcHRFdmVudDogZnVuY3Rpb24gYXBpQXR0ZW1wdEV2ZW50KHJlcXVlc3QpIHtcbiAgICB2YXIgYXBpID0gcmVxdWVzdC5zZXJ2aWNlLmFwaS5vcGVyYXRpb25zW3JlcXVlc3Qub3BlcmF0aW9uXTtcbiAgICB2YXIgbW9uaXRvcmluZ0V2ZW50ID0ge1xuICAgICAgVHlwZTogJ0FwaUNhbGxBdHRlbXB0JyxcbiAgICAgIEFwaTogYXBpID8gYXBpLm5hbWUgOiByZXF1ZXN0Lm9wZXJhdGlvbixcbiAgICAgIFZlcnNpb246IDEsXG4gICAgICBTZXJ2aWNlOiByZXF1ZXN0LnNlcnZpY2UuYXBpLnNlcnZpY2VJZCB8fCByZXF1ZXN0LnNlcnZpY2UuYXBpLmVuZHBvaW50UHJlZml4LFxuICAgICAgRnFkbjogcmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0bmFtZSxcbiAgICAgIFVzZXJBZ2VudDogcmVxdWVzdC5odHRwUmVxdWVzdC5nZXRVc2VyQWdlbnQoKSxcbiAgICB9O1xuICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuSHR0cFN0YXR1c0NvZGUgPSByZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIXJlcXVlc3QuX3VuQXV0aGVudGljYXRlZCAmJlxuICAgICAgcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscyAmJlxuICAgICAgcmVxdWVzdC5zZXJ2aWNlLmNvbmZpZy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZFxuICAgICkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LkFjY2Vzc0tleSA9IHJlcXVlc3Quc2VydmljZS5jb25maWcuY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UuaHR0cFJlc3BvbnNlLmhlYWRlcnMpIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gICAgaWYgKHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSkge1xuICAgICAgbW9uaXRvcmluZ0V2ZW50LlNlc3Npb25Ub2tlbiA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tcmVxdWVzdGlkJ10pIHtcbiAgICAgIG1vbml0b3JpbmdFdmVudC5YQW16blJlcXVlc3RJZCA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtem4tcmVxdWVzdGlkJ107XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotcmVxdWVzdC1pZCddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuWEFtelJlcXVlc3RJZCA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1yZXF1ZXN0LWlkJ107XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotaWQtMiddKSB7XG4gICAgICBtb25pdG9yaW5nRXZlbnQuWEFteklkMiA9IHJlc3BvbnNlLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1pZC0yJ107XG4gICAgfVxuICAgIHJldHVybiBtb25pdG9yaW5nRXZlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBtZXRyaWNzIG9mIGZhaWxlZCByZXF1ZXN0LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGF0dGVtcHRGYWlsRXZlbnQ6IGZ1bmN0aW9uIGF0dGVtcHRGYWlsRXZlbnQocmVxdWVzdCkge1xuICAgIHZhciBtb25pdG9yaW5nRXZlbnQgPSB0aGlzLmFwaUF0dGVtcHRFdmVudChyZXF1ZXN0KTtcbiAgICB2YXIgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIHZhciBlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuICAgIGlmIChyZXNwb25zZS5odHRwUmVzcG9uc2Uuc3RhdHVzQ29kZSA+IDI5OSApIHtcbiAgICAgIGlmIChlcnJvci5jb2RlKSBtb25pdG9yaW5nRXZlbnQuQXdzRXhjZXB0aW9uID0gZXJyb3IuY29kZTtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlKSBtb25pdG9yaW5nRXZlbnQuQXdzRXhjZXB0aW9uTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlcnJvci5jb2RlIHx8IGVycm9yLm5hbWUpIG1vbml0b3JpbmdFdmVudC5TZGtFeGNlcHRpb24gPSBlcnJvci5jb2RlIHx8IGVycm9yLm5hbWU7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZSkgbW9uaXRvcmluZ0V2ZW50LlNka0V4Y2VwdGlvbk1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gbW9uaXRvcmluZ0V2ZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdHRhY2ggbGlzdGVuZXJzIHRvIHJlcXVlc3Qgb2JqZWN0IHRvIGZldGNoIG1ldHJpY3Mgb2YgZWFjaCByZXF1ZXN0XG4gICAqIGFuZCBlbWl0IGRhdGEgb2JqZWN0IHRocm91Z2ggXFwnQXBpQ2FsbFxcJyBhbmQgXFwnQXBpQ2FsbEF0dGVtcHRcXCcgZXZlbnRzLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGF0dGFjaE1vbml0b3JpbmdFbWl0dGVyOiBmdW5jdGlvbiBhdHRhY2hNb25pdG9yaW5nRW1pdHRlcihyZXF1ZXN0KSB7XG4gICAgdmFyIGF0dGVtcHRUaW1lc3RhbXA7IC8vdGltZXN0YW1wIG1hcmtpbmcgdGhlIGJlZ2lubmluZyBvZiBhIHJlcXVlc3QgYXR0ZW1wdFxuICAgIHZhciBhdHRlbXB0U3RhcnRSZWFsVGltZTsgLy9TdGFydCB0aW1lIG9mIHJlcXVlc3QgYXR0ZW1wdC4gVXNlZCB0byBjYWxjdWxhdGluZyBhdHRlbXB0TGF0ZW5jeVxuICAgIHZhciBhdHRlbXB0TGF0ZW5jeTsgLy9sYXRlbmN5IGZyb20gcmVxdWVzdCBzZW50IG91dCB0byBodHRwIHJlc3BvbnNlIHJlYWNoaW5nIFNES1xuICAgIHZhciBjYWxsU3RhcnRSZWFsVGltZTsgLy9TdGFydCB0aW1lIG9mIEFQSSBjYWxsLiBVc2VkIHRvIGNhbGN1bGF0aW5nIEFQSSBjYWxsIGxhdGVuY3lcbiAgICB2YXIgYXR0ZW1wdENvdW50ID0gMDsgLy9yZXF1ZXN0LnJldHJ5Q291bnQgaXMgbm90IHJlbGlhYmxlIGhlcmVcbiAgICB2YXIgcmVnaW9uOyAvL3JlZ2lvbiBjYWNoZSByZWdpb24gZm9yIGVhY2ggYXR0ZW1wdCBzaW5jZSBpdCBjYW4gYmUgdXBkYXRlZCBpbiBwbGFzZSAoZS5nLiBzMylcbiAgICB2YXIgY2FsbFRpbWVzdGFtcDsgLy90aW1lc3RhbXAgd2hlbiB0aGUgcmVxdWVzdCBpcyBjcmVhdGVkXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhZGRUb0hlYWQgPSB0cnVlO1xuXG4gICAgcmVxdWVzdC5vbigndmFsaWRhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsU3RhcnRSZWFsVGltZSA9IEFXUy51dGlsLnJlYWxDbG9jay5ub3coKTtcbiAgICAgIGNhbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH0sIGFkZFRvSGVhZCk7XG4gICAgcmVxdWVzdC5vbignc2lnbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGF0dGVtcHRTdGFydFJlYWxUaW1lID0gQVdTLnV0aWwucmVhbENsb2NrLm5vdygpO1xuICAgICAgYXR0ZW1wdFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICByZWdpb24gPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbjtcbiAgICAgIGF0dGVtcHRDb3VudCsrO1xuICAgIH0sIGFkZFRvSGVhZCk7XG4gICAgcmVxdWVzdC5vbigndmFsaWRhdGVSZXNwb25zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgYXR0ZW1wdExhdGVuY3kgPSBNYXRoLnJvdW5kKEFXUy51dGlsLnJlYWxDbG9jay5ub3coKSAtIGF0dGVtcHRTdGFydFJlYWxUaW1lKTtcbiAgICB9KTtcbiAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0FQSV9DQUxMX0FUVEVNUFQnLCAnc3VjY2VzcycsIGZ1bmN0aW9uIEFQSV9DQUxMX0FUVEVNUFQoKSB7XG4gICAgICB2YXIgYXBpQXR0ZW1wdEV2ZW50ID0gc2VsZi5hcGlBdHRlbXB0RXZlbnQocmVxdWVzdCk7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuVGltZXN0YW1wID0gYXR0ZW1wdFRpbWVzdGFtcDtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5BdHRlbXB0TGF0ZW5jeSA9IGF0dGVtcHRMYXRlbmN5ID49IDAgPyBhdHRlbXB0TGF0ZW5jeSA6IDA7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuUmVnaW9uID0gcmVnaW9uO1xuICAgICAgc2VsZi5lbWl0KCdhcGlDYWxsQXR0ZW1wdCcsIFthcGlBdHRlbXB0RXZlbnRdKTtcbiAgICB9KTtcbiAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0FQSV9DQUxMX0FUVEVNUFRfUkVUUlknLCAncmV0cnknLCBmdW5jdGlvbiBBUElfQ0FMTF9BVFRFTVBUX1JFVFJZKCkge1xuICAgICAgdmFyIGFwaUF0dGVtcHRFdmVudCA9IHNlbGYuYXR0ZW1wdEZhaWxFdmVudChyZXF1ZXN0KTtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5UaW1lc3RhbXAgPSBhdHRlbXB0VGltZXN0YW1wO1xuICAgICAgLy9hdHRlbXB0TGF0ZW5jeSBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBmYWlsIGJlZm9yZSByZXNwb25zZVxuICAgICAgYXR0ZW1wdExhdGVuY3kgPSBhdHRlbXB0TGF0ZW5jeSB8fFxuICAgICAgICBNYXRoLnJvdW5kKEFXUy51dGlsLnJlYWxDbG9jay5ub3coKSAtIGF0dGVtcHRTdGFydFJlYWxUaW1lKTtcbiAgICAgIGFwaUF0dGVtcHRFdmVudC5BdHRlbXB0TGF0ZW5jeSA9IGF0dGVtcHRMYXRlbmN5ID49IDAgPyBhdHRlbXB0TGF0ZW5jeSA6IDA7XG4gICAgICBhcGlBdHRlbXB0RXZlbnQuUmVnaW9uID0gcmVnaW9uO1xuICAgICAgc2VsZi5lbWl0KCdhcGlDYWxsQXR0ZW1wdCcsIFthcGlBdHRlbXB0RXZlbnRdKTtcbiAgICB9KTtcbiAgICByZXF1ZXN0LmFkZE5hbWVkTGlzdGVuZXIoJ0FQSV9DQUxMJywgJ2NvbXBsZXRlJywgZnVuY3Rpb24gQVBJX0NBTEwoKSB7XG4gICAgICB2YXIgYXBpQ2FsbEV2ZW50ID0gc2VsZi5hcGlDYWxsRXZlbnQocmVxdWVzdCk7XG4gICAgICBhcGlDYWxsRXZlbnQuQXR0ZW1wdENvdW50ID0gYXR0ZW1wdENvdW50O1xuICAgICAgaWYgKGFwaUNhbGxFdmVudC5BdHRlbXB0Q291bnQgPD0gMCkgcmV0dXJuO1xuICAgICAgYXBpQ2FsbEV2ZW50LlRpbWVzdGFtcCA9IGNhbGxUaW1lc3RhbXA7XG4gICAgICB2YXIgbGF0ZW5jeSA9IE1hdGgucm91bmQoQVdTLnV0aWwucmVhbENsb2NrLm5vdygpIC0gY2FsbFN0YXJ0UmVhbFRpbWUpO1xuICAgICAgYXBpQ2FsbEV2ZW50LkxhdGVuY3kgPSBsYXRlbmN5ID49IDAgPyBsYXRlbmN5IDogMDtcbiAgICAgIHZhciByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgIHJlc3BvbnNlLmVycm9yLnJldHJ5YWJsZSAmJlxuICAgICAgICB0eXBlb2YgcmVzcG9uc2UucmV0cnlDb3VudCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIHJlc3BvbnNlLm1heFJldHJpZXMgPT09ICdudW1iZXInICYmXG4gICAgICAgIChyZXNwb25zZS5yZXRyeUNvdW50ID49IHJlc3BvbnNlLm1heFJldHJpZXMpXG4gICAgICApIHtcbiAgICAgICAgYXBpQ2FsbEV2ZW50Lk1heFJldHJpZXNFeGNlZWRlZCA9IDE7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ2FwaUNhbGwnLCBbYXBpQ2FsbEV2ZW50XSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHNldHVwIGFueSBjdXN0b20gcmVxdWVzdCBsaXN0ZW5lcnMgZm9yIGVhY2hcbiAgICogbmV3IHJlcXVlc3QgdG8gdGhlIHNlcnZpY2UuXG4gICAqXG4gICAqIEBtZXRob2RfYWJzdHJhY3QgVGhpcyBpcyBhbiBhYnN0cmFjdCBtZXRob2QuXG4gICAqL1xuICBzZXR1cFJlcXVlc3RMaXN0ZW5lcnM6IGZ1bmN0aW9uIHNldHVwUmVxdWVzdExpc3RlbmVycyhyZXF1ZXN0KSB7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpZ25pbmcgbmFtZSBmb3IgYSBnaXZlbiByZXF1ZXN0XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmluZ05hbWU6IGZ1bmN0aW9uIGdldFNpZ25pbmdOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmFwaS5zaWduaW5nTmFtZSB8fCB0aGlzLmFwaS5lbmRwb2ludFByZWZpeDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2lnbmVyIGNsYXNzIGZvciBhIGdpdmVuIHJlcXVlc3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduZXJDbGFzczogZnVuY3Rpb24gZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCkge1xuICAgIHZhciB2ZXJzaW9uO1xuICAgIC8vIGdldCBvcGVyYXRpb24gYXV0aHR5cGUgaWYgcHJlc2VudFxuICAgIHZhciBvcGVyYXRpb24gPSBudWxsO1xuICAgIHZhciBhdXRodHlwZSA9ICcnO1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICB2YXIgb3BlcmF0aW9ucyA9IHJlcXVlc3Quc2VydmljZS5hcGkub3BlcmF0aW9ucyB8fCB7fTtcbiAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbcmVxdWVzdC5vcGVyYXRpb25dIHx8IG51bGw7XG4gICAgICBhdXRodHlwZSA9IG9wZXJhdGlvbiA/IG9wZXJhdGlvbi5hdXRodHlwZSA6ICcnO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcuc2lnbmF0dXJlVmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb247XG4gICAgfSBlbHNlIGlmIChhdXRodHlwZSA9PT0gJ3Y0JyB8fCBhdXRodHlwZSA9PT0gJ3Y0LXVuc2lnbmVkLWJvZHknKSB7XG4gICAgICB2ZXJzaW9uID0gJ3Y0JztcbiAgICB9IGVsc2UgaWYgKGF1dGh0eXBlID09PSAnYmVhcmVyJykge1xuICAgICAgdmVyc2lvbiA9ICdiZWFyZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzaW9uID0gdGhpcy5hcGkuc2lnbmF0dXJlVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuZ2V0VmVyc2lvbih2ZXJzaW9uKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXJ2aWNlSW50ZXJmYWNlOiBmdW5jdGlvbiBzZXJ2aWNlSW50ZXJmYWNlKCkge1xuICAgIHN3aXRjaCAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgJ2VjMic6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUXVlcnk7XG4gICAgICBjYXNlICdxdWVyeSc6IHJldHVybiBBV1MuRXZlbnRMaXN0ZW5lcnMuUXVlcnk7XG4gICAgICBjYXNlICdqc29uJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5Kc29uO1xuICAgICAgY2FzZSAncmVzdC1qc29uJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5SZXN0SnNvbjtcbiAgICAgIGNhc2UgJ3Jlc3QteG1sJzogcmV0dXJuIEFXUy5FdmVudExpc3RlbmVycy5SZXN0WG1sO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcGkucHJvdG9jb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGBwcm90b2NvbFxcJyAnICtcbiAgICAgICAgdGhpcy5hcGkucHJvdG9jb2wgKyAnIGluIEFQSSBjb25maWcnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlOiBmdW5jdGlvbiBzdWNjZXNzZnVsUmVzcG9uc2UocmVzcCkge1xuICAgIHJldHVybiByZXNwLmh0dHBSZXNwb25zZS5zdGF0dXNDb2RlIDwgMzAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIb3cgbWFueSB0aW1lcyBhIGZhaWxlZCByZXF1ZXN0IHNob3VsZCBiZSByZXRyaWVkIGJlZm9yZSBnaXZpbmcgdXAuXG4gICAqIHRoZSBkZWZhdWx0UmV0cnlDb3VudCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHNlcnZpY2UgY2xhc3Nlcy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBudW1SZXRyaWVzOiBmdW5jdGlvbiBudW1SZXRyaWVzKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5tYXhSZXRyaWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0UmV0cnlDb3VudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlEZWxheXM6IGZ1bmN0aW9uIHJldHJ5RGVsYXlzKHJldHJ5Q291bnQsIGVycikge1xuICAgIHJldHVybiBBV1MudXRpbC5jYWxjdWxhdGVSZXRyeURlbGF5KHJldHJ5Q291bnQsIHRoaXMuY29uZmlnLnJldHJ5RGVsYXlPcHRpb25zLCBlcnIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJldHJ5YWJsZUVycm9yOiBmdW5jdGlvbiByZXRyeWFibGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnRpbWVvdXRFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLm5ldHdvcmtpbmdFcnJvcihlcnJvcikpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmV4cGlyZWRDcmVkZW50aWFsc0Vycm9yKGVycm9yKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMudGhyb3R0bGVkRXJyb3IoZXJyb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA+PSA1MDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBuZXR3b3JraW5nRXJyb3I6IGZ1bmN0aW9uIG5ldHdvcmtpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnTmV0d29ya2luZ0Vycm9yJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0aW1lb3V0RXJyb3I6IGZ1bmN0aW9uIHRpbWVvdXRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5jb2RlID09PSAnVGltZW91dEVycm9yJztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHBpcmVkQ3JlZGVudGlhbHNFcnJvcjogZnVuY3Rpb24gZXhwaXJlZENyZWRlbnRpYWxzRXJyb3IoZXJyb3IpIHtcbiAgICAvLyBUT0RPIDogdGhpcyBvbmx5IGhhbmRsZXMgKm9uZSogb2YgdGhlIGV4cGlyZWQgY3JlZGVudGlhbCBjb2Rlc1xuICAgIHJldHVybiAoZXJyb3IuY29kZSA9PT0gJ0V4cGlyZWRUb2tlbkV4Y2VwdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNsb2NrU2tld0Vycm9yOiBmdW5jdGlvbiBjbG9ja1NrZXdFcnJvcihlcnJvcikge1xuICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgY2FzZSAnUmVxdWVzdFRpbWVUb29Ta2V3ZWQnOlxuICAgICAgY2FzZSAnUmVxdWVzdEV4cGlyZWQnOlxuICAgICAgY2FzZSAnSW52YWxpZFNpZ25hdHVyZUV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdTaWduYXR1cmVEb2VzTm90TWF0Y2gnOlxuICAgICAgY2FzZSAnQXV0aEZhaWx1cmUnOlxuICAgICAgY2FzZSAnUmVxdWVzdEluVGhlRnV0dXJlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGdldFNrZXdDb3JyZWN0ZWREYXRlOiBmdW5jdGlvbiBnZXRTa2V3Q29ycmVjdGVkRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5ub3coKSArIHRoaXMuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhcHBseUNsb2NrT2Zmc2V0OiBmdW5jdGlvbiBhcHBseUNsb2NrT2Zmc2V0KG5ld1NlcnZlclRpbWUpIHtcbiAgICBpZiAobmV3U2VydmVyVGltZSkge1xuICAgICAgdGhpcy5jb25maWcuc3lzdGVtQ2xvY2tPZmZzZXQgPSBuZXdTZXJ2ZXJUaW1lIC0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9ja1NrZXdlZDogZnVuY3Rpb24gaXNDbG9ja1NrZXdlZChuZXdTZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKG5ld1NlcnZlclRpbWUpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkuZ2V0VGltZSgpIC0gbmV3U2VydmVyVGltZSkgPj0gMzAwMDAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0aHJvdHRsZWRFcnJvcjogZnVuY3Rpb24gdGhyb3R0bGVkRXJyb3IoZXJyb3IpIHtcbiAgICAvLyB0aGlzIGxvZ2ljIHZhcmllcyBiZXR3ZWVuIHNlcnZpY2VzXG4gICAgaWYgKGVycm9yLnN0YXR1c0NvZGUgPT09IDQyOSkgcmV0dXJuIHRydWU7XG4gICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICBjYXNlICdQcm92aXNpb25lZFRocm91Z2hwdXRFeGNlZWRlZEV4Y2VwdGlvbic6XG4gICAgICBjYXNlICdUaHJvdHRsaW5nJzpcbiAgICAgIGNhc2UgJ1Rocm90dGxpbmdFeGNlcHRpb24nOlxuICAgICAgY2FzZSAnUmVxdWVzdExpbWl0RXhjZWVkZWQnOlxuICAgICAgY2FzZSAnUmVxdWVzdFRocm90dGxlZCc6XG4gICAgICBjYXNlICdSZXF1ZXN0VGhyb3R0bGVkRXhjZXB0aW9uJzpcbiAgICAgIGNhc2UgJ1Rvb01hbnlSZXF1ZXN0c0V4Y2VwdGlvbic6XG4gICAgICBjYXNlICdUcmFuc2FjdGlvbkluUHJvZ3Jlc3NFeGNlcHRpb24nOiAvL2R5bmFtb2RiXG4gICAgICBjYXNlICdFQzJUaHJvdHRsZWRFeGNlcHRpb24nOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZW5kcG9pbnRGcm9tVGVtcGxhdGU6IGZ1bmN0aW9uIGVuZHBvaW50RnJvbVRlbXBsYXRlKGVuZHBvaW50KSB7XG4gICAgaWYgKHR5cGVvZiBlbmRwb2ludCAhPT0gJ3N0cmluZycpIHJldHVybiBlbmRwb2ludDtcblxuICAgIHZhciBlID0gZW5kcG9pbnQ7XG4gICAgZSA9IGUucmVwbGFjZSgvXFx7c2VydmljZVxcfS9nLCB0aGlzLmFwaS5lbmRwb2ludFByZWZpeCk7XG4gICAgZSA9IGUucmVwbGFjZSgvXFx7cmVnaW9uXFx9L2csIHRoaXMuY29uZmlnLnJlZ2lvbik7XG4gICAgZSA9IGUucmVwbGFjZSgvXFx7c2NoZW1lXFx9L2csIHRoaXMuY29uZmlnLnNzbEVuYWJsZWQgPyAnaHR0cHMnIDogJ2h0dHAnKTtcbiAgICByZXR1cm4gZTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzZXRFbmRwb2ludDogZnVuY3Rpb24gc2V0RW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICB0aGlzLmVuZHBvaW50ID0gbmV3IEFXUy5FbmRwb2ludChlbmRwb2ludCwgdGhpcy5jb25maWcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBhZ2luYXRpb25Db25maWc6IGZ1bmN0aW9uIHBhZ2luYXRpb25Db25maWcob3BlcmF0aW9uLCB0aHJvd0V4Y2VwdGlvbikge1xuICAgIHZhciBwYWdpbmF0b3IgPSB0aGlzLmFwaS5vcGVyYXRpb25zW29wZXJhdGlvbl0ucGFnaW5hdG9yO1xuICAgIGlmICghcGFnaW5hdG9yKSB7XG4gICAgICBpZiAodGhyb3dFeGNlcHRpb24pIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IoZSwgJ05vIHBhZ2luYXRpb24gY29uZmlndXJhdGlvbiBmb3IgJyArIG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFnaW5hdG9yO1xuICB9XG59KTtcblxuQVdTLnV0aWwudXBkYXRlKEFXUy5TZXJ2aWNlLCB7XG5cbiAgLyoqXG4gICAqIEFkZHMgb25lIG1ldGhvZCBmb3IgZWFjaCBvcGVyYXRpb24gZGVzY3JpYmVkIGluIHRoZSBhcGkgY29uZmlndXJhdGlvblxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmluZU1ldGhvZHM6IGZ1bmN0aW9uIGRlZmluZU1ldGhvZHMoc3ZjKSB7XG4gICAgQVdTLnV0aWwuZWFjaChzdmMucHJvdG90eXBlLmFwaS5vcGVyYXRpb25zLCBmdW5jdGlvbiBpdGVyYXRvcihtZXRob2QpIHtcbiAgICAgIGlmIChzdmMucHJvdG90eXBlW21ldGhvZF0pIHJldHVybjtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBzdmMucHJvdG90eXBlLmFwaS5vcGVyYXRpb25zW21ldGhvZF07XG4gICAgICBpZiAob3BlcmF0aW9uLmF1dGh0eXBlID09PSAnbm9uZScpIHtcbiAgICAgICAgc3ZjLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChtZXRob2QsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ZjLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdChtZXRob2QsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgbmV3IFNlcnZpY2UgY2xhc3MgdXNpbmcgYSBzZXJ2aWNlIGlkZW50aWZpZXIgYW5kIGxpc3Qgb2YgdmVyc2lvbnNcbiAgICogaW5jbHVkaW5nIGFuIG9wdGlvbmFsIHNldCBvZiBmZWF0dXJlcyAoZnVuY3Rpb25zKSB0byBhcHBseSB0byB0aGUgY2xhc3NcbiAgICogcHJvdG90eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmljZUlkZW50aWZpZXIgW1N0cmluZ10gdGhlIGlkZW50aWZpZXIgZm9yIHRoZSBzZXJ2aWNlXG4gICAqIEBwYXJhbSB2ZXJzaW9ucyBbQXJyYXk8U3RyaW5nPl0gYSBsaXN0IG9mIHZlcnNpb25zIHRoYXQgd29yayB3aXRoIHRoaXNcbiAgICogICBzZXJ2aWNlXG4gICAqIEBwYXJhbSBmZWF0dXJlcyBbT2JqZWN0XSBhbiBvYmplY3QgdG8gYXR0YWNoIHRvIHRoZSBwcm90b3R5cGVcbiAgICogQHJldHVybiBbQ2xhc3M8U2VydmljZT5dIHRoZSBzZXJ2aWNlIGNsYXNzIGRlZmluZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgICovXG4gIGRlZmluZVNlcnZpY2U6IGZ1bmN0aW9uIGRlZmluZVNlcnZpY2Uoc2VydmljZUlkZW50aWZpZXIsIHZlcnNpb25zLCBmZWF0dXJlcykge1xuICAgIEFXUy5TZXJ2aWNlLl9zZXJ2aWNlTWFwW3NlcnZpY2VJZGVudGlmaWVyXSA9IHRydWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZlcnNpb25zKSkge1xuICAgICAgZmVhdHVyZXMgPSB2ZXJzaW9ucztcbiAgICAgIHZlcnNpb25zID0gW107XG4gICAgfVxuXG4gICAgdmFyIHN2YyA9IGluaGVyaXQoQVdTLlNlcnZpY2UsIGZlYXR1cmVzIHx8IHt9KTtcblxuICAgIGlmICh0eXBlb2Ygc2VydmljZUlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBBV1MuU2VydmljZS5hZGRWZXJzaW9ucyhzdmMsIHZlcnNpb25zKTtcblxuICAgICAgdmFyIGlkZW50aWZpZXIgPSBzdmMuc2VydmljZUlkZW50aWZpZXIgfHwgc2VydmljZUlkZW50aWZpZXI7XG4gICAgICBzdmMuc2VydmljZUlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgIH0gZWxzZSB7IC8vIGRlZmluZVNlcnZpY2UgY2FsbGVkIHdpdGggYW4gQVBJXG4gICAgICBzdmMucHJvdG90eXBlLmFwaSA9IHNlcnZpY2VJZGVudGlmaWVyO1xuICAgICAgQVdTLlNlcnZpY2UuZGVmaW5lTWV0aG9kcyhzdmMpO1xuICAgIH1cbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwodGhpcy5wcm90b3R5cGUpO1xuICAgIC8vdXRpbC5jbGllbnRTaWRlTW9uaXRvcmluZyBpcyBvbmx5IGF2YWlsYWJsZSBpbiBub2RlXG4gICAgaWYgKCF0aGlzLnByb3RvdHlwZS5wdWJsaXNoZXIgJiYgQVdTLnV0aWwuY2xpZW50U2lkZU1vbml0b3JpbmcpIHtcbiAgICAgIHZhciBQdWJsaXNoZXIgPSBBV1MudXRpbC5jbGllbnRTaWRlTW9uaXRvcmluZy5QdWJsaXNoZXI7XG4gICAgICB2YXIgY29uZmlnUHJvdmlkZXIgPSBBV1MudXRpbC5jbGllbnRTaWRlTW9uaXRvcmluZy5jb25maWdQcm92aWRlcjtcbiAgICAgIHZhciBwdWJsaXNoZXJDb25maWcgPSBjb25maWdQcm92aWRlcigpO1xuICAgICAgdGhpcy5wcm90b3R5cGUucHVibGlzaGVyID0gbmV3IFB1Ymxpc2hlcihwdWJsaXNoZXJDb25maWcpO1xuICAgICAgaWYgKHB1Ymxpc2hlckNvbmZpZy5lbmFibGVkKSB7XG4gICAgICAgIC8vaWYgY3NtIGlzIGVuYWJsZWQgaW4gZW52aXJvbm1lbnQsIFNESyBzaG91bGQgc2VuZCBhbGwgbWV0cmljc1xuICAgICAgICBBV1MuU2VydmljZS5fY2xpZW50U2lkZU1vbml0b3JpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBBV1MuU2VxdWVudGlhbEV4ZWN1dG9yLmNhbGwoc3ZjLnByb3RvdHlwZSk7XG4gICAgQVdTLlNlcnZpY2UuYWRkRGVmYXVsdE1vbml0b3JpbmdMaXN0ZW5lcnMoc3ZjLnByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHN2YztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRWZXJzaW9uczogZnVuY3Rpb24gYWRkVmVyc2lvbnMoc3ZjLCB2ZXJzaW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJzaW9ucykpIHZlcnNpb25zID0gW3ZlcnNpb25zXTtcblxuICAgIHN2Yy5zZXJ2aWNlcyA9IHN2Yy5zZXJ2aWNlcyB8fCB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3ZjLnNlcnZpY2VzW3ZlcnNpb25zW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN2Yy5zZXJ2aWNlc1t2ZXJzaW9uc1tpXV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN2Yy5hcGlWZXJzaW9ucyA9IE9iamVjdC5rZXlzKHN2Yy5zZXJ2aWNlcykuc29ydCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmluZVNlcnZpY2VBcGk6IGZ1bmN0aW9uIGRlZmluZVNlcnZpY2VBcGkoc3VwZXJjbGFzcywgdmVyc2lvbiwgYXBpQ29uZmlnKSB7XG4gICAgdmFyIHN2YyA9IGluaGVyaXQoc3VwZXJjbGFzcywge1xuICAgICAgc2VydmljZUlkZW50aWZpZXI6IHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXJcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHNldEFwaShhcGkpIHtcbiAgICAgIGlmIChhcGkuaXNBcGkpIHtcbiAgICAgICAgc3ZjLnByb3RvdHlwZS5hcGkgPSBhcGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdmMucHJvdG90eXBlLmFwaSA9IG5ldyBBcGkoYXBpLCB7XG4gICAgICAgICAgc2VydmljZUlkZW50aWZpZXI6IHN1cGVyY2xhc3Muc2VydmljZUlkZW50aWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGFwaUNvbmZpZykge1xuICAgICAgICBzZXRBcGkoYXBpQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0QXBpKEFXUy5hcGlMb2FkZXIoc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllciwgdmVyc2lvbikpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihlcnIsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3QgZmluZCBBUEkgY29uZmlndXJhdGlvbiAnICtcbiAgICAgICAgICAgICAgc3VwZXJjbGFzcy5zZXJ2aWNlSWRlbnRpZmllciArICctJyArIHZlcnNpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3VwZXJjbGFzcy5zZXJ2aWNlcywgdmVyc2lvbikpIHtcbiAgICAgICAgc3VwZXJjbGFzcy5hcGlWZXJzaW9ucyA9IHN1cGVyY2xhc3MuYXBpVmVyc2lvbnMuY29uY2F0KHZlcnNpb24pLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyY2xhc3Muc2VydmljZXNbdmVyc2lvbl0gPSBzdmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEFwaSh2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICBBV1MuU2VydmljZS5kZWZpbmVNZXRob2RzKHN2Yyk7XG4gICAgcmV0dXJuIHN2YztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBoYXNTZXJ2aWNlOiBmdW5jdGlvbihpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBV1MuU2VydmljZS5fc2VydmljZU1hcCwgaWRlbnRpZmllcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRhY2hPbiBhdHRhY2ggZGVmYXVsdCBtb25pdG9yaW5nIGxpc3RlbmVycyB0byBvYmplY3RcbiAgICpcbiAgICogRWFjaCBtb25pdG9yaW5nIGV2ZW50IHNob3VsZCBiZSBlbWl0dGVkIGZyb20gc2VydmljZSBjbGllbnQgdG8gc2VydmljZSBjb25zdHJ1Y3RvciBwcm90b3R5cGUgYW5kIHRoZW5cbiAgICogdG8gZ2xvYmFsIHNlcnZpY2UgcHJvdG90eXBlIGxpa2UgYnViYmxpbmcgdXAuIFRoZXNlIGRlZmF1bHQgbW9uaXRvcmluZyBldmVudHMgbGlzdGVuZXIgd2lsbCB0cmFuc2ZlclxuICAgKiB0aGUgbW9uaXRvcmluZyBldmVudHMgdG8gdGhlIHVwcGVyIGxheWVyLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZERlZmF1bHRNb25pdG9yaW5nTGlzdGVuZXJzOiBmdW5jdGlvbiBhZGREZWZhdWx0TW9uaXRvcmluZ0xpc3RlbmVycyhhdHRhY2hPbikge1xuICAgIGF0dGFjaE9uLmFkZE5hbWVkTGlzdGVuZXIoJ01PTklUT1JfRVZFTlRTX0JVQkJMRScsICdhcGlDYWxsQXR0ZW1wdCcsIGZ1bmN0aW9uIEVWRU5UU19CVUJCTEUoZXZlbnQpIHtcbiAgICAgIHZhciBiYXNlQ2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXR0YWNoT24pO1xuICAgICAgaWYgKGJhc2VDbGFzcy5fZXZlbnRzKSBiYXNlQ2xhc3MuZW1pdCgnYXBpQ2FsbEF0dGVtcHQnLCBbZXZlbnRdKTtcbiAgICB9KTtcbiAgICBhdHRhY2hPbi5hZGROYW1lZExpc3RlbmVyKCdDQUxMX0VWRU5UU19CVUJCTEUnLCAnYXBpQ2FsbCcsIGZ1bmN0aW9uIENBTExfRVZFTlRTX0JVQkJMRShldmVudCkge1xuICAgICAgdmFyIGJhc2VDbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhdHRhY2hPbik7XG4gICAgICBpZiAoYmFzZUNsYXNzLl9ldmVudHMpIGJhc2VDbGFzcy5lbWl0KCdhcGlDYWxsJywgW2V2ZW50XSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgX3NlcnZpY2VNYXA6IHt9XG59KTtcblxuQVdTLnV0aWwubWl4aW4oQVdTLlNlcnZpY2UsIEFXUy5TZXF1ZW50aWFsRXhlY3V0b3IpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TZXJ2aWNlO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciB2NENyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi4vc2lnbmVycy92NF9jcmVkZW50aWFscycpO1xudmFyIHJlc29sdmVSZWdpb25hbEVuZHBvaW50c0ZsYWcgPSByZXF1aXJlKCcuLi9jb25maWdfcmVnaW9uYWxfZW5kcG9pbnQnKTtcbnZhciBzM3V0aWwgPSByZXF1aXJlKCcuL3MzdXRpbCcpO1xudmFyIHJlZ2lvblV0aWwgPSByZXF1aXJlKCcuLi9yZWdpb25fY29uZmlnJyk7XG5cbi8vIFB1bGwgaW4gbWFuYWdlZCB1cGxvYWQgZXh0ZW5zaW9uXG5yZXF1aXJlKCcuLi9zMy9tYW5hZ2VkX3VwbG9hZCcpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgb3BlcmF0aW9uc1dpdGgyMDBTdGF0dXNDb2RlRXJyb3IgPSB7XG4gICdjb21wbGV0ZU11bHRpcGFydFVwbG9hZCc6IHRydWUsXG4gICdjb3B5T2JqZWN0JzogdHJ1ZSxcbiAgJ3VwbG9hZFBhcnRDb3B5JzogdHJ1ZVxufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuIHZhciByZWdpb25SZWRpcmVjdEVycm9yQ29kZXMgPSBbXG4gICdBdXRob3JpemF0aW9uSGVhZGVyTWFsZm9ybWVkJywgLy8gbm9uLWhlYWQgb3BlcmF0aW9ucyBvbiB2aXJ0dWFsLWhvc3RlZCBnbG9iYWwgYnVja2V0IGVuZHBvaW50c1xuICAnQmFkUmVxdWVzdCcsIC8vIGhlYWQgb3BlcmF0aW9ucyBvbiB2aXJ0dWFsLWhvc3RlZCBnbG9iYWwgYnVja2V0IGVuZHBvaW50c1xuICAnUGVybWFuZW50UmVkaXJlY3QnLCAvLyBub24taGVhZCBvcGVyYXRpb25zIG9uIHBhdGgtc3R5bGUgb3IgcmVnaW9uYWwgZW5kcG9pbnRzXG4gIDMwMSAvLyBoZWFkIG9wZXJhdGlvbnMgb24gcGF0aC1zdHlsZSBvciByZWdpb25hbCBlbmRwb2ludHNcbiBdO1xuXG52YXIgT0JKRUNUX0xBTUJEQV9TRVJWSUNFID0gJ3MzLW9iamVjdC1sYW1iZGEnO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLlMzLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduYXR1cmVWZXJzaW9uOiBmdW5jdGlvbiBnZXRTaWduYXR1cmVWZXJzaW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgZGVmYXVsdEFwaVZlcnNpb24gPSB0aGlzLmFwaS5zaWduYXR1cmVWZXJzaW9uO1xuICAgIHZhciB1c2VyRGVmaW5lZFZlcnNpb24gPSB0aGlzLl9vcmlnaW5hbENvbmZpZyA/IHRoaXMuX29yaWdpbmFsQ29uZmlnLnNpZ25hdHVyZVZlcnNpb24gOiBudWxsO1xuICAgIHZhciByZWdpb25EZWZpbmVkVmVyc2lvbiA9IHRoaXMuY29uZmlnLnNpZ25hdHVyZVZlcnNpb247XG4gICAgdmFyIGlzUHJlc2lnbmVkID0gcmVxdWVzdCA/IHJlcXVlc3QuaXNQcmVzaWduZWQoKSA6IGZhbHNlO1xuICAgIC8qXG4gICAgICAxKSBVc2VyIGRlZmluZWQgdmVyc2lvbiBzcGVjaWZpZWQ6XG4gICAgICAgIGEpIGFsd2F5cyByZXR1cm4gdXNlciBkZWZpbmVkIHZlcnNpb25cbiAgICAgIDIpIE5vIHVzZXIgZGVmaW5lZCB2ZXJzaW9uIHNwZWNpZmllZDpcbiAgICAgICAgYSkgSWYgbm90IHVzaW5nIHByZXNpZ25lZCB1cmxzLCBkZWZhdWx0IHRvIFY0XG4gICAgICAgIGIpIElmIHVzaW5nIHByZXNpZ25lZCB1cmxzLCBkZWZhdWx0IHRvIGxvd2VzdCB2ZXJzaW9uIHRoZSByZWdpb24gc3VwcG9ydHNcbiAgICAqL1xuICAgIGlmICh1c2VyRGVmaW5lZFZlcnNpb24pIHtcbiAgICAgIHVzZXJEZWZpbmVkVmVyc2lvbiA9IHVzZXJEZWZpbmVkVmVyc2lvbiA9PT0gJ3YyJyA/ICdzMycgOiB1c2VyRGVmaW5lZFZlcnNpb247XG4gICAgICByZXR1cm4gdXNlckRlZmluZWRWZXJzaW9uO1xuICAgIH1cbiAgICBpZiAoaXNQcmVzaWduZWQgIT09IHRydWUpIHtcbiAgICAgIGRlZmF1bHRBcGlWZXJzaW9uID0gJ3Y0JztcbiAgICB9IGVsc2UgaWYgKHJlZ2lvbkRlZmluZWRWZXJzaW9uKSB7XG4gICAgICBkZWZhdWx0QXBpVmVyc2lvbiA9IHJlZ2lvbkRlZmluZWRWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEFwaVZlcnNpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2lnbmluZ05hbWU6IGZ1bmN0aW9uIGdldFNpZ25pbmdOYW1lKHJlcSkge1xuICAgIGlmIChyZXEgJiYgcmVxLm9wZXJhdGlvbiA9PT0gJ3dyaXRlR2V0T2JqZWN0UmVzcG9uc2UnKSB7XG4gICAgICByZXR1cm4gT0JKRUNUX0xBTUJEQV9TRVJWSUNFO1xuICAgIH1cblxuICAgIHZhciBfc3VwZXIgPSBBV1MuU2VydmljZS5wcm90b3R5cGUuZ2V0U2lnbmluZ05hbWU7XG4gICAgcmV0dXJuIChyZXEgJiYgcmVxLl9wYXJzZWRBcm4gJiYgcmVxLl9wYXJzZWRBcm4uc2VydmljZSlcbiAgICAgID8gcmVxLl9wYXJzZWRBcm4uc2VydmljZVxuICAgICAgOiBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRTaWduZXJDbGFzczogZnVuY3Rpb24gZ2V0U2lnbmVyQ2xhc3MocmVxdWVzdCkge1xuICAgIHZhciBzaWduYXR1cmVWZXJzaW9uID0gdGhpcy5nZXRTaWduYXR1cmVWZXJzaW9uKHJlcXVlc3QpO1xuICAgIHJldHVybiBBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmdldFZlcnNpb24oc2lnbmF0dXJlVmVyc2lvbik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVTZXJ2aWNlOiBmdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2UoKSB7XG4gICAgdmFyIG1zZztcbiAgICB2YXIgbWVzc2FnZXMgPSBbXTtcblxuICAgIC8vIGRlZmF1bHQgdG8gdXMtZWFzdC0xIHdoZW4gbm8gcmVnaW9uIGlzIHByb3ZpZGVkXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5yZWdpb24pIHRoaXMuY29uZmlnLnJlZ2lvbiA9ICd1cy1lYXN0LTEnO1xuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5lbmRwb2ludCAmJiB0aGlzLmNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBtZXNzYWdlcy5wdXNoKCdBbiBlbmRwb2ludCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY29uZmlndXJpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICdgczNCdWNrZXRFbmRwb2ludGAgdG8gdHJ1ZS4nKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgbXNnID0gbWVzc2FnZXNbMF07XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBtc2cgPSAnTXVsdGlwbGUgY29uZmlndXJhdGlvbiBlcnJvcnM6XFxuJyArIG1lc3NhZ2VzLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBpZiAobXNnKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAge25hbWU6ICdJbnZhbGlkRW5kcG9pbnQnLCBtZXNzYWdlOiBtc2d9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nOiBmdW5jdGlvbiBzaG91bGREaXNhYmxlQm9keVNpZ25pbmcocmVxdWVzdCkge1xuICAgIHZhciBzaWduZXJDbGFzcyA9IHRoaXMuZ2V0U2lnbmVyQ2xhc3MoKTtcbiAgICBpZiAodGhpcy5jb25maWcuczNEaXNhYmxlQm9keVNpZ25pbmcgPT09IHRydWUgJiYgc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlY0XG4gICAgICAgICYmIHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVxdWVzdExpc3RlbmVyczogZnVuY3Rpb24gc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICB2YXIgcHJlcGVuZExpc3RlbmVyID0gdHJ1ZTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVTY2hlbWUpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUJ1Y2tldE5hbWUsIHByZXBlbmRMaXN0ZW5lcik7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCB0aGlzLm9wdEluVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQsIHByZXBlbmRMaXN0ZW5lcik7XG5cbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd2YWxpZGF0ZScsXG4gICAgICBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5WQUxJREFURV9SRUdJT04pO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2J1aWxkJywgdGhpcy5hZGRDb250ZW50VHlwZSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCB0aGlzLmNvbXB1dGVDb250ZW50TWQ1KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMuY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMucG9wdWxhdGVVUkkpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCB0aGlzLmFkZEV4cGVjdDEwMENvbnRpbnVlKTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdleHRyYWN0RXJyb3InLCB0aGlzLmV4dHJhY3RFcnJvcik7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignZXh0cmFjdERhdGEnLCBBV1MudXRpbC5ob2lzdFBheWxvYWRNZW1iZXIpO1xuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2V4dHJhY3REYXRhJywgdGhpcy5leHRyYWN0RGF0YSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignZXh0cmFjdERhdGEnLCB0aGlzLmV4dHJhY3RFcnJvckZyb20yMDBSZXNwb25zZSk7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYmVmb3JlUHJlc2lnbicsIHRoaXMucHJlcGFyZVNpZ25lZFVybCk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nKHJlcXVlc3QpKSAge1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYWZ0ZXJCdWlsZCcsIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkNPTVBVVEVfU0hBMjU2KTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCB0aGlzLmRpc2FibGVCb2R5U2lnbmluZyk7XG4gICAgfVxuICAgIC8vZGVhbCB3aXRoIEFSTnMgc3VwcGxpZWQgdG8gQnVja2V0XG4gICAgaWYgKHJlcXVlc3Qub3BlcmF0aW9uICE9PSAnY3JlYXRlQnVja2V0JyAmJiBzM3V0aWwuaXNBcm5JblBhcmFtKHJlcXVlc3QsICdCdWNrZXQnKSkge1xuICAgICAgLy8gYXZvaWQgZHVwbGljYXRlIHBhcnNpbmcgaW4gdGhlIGZ1dHVyZVxuICAgICAgcmVxdWVzdC5fcGFyc2VkQXJuID0gQVdTLnV0aWwuQVJOLnBhcnNlKHJlcXVlc3QucGFyYW1zLkJ1Y2tldCk7XG5cbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUJ1Y2tldE5hbWUpO1xuICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcignYnVpbGQnLCB0aGlzLnBvcHVsYXRlVVJJKTtcbiAgICAgIGlmIChyZXF1ZXN0Ll9wYXJzZWRBcm4uc2VydmljZSA9PT0gJ3MzJykge1xuICAgICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHMzdXRpbC52YWxpZGF0ZVMzQWNjZXNzUG9pbnRBcm4pO1xuICAgICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVBcm5SZXNvdXJjZVR5cGUpO1xuICAgICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMudmFsaWRhdGVBcm5SZWdpb24pO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0Ll9wYXJzZWRBcm4uc2VydmljZSA9PT0gJ3MzLW91dHBvc3RzJykge1xuICAgICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHMzdXRpbC52YWxpZGF0ZU91dHBvc3RzQWNjZXNzUG9pbnRBcm4pO1xuICAgICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHMzdXRpbC52YWxpZGF0ZU91dHBvc3RzQXJuKTtcbiAgICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCBzM3V0aWwudmFsaWRhdGVBcm5SZWdpb24pO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCBzM3V0aWwudmFsaWRhdGVBcm5BY2NvdW50KTtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgczN1dGlsLnZhbGlkYXRlQXJuU2VydmljZSk7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHRoaXMucG9wdWxhdGVVcmlGcm9tQWNjZXNzUG9pbnRBcm4pO1xuICAgICAgcmVxdWVzdC5hZGRMaXN0ZW5lcignYnVpbGQnLCBzM3V0aWwudmFsaWRhdGVQb3B1bGF0ZVVyaUZyb21Bcm4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvL2xpc3RlbmVycyByZWdhcmRpbmcgcmVnaW9uIGluZmVyZW5jZVxuICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ3ZhbGlkYXRlJywgdGhpcy52YWxpZGF0ZUJ1Y2tldEVuZHBvaW50KTtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMuY29ycmVjdEJ1Y2tldFJlZ2lvbkZyb21DYWNoZSk7XG4gICAgcmVxdWVzdC5vbkFzeW5jKCdleHRyYWN0RXJyb3InLCB0aGlzLnJlcXVlc3RCdWNrZXRSZWdpb24pO1xuICAgIGlmIChBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgcmVxdWVzdC5vbkFzeW5jKCdyZXRyeScsIHRoaXMucmVxUmVnaW9uRm9yTmV0d29ya2luZ0Vycm9yKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdmFsaWRhdGVTY2hlbWU6IGZ1bmN0aW9uKHJlcSkge1xuICAgIHZhciBwYXJhbXMgPSByZXEucGFyYW1zLFxuICAgICAgICBzY2hlbWUgPSByZXEuaHR0cFJlcXVlc3QuZW5kcG9pbnQucHJvdG9jb2wsXG4gICAgICAgIHNlbnNpdGl2ZSA9IHBhcmFtcy5TU0VDdXN0b21lcktleSB8fCBwYXJhbXMuQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5O1xuICAgIGlmIChzZW5zaXRpdmUgJiYgc2NoZW1lICE9PSAnaHR0cHM6Jykge1xuICAgICAgdmFyIG1zZyA9ICdDYW5ub3Qgc2VuZCBTU0Uga2V5cyBvdmVyIEhUVFAuIFNldCBcXCdzc2xFbmFibGVkXFwnJyArXG4gICAgICAgICd0byBcXCd0cnVlXFwnIGluIHlvdXIgY29uZmlndXJhdGlvbic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgeyBjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiBtc2cgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHZhbGlkYXRlQnVja2V0RW5kcG9pbnQ6IGZ1bmN0aW9uKHJlcSkge1xuICAgIGlmICghcmVxLnBhcmFtcy5CdWNrZXQgJiYgcmVxLnNlcnZpY2UuY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgIHZhciBtc2cgPSAnQ2Fubm90IHNlbmQgcmVxdWVzdHMgdG8gcm9vdCBBUEkgd2l0aCBgczNCdWNrZXRFbmRwb2ludGAgc2V0Lic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgeyBjb2RlOiAnQ29uZmlnRXJyb3InLCBtZXNzYWdlOiBtc2cgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gICB2YWxpZGF0ZUFyblJlZ2lvbjogZnVuY3Rpb24gdmFsaWRhdGVBcm5SZWdpb24ocmVxKSB7XG4gICAgczN1dGlsLnZhbGlkYXRlQXJuUmVnaW9uKHJlcSwgeyBhbGxvd0ZpcHNFbmRwb2ludDogdHJ1ZSB9KTtcbiAgfSxcblxuICAvKipcbiAgICogVmFsaWRhdGUgcmVzb3VyY2UtdHlwZSBzdXBwbGllZCBpbiBTMyBBUk5cbiAgICovXG4gIHZhbGlkYXRlQXJuUmVzb3VyY2VUeXBlOiBmdW5jdGlvbiB2YWxpZGF0ZUFyblJlc291cmNlVHlwZShyZXEpIHtcbiAgICB2YXIgcmVzb3VyY2UgPSByZXEuX3BhcnNlZEFybi5yZXNvdXJjZTtcblxuICAgIGlmIChcbiAgICAgIHJlc291cmNlLmluZGV4T2YoJ2FjY2Vzc3BvaW50OicpICE9PSAwICYmXG4gICAgICByZXNvdXJjZS5pbmRleE9mKCdhY2Nlc3Nwb2ludC8nKSAhPT0gMFxuICAgICkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnQVJOIHJlc291cmNlIHNob3VsZCBiZWdpbiB3aXRoIFxcJ2FjY2Vzc3BvaW50L1xcJydcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB2YWxpZGF0ZUJ1Y2tldE5hbWU6IGZ1bmN0aW9uIHZhbGlkYXRlQnVja2V0TmFtZShyZXEpIHtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBzaWduYXR1cmVWZXJzaW9uID0gc2VydmljZS5nZXRTaWduYXR1cmVWZXJzaW9uKHJlcSk7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMgJiYgcmVxLnBhcmFtcy5CdWNrZXQ7XG4gICAgdmFyIGtleSA9IHJlcS5wYXJhbXMgJiYgcmVxLnBhcmFtcy5LZXk7XG4gICAgdmFyIHNsYXNoSW5kZXggPSBidWNrZXQgJiYgYnVja2V0LmluZGV4T2YoJy8nKTtcbiAgICBpZiAoYnVja2V0ICYmIHNsYXNoSW5kZXggPj0gMCkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHNsYXNoSW5kZXggPiAwKSB7XG4gICAgICAgIHJlcS5wYXJhbXMgPSBBV1MudXRpbC5jb3B5KHJlcS5wYXJhbXMpO1xuICAgICAgICAvLyBOZWVkIHRvIGluY2x1ZGUgdHJhaWxpbmcgc2xhc2ggdG8gbWF0Y2ggc2lndjIgYmVoYXZpb3JcbiAgICAgICAgdmFyIHByZWZpeCA9IGJ1Y2tldC5zdWJzdHIoc2xhc2hJbmRleCArIDEpIHx8ICcnO1xuICAgICAgICByZXEucGFyYW1zLktleSA9IHByZWZpeCArICcvJyArIGtleTtcbiAgICAgICAgcmVxLnBhcmFtcy5CdWNrZXQgPSBidWNrZXQuc3Vic3RyKDAsIHNsYXNoSW5kZXgpO1xuICAgICAgfSBlbHNlIGlmIChzaWduYXR1cmVWZXJzaW9uID09PSAndjQnKSB7XG4gICAgICAgIHZhciBtc2cgPSAnQnVja2V0IG5hbWVzIGNhbm5vdCBjb250YWluIGZvcndhcmQgc2xhc2hlcy4gQnVja2V0OiAnICsgYnVja2V0O1xuICAgICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgICB7IGNvZGU6ICdJbnZhbGlkQnVja2V0JywgbWVzc2FnZTogbXNnIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpc1ZhbGlkQWNjZWxlcmF0ZU9wZXJhdGlvbjogZnVuY3Rpb24gaXNWYWxpZEFjY2VsZXJhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgdmFyIGludmFsaWRPcGVyYXRpb25zID0gW1xuICAgICAgJ2NyZWF0ZUJ1Y2tldCcsXG4gICAgICAnZGVsZXRlQnVja2V0JyxcbiAgICAgICdsaXN0QnVja2V0cydcbiAgICBdO1xuICAgIHJldHVybiBpbnZhbGlkT3BlcmF0aW9ucy5pbmRleE9mKG9wZXJhdGlvbikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHVzLWVhc3QtMSByZWdpb24gZW5kcG9pbnQgY29uZmlndXJhdGlvbiBpcyBzZXQsIGluIHN0ZWFkIG9mIHNlbmRpbmcgcmVxdWVzdCB0b1xuICAgKiBnbG9iYWwgZW5kcG9pbnQoZS5nLiAnczMuYW1hem9uYXdzLmNvbScpLCB3ZSB3aWxsIHNlbmQgcmVxdWVzdCB0b1xuICAgKiAnczMudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20nLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIG9wdEluVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQ6IGZ1bmN0aW9uIG9wdEluVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQocmVxKSB7XG4gICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICB2YXIgY29uZmlnID0gc2VydmljZS5jb25maWc7XG4gICAgY29uZmlnLnMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQgPSByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnKHNlcnZpY2UuX29yaWdpbmFsQ29uZmlnLCB7XG4gICAgICBlbnY6ICdBV1NfUzNfVVNfRUFTVF8xX1JFR0lPTkFMX0VORFBPSU5UJyxcbiAgICAgIHNoYXJlZENvbmZpZzogJ3MzX3VzX2Vhc3RfMV9yZWdpb25hbF9lbmRwb2ludCcsXG4gICAgICBjbGllbnRDb25maWc6ICdzM1VzRWFzdDFSZWdpb25hbEVuZHBvaW50J1xuICAgIH0pO1xuICAgIGlmIChcbiAgICAgICEoc2VydmljZS5fb3JpZ2luYWxDb25maWcgfHwge30pLmVuZHBvaW50ICYmXG4gICAgICByZXEuaHR0cFJlcXVlc3QucmVnaW9uID09PSAndXMtZWFzdC0xJyAmJlxuICAgICAgY29uZmlnLnMzVXNFYXN0MVJlZ2lvbmFsRW5kcG9pbnQgPT09ICdyZWdpb25hbCcgJiZcbiAgICAgIHJlcS5odHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0bmFtZS5pbmRleE9mKCdzMy5hbWF6b25hd3MuY29tJykgPj0gMFxuICAgICkge1xuICAgICAgdmFyIGluc2VydFBvaW50ID0gY29uZmlnLmVuZHBvaW50LmluZGV4T2YoJy5hbWF6b25hd3MuY29tJyk7XG4gICAgICByZWdpb25hbEVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50LnN1YnN0cmluZygwLCBpbnNlcnRQb2ludCkgK1xuICAgICAgICAnLnVzLWVhc3QtMScgKyBjb25maWcuZW5kcG9pbnQuc3Vic3RyaW5nKGluc2VydFBvaW50KTtcbiAgICAgIHJlcS5odHRwUmVxdWVzdC51cGRhdGVFbmRwb2ludChyZWdpb25hbEVuZHBvaW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFMzIHByZWZlcnMgZG5zLWNvbXBhdGlibGUgYnVja2V0IG5hbWVzIHRvIGJlIG1vdmVkIGZyb20gdGhlIHVyaSBwYXRoXG4gICAqIHRvIHRoZSBob3N0bmFtZSBhcyBhIHN1Yi1kb21haW4uICBUaGlzIGlzIG5vdCBwb3NzaWJsZSwgZXZlbiBmb3IgZG5zLWNvbXBhdFxuICAgKiBidWNrZXRzIHdoZW4gdXNpbmcgU1NMIGFuZCB0aGUgYnVja2V0IG5hbWUgY29udGFpbnMgYSBkb3QgKCcuJykuICBUaGVcbiAgICogc3NsIHdpbGRjYXJkIGNlcnRpZmljYXRlIGlzIG9ubHkgMS1sZXZlbCBkZWVwLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHBvcHVsYXRlVVJJOiBmdW5jdGlvbiBwb3B1bGF0ZVVSSShyZXEpIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gICAgdmFyIGIgPSByZXEucGFyYW1zLkJ1Y2tldDtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBlbmRwb2ludCA9IGh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICAgIGlmIChiKSB7XG4gICAgICBpZiAoIXNlcnZpY2UucGF0aFN0eWxlQnVja2V0TmFtZShiKSkge1xuICAgICAgICBpZiAoc2VydmljZS5jb25maWcudXNlQWNjZWxlcmF0ZUVuZHBvaW50ICYmIHNlcnZpY2UuaXNWYWxpZEFjY2VsZXJhdGVPcGVyYXRpb24ocmVxLm9wZXJhdGlvbikpIHtcbiAgICAgICAgICBpZiAoc2VydmljZS5jb25maWcudXNlRHVhbHN0YWNrRW5kcG9pbnQpIHtcbiAgICAgICAgICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gYiArICcuczMtYWNjZWxlcmF0ZS5kdWFsc3RhY2suYW1hem9uYXdzLmNvbSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gYiArICcuczMtYWNjZWxlcmF0ZS5hbWF6b25hd3MuY29tJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNlcnZpY2UuY29uZmlnLnMzQnVja2V0RW5kcG9pbnQpIHtcbiAgICAgICAgICBlbmRwb2ludC5ob3N0bmFtZSA9XG4gICAgICAgICAgICBiICsgJy4nICsgZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9ydCA9IGVuZHBvaW50LnBvcnQ7XG4gICAgICAgIGlmIChwb3J0ICE9PSA4MCAmJiBwb3J0ICE9PSA0NDMpIHtcbiAgICAgICAgICBlbmRwb2ludC5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWUgKyAnOicgK1xuICAgICAgICAgICAgZW5kcG9pbnQucG9ydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRwb2ludC5ob3N0ID0gZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBodHRwUmVxdWVzdC52aXJ0dWFsSG9zdGVkQnVja2V0ID0gYjsgLy8gbmVlZGVkIGZvciBzaWduaW5nIHRoZSByZXF1ZXN0XG4gICAgICAgIHNlcnZpY2UucmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKHJlcSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgYnVja2V0IG5hbWUgb3V0IG9mIHRoZSBwYXRoIGlmIGJ1Y2tldCBpcyB2aXJ0dWFsLWhvc3RlZFxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHJlbW92ZVZpcnR1YWxIb3N0ZWRCdWNrZXRGcm9tUGF0aDogZnVuY3Rpb24gcmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKHJlcSkge1xuICAgIHZhciBodHRwUmVxdWVzdCA9IHJlcS5odHRwUmVxdWVzdDtcbiAgICB2YXIgYnVja2V0ID0gaHR0cFJlcXVlc3QudmlydHVhbEhvc3RlZEJ1Y2tldDtcbiAgICBpZiAoYnVja2V0ICYmIGh0dHBSZXF1ZXN0LnBhdGgpIHtcbiAgICAgIGlmIChyZXEucGFyYW1zICYmIHJlcS5wYXJhbXMuS2V5KSB7XG4gICAgICAgIHZhciBlbmNvZGVkUzNLZXkgPSAnLycgKyBBV1MudXRpbC51cmlFc2NhcGVQYXRoKHJlcS5wYXJhbXMuS2V5KTtcbiAgICAgICAgaWYgKGh0dHBSZXF1ZXN0LnBhdGguaW5kZXhPZihlbmNvZGVkUzNLZXkpID09PSAwICYmIChodHRwUmVxdWVzdC5wYXRoLmxlbmd0aCA9PT0gZW5jb2RlZFMzS2V5Lmxlbmd0aCB8fCBodHRwUmVxdWVzdC5wYXRoW2VuY29kZWRTM0tleS5sZW5ndGhdID09PSAnPycpKSB7XG4gICAgICAgICAgLy9wYXRoIG9ubHkgY29udGFpbnMga2V5IG9yIHBhdGggY29udGFpbnMgb25seSBrZXkgYW5kIHF1ZXJ5c3RyaW5nXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodHRwUmVxdWVzdC5wYXRoID0gaHR0cFJlcXVlc3QucGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJy8nICsgYnVja2V0KSwgJycpO1xuICAgICAgaWYgKGh0dHBSZXF1ZXN0LnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICBodHRwUmVxdWVzdC5wYXRoID0gJy8nICsgaHR0cFJlcXVlc3QucGF0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gdXNlciBzdXBwbHkgYW4gYWNjZXNzIHBvaW50IEFSTiBpbiB0aGUgQnVja2V0IHBhcmFtZXRlciwgd2UgbmVlZCB0b1xuICAgKiBwb3B1bGF0ZSB0aGUgVVJJIGFjY29yZGluZyB0byB0aGUgQVJOLlxuICAgKi9cbiAgcG9wdWxhdGVVcmlGcm9tQWNjZXNzUG9pbnRBcm46IGZ1bmN0aW9uIHBvcHVsYXRlVXJpRnJvbUFjY2Vzc1BvaW50QXJuKHJlcSkge1xuICAgIHZhciBhY2Nlc3NQb2ludEFybiA9IHJlcS5fcGFyc2VkQXJuO1xuXG4gICAgdmFyIGlzT3V0cG9zdEFybiA9IGFjY2Vzc1BvaW50QXJuLnNlcnZpY2UgPT09ICdzMy1vdXRwb3N0cyc7XG4gICAgdmFyIGlzT2JqZWN0TGFtYmRhQXJuID0gYWNjZXNzUG9pbnRBcm4uc2VydmljZSA9PT0gJ3MzLW9iamVjdC1sYW1iZGEnO1xuXG4gICAgdmFyIG91dHBvc3RzU3VmZml4ID0gaXNPdXRwb3N0QXJuID8gJy4nICsgYWNjZXNzUG9pbnRBcm4ub3V0cG9zdElkOiAnJztcbiAgICB2YXIgc2VydmljZU5hbWUgPSBpc091dHBvc3RBcm4gPyAnczMtb3V0cG9zdHMnOiAnczMtYWNjZXNzcG9pbnQnO1xuICAgIHZhciBmaXBzU3VmZml4ID0gIWlzT3V0cG9zdEFybiAmJiByZXEuc2VydmljZS5jb25maWcudXNlRmlwc0VuZHBvaW50ID8gJy1maXBzJzogJyc7XG4gICAgdmFyIGR1YWxTdGFja1N1ZmZpeCA9ICFpc091dHBvc3RBcm4gJiZcbiAgICAgIHJlcS5zZXJ2aWNlLmNvbmZpZy51c2VEdWFsc3RhY2tFbmRwb2ludCA/ICcuZHVhbHN0YWNrJyA6ICcnO1xuXG4gICAgdmFyIGVuZHBvaW50ID0gcmVxLmh0dHBSZXF1ZXN0LmVuZHBvaW50O1xuICAgIHZhciBkbnNTdWZmaXggPSByZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KGFjY2Vzc1BvaW50QXJuLnJlZ2lvbik7XG4gICAgdmFyIHVzZUFyblJlZ2lvbiA9IHJlcS5zZXJ2aWNlLmNvbmZpZy5zM1VzZUFyblJlZ2lvbjtcblxuICAgIGVuZHBvaW50Lmhvc3RuYW1lID0gW1xuICAgICAgYWNjZXNzUG9pbnRBcm4uYWNjZXNzUG9pbnQgKyAnLScgKyBhY2Nlc3NQb2ludEFybi5hY2NvdW50SWQgKyBvdXRwb3N0c1N1ZmZpeCxcbiAgICAgIHNlcnZpY2VOYW1lICsgZmlwc1N1ZmZpeCArIGR1YWxTdGFja1N1ZmZpeCxcbiAgICAgIHVzZUFyblJlZ2lvbiA/IGFjY2Vzc1BvaW50QXJuLnJlZ2lvbiA6IHJlcS5zZXJ2aWNlLmNvbmZpZy5yZWdpb24sXG4gICAgICBkbnNTdWZmaXhcbiAgICBdLmpvaW4oJy4nKTtcblxuICAgIGlmIChpc09iamVjdExhbWJkYUFybikge1xuICAgICAgLy8gc2hvdWxkIGJlIGluIHRoZSBmb3JtYXQ6IFwiYWNjZXNzcG9pbnQvJHthY2Nlc3Nwb2ludE5hbWV9XCJcbiAgICAgIHZhciBzZXJ2aWNlTmFtZSA9ICdzMy1vYmplY3QtbGFtYmRhJztcbiAgICAgIHZhciBhY2Nlc3Nwb2ludE5hbWUgPSBhY2Nlc3NQb2ludEFybi5yZXNvdXJjZS5zcGxpdCgnLycpWzFdO1xuICAgICAgdmFyIGZpcHNTdWZmaXggPSByZXEuc2VydmljZS5jb25maWcudXNlRmlwc0VuZHBvaW50ID8gJy1maXBzJzogJyc7XG4gICAgICBlbmRwb2ludC5ob3N0bmFtZSA9IFtcbiAgICAgICAgYWNjZXNzcG9pbnROYW1lICsgJy0nICsgYWNjZXNzUG9pbnRBcm4uYWNjb3VudElkLFxuICAgICAgICBzZXJ2aWNlTmFtZSArIGZpcHNTdWZmaXgsXG4gICAgICAgIHVzZUFyblJlZ2lvbiA/IGFjY2Vzc1BvaW50QXJuLnJlZ2lvbiA6IHJlcS5zZXJ2aWNlLmNvbmZpZy5yZWdpb24sXG4gICAgICAgIGRuc1N1ZmZpeFxuICAgICAgXS5qb2luKCcuJyk7XG4gICAgfVxuICAgIGVuZHBvaW50Lmhvc3QgPSBlbmRwb2ludC5ob3N0bmFtZTtcbiAgICB2YXIgZW5jb2RlZEFybiA9IEFXUy51dGlsLnVyaUVzY2FwZShyZXEucGFyYW1zLkJ1Y2tldCk7XG4gICAgdmFyIHBhdGggPSByZXEuaHR0cFJlcXVlc3QucGF0aDtcbiAgICAvL3JlbW92ZSB0aGUgQnVja2V0IHZhbHVlIGZyb20gcGF0aFxuICAgIHJlcS5odHRwUmVxdWVzdC5wYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJy8nICsgZW5jb2RlZEFybiksICcnKTtcbiAgICBpZiAocmVxLmh0dHBSZXF1ZXN0LnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LnBhdGggPSAnLycgKyByZXEuaHR0cFJlcXVlc3QucGF0aDtcbiAgICB9XG4gICAgcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbiA9IGFjY2Vzc1BvaW50QXJuLnJlZ2lvbjsgLy9yZWdpb24gdXNlZCB0byBzaWduXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgRXhwZWN0OiAxMDAtY29udGludWUgaGVhZGVyIGlmIHBheWxvYWQgaXMgZ3JlYXRlci1vci1lcXVhbCAxTUJcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBhZGRFeHBlY3QxMDBDb250aW51ZTogZnVuY3Rpb24gYWRkRXhwZWN0MTAwQ29udGludWUocmVxKSB7XG4gICAgdmFyIGxlbiA9IHJlcS5odHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddO1xuICAgIGlmIChBV1MudXRpbC5pc05vZGUoKSAmJiAobGVuID49IDEwMjQgKiAxMDI0IHx8IHJlcS5wYXJhbXMuQm9keSBpbnN0YW5jZW9mIEFXUy51dGlsLnN0cmVhbS5TdHJlYW0pKSB7XG4gICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1snRXhwZWN0J10gPSAnMTAwLWNvbnRpbnVlJztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBkZWZhdWx0IGNvbnRlbnQgdHlwZSBpZiBub25lIGlzIHN1cHBsaWVkLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFkZENvbnRlbnRUeXBlOiBmdW5jdGlvbiBhZGRDb250ZW50VHlwZShyZXEpIHtcbiAgICB2YXIgaHR0cFJlcXVlc3QgPSByZXEuaHR0cFJlcXVlc3Q7XG4gICAgaWYgKGh0dHBSZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcgfHwgaHR0cFJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBub3Qgc2V0IGluIEdFVC9IRUFEIHJlcXVlc3RzXG4gICAgICBkZWxldGUgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSkgeyAvLyBhbHdheXMgaGF2ZSBhIENvbnRlbnQtVHlwZVxuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICB9XG5cbiAgICB2YXIgY29udGVudFR5cGUgPSBodHRwUmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICBpZiAoQVdTLnV0aWwuaXNCcm93c2VyKCkpIHtcbiAgICAgIGlmICh0eXBlb2YgaHR0cFJlcXVlc3QuYm9keSA9PT0gJ3N0cmluZycgJiYgIWNvbnRlbnRUeXBlLm1hdGNoKC87XFxzKmNoYXJzZXQ9LykpIHtcbiAgICAgICAgdmFyIGNoYXJzZXQgPSAnOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gKz0gY2hhcnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXBsYWNlRm4gPSBmdW5jdGlvbihfLCBwcmVmaXgsIGNoYXJzZXROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIGNoYXJzZXROYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPVxuICAgICAgICAgIGNvbnRlbnRUeXBlLnJlcGxhY2UoLyg7XFxzKmNoYXJzZXQ9KSguKykkLywgcmVwbGFjZUZuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGNoZWNrc3VtcyBzaG91bGQgYmUgY29tcHV0ZWQgZm9yIHRoZSByZXF1ZXN0IGlmIGl0J3Mgbm90XG4gICAqIGFscmVhZHkgc2V0IGJ5IHtBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX0NIRUNLU1VNfS4gSXQgZGVwZW5kcyBvblxuICAgKiB3aGV0aGVyIHtBV1MuQ29uZmlnLmNvbXB1dGVDaGVja3N1bXN9IGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHJlcSBbQVdTLlJlcXVlc3RdIHRoZSByZXF1ZXN0IHRvIGNoZWNrIGFnYWluc3RcbiAgICogQHJldHVybiBbQm9vbGVhbl0gd2hldGhlciB0byBjb21wdXRlIGNoZWNrc3VtcyBmb3IgYSByZXF1ZXN0LlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHdpbGxDb21wdXRlQ2hlY2tzdW1zOiBmdW5jdGlvbiB3aWxsQ29tcHV0ZUNoZWNrc3VtcyhyZXEpIHtcbiAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXS5pbnB1dC5tZW1iZXJzO1xuICAgIHZhciBib2R5ID0gcmVxLmh0dHBSZXF1ZXN0LmJvZHk7XG4gICAgdmFyIG5lZWRzQ29udGVudE1ENSA9IHJlcS5zZXJ2aWNlLmNvbmZpZy5jb21wdXRlQ2hlY2tzdW1zICYmXG4gICAgICBydWxlcy5Db250ZW50TUQ1ICYmXG4gICAgICAhcmVxLnBhcmFtcy5Db250ZW50TUQ1ICYmXG4gICAgICBib2R5ICYmXG4gICAgICAoQVdTLnV0aWwuQnVmZmVyLmlzQnVmZmVyKHJlcS5odHRwUmVxdWVzdC5ib2R5KSB8fCB0eXBlb2YgcmVxLmh0dHBSZXF1ZXN0LmJvZHkgPT09ICdzdHJpbmcnKTtcblxuICAgIC8vIFNoYTI1NiBzaWduaW5nIGRpc2FibGVkLCBhbmQgbm90IGEgcHJlc2lnbmVkIHVybFxuICAgIGlmIChuZWVkc0NvbnRlbnRNRDUgJiYgcmVxLnNlcnZpY2Uuc2hvdWxkRGlzYWJsZUJvZHlTaWduaW5nKHJlcSkgJiYgIXJlcS5pc1ByZXNpZ25lZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTaWdWMiBhbmQgcHJlc2lnbiwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHB1cnBvc2UuXG4gICAgaWYgKG5lZWRzQ29udGVudE1ENSAmJiB0aGlzLmdldFNpZ25hdHVyZVZlcnNpb24ocmVxKSA9PT0gJ3MzJyAmJiByZXEuaXNQcmVzaWduZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBIGxpc3RlbmVyIHRoYXQgY29tcHV0ZXMgdGhlIENvbnRlbnQtTUQ1IGFuZCBzZXRzIGl0IGluIHRoZSBoZWFkZXIuXG4gICAqIFRoaXMgbGlzdGVuZXIgaXMgdG8gc3VwcG9ydCBTMy1zcGVjaWZpYyBmZWF0dXJlcyBsaWtlXG4gICAqIHMzRGlzYWJsZUJvZHlTaWduaW5nIGFuZCBTaWdWMiBwcmVzaWduLiBDb250ZW50IE1ENSBsb2dpYyBmb3IgU2lnVjQgaXNcbiAgICogaGFuZGxlZCBpbiBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX0NIRUNLU1VNXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29tcHV0ZUNvbnRlbnRNZDU6IGZ1bmN0aW9uIGNvbXB1dGVDb250ZW50TWQ1KHJlcSkge1xuICAgIGlmIChyZXEuc2VydmljZS53aWxsQ29tcHV0ZUNoZWNrc3VtcyhyZXEpKSB7XG4gICAgICB2YXIgbWQ1ID0gQVdTLnV0aWwuY3J5cHRvLm1kNShyZXEuaHR0cFJlcXVlc3QuYm9keSwgJ2Jhc2U2NCcpO1xuICAgICAgcmVxLmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtTUQ1J10gPSBtZDU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVTc2VDdXN0b21lcktleU1kNTogZnVuY3Rpb24gY29tcHV0ZVNzZUN1c3RvbWVyS2V5TWQ1KHJlcSkge1xuICAgIHZhciBrZXlzID0ge1xuICAgICAgU1NFQ3VzdG9tZXJLZXk6ICd4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleS1NRDUnLFxuICAgICAgQ29weVNvdXJjZVNTRUN1c3RvbWVyS2V5OiAneC1hbXotY29weS1zb3VyY2Utc2VydmVyLXNpZGUtZW5jcnlwdGlvbi1jdXN0b21lci1rZXktTUQ1J1xuICAgIH07XG4gICAgQVdTLnV0aWwuZWFjaChrZXlzLCBmdW5jdGlvbihrZXksIGhlYWRlcikge1xuICAgICAgaWYgKHJlcS5wYXJhbXNba2V5XSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBBV1MudXRpbC5jcnlwdG8ubWQ1KHJlcS5wYXJhbXNba2V5XSwgJ2Jhc2U2NCcpO1xuICAgICAgICByZXEuaHR0cFJlcXVlc3QuaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYnVja2V0IG5hbWUgc2hvdWxkIGJlIGxlZnQgaW4gdGhlIFVSSSBwYXRoIGZvclxuICAgKiBhIHJlcXVlc3QgdG8gUzMuICBUaGlzIGZ1bmN0aW9uIHRha2VzIGludG8gYWNjb3VudCB0aGUgY3VycmVudFxuICAgKiBlbmRwb2ludCBwcm90b2NvbCAoZS5nLiBodHRwIG9yIGh0dHBzKS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwYXRoU3R5bGVCdWNrZXROYW1lOiBmdW5jdGlvbiBwYXRoU3R5bGVCdWNrZXROYW1lKGJ1Y2tldE5hbWUpIHtcbiAgICAvLyB1c2VyIGNhbiBmb3JjZSBwYXRoIHN0eWxlIHJlcXVlc3RzIHZpYSB0aGUgY29uZmlndXJhdGlvblxuICAgIGlmICh0aGlzLmNvbmZpZy5zM0ZvcmNlUGF0aFN0eWxlKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5jb25maWcuczNCdWNrZXRFbmRwb2ludCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHMzdXRpbC5kbnNDb21wYXRpYmxlQnVja2V0TmFtZShidWNrZXROYW1lKSkge1xuICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5zc2xFbmFibGVkICYmIGJ1Y2tldE5hbWUubWF0Y2goL1xcLi8pKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIG5vdCBkbnMgY29tcGF0aWJsZSBuYW1lcyBtdXN0IGFsd2F5cyB1c2UgcGF0aCBzdHlsZVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRm9yIENPUFkgb3BlcmF0aW9ucywgc29tZSBjYW4gYmUgZXJyb3IgZXZlbiB3aXRoIHN0YXR1cyBjb2RlIDIwMC5cbiAgICogU0RLIHRyZWF0cyB0aGUgcmVzcG9uc2UgYXMgZXhjZXB0aW9uIHdoZW4gcmVzcG9uc2UgYm9keSBpbmRpY2F0ZXNcbiAgICogYW4gZXhjZXB0aW9uIG9yIGJvZHkgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgZXh0cmFjdEVycm9yRnJvbTIwMFJlc3BvbnNlOiBmdW5jdGlvbiBleHRyYWN0RXJyb3JGcm9tMjAwUmVzcG9uc2UocmVzcCkge1xuICAgIGlmICghb3BlcmF0aW9uc1dpdGgyMDBTdGF0dXNDb2RlRXJyb3JbcmVzcC5yZXF1ZXN0Lm9wZXJhdGlvbl0pIHJldHVybjtcbiAgICB2YXIgaHR0cFJlc3BvbnNlID0gcmVzcC5odHRwUmVzcG9uc2U7XG4gICAgaWYgKGh0dHBSZXNwb25zZS5ib2R5ICYmIGh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkubWF0Y2goJzxFcnJvcj4nKSkge1xuICAgICAgLy8gUmVzcG9uc2UgYm9keSB3aXRoICc8RXJyb3I+Li4uPC9FcnJvcj4nIGluZGljYXRlcyBhbiBleGNlcHRpb24uXG4gICAgICAvLyBHZXQgUzMgY2xpZW50IG9iamVjdC4gSW4gTWFuYWdlZFVwbG9hZCwgdGhpcy5zZXJ2aWNlIHJlZmVycyB0b1xuICAgICAgLy8gUzMgY2xpZW50IG9iamVjdC5cbiAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgICB2YXIgc2VydmljZSA9IHRoaXMuc2VydmljZSA/IHRoaXMuc2VydmljZSA6IHRoaXM7XG4gICAgICBzZXJ2aWNlLmV4dHJhY3RFcnJvcihyZXNwKTtcbiAgICAgIHRocm93IHJlc3AuZXJyb3I7XG4gICAgfSBlbHNlIGlmICghaHR0cFJlc3BvbnNlLmJvZHkgfHwgIWh0dHBSZXNwb25zZS5ib2R5LnRvU3RyaW5nKCkubWF0Y2goLzxbXFx3X10vKSkge1xuICAgICAgLy8gV2hlbiBib2R5IGlzIGVtcHR5IG9yIGluY29tcGxldGUsIFMzIG1pZ2h0IHN0b3AgdGhlIHJlcXVlc3Qgb24gZGV0ZWN0aW5nIGNsaWVudFxuICAgICAgLy8gc2lkZSBhYm9ydGluZyB0aGUgcmVxdWVzdC5cbiAgICAgIHJlc3AuZGF0YSA9IG51bGw7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW50ZXJuYWxFcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdTMyBhYm9ydGVkIHJlcXVlc3QnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4gW0Jvb2xlYW5dIHdoZXRoZXIgdGhlIGVycm9yIGNhbiBiZSByZXRyaWVkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcmV0cnlhYmxlRXJyb3I6IGZ1bmN0aW9uIHJldHJ5YWJsZUVycm9yKGVycm9yLCByZXF1ZXN0KSB7XG4gICAgaWYgKG9wZXJhdGlvbnNXaXRoMjAwU3RhdHVzQ29kZUVycm9yW3JlcXVlc3Qub3BlcmF0aW9uXSAmJlxuICAgICAgICBlcnJvci5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldCAmJlxuICAgICAgICByZXF1ZXN0LnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbcmVxdWVzdC5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdSZXF1ZXN0VGltZW91dCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgJiZcbiAgICAgICAgcmVnaW9uUmVkaXJlY3RFcnJvckNvZGVzLmluZGV4T2YoZXJyb3IuY29kZSkgIT0gLTEgJiZcbiAgICAgICAgZXJyb3IucmVnaW9uICYmIGVycm9yLnJlZ2lvbiAhPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgcmVxdWVzdC5odHRwUmVxdWVzdC5yZWdpb24gPSBlcnJvci5yZWdpb247XG4gICAgICBpZiAoZXJyb3Iuc3RhdHVzQ29kZSA9PT0gMzAxKSB7XG4gICAgICAgIHJlcXVlc3Quc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zdXBlciA9IEFXUy5TZXJ2aWNlLnByb3RvdHlwZS5yZXRyeWFibGVFcnJvcjtcbiAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvciwgcmVxdWVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGh0dHBSZXF1ZXN0IHdpdGggcmVnaW9uLiBJZiByZWdpb24gaXMgbm90IHByb3ZpZGVkLCB0aGVuXG4gICAqIHRoZSBodHRwUmVxdWVzdCB3aWxsIGJlIHVwZGF0ZWQgYmFzZWQgb24gaHR0cFJlcXVlc3QucmVnaW9uXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlUmVxQnVja2V0UmVnaW9uOiBmdW5jdGlvbiB1cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgcmVnaW9uKSB7XG4gICAgdmFyIGh0dHBSZXF1ZXN0ID0gcmVxdWVzdC5odHRwUmVxdWVzdDtcbiAgICBpZiAodHlwZW9mIHJlZ2lvbiA9PT0gJ3N0cmluZycgJiYgcmVnaW9uLmxlbmd0aCkge1xuICAgICAgaHR0cFJlcXVlc3QucmVnaW9uID0gcmVnaW9uO1xuICAgIH1cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmVuZHBvaW50Lmhvc3QubWF0Y2goL3MzKD8hLWFjY2VsZXJhdGUpLipcXC5hbWF6b25hd3NcXC5jb20kLykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlcnZpY2UgPSByZXF1ZXN0LnNlcnZpY2U7XG4gICAgdmFyIHMzQ29uZmlnID0gc2VydmljZS5jb25maWc7XG4gICAgdmFyIHMzQnVja2V0RW5kcG9pbnQgPSBzM0NvbmZpZy5zM0J1Y2tldEVuZHBvaW50O1xuICAgIGlmIChzM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBkZWxldGUgczNDb25maWcuczNCdWNrZXRFbmRwb2ludDtcbiAgICB9XG4gICAgdmFyIG5ld0NvbmZpZyA9IEFXUy51dGlsLmNvcHkoczNDb25maWcpO1xuICAgIGRlbGV0ZSBuZXdDb25maWcuZW5kcG9pbnQ7XG4gICAgbmV3Q29uZmlnLnJlZ2lvbiA9IGh0dHBSZXF1ZXN0LnJlZ2lvbjtcblxuICAgIGh0dHBSZXF1ZXN0LmVuZHBvaW50ID0gKG5ldyBBV1MuUzMobmV3Q29uZmlnKSkuZW5kcG9pbnQ7XG4gICAgc2VydmljZS5wb3B1bGF0ZVVSSShyZXF1ZXN0KTtcbiAgICBzM0NvbmZpZy5zM0J1Y2tldEVuZHBvaW50ID0gczNCdWNrZXRFbmRwb2ludDtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzLkhvc3QgPSBodHRwUmVxdWVzdC5lbmRwb2ludC5ob3N0O1xuXG4gICAgaWYgKHJlcXVlc3QuX2FzbS5jdXJyZW50U3RhdGUgPT09ICd2YWxpZGF0ZScpIHtcbiAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2J1aWxkJywgc2VydmljZS5wb3B1bGF0ZVVSSSk7XG4gICAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCdidWlsZCcsIHNlcnZpY2UucmVtb3ZlVmlydHVhbEhvc3RlZEJ1Y2tldEZyb21QYXRoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgc3BlY2lhbGl6ZWQgcGFyc2VyIGZvciBnZXRCdWNrZXRMb2NhdGlvbiAtLSBhbGwgb3RoZXJcbiAgICogb3BlcmF0aW9ucyBhcmUgcGFyc2VkIGJ5IHRoZSBzdXBlciBjbGFzcy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0RGF0YTogZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgaWYgKHJlcS5vcGVyYXRpb24gPT09ICdnZXRCdWNrZXRMb2NhdGlvbicpIHtcbiAgICAgIHZhciBtYXRjaCA9IHJlc3AuaHR0cFJlc3BvbnNlLmJvZHkudG9TdHJpbmcoKS5tYXRjaCgvPiguKyk8XFwvTG9jYXRpb24vKTtcbiAgICAgIGRlbGV0ZSByZXNwLmRhdGFbJ18nXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXNwLmRhdGEuTG9jYXRpb25Db25zdHJhaW50ID0gbWF0Y2hbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNwLmRhdGEuTG9jYXRpb25Db25zdHJhaW50ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBidWNrZXQgPSByZXEucGFyYW1zLkJ1Y2tldCB8fCBudWxsO1xuICAgIGlmIChyZXEub3BlcmF0aW9uID09PSAnZGVsZXRlQnVja2V0JyAmJiB0eXBlb2YgYnVja2V0ID09PSAnc3RyaW5nJyAmJiAhcmVzcC5lcnJvcikge1xuICAgICAgcmVxLnNlcnZpY2UuY2xlYXJCdWNrZXRSZWdpb25DYWNoZShidWNrZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVhZGVycyA9IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnMgfHwge307XG4gICAgICB2YXIgcmVnaW9uID0gaGVhZGVyc1sneC1hbXotYnVja2V0LXJlZ2lvbiddIHx8IG51bGw7XG4gICAgICBpZiAoIXJlZ2lvbiAmJiByZXEub3BlcmF0aW9uID09PSAnY3JlYXRlQnVja2V0JyAmJiAhcmVzcC5lcnJvcikge1xuICAgICAgICB2YXIgY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbiA9IHJlcS5wYXJhbXMuQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbjtcbiAgICAgICAgaWYgKCFjcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgcmVnaW9uID0gJ3VzLWVhc3QtMSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbi5Mb2NhdGlvbkNvbnN0cmFpbnQgPT09ICdFVScpIHtcbiAgICAgICAgICByZWdpb24gPSAnZXUtd2VzdC0xJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBjcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uLkxvY2F0aW9uQ29uc3RyYWludDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlZ2lvbikge1xuICAgICAgICAgIGlmIChidWNrZXQgJiYgcmVnaW9uICE9PSByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdKSB7XG4gICAgICAgICAgICByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZVtidWNrZXRdID0gcmVnaW9uO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVxLnNlcnZpY2UuZXh0cmFjdFJlcXVlc3RJZHMocmVzcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGFuIGVycm9yIG9iamVjdCBmcm9tIHRoZSBodHRwIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RFcnJvcjogZnVuY3Rpb24gZXh0cmFjdEVycm9yKHJlc3ApIHtcbiAgICB2YXIgY29kZXMgPSB7XG4gICAgICAzMDQ6ICdOb3RNb2RpZmllZCcsXG4gICAgICA0MDM6ICdGb3JiaWRkZW4nLFxuICAgICAgNDAwOiAnQmFkUmVxdWVzdCcsXG4gICAgICA0MDQ6ICdOb3RGb3VuZCdcbiAgICB9O1xuXG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgY29kZSA9IHJlc3AuaHR0cFJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgdmFyIGJvZHkgPSByZXNwLmh0dHBSZXNwb25zZS5ib2R5IHx8ICcnO1xuXG4gICAgdmFyIGhlYWRlcnMgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzIHx8IHt9O1xuICAgIHZhciByZWdpb24gPSBoZWFkZXJzWyd4LWFtei1idWNrZXQtcmVnaW9uJ10gfHwgbnVsbDtcbiAgICB2YXIgYnVja2V0ID0gcmVxLnBhcmFtcy5CdWNrZXQgfHwgbnVsbDtcbiAgICB2YXIgYnVja2V0UmVnaW9uQ2FjaGUgPSByZXEuc2VydmljZS5idWNrZXRSZWdpb25DYWNoZTtcbiAgICBpZiAocmVnaW9uICYmIGJ1Y2tldCAmJiByZWdpb24gIT09IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0pIHtcbiAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSByZWdpb247XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlZFJlZ2lvbjtcbiAgICBpZiAoY29kZXNbY29kZV0gJiYgYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChidWNrZXQgJiYgIXJlZ2lvbikge1xuICAgICAgICBjYWNoZWRSZWdpb24gPSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRdIHx8IG51bGw7XG4gICAgICAgIGlmIChjYWNoZWRSZWdpb24gIT09IHJlcS5odHRwUmVxdWVzdC5yZWdpb24pIHtcbiAgICAgICAgICByZWdpb24gPSBjYWNoZWRSZWdpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3AuZXJyb3IgPSBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiBjb2Rlc1tjb2RlXSxcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBBV1MuWE1MLlBhcnNlcigpLnBhcnNlKGJvZHkudG9TdHJpbmcoKSk7XG5cbiAgICAgIGlmIChkYXRhLlJlZ2lvbiAmJiAhcmVnaW9uKSB7XG4gICAgICAgIHJlZ2lvbiA9IGRhdGEuUmVnaW9uO1xuICAgICAgICBpZiAoYnVja2V0ICYmIHJlZ2lvbiAhPT0gYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSkge1xuICAgICAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSByZWdpb247XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYnVja2V0ICYmICFyZWdpb24gJiYgIWRhdGEuUmVnaW9uKSB7XG4gICAgICAgIGNhY2hlZFJlZ2lvbiA9IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKGNhY2hlZFJlZ2lvbiAhPT0gcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgICAgIHJlZ2lvbiA9IGNhY2hlZFJlZ2lvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNwLmVycm9yID0gQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogZGF0YS5Db2RlIHx8IGNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IGRhdGEuTWVzc2FnZSB8fCBudWxsLFxuICAgICAgICByZWdpb246IHJlZ2lvblxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcS5zZXJ2aWNlLmV4dHJhY3RSZXF1ZXN0SWRzKHJlc3ApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiByZWdpb24gd2FzIG5vdCBvYnRhaW5lZCBzeW5jaHJvbm91c2x5LCB0aGVuIHNlbmQgYXN5bmMgcmVxdWVzdFxuICAgKiB0byBnZXQgYnVja2V0IHJlZ2lvbiBmb3IgZXJyb3JzIHJlc3VsdGluZyBmcm9tIHdyb25nIHJlZ2lvbi5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICByZXF1ZXN0QnVja2V0UmVnaW9uOiBmdW5jdGlvbiByZXF1ZXN0QnVja2V0UmVnaW9uKHJlc3AsIGRvbmUpIHtcbiAgICB2YXIgZXJyb3IgPSByZXNwLmVycm9yO1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMuQnVja2V0IHx8IG51bGw7XG5cbiAgICBpZiAoIWVycm9yIHx8ICFidWNrZXQgfHwgZXJyb3IucmVnaW9uIHx8IHJlcS5vcGVyYXRpb24gPT09ICdsaXN0T2JqZWN0cycgfHxcbiAgICAgICAgKEFXUy51dGlsLmlzTm9kZSgpICYmIHJlcS5vcGVyYXRpb24gPT09ICdoZWFkQnVja2V0JykgfHxcbiAgICAgICAgKGVycm9yLnN0YXR1c0NvZGUgPT09IDQwMCAmJiByZXEub3BlcmF0aW9uICE9PSAnaGVhZE9iamVjdCcpIHx8XG4gICAgICAgIHJlZ2lvblJlZGlyZWN0RXJyb3JDb2Rlcy5pbmRleE9mKGVycm9yLmNvZGUpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgdmFyIHJlcU9wZXJhdGlvbiA9IEFXUy51dGlsLmlzTm9kZSgpID8gJ2hlYWRCdWNrZXQnIDogJ2xpc3RPYmplY3RzJztcbiAgICB2YXIgcmVxUGFyYW1zID0ge0J1Y2tldDogYnVja2V0fTtcbiAgICBpZiAocmVxT3BlcmF0aW9uID09PSAnbGlzdE9iamVjdHMnKSByZXFQYXJhbXMuTWF4S2V5cyA9IDA7XG4gICAgdmFyIHJlZ2lvblJlcSA9IHJlcS5zZXJ2aWNlW3JlcU9wZXJhdGlvbl0ocmVxUGFyYW1zKTtcbiAgICByZWdpb25SZXEuX3JlcXVlc3RSZWdpb25Gb3JCdWNrZXQgPSBidWNrZXQ7XG4gICAgcmVnaW9uUmVxLnNlbmQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVnaW9uID0gcmVxLnNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGVbYnVja2V0XSB8fCBudWxsO1xuICAgICAgZXJyb3IucmVnaW9uID0gcmVnaW9uO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gICAvKipcbiAgICogRm9yIGJyb3dzZXIgb25seS4gSWYgTmV0d29ya2luZ0Vycm9yIHJlY2VpdmVkLCB3aWxsIGF0dGVtcHQgdG8gb2J0YWluXG4gICAqIHRoZSBidWNrZXQgcmVnaW9uLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gICByZXFSZWdpb25Gb3JOZXR3b3JraW5nRXJyb3I6IGZ1bmN0aW9uIHJlcVJlZ2lvbkZvck5ldHdvcmtpbmdFcnJvcihyZXNwLCBkb25lKSB7XG4gICAgaWYgKCFBV1MudXRpbC5pc0Jyb3dzZXIoKSkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgdmFyIGVycm9yID0gcmVzcC5lcnJvcjtcbiAgICB2YXIgcmVxdWVzdCA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgYnVja2V0ID0gcmVxdWVzdC5wYXJhbXMuQnVja2V0O1xuICAgIGlmICghZXJyb3IgfHwgZXJyb3IuY29kZSAhPT0gJ05ldHdvcmtpbmdFcnJvcicgfHwgIWJ1Y2tldCB8fFxuICAgICAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbiA9PT0gJ3VzLWVhc3QtMScpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIHZhciBzZXJ2aWNlID0gcmVxdWVzdC5zZXJ2aWNlO1xuICAgIHZhciBidWNrZXRSZWdpb25DYWNoZSA9IHNlcnZpY2UuYnVja2V0UmVnaW9uQ2FjaGU7XG4gICAgdmFyIGNhY2hlZFJlZ2lvbiA9IGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcblxuICAgIGlmIChjYWNoZWRSZWdpb24gJiYgY2FjaGVkUmVnaW9uICE9PSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LnJlZ2lvbikge1xuICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgY2FjaGVkUmVnaW9uKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKCFzM3V0aWwuZG5zQ29tcGF0aWJsZUJ1Y2tldE5hbWUoYnVja2V0KSkge1xuICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgJ3VzLWVhc3QtMScpO1xuICAgICAgaWYgKGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gIT09ICd1cy1lYXN0LTEnKSB7XG4gICAgICAgIGJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gPSAndXMtZWFzdC0xJztcbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuaHR0cFJlcXVlc3QudmlydHVhbEhvc3RlZEJ1Y2tldCkge1xuICAgICAgdmFyIGdldFJlZ2lvblJlcSA9IHNlcnZpY2UubGlzdE9iamVjdHMoe0J1Y2tldDogYnVja2V0LCBNYXhLZXlzOiAwfSk7XG4gICAgICBzZXJ2aWNlLnVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbihnZXRSZWdpb25SZXEsICd1cy1lYXN0LTEnKTtcbiAgICAgIGdldFJlZ2lvblJlcS5fcmVxdWVzdFJlZ2lvbkZvckJ1Y2tldCA9IGJ1Y2tldDtcblxuICAgICAgZ2V0UmVnaW9uUmVxLnNlbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWdpb24gPSBzZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF0gfHwgbnVsbDtcbiAgICAgICAgaWYgKHJlZ2lvbiAmJiByZWdpb24gIT09IHJlcXVlc3QuaHR0cFJlcXVlc3QucmVnaW9uKSB7XG4gICAgICAgICAgc2VydmljZS51cGRhdGVSZXFCdWNrZXRSZWdpb24ocmVxdWVzdCwgcmVnaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRE5TLWNvbXBhdGlibGUgcGF0aC1zdHlsZVxuICAgICAgLy8gKHMzRm9yY2VQYXRoU3R5bGUgb3IgYnVja2V0IG5hbWUgd2l0aCBkb3Qgb3ZlciBodHRwcylcbiAgICAgIC8vIENhbm5vdCBvYnRhaW4gcmVnaW9uIGluZm9ybWF0aW9uIGZvciB0aGlzIGNhc2VcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gICB9LFxuXG4gIC8qKlxuICAgKiBDYWNoZSBmb3IgYnVja2V0IHJlZ2lvbi5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICAgYnVja2V0UmVnaW9uQ2FjaGU6IHt9LFxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYnVja2V0IHJlZ2lvbiBjYWNoZS5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICAgY2xlYXJCdWNrZXRSZWdpb25DYWNoZTogZnVuY3Rpb24oYnVja2V0cykge1xuICAgIHZhciBidWNrZXRSZWdpb25DYWNoZSA9IHRoaXMuYnVja2V0UmVnaW9uQ2FjaGU7XG4gICAgaWYgKCFidWNrZXRzKSB7XG4gICAgICBidWNrZXRzID0gT2JqZWN0LmtleXMoYnVja2V0UmVnaW9uQ2FjaGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJ1Y2tldHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWNrZXRzID0gW2J1Y2tldHNdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBidWNrZXRSZWdpb25DYWNoZVtidWNrZXRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Y2tldFJlZ2lvbkNhY2hlO1xuICAgfSxcblxuICAgLyoqXG4gICAgKiBDb3JyZWN0cyByZXF1ZXN0IHJlZ2lvbiBpZiBidWNrZXQncyBjYWNoZWQgcmVnaW9uIGlzIGRpZmZlcmVudFxuICAgICpcbiAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICovXG4gIGNvcnJlY3RCdWNrZXRSZWdpb25Gcm9tQ2FjaGU6IGZ1bmN0aW9uIGNvcnJlY3RCdWNrZXRSZWdpb25Gcm9tQ2FjaGUocmVxKSB7XG4gICAgdmFyIGJ1Y2tldCA9IHJlcS5wYXJhbXMuQnVja2V0IHx8IG51bGw7XG4gICAgaWYgKGJ1Y2tldCkge1xuICAgICAgdmFyIHNlcnZpY2UgPSByZXEuc2VydmljZTtcbiAgICAgIHZhciByZXF1ZXN0UmVnaW9uID0gcmVxLmh0dHBSZXF1ZXN0LnJlZ2lvbjtcbiAgICAgIHZhciBjYWNoZWRSZWdpb24gPSBzZXJ2aWNlLmJ1Y2tldFJlZ2lvbkNhY2hlW2J1Y2tldF07XG4gICAgICBpZiAoY2FjaGVkUmVnaW9uICYmIGNhY2hlZFJlZ2lvbiAhPT0gcmVxdWVzdFJlZ2lvbikge1xuICAgICAgICBzZXJ2aWNlLnVwZGF0ZVJlcUJ1Y2tldFJlZ2lvbihyZXEsIGNhY2hlZFJlZ2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBTMyBzcGVjaWZpYyByZXF1ZXN0IGlkcyBmcm9tIHRoZSBodHRwIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RSZXF1ZXN0SWRzOiBmdW5jdGlvbiBleHRyYWN0UmVxdWVzdElkcyhyZXNwKSB7XG4gICAgdmFyIGV4dGVuZGVkUmVxdWVzdElkID0gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVycyA/IHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16LWlkLTInXSA6IG51bGw7XG4gICAgdmFyIGNmSWQgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzID8gcmVzcC5odHRwUmVzcG9uc2UuaGVhZGVyc1sneC1hbXotY2YtaWQnXSA6IG51bGw7XG4gICAgcmVzcC5leHRlbmRlZFJlcXVlc3RJZCA9IGV4dGVuZGVkUmVxdWVzdElkO1xuICAgIHJlc3AuY2ZJZCA9IGNmSWQ7XG5cbiAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgcmVzcC5lcnJvci5yZXF1ZXN0SWQgPSByZXNwLnJlcXVlc3RJZCB8fCBudWxsO1xuICAgICAgcmVzcC5lcnJvci5leHRlbmRlZFJlcXVlc3RJZCA9IGV4dGVuZGVkUmVxdWVzdElkO1xuICAgICAgcmVzcC5lcnJvci5jZklkID0gY2ZJZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHByZS1zaWduZWQgVVJMIGZvciBhIGdpdmVuIG9wZXJhdGlvbiBuYW1lLlxuICAgKlxuICAgKiBAbm90ZSBZb3UgbXVzdCBlbnN1cmUgdGhhdCB5b3UgaGF2ZSBzdGF0aWMgb3IgcHJldmlvdXNseSByZXNvbHZlZFxuICAgKiAgIGNyZWRlbnRpYWxzIGlmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLFxuICAgKiAgIG90aGVyd2lzZSBpdCBtYXkgbm90IHByb3Blcmx5IHNpZ24gdGhlIHJlcXVlc3QuIElmIHlvdSBjYW5ub3QgZ3VhcmFudGVlXG4gICAqICAgdGhpcyAoeW91IGFyZSB1c2luZyBhbiBhc3luY2hyb25vdXMgY3JlZGVudGlhbCBwcm92aWRlciwgaS5lLiwgRUMyXG4gICAqICAgSUFNIHJvbGVzKSwgeW91IHNob3VsZCBhbHdheXMgY2FsbCB0aGlzIG1ldGhvZCB3aXRoIGFuIGFzeW5jaHJvbm91c1xuICAgKiAgIGNhbGxiYWNrLlxuICAgKiBAbm90ZSBOb3QgYWxsIG9wZXJhdGlvbiBwYXJhbWV0ZXJzIGFyZSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBwcmUtc2lnbmVkXG4gICAqICAgVVJMcy4gQ2VydGFpbiBwYXJhbWV0ZXJzLCBzdWNoIGFzIGBTU0VDdXN0b21lcktleWAsIGBBQ0xgLCBgRXhwaXJlc2AsXG4gICAqICAgYENvbnRlbnRMZW5ndGhgLCBvciBgVGFnZ2luZ2AgbXVzdCBiZSBwcm92aWRlZCBhcyBoZWFkZXJzIHdoZW4gc2VuZGluZyBhXG4gICAqICAgcmVxdWVzdC4gSWYgeW91IGFyZSB1c2luZyBwcmUtc2lnbmVkIFVSTHMgdG8gdXBsb2FkIGZyb20gYSBicm93c2VyIGFuZFxuICAgKiAgIG5lZWQgdG8gdXNlIHRoZXNlIGZpZWxkcywgc2VlIHtjcmVhdGVQcmVzaWduZWRQb3N0fS5cbiAgICogQG5vdGUgVGhlIGRlZmF1bHQgc2lnbmVyIGFsbG93cyBhbHRlcmluZyB0aGUgcmVxdWVzdCBieSBhZGRpbmcgY29ycmVzcG9uZGluZ1xuICAgKiAgIGhlYWRlcnMgdG8gc2V0IHNvbWUgcGFyYW1ldGVycyAoZS5nLiBSYW5nZSkgYW5kIHRoZXNlIGFkZGVkIHBhcmFtZXRlcnNcbiAgICogICB3b24ndCBiZSBzaWduZWQuIFlvdSBtdXN0IHVzZSBzaWduYXR1cmVWZXJzaW9uIHY0IHRvIHRvIGluY2x1ZGUgdGhlc2VcbiAgICogICBwYXJhbWV0ZXJzIGluIHRoZSBzaWduZWQgcG9ydGlvbiBvZiB0aGUgVVJMIGFuZCBlbmZvcmNlIGV4YWN0IG1hdGNoaW5nXG4gICAqICAgYmV0d2VlbiBoZWFkZXJzIGFuZCBzaWduZWQgcGFyYW1zIGluIHRoZSBVUkwuXG4gICAqIEBub3RlIFRoaXMgb3BlcmF0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggYSBwcm9taXNlLiBTZWUgbm90ZSBhYm92ZSByZWdhcmRpbmdcbiAgICogICBhc3luY2hyb25vdXMgY3JlZGVudGlhbHMgYW5kIHVzZSB3aXRoIGEgY2FsbGJhY2suXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG9wZXJhdGlvbiB0byBjYWxsXG4gICAqIEBwYXJhbSBwYXJhbXMgW21hcF0gcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBvcGVyYXRpb24uIFNlZSB0aGUgZ2l2ZW5cbiAgICogICBvcGVyYXRpb24gZm9yIHRoZSBleHBlY3RlZCBvcGVyYXRpb24gcGFyYW1ldGVycy4gSW4gYWRkaXRpb24sIHlvdSBjYW5cbiAgICogICBhbHNvIHBhc3MgdGhlIFwiRXhwaXJlc1wiIHBhcmFtZXRlciB0byBpbmZvcm0gUzMgaG93IGxvbmcgdGhlIFVSTCBzaG91bGRcbiAgICogICB3b3JrIGZvci5cbiAgICogQG9wdGlvbiBwYXJhbXMgRXhwaXJlcyBbSW50ZWdlcl0gKDkwMCkgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGV4cGlyZVxuICAgKiAgIHRoZSBwcmUtc2lnbmVkIFVSTCBvcGVyYXRpb24gaW4uIERlZmF1bHRzIHRvIDE1IG1pbnV0ZXMuXG4gICAqIEBwYXJhbSBjYWxsYmFjayBbRnVuY3Rpb25dIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAgIHBhc3MgdGhlIFVSTCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciAoYWZ0ZXIgdGhlIGVycm9yIHBhcmFtZXRlcikgdG9cbiAgICogICB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4gW1N0cmluZ10gaWYgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLCByZXR1cm5zIHRoZVxuICAgKiAgIHNpZ25lZCBVUkwuXG4gICAqIEByZXR1cm4gW251bGxdIG5vdGhpbmcgaXMgcmV0dXJuZWQgaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZC5cbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBnZXRPYmplY3Qgb3BlcmF0aW9uIChzeW5jaHJvbm91c2x5KVxuICAgKiAgIHZhciBwYXJhbXMgPSB7QnVja2V0OiAnYnVja2V0JywgS2V5OiAna2V5J307XG4gICAqICAgdmFyIHVybCA9IHMzLmdldFNpZ25lZFVybCgnZ2V0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqIEBleGFtcGxlIFByZS1zaWduaW5nIGEgcHV0T2JqZWN0IChhc3luY2hyb25vdXNseSlcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleSd9O1xuICAgKiAgIHMzLmdldFNpZ25lZFVybCgncHV0T2JqZWN0JywgcGFyYW1zLCBmdW5jdGlvbiAoZXJyLCB1cmwpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTtcbiAgICogICB9KTtcbiAgICogQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBwdXRPYmplY3Qgb3BlcmF0aW9uIHdpdGggYSBzcGVjaWZpYyBwYXlsb2FkXG4gICAqICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiAnYm9keSd9O1xuICAgKiAgIHZhciB1cmwgPSBzMy5nZXRTaWduZWRVcmwoJ3B1dE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiBAZXhhbXBsZSBQYXNzaW5nIGluIGEgMS1taW51dGUgZXhwaXJ5IHRpbWUgZm9yIGEgcHJlLXNpZ25lZCBVUkxcbiAgICogICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEV4cGlyZXM6IDYwfTtcbiAgICogICB2YXIgdXJsID0gczMuZ2V0U2lnbmVkVXJsKCdnZXRPYmplY3QnLCBwYXJhbXMpO1xuICAgKiAgIGNvbnNvbGUubG9nKCdUaGUgVVJMIGlzJywgdXJsKTsgLy8gZXhwaXJlcyBpbiA2MCBzZWNvbmRzXG4gICAqL1xuICBnZXRTaWduZWRVcmw6IGZ1bmN0aW9uIGdldFNpZ25lZFVybChvcGVyYXRpb24sIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICBwYXJhbXMgPSBBV1MudXRpbC5jb3B5KHBhcmFtcyB8fCB7fSk7XG4gICAgdmFyIGV4cGlyZXMgPSBwYXJhbXMuRXhwaXJlcyB8fCA5MDA7XG5cbiAgICBpZiAodHlwZW9mIGV4cGlyZXMgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSxcbiAgICAgICAgeyBjb2RlOiAnSW52YWxpZFBhcmFtZXRlckV4Y2VwdGlvbicsIG1lc3NhZ2U6ICdUaGUgZXhwaXJhdGlvbiBtdXN0IGJlIGEgbnVtYmVyLCByZWNlaXZlZCAnICsgdHlwZW9mIGV4cGlyZXMgfSk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHBhcmFtcy5FeHBpcmVzOyAvLyB3ZSBjYW4ndCB2YWxpZGF0ZSB0aGlzXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KG9wZXJhdGlvbiwgcGFyYW1zKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgQVdTLnV0aWwuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlcXVlc3QucHJlc2lnbihleHBpcmVzLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcXVlc3QucHJlc2lnbihleHBpcmVzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAIW1ldGhvZCAgZ2V0U2lnbmVkVXJsUHJvbWlzZSgpXG4gICAqICAgUmV0dXJucyBhICd0aGVuYWJsZScgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCBhIHByZS1zaWduZWQgVVJMXG4gICAqICAgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uIG5hbWUuXG4gICAqXG4gICAqICAgVHdvIGNhbGxiYWNrcyBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIGB0aGVuYCBtZXRob2Qgb24gdGhlIHJldHVybmVkIHByb21pc2UuXG4gICAqICAgVGhlIGZpcnN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIHRoZSBzZWNvbmRcbiAgICogICBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgcHJvbWlzZSBpcyByZWplY3RlZC5cbiAgICogICBAbm90ZSBOb3QgYWxsIG9wZXJhdGlvbiBwYXJhbWV0ZXJzIGFyZSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBwcmUtc2lnbmVkXG4gICAqICAgICAgVVJMcy4gQ2VydGFpbiBwYXJhbWV0ZXJzLCBzdWNoIGFzIGBTU0VDdXN0b21lcktleWAsIGBBQ0xgLCBgRXhwaXJlc2AsXG4gICAqICAgICAgYENvbnRlbnRMZW5ndGhgLCBvciBgVGFnZ2luZ2AgbXVzdCBiZSBwcm92aWRlZCBhcyBoZWFkZXJzIHdoZW4gc2VuZGluZyBhXG4gICAqICAgICAgcmVxdWVzdC4gSWYgeW91IGFyZSB1c2luZyBwcmUtc2lnbmVkIFVSTHMgdG8gdXBsb2FkIGZyb20gYSBicm93c2VyIGFuZFxuICAgKiAgICAgIG5lZWQgdG8gdXNlIHRoZXNlIGZpZWxkcywgc2VlIHtjcmVhdGVQcmVzaWduZWRQb3N0fS5cbiAgICogICBAcGFyYW0gb3BlcmF0aW9uIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBvcGVyYXRpb24gdG8gY2FsbFxuICAgKiAgIEBwYXJhbSBwYXJhbXMgW21hcF0gcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBvcGVyYXRpb24uIFNlZSB0aGUgZ2l2ZW5cbiAgICogICAgICBvcGVyYXRpb24gZm9yIHRoZSBleHBlY3RlZCBvcGVyYXRpb24gcGFyYW1ldGVycy4gSW4gYWRkaXRpb24sIHlvdSBjYW5cbiAgICogICAgICBhbHNvIHBhc3MgdGhlIFwiRXhwaXJlc1wiIHBhcmFtZXRlciB0byBpbmZvcm0gUzMgaG93IGxvbmcgdGhlIFVSTCBzaG91bGRcbiAgICogICAgICB3b3JrIGZvci5cbiAgICogICBAb3B0aW9uIHBhcmFtcyBFeHBpcmVzIFtJbnRlZ2VyXSAoOTAwKSB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gZXhwaXJlXG4gICAqICAgICAgdGhlIHByZS1zaWduZWQgVVJMIG9wZXJhdGlvbiBpbi4gRGVmYXVsdHMgdG8gMTUgbWludXRlcy5cbiAgICogICBAY2FsbGJhY2sgZnVsZmlsbGVkQ2FsbGJhY2sgZnVuY3Rpb24odXJsKVxuICAgKiAgICAgQ2FsbGVkIGlmIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICogICAgIEBwYXJhbSB1cmwgW1N0cmluZ10gdGhlIHNpZ25lZCB1cmxcbiAgICogICBAY2FsbGJhY2sgcmVqZWN0ZWRDYWxsYmFjayBmdW5jdGlvbihlcnIpXG4gICAqICAgICBDYWxsZWQgaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQuXG4gICAqICAgICBAcGFyYW0gZXJyIFtFcnJvcl0gaWYgYW4gZXJyb3Igb2NjdXJyZWQsIHRoaXMgdmFsdWUgd2lsbCBiZSBmaWxsZWRcbiAgICogICBAcmV0dXJuIFtQcm9taXNlXSBBIHByb21pc2UgdGhhdCByZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiB0aGUgYHJlZnJlc2hgIGNhbGwuXG4gICAqICAgQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBnZXRPYmplY3Qgb3BlcmF0aW9uXG4gICAqICAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknfTtcbiAgICogICAgICB2YXIgcHJvbWlzZSA9IHMzLmdldFNpZ25lZFVybFByb21pc2UoJ2dldE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgKiAgICAgICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiAgICAgIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqICAgQGV4YW1wbGUgUHJlLXNpZ25pbmcgYSBwdXRPYmplY3Qgb3BlcmF0aW9uIHdpdGggYSBzcGVjaWZpYyBwYXlsb2FkXG4gICAqICAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiAnYm9keSd9O1xuICAgKiAgICAgIHZhciBwcm9taXNlID0gczMuZ2V0U2lnbmVkVXJsUHJvbWlzZSgncHV0T2JqZWN0JywgcGFyYW1zKTtcbiAgICogICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odXJsKSB7XG4gICAqICAgICAgICBjb25zb2xlLmxvZygnVGhlIFVSTCBpcycsIHVybCk7XG4gICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7IC4uLiB9KTtcbiAgICogICBAZXhhbXBsZSBQYXNzaW5nIGluIGEgMS1taW51dGUgZXhwaXJ5IHRpbWUgZm9yIGEgcHJlLXNpZ25lZCBVUkxcbiAgICogICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEV4cGlyZXM6IDYwfTtcbiAgICogICAgICB2YXIgcHJvbWlzZSA9IHMzLmdldFNpZ25lZFVybFByb21pc2UoJ2dldE9iamVjdCcsIHBhcmFtcyk7XG4gICAqICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgKiAgICAgICAgY29uc29sZS5sb2coJ1RoZSBVUkwgaXMnLCB1cmwpO1xuICAgKiAgICAgIH0sIGZ1bmN0aW9uKGVycikgeyAuLi4gfSk7XG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZXQgYSBwcmUtc2lnbmVkIFBPU1QgcG9saWN5IHRvIHN1cHBvcnQgdXBsb2FkaW5nIHRvIFMzIGRpcmVjdGx5IGZyb20gYW5cbiAgICogSFRNTCBmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIFttYXBdXG4gICAqIEBvcHRpb24gcGFyYW1zIEJ1Y2tldCBbU3RyaW5nXSAgICAgVGhlIGJ1Y2tldCB0byB3aGljaCB0aGUgcG9zdCBzaG91bGQgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZFxuICAgKiBAb3B0aW9uIHBhcmFtcyBFeHBpcmVzIFtJbnRlZ2VyXSAgICgzNjAwKSBUaGUgbnVtYmVyIG9mIHNlY29uZHMgZm9yIHdoaWNoXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHByZXNpZ25lZCBwb2xpY3kgc2hvdWxkIGJlIHZhbGlkLlxuICAgKiBAb3B0aW9uIHBhcmFtcyBDb25kaXRpb25zIFtBcnJheV0gIEFuIGFycmF5IG9mIGNvbmRpdGlvbnMgdGhhdCBtdXN0IGJlIG1ldFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgcHJlc2lnbmVkIHBvbGljeSB0byBhbGxvdyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWQuIFRoaXMgY2FuIGluY2x1ZGUgcmVxdWlyZWQgdGFncyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYWNjZXB0ZWQgcmFuZ2UgZm9yIGNvbnRlbnQgbGVuZ3RocyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldGMuXG4gICAqIEBzZWUgaHR0cDovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L0FQSS9zaWd2NC1IVFRQUE9TVENvbnN0cnVjdFBvbGljeS5odG1sXG4gICAqIEBvcHRpb24gcGFyYW1zIEZpZWxkcyBbbWFwXSAgICAgICAgRmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIGZvcm0uIEFsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyBwYXNzZWQgaW4gYXMgZmllbGRzIHdpbGwgYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduZWQgYXMgZXhhY3QgbWF0Y2ggY29uZGl0aW9ucy5cbiAgICogQHBhcmFtIGNhbGxiYWNrIFtGdW5jdGlvbl1cbiAgICpcbiAgICogQG5vdGUgQWxsIGZpZWxkcyBwYXNzZWQgaW4gd2hlbiBjcmVhdGluZyBwcmVzaWduZWQgcG9zdCBkYXRhIHdpbGwgYmUgc2lnbmVkXG4gICAqICAgYXMgZXhhY3QgbWF0Y2ggY29uZGl0aW9ucy4gQW55IGZpZWxkcyB0aGF0IHdpbGwgYmUgaW50ZXJwb2xhdGVkIGJ5IFMzXG4gICAqICAgbXVzdCBiZSBhZGRlZCB0byB0aGUgZmllbGRzIGhhc2ggYWZ0ZXIgc2lnbmluZywgYW5kIGFuIGFwcHJvcHJpYXRlXG4gICAqICAgY29uZGl0aW9uIGZvciBzdWNoIGZpZWxkcyBtdXN0IGJlIGV4cGxpY2l0bHkgYWRkZWQgdG8gdGhlIENvbmRpdGlvbnNcbiAgICogICBhcnJheSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBiZWZvcmUgc2lnbmluZy5cbiAgICpcbiAgICogQGV4YW1wbGUgUHJlc2lnaW5nIHBvc3QgZGF0YSB3aXRoIGEga25vd24ga2V5XG4gICAqICAgdmFyIHBhcmFtcyA9IHtcbiAgICogICAgIEJ1Y2tldDogJ2J1Y2tldCcsXG4gICAqICAgICBGaWVsZHM6IHtcbiAgICogICAgICAga2V5OiAna2V5J1xuICAgKiAgICAgfVxuICAgKiAgIH07XG4gICAqICAgczMuY3JlYXRlUHJlc2lnbmVkUG9zdChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikge1xuICAgKiAgICAgICBjb25zb2xlLmVycm9yKCdQcmVzaWduaW5nIHBvc3QgZGF0YSBlbmNvdW50ZXJlZCBhbiBlcnJvcicsIGVycik7XG4gICAqICAgICB9IGVsc2Uge1xuICAgKiAgICAgICBjb25zb2xlLmxvZygnVGhlIHBvc3QgZGF0YSBpcycsIGRhdGEpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZSBQcmVzaWduaW5nIHBvc3QgZGF0YSB3aXRoIGFuIGludGVycG9sYXRlZCBrZXlcbiAgICogICB2YXIgcGFyYW1zID0ge1xuICAgKiAgICAgQnVja2V0OiAnYnVja2V0JyxcbiAgICogICAgIENvbmRpdGlvbnM6IFtcbiAgICogICAgICAgWydzdGFydHMtd2l0aCcsICcka2V5JywgJ3BhdGgvdG8vdXBsb2Fkcy8nXVxuICAgKiAgICAgXVxuICAgKiAgIH07XG4gICAqICAgczMuY3JlYXRlUHJlc2lnbmVkUG9zdChwYXJhbXMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgaWYgKGVycikge1xuICAgKiAgICAgICBjb25zb2xlLmVycm9yKCdQcmVzaWduaW5nIHBvc3QgZGF0YSBlbmNvdW50ZXJlZCBhbiBlcnJvcicsIGVycik7XG4gICAqICAgICB9IGVsc2Uge1xuICAgKiAgICAgICBkYXRhLkZpZWxkcy5rZXkgPSAncGF0aC90by91cGxvYWRzLyR7ZmlsZW5hbWV9JztcbiAgICogICAgICAgY29uc29sZS5sb2coJ1RoZSBwb3N0IGRhdGEgaXMnLCBkYXRhKTtcbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQG5vdGUgWW91IG11c3QgZW5zdXJlIHRoYXQgeW91IGhhdmUgc3RhdGljIG9yIHByZXZpb3VzbHkgcmVzb2x2ZWRcbiAgICogICBjcmVkZW50aWFscyBpZiB5b3UgY2FsbCB0aGlzIG1ldGhvZCBzeW5jaHJvbm91c2x5ICh3aXRoIG5vIGNhbGxiYWNrKSxcbiAgICogICBvdGhlcndpc2UgaXQgbWF5IG5vdCBwcm9wZXJseSBzaWduIHRoZSByZXF1ZXN0LiBJZiB5b3UgY2Fubm90IGd1YXJhbnRlZVxuICAgKiAgIHRoaXMgKHlvdSBhcmUgdXNpbmcgYW4gYXN5bmNocm9ub3VzIGNyZWRlbnRpYWwgcHJvdmlkZXIsIGkuZS4sIEVDMlxuICAgKiAgIElBTSByb2xlcyksIHlvdSBzaG91bGQgYWx3YXlzIGNhbGwgdGhpcyBtZXRob2Qgd2l0aCBhbiBhc3luY2hyb25vdXNcbiAgICogICBjYWxsYmFjay5cbiAgICpcbiAgICogQHJldHVybiBbbWFwXSAgSWYgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdpdGggbm8gY2FsbGJhY2spLCByZXR1cm5zIGEgaGFzaFxuICAgKiAgICAgICAgICAgICAgICB3aXRoIHRoZSB1cmwgdG8gc2V0IGFzIHRoZSBmb3JtIGFjdGlvbiBhbmQgYSBoYXNoIG9mIGZpZWxkc1xuICAgKiAgICAgICAgICAgICAgICB0byBpbmNsdWRlIGluIHRoZSBmb3JtLlxuICAgKiBAcmV0dXJuIFtudWxsXSBOb3RoaW5nIGlzIHJldHVybmVkIGlmIGEgY2FsbGJhY2sgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiAoZXJyLCBkYXRhKVxuICAgKiAgQHBhcmFtIGVyciBbRXJyb3JdIHRoZSBlcnJvciBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgcG9saWN5IHNpZ25lclxuICAgKiAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIGRhdGEgbmVjZXNzYXJ5IHRvIGNvbnN0cnVjdCBhbiBIVE1MIGZvcm1cbiAgICogIEBwYXJhbSBkYXRhLnVybCBbU3RyaW5nXSBUaGUgVVJMIHRvIHVzZSBhcyB0aGUgYWN0aW9uIG9mIHRoZSBmb3JtXG4gICAqICBAcGFyYW0gZGF0YS5maWVsZHMgW21hcF0gQSBoYXNoIG9mIGZpZWxkcyB0aGF0IG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSBmb3IgdGhlIHVwbG9hZCB0byBzdWNjZWVkLiBUaGlzIGhhc2ggd2lsbFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgdGhlIHNpZ25lZCBQT1NUIHBvbGljeSwgeW91ciBhY2Nlc3Mga2V5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgSUQgYW5kIHNlY3VyaXR5IHRva2VuIChpZiBwcmVzZW50KSwgZXRjLiBUaGVzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heSBiZSBzYWZlbHkgaW5jbHVkZWQgYXMgaW5wdXQgZWxlbWVudHMgb2YgdHlwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICdoaWRkZW4uJ1xuICAgKi9cbiAgY3JlYXRlUHJlc2lnbmVkUG9zdDogZnVuY3Rpb24gY3JlYXRlUHJlc2lnbmVkUG9zdChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICBwYXJhbXMgPSBudWxsO1xuICAgIH1cblxuICAgIHBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zIHx8IHt9KTtcbiAgICB2YXIgYm91bmRQYXJhbXMgPSB0aGlzLmNvbmZpZy5wYXJhbXMgfHwge307XG4gICAgdmFyIGJ1Y2tldCA9IHBhcmFtcy5CdWNrZXQgfHwgYm91bmRQYXJhbXMuQnVja2V0LFxuICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICBjb25maWcgPSB0aGlzLmNvbmZpZyxcbiAgICAgIGVuZHBvaW50ID0gQVdTLnV0aWwuY29weSh0aGlzLmVuZHBvaW50KTtcbiAgICBpZiAoIWNvbmZpZy5zM0J1Y2tldEVuZHBvaW50KSB7XG4gICAgICBlbmRwb2ludC5wYXRobmFtZSA9ICcvJyArIGJ1Y2tldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5hbGl6ZVBvc3QoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IEFXUy51dGlsLnVybEZvcm1hdChlbmRwb2ludCksXG4gICAgICAgIGZpZWxkczogc2VsZi5wcmVwYXJlUG9zdEZpZWxkcyhcbiAgICAgICAgICBjb25maWcuY3JlZGVudGlhbHMsXG4gICAgICAgICAgY29uZmlnLnJlZ2lvbixcbiAgICAgICAgICBidWNrZXQsXG4gICAgICAgICAgcGFyYW1zLkZpZWxkcyxcbiAgICAgICAgICBwYXJhbXMuQ29uZGl0aW9ucyxcbiAgICAgICAgICBwYXJhbXMuRXhwaXJlc1xuICAgICAgICApXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uZmlnLmdldENyZWRlbnRpYWxzKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZpbmFsaXplUG9zdCgpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbmFsaXplUG9zdCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlUG9zdEZpZWxkczogZnVuY3Rpb24gcHJlcGFyZVBvc3RGaWVsZHMoXG4gICAgY3JlZGVudGlhbHMsXG4gICAgcmVnaW9uLFxuICAgIGJ1Y2tldCxcbiAgICBmaWVsZHMsXG4gICAgY29uZGl0aW9ucyxcbiAgICBleHBpcmVzSW5TZWNvbmRzXG4gICkge1xuICAgIHZhciBub3cgPSB0aGlzLmdldFNrZXdDb3JyZWN0ZWREYXRlKCk7XG4gICAgaWYgKCFjcmVkZW50aWFscyB8fCAhcmVnaW9uIHx8ICFidWNrZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSBhIFBPU1Qgb2JqZWN0IHBvbGljeSB3aXRob3V0IGEgYnVja2V0LCdcbiAgICAgICAgKyAnIHJlZ2lvbiwgYW5kIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuICAgIGZpZWxkcyA9IEFXUy51dGlsLmNvcHkoZmllbGRzIHx8IHt9KTtcbiAgICBjb25kaXRpb25zID0gKGNvbmRpdGlvbnMgfHwgW10pLnNsaWNlKDApO1xuICAgIGV4cGlyZXNJblNlY29uZHMgPSBleHBpcmVzSW5TZWNvbmRzIHx8IDM2MDA7XG5cbiAgICB2YXIgc2lnbmluZ0RhdGUgPSBBV1MudXRpbC5kYXRlLmlzbzg2MDEobm93KS5yZXBsYWNlKC9bOlxcLV18XFwuXFxkezN9L2csICcnKTtcbiAgICB2YXIgc2hvcnREYXRlID0gc2lnbmluZ0RhdGUuc3Vic3RyKDAsIDgpO1xuICAgIHZhciBzY29wZSA9IHY0Q3JlZGVudGlhbHMuY3JlYXRlU2NvcGUoc2hvcnREYXRlLCByZWdpb24sICdzMycpO1xuICAgIHZhciBjcmVkZW50aWFsID0gY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyBzY29wZTtcblxuICAgIGZpZWxkc1snYnVja2V0J10gPSBidWNrZXQ7XG4gICAgZmllbGRzWydYLUFtei1BbGdvcml0aG0nXSA9ICdBV1M0LUhNQUMtU0hBMjU2JztcbiAgICBmaWVsZHNbJ1gtQW16LUNyZWRlbnRpYWwnXSA9IGNyZWRlbnRpYWw7XG4gICAgZmllbGRzWydYLUFtei1EYXRlJ10gPSBzaWduaW5nRGF0ZTtcbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICBmaWVsZHNbJ1gtQW16LVNlY3VyaXR5LVRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuICAgIGZvciAodmFyIGZpZWxkIGluIGZpZWxkcykge1xuICAgICAgaWYgKGZpZWxkcy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHt9O1xuICAgICAgICBjb25kaXRpb25bZmllbGRdID0gZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgY29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmllbGRzLlBvbGljeSA9IHRoaXMucHJlcGFyZVBvc3RQb2xpY3koXG4gICAgICBuZXcgRGF0ZShub3cudmFsdWVPZigpICsgZXhwaXJlc0luU2Vjb25kcyAqIDEwMDApLFxuICAgICAgY29uZGl0aW9uc1xuICAgICk7XG4gICAgZmllbGRzWydYLUFtei1TaWduYXR1cmUnXSA9IEFXUy51dGlsLmNyeXB0by5obWFjKFxuICAgICAgdjRDcmVkZW50aWFscy5nZXRTaWduaW5nS2V5KGNyZWRlbnRpYWxzLCBzaG9ydERhdGUsIHJlZ2lvbiwgJ3MzJywgdHJ1ZSksXG4gICAgICBmaWVsZHMuUG9saWN5LFxuICAgICAgJ2hleCdcbiAgICApO1xuXG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcmVwYXJlUG9zdFBvbGljeTogZnVuY3Rpb24gcHJlcGFyZVBvc3RQb2xpY3koZXhwaXJhdGlvbiwgY29uZGl0aW9ucykge1xuICAgIHJldHVybiBBV1MudXRpbC5iYXNlNjQuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGV4cGlyYXRpb246IEFXUy51dGlsLmRhdGUuaXNvODYwMShleHBpcmF0aW9uKSxcbiAgICAgIGNvbmRpdGlvbnM6IGNvbmRpdGlvbnNcbiAgICB9KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgcHJlcGFyZVNpZ25lZFVybDogZnVuY3Rpb24gcHJlcGFyZVNpZ25lZFVybChyZXF1ZXN0KSB7XG4gICAgcmVxdWVzdC5hZGRMaXN0ZW5lcigndmFsaWRhdGUnLCByZXF1ZXN0LnNlcnZpY2Uubm9QcmVzaWduZWRDb250ZW50TGVuZ3RoKTtcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdidWlsZCcsIHJlcXVlc3Quc2VydmljZS5hZGRDb250ZW50VHlwZSk7XG4gICAgaWYgKCFyZXF1ZXN0LnBhcmFtcy5Cb2R5KSB7XG4gICAgICAvLyBubyBDb250ZW50LU1ENS9TSEEtMjU2IGlmIGJvZHkgaXMgbm90IHByb3ZpZGVkXG4gICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdidWlsZCcsIHJlcXVlc3Quc2VydmljZS5jb21wdXRlQ29udGVudE1kNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuYWRkTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLCBBV1MuRXZlbnRMaXN0ZW5lcnMuQ29yZS5DT01QVVRFX1NIQTI1Nik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIHJlcXVlc3RcbiAgICovXG4gIGRpc2FibGVCb2R5U2lnbmluZzogZnVuY3Rpb24gZGlzYWJsZUJvZHlTaWduaW5nKHJlcXVlc3QpIHtcbiAgICB2YXIgaGVhZGVycyA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVycztcbiAgICAvLyBBZGQgdGhlIGhlYWRlciB0byBhbnl0aGluZyB0aGF0IGlzbid0IGEgcHJlc2lnbmVkIHVybCwgdW5sZXNzIHRoYXQgcHJlc2lnbmVkIHVybCBoYWQgYSBib2R5IGRlZmluZWRcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCAncHJlc2lnbmVkLWV4cGlyZXMnKSkge1xuICAgICAgaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSA9ICdVTlNJR05FRC1QQVlMT0FEJztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbm9QcmVzaWduZWRDb250ZW50TGVuZ3RoOiBmdW5jdGlvbiBub1ByZXNpZ25lZENvbnRlbnRMZW5ndGgocmVxdWVzdCkge1xuICAgIGlmIChyZXF1ZXN0LnBhcmFtcy5Db250ZW50TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7Y29kZTogJ1VuZXhwZWN0ZWRQYXJhbWV0ZXInLFxuICAgICAgICBtZXNzYWdlOiAnQ29udGVudExlbmd0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHByZS1zaWduZWQgVVJMcy4nfSk7XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUJ1Y2tldDogZnVuY3Rpb24gY3JlYXRlQnVja2V0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAvLyBXaGVuIGNyZWF0aW5nIGEgYnVja2V0ICpvdXRzaWRlKiB0aGUgY2xhc3NpYyByZWdpb24sIHRoZSBsb2NhdGlvblxuICAgIC8vIGNvbnN0cmFpbnQgbXVzdCBiZSBzZXQgZm9yIHRoZSBidWNrZXQgYW5kIGl0IG11c3QgbWF0Y2ggdGhlIGVuZHBvaW50LlxuICAgIC8vIFRoaXMgY2h1bmsgb2YgY29kZSB3aWxsIHNldCB0aGUgbG9jYXRpb24gY29uc3RyYWludCBwYXJhbSBiYXNlZFxuICAgIC8vIG9uIHRoZSByZWdpb24gKHdoZW4gcG9zc2libGUpLCBidXQgaXQgd2lsbCBub3Qgb3ZlcnJpZGUgYSBwYXNzZWQtaW5cbiAgICAvLyBsb2NhdGlvbiBjb25zdHJhaW50LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nIHx8ICFwYXJhbXMpIHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgcGFyYW1zO1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIHZhciBob3N0bmFtZSA9IHRoaXMuZW5kcG9pbnQuaG9zdG5hbWU7XG4gICAgLy8gY29weSBwYXJhbXMgc28gdGhhdCBhcHBlbmRpbmcga2V5cyBkb2VzIG5vdCB1bmludGVudGlvaW5hbGxseVxuICAgIC8vIG11dGF0ZSBwYXJhbXMgb2JqZWN0IGFyZ3VtZW50IHBhc3NlZCBpbiBieSB1c2VyXG4gICAgdmFyIGNvcGllZFBhcmFtcyA9IEFXUy51dGlsLmNvcHkocGFyYW1zKTtcblxuICAgIGlmIChob3N0bmFtZSAhPT0gdGhpcy5hcGkuZ2xvYmFsRW5kcG9pbnQgJiYgIXBhcmFtcy5DcmVhdGVCdWNrZXRDb25maWd1cmF0aW9uKSB7XG4gICAgICBjb3BpZWRQYXJhbXMuQ3JlYXRlQnVja2V0Q29uZmlndXJhdGlvbiA9IHsgTG9jYXRpb25Db25zdHJhaW50OiB0aGlzLmNvbmZpZy5yZWdpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3QoJ2NyZWF0ZUJ1Y2tldCcsIGNvcGllZFBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIHdyaXRlR2V0T2JqZWN0UmVzcG9uc2U6IGZ1bmN0aW9uIHdyaXRlR2V0T2JqZWN0UmVzcG9uc2UocGFyYW1zLCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHJlcXVlc3QgPSB0aGlzLm1ha2VSZXF1ZXN0KCd3cml0ZUdldE9iamVjdFJlc3BvbnNlJywgQVdTLnV0aWwuY29weShwYXJhbXMpLCBjYWxsYmFjayk7XG4gICAgdmFyIGhvc3RuYW1lID0gdGhpcy5lbmRwb2ludC5ob3N0bmFtZTtcbiAgICBpZiAoaG9zdG5hbWUuaW5kZXhPZih0aGlzLmNvbmZpZy5yZWdpb24pICE9PSAtMSkge1xuICAgICAgLy8gaG9zdG5hbWUgc3BlY2lmaWVzIGEgcmVnaW9uIGFscmVhZHlcbiAgICAgIGhvc3RuYW1lID0gaG9zdG5hbWUucmVwbGFjZSgnczMuJywgT0JKRUNUX0xBTUJEQV9TRVJWSUNFICsgJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSG9zdG5hbWUgZG9lc24ndCBoYXZlIGEgcmVnaW9uLlxuICAgICAgLy8gT2JqZWN0IExhbWJkYSByZXF1aXJlcyBhbiBleHBsaWNpdCByZWdpb24uXG4gICAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnJlcGxhY2UoJ3MzLicsIE9CSkVDVF9MQU1CREFfU0VSVklDRSArICcuJyArIHRoaXMuY29uZmlnLnJlZ2lvbiArICcuJyk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5lbmRwb2ludCA9IG5ldyBBV1MuRW5kcG9pbnQoaG9zdG5hbWUsIHRoaXMuY29uZmlnKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfSxcblxuICAvKipcbiAgICogQHNlZSBBV1MuUzMuTWFuYWdlZFVwbG9hZFxuICAgKiBAb3ZlcmxvYWQgdXBsb2FkKHBhcmFtcyA9IHt9LCBbb3B0aW9uc10sIFtjYWxsYmFja10pXG4gICAqICAgVXBsb2FkcyBhbiBhcmJpdHJhcmlseSBzaXplZCBidWZmZXIsIGJsb2IsIG9yIHN0cmVhbSwgdXNpbmcgaW50ZWxsaWdlbnRcbiAgICogICBjb25jdXJyZW50IGhhbmRsaW5nIG9mIHBhcnRzIGlmIHRoZSBwYXlsb2FkIGlzIGxhcmdlIGVub3VnaC4gWW91IGNhblxuICAgKiAgIGNvbmZpZ3VyZSB0aGUgY29uY3VycmVudCBxdWV1ZSBzaXplIGJ5IHNldHRpbmcgYG9wdGlvbnNgLiBOb3RlIHRoYXQgdGhpc1xuICAgKiAgIGlzIHRoZSBvbmx5IG9wZXJhdGlvbiBmb3Igd2hpY2ggdGhlIFNESyBjYW4gcmV0cnkgcmVxdWVzdHMgd2l0aCBzdHJlYW1cbiAgICogICBib2RpZXMuXG4gICAqXG4gICAqICAgQHBhcmFtIChzZWUgQVdTLlMzLnB1dE9iamVjdClcbiAgICogICBAb3B0aW9uIChzZWUgQVdTLlMzLk1hbmFnZWRVcGxvYWQuY29uc3RydWN0b3IpXG4gICAqICAgQHJldHVybiBbQVdTLlMzLk1hbmFnZWRVcGxvYWRdIHRoZSBtYW5hZ2VkIHVwbG9hZCBvYmplY3QgdGhhdCBjYW4gY2FsbFxuICAgKiAgICAgYHNlbmQoKWAgb3IgdHJhY2sgcHJvZ3Jlc3MuXG4gICAqICAgQGV4YW1wbGUgVXBsb2FkaW5nIGEgc3RyZWFtIG9iamVjdFxuICAgKiAgICAgdmFyIHBhcmFtcyA9IHtCdWNrZXQ6ICdidWNrZXQnLCBLZXk6ICdrZXknLCBCb2R5OiBzdHJlYW19O1xuICAgKiAgICAgczMudXBsb2FkKHBhcmFtcywgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAqICAgICAgIGNvbnNvbGUubG9nKGVyciwgZGF0YSk7XG4gICAqICAgICB9KTtcbiAgICogICBAZXhhbXBsZSBVcGxvYWRpbmcgYSBzdHJlYW0gd2l0aCBjb25jdXJyZW5jeSBvZiAxIGFuZCBwYXJ0U2l6ZSBvZiAxMG1iXG4gICAqICAgICB2YXIgcGFyYW1zID0ge0J1Y2tldDogJ2J1Y2tldCcsIEtleTogJ2tleScsIEJvZHk6IHN0cmVhbX07XG4gICAqICAgICB2YXIgb3B0aW9ucyA9IHtwYXJ0U2l6ZTogMTAgKiAxMDI0ICogMTAyNCwgcXVldWVTaXplOiAxfTtcbiAgICogICAgIHMzLnVwbG9hZChwYXJhbXMsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgKiAgICAgICBjb25zb2xlLmxvZyhlcnIsIGRhdGEpO1xuICAgKiAgICAgfSk7XG4gICAqIEBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbihlcnIsIGRhdGEpXG4gICAqICAgQHBhcmFtIGVyciBbRXJyb3JdIGFuIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3Igb2NjdXJyZWQuXG4gICAqICAgQHBhcmFtIGRhdGEgW21hcF0gVGhlIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc3VjY2Vzc2Z1bCB1cGxvYWQ6XG4gICAqICAgQHBhcmFtIGRhdGEuTG9jYXRpb24gW1N0cmluZ10gdGhlIFVSTCBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgQHBhcmFtIGRhdGEuRVRhZyBbU3RyaW5nXSB0aGUgRVRhZyBvZiB0aGUgdXBsb2FkZWQgb2JqZWN0XG4gICAqICAgQHBhcmFtIGRhdGEuQnVja2V0IFtTdHJpbmddICB0aGUgYnVja2V0IHRvIHdoaWNoIHRoZSBvYmplY3Qgd2FzIHVwbG9hZGVkXG4gICAqICAgQHBhcmFtIGRhdGEuS2V5IFtTdHJpbmddIHRoZSBrZXkgdG8gd2hpY2ggdGhlIG9iamVjdCB3YXMgdXBsb2FkZWRcbiAgICovXG4gIHVwbG9hZDogZnVuY3Rpb24gdXBsb2FkKHBhcmFtcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucyA9IEFXUy51dGlsLm1lcmdlKG9wdGlvbnMgfHwge30sIHtzZXJ2aWNlOiB0aGlzLCBwYXJhbXM6IHBhcmFtc30pO1xuXG4gICAgdmFyIHVwbG9hZGVyID0gbmV3IEFXUy5TMy5NYW5hZ2VkVXBsb2FkKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHVwbG9hZGVyLnNlbmQoY2FsbGJhY2spO1xuICAgIHJldHVybiB1cGxvYWRlcjtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TMy5hZGRQcm9taXNlc1RvQ2xhc3MgPSBmdW5jdGlvbiBhZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgdGhpcy5wcm90b3R5cGUuZ2V0U2lnbmVkVXJsUHJvbWlzZSA9IEFXUy51dGlsLnByb21pc2lmeU1ldGhvZCgnZ2V0U2lnbmVkVXJsJywgUHJvbWlzZURlcGVuZGVuY3kpO1xufTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQVdTLlMzLmRlbGV0ZVByb21pc2VzRnJvbUNsYXNzID0gZnVuY3Rpb24gZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MoKSB7XG4gIGRlbGV0ZSB0aGlzLnByb3RvdHlwZS5nZXRTaWduZWRVcmxQcm9taXNlO1xufTtcblxuQVdTLnV0aWwuYWRkUHJvbWlzZXMoQVdTLlMzKTtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgcmVnaW9uVXRpbCA9IHJlcXVpcmUoJy4uL3JlZ2lvbl9jb25maWcnKTtcblxudmFyIHMzdXRpbCA9IHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNBcm5JblBhcmFtOiBmdW5jdGlvbiBpc0FybkluUGFyYW0ocmVxLCBwYXJhbU5hbWUpIHtcbiAgICB2YXIgaW5wdXRTaGFwZSA9IChyZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tyZXEub3BlcmF0aW9uXSB8fCB7fSkuaW5wdXQgfHwge307XG4gICAgdmFyIGlucHV0TWVtYmVycyA9IGlucHV0U2hhcGUubWVtYmVycyB8fCB7fTtcbiAgICBpZiAoIXJlcS5wYXJhbXNbcGFyYW1OYW1lXSB8fCAhaW5wdXRNZW1iZXJzW3BhcmFtTmFtZV0pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gQVdTLnV0aWwuQVJOLnZhbGlkYXRlKHJlcS5wYXJhbXNbcGFyYW1OYW1lXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHNlcnZpY2UgY29tcG9uZW50IGZyb20gQVJOIHN1cHBsaWVkIGluIEJ1Y2tldCBwYXJhbWV0ZXJcbiAgICovXG4gIHZhbGlkYXRlQXJuU2VydmljZTogZnVuY3Rpb24gdmFsaWRhdGVBcm5TZXJ2aWNlKHJlcSkge1xuICAgIHZhciBwYXJzZWRBcm4gPSByZXEuX3BhcnNlZEFybjtcblxuICAgIGlmIChwYXJzZWRBcm4uc2VydmljZSAhPT0gJ3MzJ1xuICAgICAgJiYgcGFyc2VkQXJuLnNlcnZpY2UgIT09ICdzMy1vdXRwb3N0cydcbiAgICAgICYmIHBhcnNlZEFybi5zZXJ2aWNlICE9PSAnczMtb2JqZWN0LWxhbWJkYScpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ2V4cGVjdCBcXCdzM1xcJyBvciBcXCdzMy1vdXRwb3N0c1xcJyBvciBcXCdzMy1vYmplY3QtbGFtYmRhXFwnIGluIEFSTiBzZXJ2aWNlIGNvbXBvbmVudCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVmFsaWRhdGUgYWNjb3VudCBJRCBmcm9tIEFSTiBzdXBwbGllZCBpbiBCdWNrZXQgcGFyYW1ldGVyIGlzIGEgdmFsaWQgYWNjb3VudFxuICAgKi9cbiAgdmFsaWRhdGVBcm5BY2NvdW50OiBmdW5jdGlvbiB2YWxpZGF0ZUFybkFjY291bnQocmVxKSB7XG4gICAgdmFyIHBhcnNlZEFybiA9IHJlcS5fcGFyc2VkQXJuO1xuXG4gICAgaWYgKCEvWzAtOV17MTJ9Ly5leGVjKHBhcnNlZEFybi5hY2NvdW50SWQpKSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEFSTicsXG4gICAgICAgIG1lc3NhZ2U6ICdBUk4gYWNjb3VudElEIGRvZXMgbm90IG1hdGNoIHJlZ2V4IFwiWzAtOV17MTJ9XCInXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIEFSTiBzdXBwbGllZCBpbiBCdWNrZXQgcGFyYW1ldGVyIGlzIGEgdmFsaWQgYWNjZXNzIHBvaW50IEFSTlxuICAgKi9cbiAgdmFsaWRhdGVTM0FjY2Vzc1BvaW50QXJuOiBmdW5jdGlvbiB2YWxpZGF0ZVMzQWNjZXNzUG9pbnRBcm4ocmVxKSB7XG4gICAgdmFyIHBhcnNlZEFybiA9IHJlcS5fcGFyc2VkQXJuO1xuXG4gICAgLy9jYW4gYmUgJzonIG9yICcvJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSBwYXJzZWRBcm4ucmVzb3VyY2VbJ2FjY2Vzc3BvaW50Jy5sZW5ndGhdO1xuXG4gICAgaWYgKHBhcnNlZEFybi5yZXNvdXJjZS5zcGxpdChkZWxpbWl0ZXIpLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnQWNjZXNzIFBvaW50IEFSTiBzaG91bGQgaGF2ZSBvbmUgcmVzb3VyY2UgYWNjZXNzcG9pbnQve2FjY2Vzc3BvaW50TmFtZX0nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYWNjZXNzUG9pbnQgPSBwYXJzZWRBcm4ucmVzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKVsxXTtcbiAgICB2YXIgYWNjZXNzUG9pbnRQcmVmaXggPSBhY2Nlc3NQb2ludCArICctJyArIHBhcnNlZEFybi5hY2NvdW50SWQ7XG4gICAgaWYgKCFzM3V0aWwuZG5zQ29tcGF0aWJsZUJ1Y2tldE5hbWUoYWNjZXNzUG9pbnRQcmVmaXgpIHx8IGFjY2Vzc1BvaW50UHJlZml4Lm1hdGNoKC9cXC4vKSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnQWNjZXNzIHBvaW50IHJlc291cmNlIGluIEFSTiBpcyBub3QgRE5TIGNvbXBhdGlibGUuIEdvdCAnICsgYWNjZXNzUG9pbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vc2V0IHBhcnNlZCB2YWxpZCBhY2Nlc3MgcG9pbnRcbiAgICByZXEuX3BhcnNlZEFybi5hY2Nlc3NQb2ludCA9IGFjY2Vzc1BvaW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBPdXRwb3N0cyBBUk4gc3VwcGxpZWQgaW4gQnVja2V0IHBhcmFtZXRlciBpcyBhIHZhbGlkIG91dHBvc3RzIEFSTlxuICAgKi9cbiAgdmFsaWRhdGVPdXRwb3N0c0FybjogZnVuY3Rpb24gdmFsaWRhdGVPdXRwb3N0c0FybihyZXEpIHtcbiAgICB2YXIgcGFyc2VkQXJuID0gcmVxLl9wYXJzZWRBcm47XG5cbiAgICBpZiAoXG4gICAgICBwYXJzZWRBcm4ucmVzb3VyY2UuaW5kZXhPZignb3V0cG9zdDonKSAhPT0gMCAmJlxuICAgICAgcGFyc2VkQXJuLnJlc291cmNlLmluZGV4T2YoJ291dHBvc3QvJykgIT09IDBcbiAgICApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ0FSTiByZXNvdXJjZSBzaG91bGQgYmVnaW4gd2l0aCBcXCdvdXRwb3N0L1xcJydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vY2FuIGJlICc6JyBvciAnLydcbiAgICB2YXIgZGVsaW1pdGVyID0gcGFyc2VkQXJuLnJlc291cmNlWydvdXRwb3N0Jy5sZW5ndGhdO1xuICAgIHZhciBvdXRwb3N0SWQgPSBwYXJzZWRBcm4ucmVzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKVsxXTtcbiAgICB2YXIgZG5zSG9zdFJlZ2V4ID0gbmV3IFJlZ0V4cCgvXihbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKSQvKTtcbiAgICBpZiAoIWRuc0hvc3RSZWdleC50ZXN0KG91dHBvc3RJZCkpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ091dHBvc3QgcmVzb3VyY2UgaW4gQVJOIGlzIG5vdCBETlMgY29tcGF0aWJsZS4gR290ICcgKyBvdXRwb3N0SWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXEuX3BhcnNlZEFybi5vdXRwb3N0SWQgPSBvdXRwb3N0SWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIE91dHBvc3RzIEFSTiBzdXBwbGllZCBpbiBCdWNrZXQgcGFyYW1ldGVyIGlzIGEgdmFsaWQgb3V0cG9zdHMgQVJOXG4gICAqL1xuICB2YWxpZGF0ZU91dHBvc3RzQWNjZXNzUG9pbnRBcm46IGZ1bmN0aW9uIHZhbGlkYXRlT3V0cG9zdHNBY2Nlc3NQb2ludEFybihyZXEpIHtcbiAgICB2YXIgcGFyc2VkQXJuID0gcmVxLl9wYXJzZWRBcm47XG5cbiAgICAvL2NhbiBiZSAnOicgb3IgJy8nXG4gICAgdmFyIGRlbGltaXRlciA9IHBhcnNlZEFybi5yZXNvdXJjZVsnb3V0cG9zdCcubGVuZ3RoXTtcblxuICAgIGlmIChwYXJzZWRBcm4ucmVzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKS5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQVJOJyxcbiAgICAgICAgbWVzc2FnZTogJ091dHBvc3RzIEFSTiBzaG91bGQgaGF2ZSB0d28gcmVzb3VyY2VzIG91dHBvc3Qve291dHBvc3RJZH0vYWNjZXNzcG9pbnQve2FjY2Vzc3BvaW50TmFtZX0nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYWNjZXNzUG9pbnQgPSBwYXJzZWRBcm4ucmVzb3VyY2Uuc3BsaXQoZGVsaW1pdGVyKVszXTtcbiAgICB2YXIgYWNjZXNzUG9pbnRQcmVmaXggPSBhY2Nlc3NQb2ludCArICctJyArIHBhcnNlZEFybi5hY2NvdW50SWQ7XG4gICAgaWYgKCFzM3V0aWwuZG5zQ29tcGF0aWJsZUJ1Y2tldE5hbWUoYWNjZXNzUG9pbnRQcmVmaXgpIHx8IGFjY2Vzc1BvaW50UHJlZml4Lm1hdGNoKC9cXC4vKSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRBUk4nLFxuICAgICAgICBtZXNzYWdlOiAnQWNjZXNzIHBvaW50IHJlc291cmNlIGluIEFSTiBpcyBub3QgRE5TIGNvbXBhdGlibGUuIEdvdCAnICsgYWNjZXNzUG9pbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vc2V0IHBhcnNlZCB2YWxpZCBhY2Nlc3MgcG9pbnRcbiAgICByZXEuX3BhcnNlZEFybi5hY2Nlc3NQb2ludCA9IGFjY2Vzc1BvaW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSByZWdpb24gZmllbGQgaW4gQVJOIHN1cHBsaWVkIGluIEJ1Y2tldCBwYXJhbWV0ZXIgaXMgYSB2YWxpZCByZWdpb25cbiAgICovXG4gIHZhbGlkYXRlQXJuUmVnaW9uOiBmdW5jdGlvbiB2YWxpZGF0ZUFyblJlZ2lvbihyZXEsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIHVzZUFyblJlZ2lvbiA9IHMzdXRpbC5sb2FkVXNlQXJuUmVnaW9uQ29uZmlnKHJlcSk7XG4gICAgdmFyIHJlZ2lvbkZyb21Bcm4gPSByZXEuX3BhcnNlZEFybi5yZWdpb247XG4gICAgdmFyIGNsaWVudFJlZ2lvbiA9IHJlcS5zZXJ2aWNlLmNvbmZpZy5yZWdpb247XG4gICAgdmFyIHVzZUZpcHNFbmRwb2ludCA9IHJlcS5zZXJ2aWNlLmNvbmZpZy51c2VGaXBzRW5kcG9pbnQ7XG4gICAgdmFyIGFsbG93Rmlwc0VuZHBvaW50ID0gb3B0aW9ucy5hbGxvd0ZpcHNFbmRwb2ludCB8fCBmYWxzZTtcblxuICAgIGlmICghcmVnaW9uRnJvbUFybikge1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnQVJOIHJlZ2lvbiBpcyBlbXB0eSc7XG4gICAgICBpZiAocmVxLl9wYXJzZWRBcm4uc2VydmljZSA9PT0gJ3MzJykge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSArICdcXG5Zb3UgbWF5IHdhbnQgdG8gdXNlIG11bHRpLXJlZ2lvbmFsIEFSTi4gVGhlIGZlYXR1cmUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IFNESy4gJyArXG4gICAgICAgICdZb3Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyB0byBWMyhodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1zZGstanMtdjMpLic7XG4gICAgICB9XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEFSTicsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh1c2VGaXBzRW5kcG9pbnQgJiYgIWFsbG93Rmlwc0VuZHBvaW50KSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICBtZXNzYWdlOiAnQVJOIGVuZHBvaW50IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggRklQUyByZWdpb24nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVnaW9uRnJvbUFybi5pbmRleE9mKCdmaXBzJykgPj0gMCkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ0ZJUFMgcmVnaW9uIG5vdCBhbGxvd2VkIGluIEFSTidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdXNlQXJuUmVnaW9uICYmIHJlZ2lvbkZyb21Bcm4gIT09IGNsaWVudFJlZ2lvbikge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ0NvbmZpZ3VyZWQgcmVnaW9uIGNvbmZsaWN0cyB3aXRoIGFjY2VzcyBwb2ludCByZWdpb24nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdXNlQXJuUmVnaW9uICYmXG4gICAgICByZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KHJlZ2lvbkZyb21Bcm4pICE9PSByZWdpb25VdGlsLmdldEVuZHBvaW50U3VmZml4KGNsaWVudFJlZ2lvbilcbiAgICApIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdDb25maWd1cmVkIHJlZ2lvbiBhbmQgYWNjZXNzIHBvaW50IHJlZ2lvbiBub3QgaW4gc2FtZSBwYXJ0aXRpb24nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxLnNlcnZpY2UuY29uZmlnLnVzZUFjY2VsZXJhdGVFbmRwb2ludCkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ3VzZUFjY2VsZXJhdGVFbmRwb2ludCBjb25maWcgaXMgbm90IHN1cHBvcnRlZCB3aXRoIGFjY2VzcyBwb2ludCBBUk4nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxLl9wYXJzZWRBcm4uc2VydmljZSA9PT0gJ3MzLW91dHBvc3RzJyAmJiByZXEuc2VydmljZS5jb25maWcudXNlRHVhbHN0YWNrRW5kcG9pbnQpIHtcbiAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgIG1lc3NhZ2U6ICdEdWFsc3RhY2sgaXMgbm90IHN1cHBvcnRlZCB3aXRoIG91dHBvc3RzIGFjY2VzcyBwb2ludCBBUk4nXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgbG9hZFVzZUFyblJlZ2lvbkNvbmZpZzogZnVuY3Rpb24gbG9hZFVzZUFyblJlZ2lvbkNvbmZpZyhyZXEpIHtcbiAgICB2YXIgZW52TmFtZSA9ICdBV1NfUzNfVVNFX0FSTl9SRUdJT04nO1xuICAgIHZhciBjb25maWdOYW1lID0gJ3MzX3VzZV9hcm5fcmVnaW9uJztcbiAgICB2YXIgdXNlQXJuUmVnaW9uID0gdHJ1ZTtcbiAgICB2YXIgb3JpZ2luYWxDb25maWcgPSByZXEuc2VydmljZS5fb3JpZ2luYWxDb25maWcgfHwge307XG4gICAgaWYgKHJlcS5zZXJ2aWNlLmNvbmZpZy5zM1VzZUFyblJlZ2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVxLnNlcnZpY2UuY29uZmlnLnMzVXNlQXJuUmVnaW9uO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxDb25maWcuczNVc2VBcm5SZWdpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlQXJuUmVnaW9uID0gb3JpZ2luYWxDb25maWcuczNVc2VBcm5SZWdpb24gPT09IHRydWU7XG4gICAgfSBlbHNlIGlmIChBV1MudXRpbC5pc05vZGUoKSkge1xuICAgICAgLy9sb2FkIGZyb20gZW52aXJvbm1lbnRhbCB2YXJpYWJsZSBBV1NfVVNFX0FSTl9SRUdJT05cbiAgICAgIGlmIChwcm9jZXNzLmVudltlbnZOYW1lXSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9jZXNzLmVudltlbnZOYW1lXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFsnZmFsc2UnLCAndHJ1ZSddLmluZGV4T2YodmFsdWUpIDwgMCkge1xuICAgICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICAgICAgbWVzc2FnZTogZW52TmFtZSArICcgb25seSBhY2NlcHRzIHRydWUgb3IgZmFsc2UuIEdvdCAnICsgcHJvY2Vzcy5lbnZbZW52TmFtZV0sXG4gICAgICAgICAgICByZXRyeWFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXNlQXJuUmVnaW9uID0gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgIH0gZWxzZSB7ICAvL2xvYWQgZnJvbSBzaGFyZWQgY29uZmlnIHByb3BlcnR5IHVzZV9hcm5fcmVnaW9uXG4gICAgICAgIHZhciBwcm9maWxlcyA9IHt9O1xuICAgICAgICB2YXIgcHJvZmlsZSA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb2ZpbGVzID0gQVdTLnV0aWwuZ2V0UHJvZmlsZXNGcm9tU2hhcmVkQ29uZmlnKEFXUy51dGlsLmluaUxvYWRlcik7XG4gICAgICAgICAgcHJvZmlsZSA9IHByb2ZpbGVzW3Byb2Nlc3MuZW52LkFXU19QUk9GSUxFIHx8IEFXUy51dGlsLmRlZmF1bHRQcm9maWxlXTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgaWYgKHByb2ZpbGVbY29uZmlnTmFtZV0pIHtcbiAgICAgICAgICBpZiAoWydmYWxzZScsICd0cnVlJ10uaW5kZXhPZihwcm9maWxlW2NvbmZpZ05hbWVdLnRyaW0oKS50b0xvd2VyQ2FzZSgpKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IEFXUy51dGlsLmVycm9yKG5ldyBFcnJvcigpLCB7XG4gICAgICAgICAgICAgIGNvZGU6ICdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNvbmZpZ05hbWUgKyAnIG9ubHkgYWNjZXB0cyB0cnVlIG9yIGZhbHNlLiBHb3QgJyArIHByb2ZpbGVbY29uZmlnTmFtZV0sXG4gICAgICAgICAgICAgIHJldHJ5YWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1c2VBcm5SZWdpb24gPSBwcm9maWxlW2NvbmZpZ05hbWVdLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVxLnNlcnZpY2UuY29uZmlnLnMzVXNlQXJuUmVnaW9uID0gdXNlQXJuUmVnaW9uO1xuICAgIHJldHVybiB1c2VBcm5SZWdpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRpb25zIGJlZm9yZSBVUkkgY2FuIGJlIHBvcHVsYXRlZFxuICAgKi9cbiAgdmFsaWRhdGVQb3B1bGF0ZVVyaUZyb21Bcm46IGZ1bmN0aW9uIHZhbGlkYXRlUG9wdWxhdGVVcmlGcm9tQXJuKHJlcSkge1xuICAgIGlmIChyZXEuc2VydmljZS5fb3JpZ2luYWxDb25maWcgJiYgcmVxLnNlcnZpY2UuX29yaWdpbmFsQ29uZmlnLmVuZHBvaW50KSB7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZENvbmZpZ3VyYXRpb24nLFxuICAgICAgICBtZXNzYWdlOiAnQ3VzdG9tIGVuZHBvaW50IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggYWNjZXNzIHBvaW50IEFSTidcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXEuc2VydmljZS5jb25maWcuczNGb3JjZVBhdGhTdHlsZSkge1xuICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgICAgY29kZTogJ0ludmFsaWRDb25maWd1cmF0aW9uJyxcbiAgICAgICAgbWVzc2FnZTogJ0Nhbm5vdCBjb25zdHJ1Y3QgcGF0aC1zdHlsZSBlbmRwb2ludCB3aXRoIGFjY2VzcyBwb2ludCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBidWNrZXQgbmFtZSBpcyBETlMgY29tcGF0aWJsZS4gIEJ1Y2tldHMgY3JlYXRlZFxuICAgKiBvdXRzaWRlIG9mIHRoZSBjbGFzc2ljIHJlZ2lvbiBNVVNUIGJlIEROUyBjb21wYXRpYmxlLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRuc0NvbXBhdGlibGVCdWNrZXROYW1lOiBmdW5jdGlvbiBkbnNDb21wYXRpYmxlQnVja2V0TmFtZShidWNrZXROYW1lKSB7XG4gICAgdmFyIGIgPSBidWNrZXROYW1lO1xuICAgIHZhciBkb21haW4gPSBuZXcgUmVnRXhwKC9eW2EtejAtOV1bYS16MC05XFwuXFwtXXsxLDYxfVthLXowLTldJC8pO1xuICAgIHZhciBpcEFkZHJlc3MgPSBuZXcgUmVnRXhwKC8oXFxkK1xcLil7M31cXGQrLyk7XG4gICAgdmFyIGRvdHMgPSBuZXcgUmVnRXhwKC9cXC5cXC4vKTtcbiAgICByZXR1cm4gKGIubWF0Y2goZG9tYWluKSAmJiAhYi5tYXRjaChpcEFkZHJlc3MpICYmICFiLm1hdGNoKGRvdHMpKSA/IHRydWUgOiBmYWxzZTtcbiAgfSxcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gczN1dGlsO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnID0gcmVxdWlyZSgnLi4vY29uZmlnX3JlZ2lvbmFsX2VuZHBvaW50Jyk7XG52YXIgRU5WX1JFR0lPTkFMX0VORFBPSU5UX0VOQUJMRUQgPSAnQVdTX1NUU19SRUdJT05BTF9FTkRQT0lOVFMnO1xudmFyIENPTkZJR19SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVEID0gJ3N0c19yZWdpb25hbF9lbmRwb2ludHMnO1xuXG5BV1MudXRpbC51cGRhdGUoQVdTLlNUUy5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIEBvdmVybG9hZCBjcmVkZW50aWFsc0Zyb20oZGF0YSwgY3JlZGVudGlhbHMgPSBudWxsKVxuICAgKiAgIENyZWF0ZXMgYSBjcmVkZW50aWFscyBvYmplY3QgZnJvbSBTVFMgcmVzcG9uc2UgZGF0YSBjb250YWluaW5nXG4gICAqICAgY3JlZGVudGlhbHMgaW5mb3JtYXRpb24uIFVzZWZ1bCBmb3IgcXVpY2tseSBzZXR0aW5nIEFXUyBjcmVkZW50aWFscy5cbiAgICpcbiAgICogICBAbm90ZSBUaGlzIGlzIGEgbG93LWxldmVsIHV0aWxpdHkgZnVuY3Rpb24uIElmIHlvdSB3YW50IHRvIGxvYWQgdGVtcG9yYXJ5XG4gICAqICAgICBjcmVkZW50aWFscyBpbnRvIHlvdXIgcHJvY2VzcyBmb3Igc3Vic2VxdWVudCByZXF1ZXN0cyB0byBBV1MgcmVzb3VyY2VzLFxuICAgKiAgICAgeW91IHNob3VsZCB1c2Uge0FXUy5UZW1wb3JhcnlDcmVkZW50aWFsc30gaW5zdGVhZC5cbiAgICogICBAcGFyYW0gZGF0YSBbbWFwXSBkYXRhIHJldHJpZXZlZCBmcm9tIGEgY2FsbCB0byB7Z2V0RmVkZXJhdGVkVG9rZW59LFxuICAgKiAgICAge2dldFNlc3Npb25Ub2tlbn0sIHthc3N1bWVSb2xlfSwgb3Ige2Fzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHl9LlxuICAgKiAgIEBwYXJhbSBjcmVkZW50aWFscyBbQVdTLkNyZWRlbnRpYWxzXSBhbiBvcHRpb25hbCBjcmVkZW50aWFscyBvYmplY3QgdG9cbiAgICogICAgIGZpbGwgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvYmplY3QuIFVzZWZ1bCB3aGVuIG1vZGlmeWluZyBhblxuICAgKiAgICAgZXhpc3RpbmcgY3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSByZWZyZXNoIGNhbGwuXG4gICAqICAgQHJldHVybiBbQVdTLlRlbXBvcmFyeUNyZWRlbnRpYWxzXSB0aGUgc2V0IG9mIHRlbXBvcmFyeSBjcmVkZW50aWFsc1xuICAgKiAgICAgbG9hZGVkIGZyb20gYSByYXcgU1RTIG9wZXJhdGlvbiByZXNwb25zZS5cbiAgICogICBAZXhhbXBsZSBVc2luZyBjcmVkZW50aWFsc0Zyb20gdG8gbG9hZCBnbG9iYWwgQVdTIGNyZWRlbnRpYWxzXG4gICAqICAgICB2YXIgc3RzID0gbmV3IEFXUy5TVFMoKTtcbiAgICogICAgIHN0cy5nZXRTZXNzaW9uVG9rZW4oZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgKiAgICAgICBpZiAoZXJyKSBjb25zb2xlLmxvZyhcIkVycm9yIGdldHRpbmcgY3JlZGVudGlhbHNcIik7XG4gICAqICAgICAgIGVsc2Uge1xuICAgKiAgICAgICAgIEFXUy5jb25maWcuY3JlZGVudGlhbHMgPSBzdHMuY3JlZGVudGlhbHNGcm9tKGRhdGEpO1xuICAgKiAgICAgICB9XG4gICAqICAgICB9KTtcbiAgICogICBAc2VlIEFXUy5UZW1wb3JhcnlDcmVkZW50aWFsc1xuICAgKi9cbiAgY3JlZGVudGlhbHNGcm9tOiBmdW5jdGlvbiBjcmVkZW50aWFsc0Zyb20oZGF0YSwgY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuICAgIGlmICghY3JlZGVudGlhbHMpIGNyZWRlbnRpYWxzID0gbmV3IEFXUy5UZW1wb3JhcnlDcmVkZW50aWFscygpO1xuICAgIGNyZWRlbnRpYWxzLmV4cGlyZWQgPSBmYWxzZTtcbiAgICBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCA9IGRhdGEuQ3JlZGVudGlhbHMuQWNjZXNzS2V5SWQ7XG4gICAgY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5ID0gZGF0YS5DcmVkZW50aWFscy5TZWNyZXRBY2Nlc3NLZXk7XG4gICAgY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuID0gZGF0YS5DcmVkZW50aWFscy5TZXNzaW9uVG9rZW47XG4gICAgY3JlZGVudGlhbHMuZXhwaXJlVGltZSA9IGRhdGEuQ3JlZGVudGlhbHMuRXhwaXJhdGlvbjtcbiAgICByZXR1cm4gY3JlZGVudGlhbHM7XG4gIH0sXG5cbiAgYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eTogZnVuY3Rpb24gYXNzdW1lUm9sZVdpdGhXZWJJZGVudGl0eShwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2Fzc3VtZVJvbGVXaXRoV2ViSWRlbnRpdHknLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBhc3N1bWVSb2xlV2l0aFNBTUw6IGZ1bmN0aW9uIGFzc3VtZVJvbGVXaXRoU0FNTChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVVuYXV0aGVudGljYXRlZFJlcXVlc3QoJ2Fzc3VtZVJvbGVXaXRoU0FNTCcsIHBhcmFtcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNldHVwUmVxdWVzdExpc3RlbmVyczogZnVuY3Rpb24gc2V0dXBSZXF1ZXN0TGlzdGVuZXJzKHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LmFkZExpc3RlbmVyKCd2YWxpZGF0ZScsIHRoaXMub3B0SW5SZWdpb25hbEVuZHBvaW50LCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBvcHRJblJlZ2lvbmFsRW5kcG9pbnQ6IGZ1bmN0aW9uIG9wdEluUmVnaW9uYWxFbmRwb2ludChyZXEpIHtcbiAgICB2YXIgc2VydmljZSA9IHJlcS5zZXJ2aWNlO1xuICAgIHZhciBjb25maWcgPSBzZXJ2aWNlLmNvbmZpZztcbiAgICBjb25maWcuc3RzUmVnaW9uYWxFbmRwb2ludHMgPSByZXNvbHZlUmVnaW9uYWxFbmRwb2ludHNGbGFnKHNlcnZpY2UuX29yaWdpbmFsQ29uZmlnLCB7XG4gICAgICBlbnY6IEVOVl9SRUdJT05BTF9FTkRQT0lOVF9FTkFCTEVELFxuICAgICAgc2hhcmVkQ29uZmlnOiBDT05GSUdfUkVHSU9OQUxfRU5EUE9JTlRfRU5BQkxFRCxcbiAgICAgIGNsaWVudENvbmZpZzogJ3N0c1JlZ2lvbmFsRW5kcG9pbnRzJ1xuICAgIH0pO1xuICAgIGlmIChcbiAgICAgIGNvbmZpZy5zdHNSZWdpb25hbEVuZHBvaW50cyA9PT0gJ3JlZ2lvbmFsJyAmJlxuICAgICAgc2VydmljZS5pc0dsb2JhbEVuZHBvaW50XG4gICAgKSB7XG4gICAgICAvL2NsaWVudCB3aWxsIHRocm93IGlmIHJlZ2lvbiBpcyBub3Qgc3VwcGxpZWQ7IHJlcXVlc3Qgd2lsbCBiZSBzaWduZWQgd2l0aCBzcGVjaWZpZWQgcmVnaW9uXG4gICAgICBpZiAoIWNvbmZpZy5yZWdpb24pIHtcbiAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAge2NvZGU6ICdDb25maWdFcnJvcicsIG1lc3NhZ2U6ICdNaXNzaW5nIHJlZ2lvbiBpbiBjb25maWcnfSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5zZXJ0UG9pbnQgPSBjb25maWcuZW5kcG9pbnQuaW5kZXhPZignLmFtYXpvbmF3cy5jb20nKTtcbiAgICAgIHZhciByZWdpb25hbEVuZHBvaW50ID0gY29uZmlnLmVuZHBvaW50LnN1YnN0cmluZygwLCBpbnNlcnRQb2ludCkgK1xuICAgICAgICAnLicgKyBjb25maWcucmVnaW9uICsgY29uZmlnLmVuZHBvaW50LnN1YnN0cmluZyhpbnNlcnRQb2ludCk7XG4gICAgICByZXEuaHR0cFJlcXVlc3QudXBkYXRlRW5kcG9pbnQocmVnaW9uYWxFbmRwb2ludCk7XG4gICAgICByZXEuaHR0cFJlcXVlc3QucmVnaW9uID0gY29uZmlnLnJlZ2lvbjtcbiAgICB9XG4gIH1cblxufSk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5CZWFyZXIgPSBBV1MudXRpbC5pbmhlcml0KEFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIsIHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIEJlYXJlcihyZXF1ZXN0KSB7XG4gICAgQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lci5jYWxsKHRoaXMsIHJlcXVlc3QpO1xuICB9LFxuXG4gIGFkZEF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGFkZEF1dGhvcml6YXRpb24odG9rZW4pIHtcbiAgICB0aGlzLnJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgdG9rZW4udG9rZW47XG4gIH1cbn0pO1xuIiwidmFyIEFXUyA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGV4cGlyZXNIZWFkZXIgPSAncHJlc2lnbmVkLWV4cGlyZXMnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaWduZWRVcmxCdWlsZGVyKHJlcXVlc3QpIHtcbiAgdmFyIGV4cGlyZXMgPSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl07XG4gIHZhciBzaWduZXJDbGFzcyA9IHJlcXVlc3Quc2VydmljZS5nZXRTaWduZXJDbGFzcyhyZXF1ZXN0KTtcblxuICBkZWxldGUgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzWydVc2VyLUFnZW50J107XG4gIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LVVzZXItQWdlbnQnXTtcblxuICBpZiAoc2lnbmVyQ2xhc3MgPT09IEFXUy5TaWduZXJzLlY0KSB7XG4gICAgaWYgKGV4cGlyZXMgPiA2MDQ4MDApIHsgLy8gb25lIHdlZWsgZXhwaXJ5IGlzIGludmFsaWRcbiAgICAgIHZhciBtZXNzYWdlID0gJ1ByZXNpZ25pbmcgZG9lcyBub3Qgc3VwcG9ydCBleHBpcnkgdGltZSBncmVhdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhhbiBhIHdlZWsgd2l0aCBTaWdWNCBzaWduaW5nLic7XG4gICAgICB0aHJvdyBBV1MudXRpbC5lcnJvcihuZXcgRXJyb3IoKSwge1xuICAgICAgICBjb2RlOiAnSW52YWxpZEV4cGlyeVRpbWUnLCBtZXNzYWdlOiBtZXNzYWdlLCByZXRyeWFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdC5odHRwUmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdID0gZXhwaXJlcztcbiAgfSBlbHNlIGlmIChzaWduZXJDbGFzcyA9PT0gQVdTLlNpZ25lcnMuUzMpIHtcbiAgICB2YXIgbm93ID0gcmVxdWVzdC5zZXJ2aWNlID8gcmVxdWVzdC5zZXJ2aWNlLmdldFNrZXdDb3JyZWN0ZWREYXRlKCkgOiBBV1MudXRpbC5kYXRlLmdldERhdGUoKTtcbiAgICByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl0gPSBwYXJzZUludChcbiAgICAgIEFXUy51dGlsLmRhdGUudW5peFRpbWVzdGFtcChub3cpICsgZXhwaXJlcywgMTApLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCksIHtcbiAgICAgIG1lc3NhZ2U6ICdQcmVzaWduaW5nIG9ubHkgc3VwcG9ydHMgUzMgb3IgU2lnVjQgc2lnbmluZy4nLFxuICAgICAgY29kZTogJ1Vuc3VwcG9ydGVkU2lnbmVyJywgcmV0cnlhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNpZ25lZFVybFNpZ25lcihyZXF1ZXN0KSB7XG4gIHZhciBlbmRwb2ludCA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQ7XG4gIHZhciBwYXJzZWRVcmwgPSBBV1MudXRpbC51cmxQYXJzZShyZXF1ZXN0Lmh0dHBSZXF1ZXN0LnBhdGgpO1xuICB2YXIgcXVlcnlQYXJhbXMgPSB7fTtcblxuICBpZiAocGFyc2VkVXJsLnNlYXJjaCkge1xuICAgIHF1ZXJ5UGFyYW1zID0gQVdTLnV0aWwucXVlcnlTdHJpbmdQYXJzZShwYXJzZWRVcmwuc2VhcmNoLnN1YnN0cigxKSk7XG4gIH1cblxuICB2YXIgYXV0aCA9IHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddLnNwbGl0KCcgJyk7XG4gIGlmIChhdXRoWzBdID09PSAnQVdTJykge1xuICAgIGF1dGggPSBhdXRoWzFdLnNwbGl0KCc6Jyk7XG4gICAgcXVlcnlQYXJhbXNbJ1NpZ25hdHVyZSddID0gYXV0aC5wb3AoKTtcbiAgICBxdWVyeVBhcmFtc1snQVdTQWNjZXNzS2V5SWQnXSA9IGF1dGguam9pbignOicpO1xuXG4gICAgQVdTLnV0aWwuZWFjaChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09PSBleHBpcmVzSGVhZGVyKSBrZXkgPSAnRXhwaXJlcyc7XG4gICAgICBpZiAoa2V5LmluZGV4T2YoJ3gtYW16LW1ldGEtJykgPT09IDApIHtcbiAgICAgICAgLy8gRGVsZXRlIGV4aXN0aW5nLCBwb3RlbnRpYWxseSBub3Qgbm9ybWFsaXplZCBrZXlcbiAgICAgICAgZGVsZXRlIHF1ZXJ5UGFyYW1zW2tleV07XG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIGRlbGV0ZSByZXF1ZXN0Lmh0dHBSZXF1ZXN0LmhlYWRlcnNbZXhwaXJlc0hlYWRlcl07XG4gICAgZGVsZXRlIHF1ZXJ5UGFyYW1zWydBdXRob3JpemF0aW9uJ107XG4gICAgZGVsZXRlIHF1ZXJ5UGFyYW1zWydIb3N0J107XG4gIH0gZWxzZSBpZiAoYXV0aFswXSA9PT0gJ0FXUzQtSE1BQy1TSEEyNTYnKSB7IC8vIFNpZ1Y0IHNpZ25pbmdcbiAgICBhdXRoLnNoaWZ0KCk7XG4gICAgdmFyIHJlc3QgPSBhdXRoLmpvaW4oJyAnKTtcbiAgICB2YXIgc2lnbmF0dXJlID0gcmVzdC5tYXRjaCgvU2lnbmF0dXJlPSguKj8pKD86LHxcXHN8XFxyP1xcbnwkKS8pWzFdO1xuICAgIHF1ZXJ5UGFyYW1zWydYLUFtei1TaWduYXR1cmUnXSA9IHNpZ25hdHVyZTtcbiAgICBkZWxldGUgcXVlcnlQYXJhbXNbJ0V4cGlyZXMnXTtcbiAgfVxuXG4gIC8vIGJ1aWxkIFVSTFxuICBlbmRwb2ludC5wYXRobmFtZSA9IHBhcnNlZFVybC5wYXRobmFtZTtcbiAgZW5kcG9pbnQuc2VhcmNoID0gQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhxdWVyeVBhcmFtcyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlByZXNpZ24gPSBpbmhlcml0KHtcbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgc2lnbjogZnVuY3Rpb24gc2lnbihyZXF1ZXN0LCBleHBpcmVUaW1lLCBjYWxsYmFjaykge1xuICAgIHJlcXVlc3QuaHR0cFJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSA9IGV4cGlyZVRpbWUgfHwgMzYwMDtcbiAgICByZXF1ZXN0Lm9uKCdidWlsZCcsIHNpZ25lZFVybEJ1aWxkZXIpO1xuICAgIHJlcXVlc3Qub24oJ3NpZ24nLCBzaWduZWRVcmxTaWduZXIpO1xuICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2FmdGVyQnVpbGQnLFxuICAgICAgQVdTLkV2ZW50TGlzdGVuZXJzLkNvcmUuU0VUX0NPTlRFTlRfTEVOR1RIKTtcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdhZnRlckJ1aWxkJyxcbiAgICAgIEFXUy5FdmVudExpc3RlbmVycy5Db3JlLkNPTVBVVEVfU0hBMjU2KTtcblxuICAgIHJlcXVlc3QuZW1pdCgnYmVmb3JlUHJlc2lnbicsIFtyZXF1ZXN0XSk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJlcXVlc3QuYnVpbGQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlLmVycm9yKSBjYWxsYmFjayh0aGlzLnJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgQVdTLnV0aWwudXJsRm9ybWF0KHJlcXVlc3QuaHR0cFJlcXVlc3QuZW5kcG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuYnVpbGQoKTtcbiAgICAgIGlmIChyZXF1ZXN0LnJlc3BvbnNlLmVycm9yKSB0aHJvdyByZXF1ZXN0LnJlc3BvbnNlLmVycm9yO1xuICAgICAgcmV0dXJuIEFXUy51dGlsLnVybEZvcm1hdChyZXF1ZXN0Lmh0dHBSZXF1ZXN0LmVuZHBvaW50KTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFXUy5TaWduZXJzLlByZXNpZ247XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgaW5oZXJpdCA9IEFXUy51dGlsLmluaGVyaXQ7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIgPSBpbmhlcml0KHtcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIFJlcXVlc3RTaWduZXIocmVxdWVzdCkge1xuICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIH0sXG5cbiAgc2V0U2VydmljZUNsaWVudElkOiBmdW5jdGlvbiBzZXRTZXJ2aWNlQ2xpZW50SWQoaWQpIHtcbiAgICB0aGlzLnNlcnZpY2VDbGllbnRJZCA9IGlkO1xuICB9LFxuXG4gIGdldFNlcnZpY2VDbGllbnRJZDogZnVuY3Rpb24gZ2V0U2VydmljZUNsaWVudElkKCkge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2VDbGllbnRJZDtcbiAgfVxufSk7XG5cbkFXUy5TaWduZXJzLlJlcXVlc3RTaWduZXIuZ2V0VmVyc2lvbiA9IGZ1bmN0aW9uIGdldFZlcnNpb24odmVyc2lvbikge1xuICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICBjYXNlICd2Mic6IHJldHVybiBBV1MuU2lnbmVycy5WMjtcbiAgICBjYXNlICd2Myc6IHJldHVybiBBV1MuU2lnbmVycy5WMztcbiAgICBjYXNlICdzM3Y0JzogcmV0dXJuIEFXUy5TaWduZXJzLlY0O1xuICAgIGNhc2UgJ3Y0JzogcmV0dXJuIEFXUy5TaWduZXJzLlY0O1xuICAgIGNhc2UgJ3MzJzogcmV0dXJuIEFXUy5TaWduZXJzLlMzO1xuICAgIGNhc2UgJ3YzaHR0cHMnOiByZXR1cm4gQVdTLlNpZ25lcnMuVjNIdHRwcztcbiAgICBjYXNlICdiZWFyZXInOiByZXR1cm4gQVdTLlNpZ25lcnMuQmVhcmVyO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzaWduaW5nIHZlcnNpb24gJyArIHZlcnNpb24pO1xufTtcblxucmVxdWlyZSgnLi92MicpO1xucmVxdWlyZSgnLi92MycpO1xucmVxdWlyZSgnLi92M2h0dHBzJyk7XG5yZXF1aXJlKCcuL3Y0Jyk7XG5yZXF1aXJlKCcuL3MzJyk7XG5yZXF1aXJlKCcuL3ByZXNpZ24nKTtcbnJlcXVpcmUoJy4vYmVhcmVyJyk7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5TMyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICAvKipcbiAgICogV2hlbiBidWlsZGluZyB0aGUgc3RyaW5nVG9TaWduLCB0aGVzZSBzdWIgcmVzb3VyY2UgcGFyYW1zIHNob3VsZCBiZVxuICAgKiBwYXJ0IG9mIHRoZSBjYW5vbmljYWwgcmVzb3VyY2Ugc3RyaW5nIHdpdGggdGhlaXIgTk9OLWRlY29kZWQgdmFsdWVzXG4gICAqL1xuICBzdWJSZXNvdXJjZXM6IHtcbiAgICAnYWNsJzogMSxcbiAgICAnYWNjZWxlcmF0ZSc6IDEsXG4gICAgJ2FuYWx5dGljcyc6IDEsXG4gICAgJ2NvcnMnOiAxLFxuICAgICdsaWZlY3ljbGUnOiAxLFxuICAgICdkZWxldGUnOiAxLFxuICAgICdpbnZlbnRvcnknOiAxLFxuICAgICdsb2NhdGlvbic6IDEsXG4gICAgJ2xvZ2dpbmcnOiAxLFxuICAgICdtZXRyaWNzJzogMSxcbiAgICAnbm90aWZpY2F0aW9uJzogMSxcbiAgICAncGFydE51bWJlcic6IDEsXG4gICAgJ3BvbGljeSc6IDEsXG4gICAgJ3JlcXVlc3RQYXltZW50JzogMSxcbiAgICAncmVwbGljYXRpb24nOiAxLFxuICAgICdyZXN0b3JlJzogMSxcbiAgICAndGFnZ2luZyc6IDEsXG4gICAgJ3RvcnJlbnQnOiAxLFxuICAgICd1cGxvYWRJZCc6IDEsXG4gICAgJ3VwbG9hZHMnOiAxLFxuICAgICd2ZXJzaW9uSWQnOiAxLFxuICAgICd2ZXJzaW9uaW5nJzogMSxcbiAgICAndmVyc2lvbnMnOiAxLFxuICAgICd3ZWJzaXRlJzogMVxuICB9LFxuXG4gIC8vIHdoZW4gYnVpbGRpbmcgdGhlIHN0cmluZ1RvU2lnbiwgdGhlc2UgcXVlcnlzdHJpbmcgcGFyYW1zIHNob3VsZCBiZVxuICAvLyBwYXJ0IG9mIHRoZSBjYW5vbmljYWwgcmVzb3VyY2Ugc3RyaW5nIHdpdGggdGhlaXIgTk9OLWVuY29kZWQgdmFsdWVzXG4gIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICdyZXNwb25zZS1jb250ZW50LXR5cGUnOiAxLFxuICAgICdyZXNwb25zZS1jb250ZW50LWxhbmd1YWdlJzogMSxcbiAgICAncmVzcG9uc2UtZXhwaXJlcyc6IDEsXG4gICAgJ3Jlc3BvbnNlLWNhY2hlLWNvbnRyb2wnOiAxLFxuICAgICdyZXNwb25zZS1jb250ZW50LWRpc3Bvc2l0aW9uJzogMSxcbiAgICAncmVzcG9uc2UtY29udGVudC1lbmNvZGluZyc6IDFcbiAgfSxcblxuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG4gICAgaWYgKCF0aGlzLnJlcXVlc3QuaGVhZGVyc1sncHJlc2lnbmVkLWV4cGlyZXMnXSkge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXSA9IEFXUy51dGlsLmRhdGUucmZjODIyKGRhdGUpO1xuICAgIH1cblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIC8vIHByZXNpZ25lZCBVUkxzIHJlcXVpcmUgdGhpcyBoZWFkZXIgdG8gYmUgbG93ZXJjYXNlZFxuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuc2lnbihjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCkpO1xuICAgIHZhciBhdXRoID0gJ0FXUyAnICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnOicgKyBzaWduYXR1cmU7XG5cbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYXV0aDtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgciA9IHRoaXMucmVxdWVzdDtcblxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHBhcnRzLnB1c2goci5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2goci5oZWFkZXJzWydDb250ZW50LU1ENSddIHx8ICcnKTtcbiAgICBwYXJ0cy5wdXNoKHIuaGVhZGVyc1snQ29udGVudC1UeXBlJ10gfHwgJycpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgXCJEYXRlXCIgaGVhZGVyLCBidXQgd2UgdXNlIFgtQW16LURhdGUuXG4gICAgLy8gVGhlIFMzIHNpZ25pbmcgbWVjaGFuaXNtIHJlcXVpcmVzIHVzIHRvIHBhc3MgYW4gZW1wdHlcbiAgICAvLyBzdHJpbmcgZm9yIHRoaXMgRGF0ZSBoZWFkZXIgcmVnYXJkbGVzcy5cbiAgICBwYXJ0cy5wdXNoKHIuaGVhZGVyc1sncHJlc2lnbmVkLWV4cGlyZXMnXSB8fCAnJyk7XG5cbiAgICB2YXIgaGVhZGVycyA9IHRoaXMuY2Fub25pY2FsaXplZEFtekhlYWRlcnMoKTtcbiAgICBpZiAoaGVhZGVycykgcGFydHMucHVzaChoZWFkZXJzKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY2Fub25pY2FsaXplZFJlc291cmNlKCkpO1xuXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJ1xcbicpO1xuXG4gIH0sXG5cbiAgY2Fub25pY2FsaXplZEFtekhlYWRlcnM6IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZWRBbXpIZWFkZXJzKCkge1xuXG4gICAgdmFyIGFtekhlYWRlcnMgPSBbXTtcblxuICAgIEFXUy51dGlsLmVhY2godGhpcy5yZXF1ZXN0LmhlYWRlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZS5tYXRjaCgvXngtYW16LS9pKSlcbiAgICAgICAgYW16SGVhZGVycy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgYW16SGVhZGVycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS50b0xvd2VyQ2FzZSgpIDwgYi50b0xvd2VyQ2FzZSgpID8gLTEgOiAxO1xuICAgIH0pO1xuXG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgYW16SGVhZGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHBhcnRzLnB1c2gobmFtZS50b0xvd2VyQ2FzZSgpICsgJzonICsgU3RyaW5nKHRoaXMucmVxdWVzdC5oZWFkZXJzW25hbWVdKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG5cbiAgfSxcblxuICBjYW5vbmljYWxpemVkUmVzb3VyY2U6IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZWRSZXNvdXJjZSgpIHtcblxuICAgIHZhciByID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgdmFyIHBhcnRzID0gci5wYXRoLnNwbGl0KCc/Jyk7XG4gICAgdmFyIHBhdGggPSBwYXJ0c1swXTtcbiAgICB2YXIgcXVlcnlzdHJpbmcgPSBwYXJ0c1sxXTtcblxuICAgIHZhciByZXNvdXJjZSA9ICcnO1xuXG4gICAgaWYgKHIudmlydHVhbEhvc3RlZEJ1Y2tldClcbiAgICAgIHJlc291cmNlICs9ICcvJyArIHIudmlydHVhbEhvc3RlZEJ1Y2tldDtcblxuICAgIHJlc291cmNlICs9IHBhdGg7XG5cbiAgICBpZiAocXVlcnlzdHJpbmcpIHtcblxuICAgICAgLy8gY29sbGVjdCBhIGxpc3Qgb2Ygc3ViIHJlc291cmNlcyBhbmQgcXVlcnkgcGFyYW1zIHRoYXQgbmVlZCB0byBiZSBzaWduZWRcbiAgICAgIHZhciByZXNvdXJjZXMgPSBbXTtcblxuICAgICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgcXVlcnlzdHJpbmcuc3BsaXQoJyYnKSwgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyYW0uc3BsaXQoJz0nKVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW0uc3BsaXQoJz0nKVsxXTtcbiAgICAgICAgaWYgKHRoaXMuc3ViUmVzb3VyY2VzW25hbWVdIHx8IHRoaXMucmVzcG9uc2VIZWFkZXJzW25hbWVdKSB7XG4gICAgICAgICAgdmFyIHN1YnJlc291cmNlID0geyBuYW1lOiBuYW1lIH07XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YlJlc291cmNlc1tuYW1lXSkge1xuICAgICAgICAgICAgICBzdWJyZXNvdXJjZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VicmVzb3VyY2UudmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvdXJjZXMucHVzaChzdWJyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXNvdXJjZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxOyB9KTtcblxuICAgICAgaWYgKHJlc291cmNlcy5sZW5ndGgpIHtcblxuICAgICAgICBxdWVyeXN0cmluZyA9IFtdO1xuICAgICAgICBBV1MudXRpbC5hcnJheUVhY2gocmVzb3VyY2VzLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgaWYgKHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxdWVyeXN0cmluZy5wdXNoKHJlcy5uYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVlcnlzdHJpbmcucHVzaChyZXMubmFtZSArICc9JyArIHJlcy52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXNvdXJjZSArPSAnPycgKyBxdWVyeXN0cmluZy5qb2luKCcmJyk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzb3VyY2U7XG5cbiAgfSxcblxuICBzaWduOiBmdW5jdGlvbiBzaWduKHNlY3JldCwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIEFXUy51dGlsLmNyeXB0by5obWFjKHNlY3JldCwgc3RyaW5nLCAnYmFzZTY0JywgJ3NoYTEnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuUzM7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WMiA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG5cbiAgICBpZiAoIWRhdGUpIGRhdGUgPSBBV1MudXRpbC5kYXRlLmdldERhdGUoKTtcblxuICAgIHZhciByID0gdGhpcy5yZXF1ZXN0O1xuXG4gICAgci5wYXJhbXMuVGltZXN0YW1wID0gQVdTLnV0aWwuZGF0ZS5pc284NjAxKGRhdGUpO1xuICAgIHIucGFyYW1zLlNpZ25hdHVyZVZlcnNpb24gPSAnMic7XG4gICAgci5wYXJhbXMuU2lnbmF0dXJlTWV0aG9kID0gJ0htYWNTSEEyNTYnO1xuICAgIHIucGFyYW1zLkFXU0FjY2Vzc0tleUlkID0gY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQ7XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICByLnBhcmFtcy5TZWN1cml0eVRva2VuID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIGRlbGV0ZSByLnBhcmFtcy5TaWduYXR1cmU7IC8vIGRlbGV0ZSBvbGQgU2lnbmF0dXJlIGZvciByZS1zaWduaW5nXG4gICAgci5wYXJhbXMuU2lnbmF0dXJlID0gdGhpcy5zaWduYXR1cmUoY3JlZGVudGlhbHMpO1xuXG4gICAgci5ib2R5ID0gQVdTLnV0aWwucXVlcnlQYXJhbXNUb1N0cmluZyhyLnBhcmFtcyk7XG4gICAgci5oZWFkZXJzWydDb250ZW50LUxlbmd0aCddID0gci5ib2R5Lmxlbmd0aDtcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCksICdiYXNlNjQnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0LmVuZHBvaW50Lmhvc3QudG9Mb3dlckNhc2UoKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3QucGF0aG5hbWUoKSk7XG4gICAgcGFydHMucHVzaChBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHRoaXMucmVxdWVzdC5wYXJhbXMpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjI7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WMyA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBhZGRBdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhZGRBdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRlKSB7XG5cbiAgICB2YXIgZGF0ZXRpbWUgPSBBV1MudXRpbC5kYXRlLnJmYzgyMihkYXRlKTtcblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtei1EYXRlJ10gPSBkYXRldGltZTtcblxuICAgIGlmIChjcmVkZW50aWFscy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWyd4LWFtei1zZWN1cml0eS10b2tlbiddID0gY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydYLUFtem4tQXV0aG9yaXphdGlvbiddID1cbiAgICAgIHRoaXMuYXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuXG4gIH0sXG5cbiAgYXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYXV0aG9yaXphdGlvbihjcmVkZW50aWFscykge1xuICAgIHJldHVybiAnQVdTMyAnICtcbiAgICAgICdBV1NBY2Nlc3NLZXlJZD0nICsgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLCcgK1xuICAgICAgJ0FsZ29yaXRobT1IbWFjU0hBMjU2LCcgK1xuICAgICAgJ1NpZ25lZEhlYWRlcnM9JyArIHRoaXMuc2lnbmVkSGVhZGVycygpICsgJywnICtcbiAgICAgICdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzKTtcbiAgfSxcblxuICBzaWduZWRIZWFkZXJzOiBmdW5jdGlvbiBzaWduZWRIZWFkZXJzKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoKHRoaXMuaGVhZGVyc1RvU2lnbigpLCBmdW5jdGlvbiBpdGVyYXRvcihoKSB7XG4gICAgICBoZWFkZXJzLnB1c2goaC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycy5zb3J0KCkuam9pbignOycpO1xuICB9LFxuXG4gIGNhbm9uaWNhbEhlYWRlcnM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlcnMoKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlcXVlc3QuaGVhZGVycztcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBBV1MudXRpbC5hcnJheUVhY2godGhpcy5oZWFkZXJzVG9TaWduKCksIGZ1bmN0aW9uIGl0ZXJhdG9yKGgpIHtcbiAgICAgIHBhcnRzLnB1c2goaC50b0xvd2VyQ2FzZSgpLnRyaW0oKSArICc6JyArIFN0cmluZyhoZWFkZXJzW2hdKS50cmltKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5zb3J0KCkuam9pbignXFxuJykgKyAnXFxuJztcbiAgfSxcblxuICBoZWFkZXJzVG9TaWduOiBmdW5jdGlvbiBoZWFkZXJzVG9TaWduKCkge1xuICAgIHZhciBoZWFkZXJzID0gW107XG4gICAgQVdTLnV0aWwuZWFjaCh0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gaXRlcmF0b3Ioaykge1xuICAgICAgaWYgKGsgPT09ICdIb3N0JyB8fCBrID09PSAnQ29udGVudC1FbmNvZGluZycgfHwgay5tYXRjaCgvXlgtQW16L2kpKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uaG1hYyhjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksIHRoaXMuc3RyaW5nVG9TaWduKCksICdiYXNlNjQnKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5tZXRob2QpO1xuICAgIHBhcnRzLnB1c2goJy8nKTtcbiAgICBwYXJ0cy5wdXNoKCcnKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuY2Fub25pY2FsSGVhZGVycygpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMucmVxdWVzdC5ib2R5KTtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLnNoYTI1NihwYXJ0cy5qb2luKCdcXG4nKSk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjM7XG4iLCJ2YXIgQVdTID0gcmVxdWlyZSgnLi4vY29yZScpO1xudmFyIGluaGVyaXQgPSBBV1MudXRpbC5pbmhlcml0O1xuXG5yZXF1aXJlKCcuL3YzJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbkFXUy5TaWduZXJzLlYzSHR0cHMgPSBpbmhlcml0KEFXUy5TaWduZXJzLlYzLCB7XG4gIGF1dGhvcml6YXRpb246IGZ1bmN0aW9uIGF1dGhvcml6YXRpb24oY3JlZGVudGlhbHMpIHtcbiAgICByZXR1cm4gJ0FXUzMtSFRUUFMgJyArXG4gICAgICAnQVdTQWNjZXNzS2V5SWQ9JyArIGNyZWRlbnRpYWxzLmFjY2Vzc0tleUlkICsgJywnICtcbiAgICAgICdBbGdvcml0aG09SG1hY1NIQTI1NiwnICtcbiAgICAgICdTaWduYXR1cmU9JyArIHRoaXMuc2lnbmF0dXJlKGNyZWRlbnRpYWxzKTtcbiAgfSxcblxuICBzdHJpbmdUb1NpZ246IGZ1bmN0aW9uIHN0cmluZ1RvU2lnbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ1gtQW16LURhdGUnXTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVdTLlNpZ25lcnMuVjNIdHRwcztcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG52YXIgdjRDcmVkZW50aWFscyA9IHJlcXVpcmUoJy4vdjRfY3JlZGVudGlhbHMnKTtcbnZhciBpbmhlcml0ID0gQVdTLnV0aWwuaW5oZXJpdDtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGV4cGlyZXNIZWFkZXIgPSAncHJlc2lnbmVkLWV4cGlyZXMnO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5BV1MuU2lnbmVycy5WNCA9IGluaGVyaXQoQVdTLlNpZ25lcnMuUmVxdWVzdFNpZ25lciwge1xuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gVjQocmVxdWVzdCwgc2VydmljZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBBV1MuU2lnbmVycy5SZXF1ZXN0U2lnbmVyLmNhbGwodGhpcywgcmVxdWVzdCk7XG4gICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuc2lnbmF0dXJlQ2FjaGUgPSB0eXBlb2Ygb3B0aW9ucy5zaWduYXR1cmVDYWNoZSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zaWduYXR1cmVDYWNoZSA6IHRydWU7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcHRpb25zLm9wZXJhdGlvbjtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcnNpb24gPSBvcHRpb25zLnNpZ25hdHVyZVZlcnNpb247XG4gIH0sXG5cbiAgYWxnb3JpdGhtOiAnQVdTNC1ITUFDLVNIQTI1NicsXG5cbiAgYWRkQXV0aG9yaXphdGlvbjogZnVuY3Rpb24gYWRkQXV0aG9yaXphdGlvbihjcmVkZW50aWFscywgZGF0ZSkge1xuICAgIHZhciBkYXRldGltZSA9IEFXUy51dGlsLmRhdGUuaXNvODYwMShkYXRlKS5yZXBsYWNlKC9bOlxcLV18XFwuXFxkezN9L2csICcnKTtcblxuICAgIGlmICh0aGlzLmlzUHJlc2lnbmVkKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlRm9yUHJlc2lnbmVkKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkSGVhZGVycyhjcmVkZW50aWFscywgZGF0ZXRpbWUpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdC5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPVxuICAgICAgdGhpcy5hdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSk7XG4gIH0sXG5cbiAgYWRkSGVhZGVyczogZnVuY3Rpb24gYWRkSGVhZGVycyhjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB0aGlzLnJlcXVlc3QuaGVhZGVyc1snWC1BbXotRGF0ZSddID0gZGF0ZXRpbWU7XG4gICAgaWYgKGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ3gtYW16LXNlY3VyaXR5LXRva2VuJ10gPSBjcmVkZW50aWFscy5zZXNzaW9uVG9rZW47XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZUZvclByZXNpZ25lZDogZnVuY3Rpb24gdXBkYXRlRm9yUHJlc2lnbmVkKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBjcmVkU3RyaW5nID0gdGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKTtcbiAgICB2YXIgcXMgPSB7XG4gICAgICAnWC1BbXotRGF0ZSc6IGRhdGV0aW1lLFxuICAgICAgJ1gtQW16LUFsZ29yaXRobSc6IHRoaXMuYWxnb3JpdGhtLFxuICAgICAgJ1gtQW16LUNyZWRlbnRpYWwnOiBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCArICcvJyArIGNyZWRTdHJpbmcsXG4gICAgICAnWC1BbXotRXhwaXJlcyc6IHRoaXMucmVxdWVzdC5oZWFkZXJzW2V4cGlyZXNIZWFkZXJdLFxuICAgICAgJ1gtQW16LVNpZ25lZEhlYWRlcnMnOiB0aGlzLnNpZ25lZEhlYWRlcnMoKVxuICAgIH07XG5cbiAgICBpZiAoY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuKSB7XG4gICAgICBxc1snWC1BbXotU2VjdXJpdHktVG9rZW4nXSA9IGNyZWRlbnRpYWxzLnNlc3Npb25Ub2tlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICBxc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgfVxuICAgIGlmICh0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXSkge1xuICAgICAgcXNbJ0NvbnRlbnQtTUQ1J10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1NRDUnXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVxdWVzdC5oZWFkZXJzWydDYWNoZS1Db250cm9sJ10pIHtcbiAgICAgIHFzWydDYWNoZS1Db250cm9sJ10gPSB0aGlzLnJlcXVlc3QuaGVhZGVyc1snQ2FjaGUtQ29udHJvbCddO1xuICAgIH1cblxuICAgIC8vIG5lZWQgdG8gcHVsbCBpbiBhbnkgb3RoZXIgWC1BbXotKiBoZWFkZXJzXG4gICAgQVdTLnV0aWwuZWFjaC5jYWxsKHRoaXMsIHRoaXMucmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09PSBleHBpcmVzSGVhZGVyKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIHtcbiAgICAgICAgdmFyIGxvd2VyS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIE1ldGFkYXRhIHNob3VsZCBiZSBub3JtYWxpemVkXG4gICAgICAgIGlmIChsb3dlcktleS5pbmRleE9mKCd4LWFtei1tZXRhLScpID09PSAwKSB7XG4gICAgICAgICAgcXNbbG93ZXJLZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAobG93ZXJLZXkuaW5kZXhPZigneC1hbXotJykgPT09IDApIHtcbiAgICAgICAgICBxc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBzZXAgPSB0aGlzLnJlcXVlc3QucGF0aC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JztcbiAgICB0aGlzLnJlcXVlc3QucGF0aCArPSBzZXAgKyBBV1MudXRpbC5xdWVyeVBhcmFtc1RvU3RyaW5nKHFzKTtcbiAgfSxcblxuICBhdXRob3JpemF0aW9uOiBmdW5jdGlvbiBhdXRob3JpemF0aW9uKGNyZWRlbnRpYWxzLCBkYXRldGltZSkge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBjcmVkU3RyaW5nID0gdGhpcy5jcmVkZW50aWFsU3RyaW5nKGRhdGV0aW1lKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuYWxnb3JpdGhtICsgJyBDcmVkZW50aWFsPScgK1xuICAgICAgY3JlZGVudGlhbHMuYWNjZXNzS2V5SWQgKyAnLycgKyBjcmVkU3RyaW5nKTtcbiAgICBwYXJ0cy5wdXNoKCdTaWduZWRIZWFkZXJzPScgKyB0aGlzLnNpZ25lZEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCgnU2lnbmF0dXJlPScgKyB0aGlzLnNpZ25hdHVyZShjcmVkZW50aWFscywgZGF0ZXRpbWUpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLCAnKTtcbiAgfSxcblxuICBzaWduYXR1cmU6IGZ1bmN0aW9uIHNpZ25hdHVyZShjcmVkZW50aWFscywgZGF0ZXRpbWUpIHtcbiAgICB2YXIgc2lnbmluZ0tleSA9IHY0Q3JlZGVudGlhbHMuZ2V0U2lnbmluZ0tleShcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgZGF0ZXRpbWUuc3Vic3RyKDAsIDgpLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlZ2lvbixcbiAgICAgIHRoaXMuc2VydmljZU5hbWUsXG4gICAgICB0aGlzLnNpZ25hdHVyZUNhY2hlXG4gICAgKTtcbiAgICByZXR1cm4gQVdTLnV0aWwuY3J5cHRvLmhtYWMoc2lnbmluZ0tleSwgdGhpcy5zdHJpbmdUb1NpZ24oZGF0ZXRpbWUpLCAnaGV4Jyk7XG4gIH0sXG5cbiAgc3RyaW5nVG9TaWduOiBmdW5jdGlvbiBzdHJpbmdUb1NpZ24oZGF0ZXRpbWUpIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICBwYXJ0cy5wdXNoKCdBV1M0LUhNQUMtU0hBMjU2Jyk7XG4gICAgcGFydHMucHVzaChkYXRldGltZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmNyZWRlbnRpYWxTdHJpbmcoZGF0ZXRpbWUpKTtcbiAgICBwYXJ0cy5wdXNoKHRoaXMuaGV4RW5jb2RlZEhhc2godGhpcy5jYW5vbmljYWxTdHJpbmcoKSkpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxTdHJpbmc6IGZ1bmN0aW9uIGNhbm9uaWNhbFN0cmluZygpIHtcbiAgICB2YXIgcGFydHMgPSBbXSwgcGF0aG5hbWUgPSB0aGlzLnJlcXVlc3QucGF0aG5hbWUoKTtcbiAgICBpZiAodGhpcy5zZXJ2aWNlTmFtZSAhPT0gJ3MzJyAmJiB0aGlzLnNpZ25hdHVyZVZlcnNpb24gIT09ICdzM3Y0JykgcGF0aG5hbWUgPSBBV1MudXRpbC51cmlFc2NhcGVQYXRoKHBhdGhuYW1lKTtcblxuICAgIHBhcnRzLnB1c2godGhpcy5yZXF1ZXN0Lm1ldGhvZCk7XG4gICAgcGFydHMucHVzaChwYXRobmFtZSk7XG4gICAgcGFydHMucHVzaCh0aGlzLnJlcXVlc3Quc2VhcmNoKCkpO1xuICAgIHBhcnRzLnB1c2godGhpcy5jYW5vbmljYWxIZWFkZXJzKCkgKyAnXFxuJyk7XG4gICAgcGFydHMucHVzaCh0aGlzLnNpZ25lZEhlYWRlcnMoKSk7XG4gICAgcGFydHMucHVzaCh0aGlzLmhleEVuY29kZWRCb2R5SGFzaCgpKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH0sXG5cbiAgY2Fub25pY2FsSGVhZGVyczogZnVuY3Rpb24gY2Fub25pY2FsSGVhZGVycygpIHtcbiAgICB2YXIgaGVhZGVycyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSwgaXRlbSkge1xuICAgICAgaGVhZGVycy5wdXNoKFtrZXksIGl0ZW1dKTtcbiAgICB9KTtcbiAgICBoZWFkZXJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdLnRvTG93ZXJDYXNlKCkgPCBiWzBdLnRvTG93ZXJDYXNlKCkgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgQVdTLnV0aWwuYXJyYXlFYWNoLmNhbGwodGhpcywgaGVhZGVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBpdGVtWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbVsxXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgQVdTLnV0aWwuZXJyb3IobmV3IEVycm9yKCdIZWFkZXIgJyArIGtleSArICcgY29udGFpbnMgaW52YWxpZCB2YWx1ZScpLCB7XG4gICAgICAgICAgICBjb2RlOiAnSW52YWxpZEhlYWRlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGtleSArICc6JyArXG4gICAgICAgICAgdGhpcy5jYW5vbmljYWxIZWFkZXJWYWx1ZXModmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgfSxcblxuICBjYW5vbmljYWxIZWFkZXJWYWx1ZXM6IGZ1bmN0aW9uIGNhbm9uaWNhbEhlYWRlclZhbHVlcyh2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH0sXG5cbiAgc2lnbmVkSGVhZGVyczogZnVuY3Rpb24gc2lnbmVkSGVhZGVycygpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIEFXUy51dGlsLmVhY2guY2FsbCh0aGlzLCB0aGlzLnJlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKGtleSkge1xuICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5pc1NpZ25hYmxlSGVhZGVyKGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBrZXlzLnNvcnQoKS5qb2luKCc7Jyk7XG4gIH0sXG5cbiAgY3JlZGVudGlhbFN0cmluZzogZnVuY3Rpb24gY3JlZGVudGlhbFN0cmluZyhkYXRldGltZSkge1xuICAgIHJldHVybiB2NENyZWRlbnRpYWxzLmNyZWF0ZVNjb3BlKFxuICAgICAgZGF0ZXRpbWUuc3Vic3RyKDAsIDgpLFxuICAgICAgdGhpcy5yZXF1ZXN0LnJlZ2lvbixcbiAgICAgIHRoaXMuc2VydmljZU5hbWVcbiAgICApO1xuICB9LFxuXG4gIGhleEVuY29kZWRIYXNoOiBmdW5jdGlvbiBoYXNoKHN0cmluZykge1xuICAgIHJldHVybiBBV1MudXRpbC5jcnlwdG8uc2hhMjU2KHN0cmluZywgJ2hleCcpO1xuICB9LFxuXG4gIGhleEVuY29kZWRCb2R5SGFzaDogZnVuY3Rpb24gaGV4RW5jb2RlZEJvZHlIYXNoKCkge1xuICAgIHZhciByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0O1xuICAgIGlmICh0aGlzLmlzUHJlc2lnbmVkKCkgJiYgKFsnczMnLCAnczMtb2JqZWN0LWxhbWJkYSddLmluZGV4T2YodGhpcy5zZXJ2aWNlTmFtZSkgPiAtMSkgJiYgIXJlcXVlc3QuYm9keSkge1xuICAgICAgcmV0dXJuICdVTlNJR05FRC1QQVlMT0FEJztcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXSkge1xuICAgICAgcmV0dXJuIHJlcXVlc3QuaGVhZGVyc1snWC1BbXotQ29udGVudC1TaGEyNTYnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGV4RW5jb2RlZEhhc2godGhpcy5yZXF1ZXN0LmJvZHkgfHwgJycpO1xuICAgIH1cbiAgfSxcblxuICB1bnNpZ25hYmxlSGVhZGVyczogW1xuICAgICdhdXRob3JpemF0aW9uJyxcbiAgICAnY29udGVudC10eXBlJyxcbiAgICAnY29udGVudC1sZW5ndGgnLFxuICAgICd1c2VyLWFnZW50JyxcbiAgICBleHBpcmVzSGVhZGVyLFxuICAgICdleHBlY3QnLFxuICAgICd4LWFtem4tdHJhY2UtaWQnXG4gIF0sXG5cbiAgaXNTaWduYWJsZUhlYWRlcjogZnVuY3Rpb24gaXNTaWduYWJsZUhlYWRlcihrZXkpIHtcbiAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkuaW5kZXhPZigneC1hbXotJykgPT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzLnVuc2lnbmFibGVIZWFkZXJzLmluZGV4T2Yoa2V5KSA8IDA7XG4gIH0sXG5cbiAgaXNQcmVzaWduZWQ6IGZ1bmN0aW9uIGlzUHJlc2lnbmVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QuaGVhZGVyc1tleHBpcmVzSGVhZGVyXSA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBV1MuU2lnbmVycy5WNDtcbiIsInZhciBBV1MgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciBjYWNoZWRTZWNyZXQgPSB7fTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIGNhY2hlUXVldWUgPSBbXTtcblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xudmFyIG1heENhY2hlRW50cmllcyA9IDUwO1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG52YXIgdjRJZGVudGlmaWVyID0gJ2F3czRfcmVxdWVzdCc7XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIFtTdHJpbmddXG4gICAqIEBwYXJhbSByZWdpb24gW1N0cmluZ11cbiAgICogQHBhcmFtIHNlcnZpY2VOYW1lIFtTdHJpbmddXG4gICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICovXG4gIGNyZWF0ZVNjb3BlOiBmdW5jdGlvbiBjcmVhdGVTY29wZShkYXRlLCByZWdpb24sIHNlcnZpY2VOYW1lKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGRhdGUuc3Vic3RyKDAsIDgpLFxuICAgICAgcmVnaW9uLFxuICAgICAgc2VydmljZU5hbWUsXG4gICAgICB2NElkZW50aWZpZXJcbiAgICBdLmpvaW4oJy8nKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSBjcmVkZW50aWFscyBbQ3JlZGVudGlhbHNdXG4gICAqIEBwYXJhbSBkYXRlIFtTdHJpbmddXG4gICAqIEBwYXJhbSByZWdpb24gW1N0cmluZ11cbiAgICogQHBhcmFtIHNlcnZpY2UgW1N0cmluZ11cbiAgICogQHBhcmFtIHNob3VsZENhY2hlIFtCb29sZWFuXVxuICAgKiBAcmV0dXJuIFtTdHJpbmddXG4gICAqL1xuICBnZXRTaWduaW5nS2V5OiBmdW5jdGlvbiBnZXRTaWduaW5nS2V5KFxuICAgIGNyZWRlbnRpYWxzLFxuICAgIGRhdGUsXG4gICAgcmVnaW9uLFxuICAgIHNlcnZpY2UsXG4gICAgc2hvdWxkQ2FjaGVcbiAgKSB7XG4gICAgdmFyIGNyZWRzSWRlbnRpZmllciA9IEFXUy51dGlsLmNyeXB0b1xuICAgICAgLmhtYWMoY3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCwgJ2Jhc2U2NCcpO1xuICAgIHZhciBjYWNoZUtleSA9IFtjcmVkc0lkZW50aWZpZXIsIGRhdGUsIHJlZ2lvbiwgc2VydmljZV0uam9pbignXycpO1xuICAgIHNob3VsZENhY2hlID0gc2hvdWxkQ2FjaGUgIT09IGZhbHNlO1xuICAgIGlmIChzaG91bGRDYWNoZSAmJiAoY2FjaGVLZXkgaW4gY2FjaGVkU2VjcmV0KSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFNlY3JldFtjYWNoZUtleV07XG4gICAgfVxuXG4gICAgdmFyIGtEYXRlID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoXG4gICAgICAnQVdTNCcgKyBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksXG4gICAgICBkYXRlLFxuICAgICAgJ2J1ZmZlcidcbiAgICApO1xuICAgIHZhciBrUmVnaW9uID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoa0RhdGUsIHJlZ2lvbiwgJ2J1ZmZlcicpO1xuICAgIHZhciBrU2VydmljZSA9IEFXUy51dGlsLmNyeXB0by5obWFjKGtSZWdpb24sIHNlcnZpY2UsICdidWZmZXInKTtcblxuICAgIHZhciBzaWduaW5nS2V5ID0gQVdTLnV0aWwuY3J5cHRvLmhtYWMoa1NlcnZpY2UsIHY0SWRlbnRpZmllciwgJ2J1ZmZlcicpO1xuICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgY2FjaGVkU2VjcmV0W2NhY2hlS2V5XSA9IHNpZ25pbmdLZXk7XG4gICAgICBjYWNoZVF1ZXVlLnB1c2goY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlUXVldWUubGVuZ3RoID4gbWF4Q2FjaGVFbnRyaWVzKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgb2xkZXN0IGVudHJ5IChub3QgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQpXG4gICAgICAgIGRlbGV0ZSBjYWNoZWRTZWNyZXRbY2FjaGVRdWV1ZS5zaGlmdCgpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2lnbmluZ0tleTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqXG4gICAqIEVtcHRpZXMgdGhlIGRlcml2ZWQgc2lnbmluZyBrZXkgY2FjaGUuIE1hZGUgYXZhaWxhYmxlIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAqIG9ubHkuXG4gICAqL1xuICBlbXB0eUNhY2hlOiBmdW5jdGlvbiBlbXB0eUNhY2hlKCkge1xuICAgIGNhY2hlZFNlY3JldCA9IHt9O1xuICAgIGNhY2hlUXVldWUgPSBbXTtcbiAgfVxufTtcbiIsImZ1bmN0aW9uIEFjY2VwdG9yU3RhdGVNYWNoaW5lKHN0YXRlcywgc3RhdGUpIHtcbiAgdGhpcy5jdXJyZW50U3RhdGUgPSBzdGF0ZSB8fCBudWxsO1xuICB0aGlzLnN0YXRlcyA9IHN0YXRlcyB8fCB7fTtcbn1cblxuQWNjZXB0b3JTdGF0ZU1hY2hpbmUucHJvdG90eXBlLnJ1blRvID0gZnVuY3Rpb24gcnVuVG8oZmluYWxTdGF0ZSwgZG9uZSwgYmluZE9iamVjdCwgaW5wdXRFcnJvcikge1xuICBpZiAodHlwZW9mIGZpbmFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnB1dEVycm9yID0gYmluZE9iamVjdDsgYmluZE9iamVjdCA9IGRvbmU7XG4gICAgZG9uZSA9IGZpbmFsU3RhdGU7IGZpbmFsU3RhdGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSBzZWxmLnN0YXRlc1tzZWxmLmN1cnJlbnRTdGF0ZV07XG4gIHN0YXRlLmZuLmNhbGwoYmluZE9iamVjdCB8fCBzZWxmLCBpbnB1dEVycm9yLCBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoc3RhdGUuZmFpbCkgc2VsZi5jdXJyZW50U3RhdGUgPSBzdGF0ZS5mYWlsO1xuICAgICAgZWxzZSByZXR1cm4gZG9uZSA/IGRvbmUuY2FsbChiaW5kT2JqZWN0LCBlcnIpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmFjY2VwdCkgc2VsZi5jdXJyZW50U3RhdGUgPSBzdGF0ZS5hY2NlcHQ7XG4gICAgICBlbHNlIHJldHVybiBkb25lID8gZG9uZS5jYWxsKGJpbmRPYmplY3QpIDogbnVsbDtcbiAgICB9XG4gICAgaWYgKHNlbGYuY3VycmVudFN0YXRlID09PSBmaW5hbFN0YXRlKSB7XG4gICAgICByZXR1cm4gZG9uZSA/IGRvbmUuY2FsbChiaW5kT2JqZWN0LCBlcnIpIDogbnVsbDtcbiAgICB9XG5cbiAgICBzZWxmLnJ1blRvKGZpbmFsU3RhdGUsIGRvbmUsIGJpbmRPYmplY3QsIGVycik7XG4gIH0pO1xufTtcblxuQWNjZXB0b3JTdGF0ZU1hY2hpbmUucHJvdG90eXBlLmFkZFN0YXRlID0gZnVuY3Rpb24gYWRkU3RhdGUobmFtZSwgYWNjZXB0U3RhdGUsIGZhaWxTdGF0ZSwgZm4pIHtcbiAgaWYgKHR5cGVvZiBhY2NlcHRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gYWNjZXB0U3RhdGU7IGFjY2VwdFN0YXRlID0gbnVsbDsgZmFpbFN0YXRlID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmFpbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBmYWlsU3RhdGU7IGZhaWxTdGF0ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMuY3VycmVudFN0YXRlKSB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5hbWU7XG4gIHRoaXMuc3RhdGVzW25hbWVdID0geyBhY2NlcHQ6IGFjY2VwdFN0YXRlLCBmYWlsOiBmYWlsU3RhdGUsIGZuOiBmbiB9O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQWNjZXB0b3JTdGF0ZU1hY2hpbmU7XG4iLCIvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOjAgKi9cbnZhciBBV1M7XG5cbi8qKlxuICogQSBzZXQgb2YgdXRpbGl0eSBtZXRob2RzIGZvciB1c2Ugd2l0aCB0aGUgQVdTIFNESy5cbiAqXG4gKiBAIWF0dHJpYnV0ZSBhYm9ydFxuICogICBSZXR1cm4gdGhpcyB2YWx1ZSBmcm9tIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uIHtlYWNofSBvciB7YXJyYXlFYWNofVxuICogICB0byBicmVhayBvdXQgb2YgdGhlIGl0ZXJhdGlvbi5cbiAqICAgQGV4YW1wbGUgQnJlYWtpbmcgb3V0IG9mIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gKiAgICAgQVdTLnV0aWwuZWFjaCh7YTogMSwgYjogMiwgYzogM30sIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAqICAgICAgIGlmIChrZXkgPT0gJ2InKSByZXR1cm4gQVdTLnV0aWwuYWJvcnQ7XG4gKiAgICAgfSk7XG4gKiAgIEBzZWUgZWFjaFxuICogICBAc2VlIGFycmF5RWFjaFxuICogQGFwaSBwcml2YXRlXG4gKi9cbnZhciB1dGlsID0ge1xuICBlbnZpcm9ubWVudDogJ25vZGVqcycsXG4gIGVuZ2luZTogZnVuY3Rpb24gZW5naW5lKCkge1xuICAgIGlmICh1dGlsLmlzQnJvd3NlcigpICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZ2luZSA9IHByb2Nlc3MucGxhdGZvcm0gKyAnLycgKyBwcm9jZXNzLnZlcnNpb247XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuQVdTX0VYRUNVVElPTl9FTlYpIHtcbiAgICAgICAgZW5naW5lICs9ICcgZXhlYy1lbnYvJyArIHByb2Nlc3MuZW52LkFXU19FWEVDVVRJT05fRU5WO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZ2luZTtcbiAgICB9XG4gIH0sXG5cbiAgdXNlckFnZW50OiBmdW5jdGlvbiB1c2VyQWdlbnQoKSB7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmVudmlyb25tZW50O1xuICAgIHZhciBhZ2VudCA9ICdhd3Mtc2RrLScgKyBuYW1lICsgJy8nICsgcmVxdWlyZSgnLi9jb3JlJykuVkVSU0lPTjtcbiAgICBpZiAobmFtZSA9PT0gJ25vZGVqcycpIGFnZW50ICs9ICcgJyArIHV0aWwuZW5naW5lKCk7XG4gICAgcmV0dXJuIGFnZW50O1xuICB9LFxuXG4gIHVyaUVzY2FwZTogZnVuY3Rpb24gdXJpRXNjYXBlKHN0cmluZykge1xuICAgIHZhciBvdXRwdXQgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nKTtcbiAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvW15BLVphLXowLTlfLn5cXC0lXSsvZywgZXNjYXBlKTtcblxuICAgIC8vIEFXUyBwZXJjZW50LWVuY29kZXMgc29tZSBleHRyYSBub24tc3RhbmRhcmQgY2hhcmFjdGVycyBpbiBhIFVSSVxuICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC9bKl0vZywgZnVuY3Rpb24oY2gpIHtcbiAgICAgIHJldHVybiAnJScgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSxcblxuICB1cmlFc2NhcGVQYXRoOiBmdW5jdGlvbiB1cmlFc2NhcGVQYXRoKHN0cmluZykge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHV0aWwuYXJyYXlFYWNoKHN0cmluZy5zcGxpdCgnLycpLCBmdW5jdGlvbiAocGFydCkge1xuICAgICAgcGFydHMucHVzaCh1dGlsLnVyaUVzY2FwZShwYXJ0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcbiAgfSxcblxuICB1cmxQYXJzZTogZnVuY3Rpb24gdXJsUGFyc2UodXJsKSB7XG4gICAgcmV0dXJuIHV0aWwudXJsLnBhcnNlKHVybCk7XG4gIH0sXG5cbiAgdXJsRm9ybWF0OiBmdW5jdGlvbiB1cmxGb3JtYXQodXJsKSB7XG4gICAgcmV0dXJuIHV0aWwudXJsLmZvcm1hdCh1cmwpO1xuICB9LFxuXG4gIHF1ZXJ5U3RyaW5nUGFyc2U6IGZ1bmN0aW9uIHF1ZXJ5U3RyaW5nUGFyc2UocXMpIHtcbiAgICByZXR1cm4gdXRpbC5xdWVyeXN0cmluZy5wYXJzZShxcyk7XG4gIH0sXG5cbiAgcXVlcnlQYXJhbXNUb1N0cmluZzogZnVuY3Rpb24gcXVlcnlQYXJhbXNUb1N0cmluZyhwYXJhbXMpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgZXNjYXBlID0gdXRpbC51cmlFc2NhcGU7XG4gICAgdmFyIHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnNvcnQoKTtcblxuICAgIHV0aWwuYXJyYXlFYWNoKHNvcnRlZEtleXMsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICAgIHZhciBlbmFtZSA9IGVzY2FwZShuYW1lKTtcbiAgICAgIHZhciByZXN1bHQgPSBlbmFtZSArICc9JztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YXIgdmFscyA9IFtdO1xuICAgICAgICB1dGlsLmFycmF5RWFjaCh2YWx1ZSwgZnVuY3Rpb24oaXRlbSkgeyB2YWxzLnB1c2goZXNjYXBlKGl0ZW0pKTsgfSk7XG4gICAgICAgIHJlc3VsdCA9IGVuYW1lICsgJz0nICsgdmFscy5zb3J0KCkuam9pbignJicgKyBlbmFtZSArICc9Jyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gZW5hbWUgKyAnPScgKyBlc2NhcGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaChyZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGl0ZW1zLmpvaW4oJyYnKTtcbiAgfSxcblxuICByZWFkRmlsZVN5bmM6IGZ1bmN0aW9uIHJlYWRGaWxlU3luYyhwYXRoKSB7XG4gICAgaWYgKHV0aWwuaXNCcm93c2VyKCkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhwYXRoLCAndXRmLTgnKTtcbiAgfSxcblxuICBiYXNlNjQ6IHtcbiAgICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZTY0KHN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKCdDYW5ub3QgYmFzZTY0IGVuY29kZSBudW1iZXIgJyArIHN0cmluZykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RyaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGJ1ZiA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyKHN0cmluZyk7XG4gICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9LFxuXG4gICAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGU2NChzdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignQ2Fubm90IGJhc2U2NCBkZWNvZGUgbnVtYmVyICcgKyBzdHJpbmcpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJpbmcgPT09IG51bGwgfHwgdHlwZW9mIHN0cmluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGlsLmJ1ZmZlci50b0J1ZmZlcihzdHJpbmcsICdiYXNlNjQnKTtcbiAgICB9XG5cbiAgfSxcblxuICBidWZmZXI6IHtcbiAgICAvKipcbiAgICAgKiBCdWZmZXIgY29uc3RydWN0b3IgZm9yIE5vZGUgYnVmZmVyIGFuZCBidWZmZXIgcG9sbHlmaWxsXG4gICAgICovXG4gICAgdG9CdWZmZXI6IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiB1dGlsLkJ1ZmZlci5mcm9tID09PSAnZnVuY3Rpb24nICYmIHV0aWwuQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSkgP1xuICAgICAgICB1dGlsLkJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKSA6IG5ldyB1dGlsLkJ1ZmZlcihkYXRhLCBlbmNvZGluZyk7XG4gICAgfSxcblxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpemUgcGFzc2VkIHRvIGFsbG9jIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHV0aWwuQnVmZmVyLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5hbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWwuQnVmZmVyKHNpemUpO1xuICAgICAgICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBidWYuZmlsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJ1Zi5maWxsKGZpbGwsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9TdHJlYW06IGZ1bmN0aW9uIHRvU3RyZWFtKGJ1ZmZlcikge1xuICAgICAgaWYgKCF1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSBidWZmZXIgPSAgdXRpbC5idWZmZXIudG9CdWZmZXIoYnVmZmVyKTtcblxuICAgICAgdmFyIHJlYWRhYmxlID0gbmV3ICh1dGlsLnN0cmVhbS5SZWFkYWJsZSkoKTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgcmVhZGFibGUuX3JlYWQgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIGlmIChwb3MgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIHJlYWRhYmxlLnB1c2gobnVsbCk7XG5cbiAgICAgICAgdmFyIGVuZCA9IHBvcyArIHNpemU7XG4gICAgICAgIGlmIChlbmQgPiBidWZmZXIubGVuZ3RoKSBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICByZWFkYWJsZS5wdXNoKGJ1ZmZlci5zbGljZShwb3MsIGVuZCkpO1xuICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVhZGFibGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbmNhdGVuYXRlcyBhIGxpc3Qgb2YgQnVmZmVyIG9iamVjdHMuXG4gICAgICovXG4gICAgY29uY2F0OiBmdW5jdGlvbihidWZmZXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gMCxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIGJ1ZmZlciA9IG51bGwsIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aCArPSBidWZmZXJzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgYnVmZmVyID0gdXRpbC5idWZmZXIuYWxsb2MobGVuZ3RoKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVmZmVyc1tpXS5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ1ZmZlcnNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgfSxcblxuICBzdHJpbmc6IHtcbiAgICBieXRlTGVuZ3RoOiBmdW5jdGlvbiBieXRlTGVuZ3RoKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHN0cmluZyA9IHV0aWwuYnVmZmVyLnRvQnVmZmVyKHN0cmluZyk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmluZy5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcuc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0cmluZy5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnZnMnKS5sc3RhdFN5bmMoc3RyaW5nLnBhdGgpLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignQ2Fubm90IGRldGVybWluZSBsZW5ndGggb2YgJyArIHN0cmluZyksXG4gICAgICAgICAgeyBvYmplY3Q6IHN0cmluZyB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBwZXJGaXJzdDogZnVuY3Rpb24gdXBwZXJGaXJzdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmdbMF0udG9VcHBlckNhc2UoKSArIHN0cmluZy5zdWJzdHIoMSk7XG4gICAgfSxcblxuICAgIGxvd2VyRmlyc3Q6IGZ1bmN0aW9uIGxvd2VyRmlyc3Qoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nWzBdLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc3Vic3RyKDEpO1xuICAgIH1cbiAgfSxcblxuICBpbmk6IHtcbiAgICBwYXJzZTogZnVuY3Rpb24gc3RyaW5nKGluaSkge1xuICAgICAgdmFyIGN1cnJlbnRTZWN0aW9uLCBtYXAgPSB7fTtcbiAgICAgIHV0aWwuYXJyYXlFYWNoKGluaS5zcGxpdCgvXFxyP1xcbi8pLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnNwbGl0KC8oXnxcXHMpWzsjXS8pWzBdLnRyaW0oKTsgLy8gcmVtb3ZlIGNvbW1lbnRzIGFuZCB0cmltXG4gICAgICAgIHZhciBpc1NlY3Rpb24gPSBsaW5lWzBdID09PSAnWycgJiYgbGluZVtsaW5lLmxlbmd0aCAtIDFdID09PSAnXSc7XG4gICAgICAgIGlmIChpc1NlY3Rpb24pIHtcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbiA9IGxpbmUuc3Vic3RyaW5nKDEsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uID09PSAnX19wcm90b19fJyB8fCBjdXJyZW50U2VjdGlvbi5zcGxpdCgvXFxzLylbMV0gPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICB0aHJvdyB1dGlsLmVycm9yKFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHByb2ZpbGUgbmFtZSBcXCcnICsgY3VycmVudFNlY3Rpb24gKyAnXFwnIGZyb20gc2hhcmVkIGluaSBmaWxlLicpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50U2VjdGlvbikge1xuICAgICAgICAgIHZhciBpbmRleE9mRXF1YWxzU2lnbiA9IGxpbmUuaW5kZXhPZignPScpO1xuICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgdmFyIGVuZCA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgaXNBc3NpZ25tZW50ID1cbiAgICAgICAgICAgIGluZGV4T2ZFcXVhbHNTaWduICE9PSAtMSAmJiBpbmRleE9mRXF1YWxzU2lnbiAhPT0gc3RhcnQgJiYgaW5kZXhPZkVxdWFsc1NpZ24gIT09IGVuZDtcblxuICAgICAgICAgIGlmIChpc0Fzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGluZS5zdWJzdHJpbmcoMCwgaW5kZXhPZkVxdWFsc1NpZ24pLnRyaW0oKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGluZGV4T2ZFcXVhbHNTaWduICsgMSkudHJpbSgpO1xuXG4gICAgICAgICAgICBtYXBbY3VycmVudFNlY3Rpb25dID0gbWFwW2N1cnJlbnRTZWN0aW9uXSB8fCB7fTtcbiAgICAgICAgICAgIG1hcFtjdXJyZW50U2VjdGlvbl1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgfSxcblxuICBmbjoge1xuICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybiBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gYXMgXCJhc3luY1wiIGZ1bmN0aW9uIGJ5IG1ha2luZyBpdCBjYWxsXG4gICAgICogYSBjYWxsYmFjay4gVGhlIHVuZGVybHlpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYWxsIGJ1dCB0aGUgbGFzdCBhcmd1bWVudCxcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIHRoZSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIGlzIHBhc3NlZCBwYXNzZWQgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIG9mIG51bGwgb24gc3VjY2VzcyB0byBtaW1pY2sgc3RhbmRhcmQgbm9kZSBjYWxsYmFja3MuXG4gICAgICovXG4gICAgbWFrZUFzeW5jOiBmdW5jdGlvbiBtYWtlQXN5bmMoZm4sIGV4cGVjdGVkQXJncykge1xuICAgICAgaWYgKGV4cGVjdGVkQXJncyAmJiBleHBlY3RlZEFyZ3MgPD0gZm4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEYXRlIGFuZCB0aW1lIHV0aWxpdHkgZnVuY3Rpb25zLlxuICAgKi9cbiAgZGF0ZToge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbRGF0ZV0gdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBkYXRlIG9iamVjdC4gU2luY2UgYWxsXG4gICAgICogICBBV1Mgc2VydmljZXMgcmVseSBvbiB0aGlzIGRhdGUgb2JqZWN0LCB5b3UgY2FuIG92ZXJyaWRlXG4gICAgICogICB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBzcGVjaWFsIHRpbWUgdmFsdWUgdG8gQVdTIHNlcnZpY2VcbiAgICAgKiAgIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGdldERhdGU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICBpZiAoIUFXUykgQVdTID0gcmVxdWlyZSgnLi9jb3JlJyk7XG4gICAgICBpZiAoQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCkgeyAvLyB1c2Ugb2Zmc2V0IHdoZW4gbm9uLXplcm9cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgQVdTLmNvbmZpZy5zeXN0ZW1DbG9ja09mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbU3RyaW5nXSB0aGUgZGF0ZSBpbiBJU08tODYwMSBmb3JtYXRcbiAgICAgKi9cbiAgICBpc284NjAxOiBmdW5jdGlvbiBpc284NjAxKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHsgZGF0ZSA9IHV0aWwuZGF0ZS5nZXREYXRlKCk7IH1cbiAgICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvXFwuXFxkezN9WiQvLCAnWicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFtTdHJpbmddIHRoZSBkYXRlIGluIFJGQyA4MjIgZm9ybWF0XG4gICAgICovXG4gICAgcmZjODIyOiBmdW5jdGlvbiByZmM4MjIoZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkgeyBkYXRlID0gdXRpbC5kYXRlLmdldERhdGUoKTsgfVxuICAgICAgcmV0dXJuIGRhdGUudG9VVENTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiBbSW50ZWdlcl0gdGhlIFVOSVggdGltZXN0YW1wIHZhbHVlIGZvciB0aGUgY3VycmVudCB0aW1lXG4gICAgICovXG4gICAgdW5peFRpbWVzdGFtcDogZnVuY3Rpb24gdW5peFRpbWVzdGFtcChkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7IGRhdGUgPSB1dGlsLmRhdGUuZ2V0RGF0ZSgpOyB9XG4gICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gW1N0cmluZyxudW1iZXIsRGF0ZV0gZGF0ZVxuICAgICAqIEByZXR1cm4gW0RhdGVdXG4gICAgICovXG4gICAgZnJvbTogZnVuY3Rpb24gZm9ybWF0KGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUgKiAxMDAwKTsgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBEYXRlIG9yIGRhdGUtbGlrZSB2YWx1ZSwgdGhpcyBmdW5jdGlvbiBmb3JtYXRzIHRoZVxuICAgICAqIGRhdGUgaW50byBhIHN0cmluZyBvZiB0aGUgcmVxdWVzdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSBbU3RyaW5nLG51bWJlcixEYXRlXSBkYXRlXG4gICAgICogQHBhcmFtIFtTdHJpbmddIGZvcm1hdHRlciBWYWxpZCBmb3JtYXRzIGFyZTpcbiAgICAgIyAgICogJ2lzbzg2MDEnXG4gICAgICMgICAqICdyZmM4MjInXG4gICAgICMgICAqICd1bml4VGltZXN0YW1wJ1xuICAgICAqIEByZXR1cm4gW1N0cmluZ11cbiAgICAgKi9cbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChkYXRlLCBmb3JtYXR0ZXIpIHtcbiAgICAgIGlmICghZm9ybWF0dGVyKSBmb3JtYXR0ZXIgPSAnaXNvODYwMSc7XG4gICAgICByZXR1cm4gdXRpbC5kYXRlW2Zvcm1hdHRlcl0odXRpbC5kYXRlLmZyb20oZGF0ZSkpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpbWVzdGFtcDogZnVuY3Rpb24gcGFyc2VUaW1lc3RhbXAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7IC8vIHVuaXggdGltZXN0YW1wIChudW1iZXIpXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSAqIDEwMDApO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcZCskLykpIHsgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlICogMTAwMCk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlLm1hdGNoKC9eXFxkezR9LykpIHsgLy8gaXNvODYwMVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5tYXRjaCgvXlxcd3szfSwvKSkgeyAvLyByZmM4MjJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKCd1bmhhbmRsZWQgdGltZXN0YW1wIGZvcm1hdDogJyArIHZhbHVlKSxcbiAgICAgICAgICB7Y29kZTogJ1RpbWVzdGFtcFBhcnNlckVycm9yJ30pO1xuICAgICAgfVxuICAgIH1cblxuICB9LFxuXG4gIGNyeXB0bzoge1xuICAgIGNyYzMyVGFibGU6IFtcbiAgICAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSwgMHgwNzZEQzQxOSxcbiAgICAgMHg3MDZBRjQ4RiwgMHhFOTYzQTUzNSwgMHg5RTY0OTVBMywgMHgwRURCODgzMiwgMHg3OURDQjhBNCxcbiAgICAgMHhFMEQ1RTkxRSwgMHg5N0QyRDk4OCwgMHgwOUI2NEMyQiwgMHg3RUIxN0NCRCwgMHhFN0I4MkQwNyxcbiAgICAgMHg5MEJGMUQ5MSwgMHgxREI3MTA2NCwgMHg2QUIwMjBGMiwgMHhGM0I5NzE0OCwgMHg4NEJFNDFERSxcbiAgICAgMHgxQURBRDQ3RCwgMHg2RERERTRFQiwgMHhGNEQ0QjU1MSwgMHg4M0QzODVDNywgMHgxMzZDOTg1NixcbiAgICAgMHg2NDZCQThDMCwgMHhGRDYyRjk3QSwgMHg4QTY1QzlFQywgMHgxNDAxNUM0RiwgMHg2MzA2NkNEOSxcbiAgICAgMHhGQTBGM0Q2MywgMHg4RDA4MERGNSwgMHgzQjZFMjBDOCwgMHg0QzY5MTA1RSwgMHhENTYwNDFFNCxcbiAgICAgMHhBMjY3NzE3MiwgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QixcbiAgICAgMHgzNUI1QThGQSwgMHg0MkIyOTg2QywgMHhEQkJCQzlENiwgMHhBQ0JDRjk0MCwgMHgzMkQ4NkNFMyxcbiAgICAgMHg0NURGNUM3NSwgMHhEQ0Q2MERDRiwgMHhBQkQxM0Q1OSwgMHgyNkQ5MzBBQywgMHg1MURFMDAzQSxcbiAgICAgMHhDOEQ3NTE4MCwgMHhCRkQwNjExNiwgMHgyMUI0RjRCNSwgMHg1NkIzQzQyMywgMHhDRkJBOTU5OSxcbiAgICAgMHhCOEJEQTUwRiwgMHgyODAyQjg5RSwgMHg1RjA1ODgwOCwgMHhDNjBDRDlCMiwgMHhCMTBCRTkyNCxcbiAgICAgMHgyRjZGN0M4NywgMHg1ODY4NEMxMSwgMHhDMTYxMURBQiwgMHhCNjY2MkQzRCwgMHg3NkRDNDE5MCxcbiAgICAgMHgwMURCNzEwNiwgMHg5OEQyMjBCQywgMHhFRkQ1MTAyQSwgMHg3MUIxODU4OSwgMHgwNkI2QjUxRixcbiAgICAgMHg5RkJGRTRBNSwgMHhFOEI4RDQzMywgMHg3ODA3QzlBMiwgMHgwRjAwRjkzNCwgMHg5NjA5QTg4RSxcbiAgICAgMHhFMTBFOTgxOCwgMHg3RjZBMERCQiwgMHgwODZEM0QyRCwgMHg5MTY0NkM5NywgMHhFNjYzNUMwMSxcbiAgICAgMHg2QjZCNTFGNCwgMHgxQzZDNjE2MiwgMHg4NTY1MzBEOCwgMHhGMjYyMDA0RSwgMHg2QzA2OTVFRCxcbiAgICAgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NywgMHg2NUIwRDlDNiwgMHgxMkI3RTk1MCxcbiAgICAgMHg4QkJFQjhFQSwgMHhGQ0I5ODg3QywgMHg2MkREMURERiwgMHgxNURBMkQ0OSwgMHg4Q0QzN0NGMyxcbiAgICAgMHhGQkQ0NEM2NSwgMHg0REIyNjE1OCwgMHgzQUI1NTFDRSwgMHhBM0JDMDA3NCwgMHhENEJCMzBFMixcbiAgICAgMHg0QURGQTU0MSwgMHgzREQ4OTVENywgMHhBNEQxQzQ2RCwgMHhEM0Q2RjRGQiwgMHg0MzY5RTk2QSxcbiAgICAgMHgzNDZFRDlGQywgMHhBRDY3ODg0NiwgMHhEQTYwQjhEMCwgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSxcbiAgICAgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSwgMHg1MDA1NzEzQywgMHgyNzAyNDFBQSwgMHhCRTBCMTAxMCxcbiAgICAgMHhDOTBDMjA4NiwgMHg1NzY4QjUyNSwgMHgyMDZGODVCMywgMHhCOTY2RDQwOSwgMHhDRTYxRTQ5RixcbiAgICAgMHg1RURFRjkwRSwgMHgyOUQ5Qzk5OCwgMHhCMEQwOTgyMiwgMHhDN0Q3QThCNCwgMHg1OUIzM0QxNyxcbiAgICAgMHgyRUI0MEQ4MSwgMHhCN0JENUMzQiwgMHhDMEJBNkNBRCwgMHhFREI4ODMyMCwgMHg5QUJGQjNCNixcbiAgICAgMHgwM0I2RTIwQywgMHg3NEIxRDI5QSwgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSxcbiAgICAgMHg3M0RDMTY4MywgMHhFMzYzMEIxMiwgMHg5NDY0M0I4NCwgMHgwRDZENkEzRSwgMHg3QTZBNUFBOCxcbiAgICAgMHhFNDBFQ0YwQiwgMHg5MzA5RkY5RCwgMHgwQTAwQUUyNywgMHg3RDA3OUVCMSwgMHhGMDBGOTM0NCxcbiAgICAgMHg4NzA4QTNEMiwgMHgxRTAxRjI2OCwgMHg2OTA2QzJGRSwgMHhGNzYyNTc1RCwgMHg4MDY1NjdDQixcbiAgICAgMHgxOTZDMzY3MSwgMHg2RTZCMDZFNywgMHhGRUQ0MUI3NiwgMHg4OUQzMkJFMCwgMHgxMERBN0E1QSxcbiAgICAgMHg2N0RENEFDQywgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSxcbiAgICAgMHhENkQ2QTNFOCwgMHhBMUQxOTM3RSwgMHgzOEQ4QzJDNCwgMHg0RkRGRjI1MiwgMHhEMUJCNjdGMSxcbiAgICAgMHhBNkJDNTc2NywgMHgzRkI1MDZERCwgMHg0OEIyMzY0QiwgMHhEODBEMkJEQSwgMHhBRjBBMUI0QyxcbiAgICAgMHgzNjAzNEFGNiwgMHg0MTA0N0E2MCwgMHhERjYwRUZDMywgMHhBODY3REY1NSwgMHgzMTZFOEVFRixcbiAgICAgMHg0NjY5QkU3OSwgMHhDQjYxQjM4QywgMHhCQzY2ODMxQSwgMHgyNTZGRDJBMCwgMHg1MjY4RTIzNixcbiAgICAgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRiwgMHhDNUJBM0JCRSxcbiAgICAgMHhCMkJEMEIyOCwgMHgyQkI0NUE5MiwgMHg1Q0IzNkEwNCwgMHhDMkQ3RkZBNywgMHhCNUQwQ0YzMSxcbiAgICAgMHgyQ0Q5OUU4QiwgMHg1QkRFQUUxRCwgMHg5QjY0QzJCMCwgMHhFQzYzRjIyNiwgMHg3NTZBQTM5QyxcbiAgICAgMHgwMjZEOTMwQSwgMHg5QzA5MDZBOSwgMHhFQjBFMzYzRiwgMHg3MjA3Njc4NSwgMHgwNTAwNTcxMyxcbiAgICAgMHg5NUJGNEE4MiwgMHhFMkI4N0ExNCwgMHg3QkIxMkJBRSwgMHgwQ0I2MUIzOCwgMHg5MkQyOEU5QixcbiAgICAgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSwgMHg4NkQzRDJENCwgMHhGMUQ0RTI0MixcbiAgICAgMHg2OEREQjNGOCwgMHgxRkRBODM2RSwgMHg4MUJFMTZDRCwgMHhGNkI5MjY1QiwgMHg2RkIwNzdFMSxcbiAgICAgMHgxOEI3NDc3NywgMHg4ODA4NUFFNiwgMHhGRjBGNkE3MCwgMHg2NjA2M0JDQSwgMHgxMTAxMEI1QyxcbiAgICAgMHg4RjY1OUVGRiwgMHhGODYyQUU2OSwgMHg2MTZCRkZEMywgMHgxNjZDQ0Y0NSwgMHhBMDBBRTI3OCxcbiAgICAgMHhENzBERDJFRSwgMHg0RTA0ODM1NCwgMHgzOTAzQjNDMiwgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNyxcbiAgICAgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQiwgMHhBRUQxNkE0QSwgMHhEOUQ2NUFEQywgMHg0MERGMEI2NixcbiAgICAgMHgzN0Q4M0JGMCwgMHhBOUJDQUU1MywgMHhERUJCOUVDNSwgMHg0N0IyQ0Y3RiwgMHgzMEI1RkZFOSxcbiAgICAgMHhCREJERjIxQywgMHhDQUJBQzI4QSwgMHg1M0IzOTMzMCwgMHgyNEI0QTNBNiwgMHhCQUQwMzYwNSxcbiAgICAgMHhDREQ3MDY5MywgMHg1NERFNTcyOSwgMHgyM0Q5NjdCRiwgMHhCMzY2N0EyRSwgMHhDNDYxNEFCOCxcbiAgICAgMHg1RDY4MUIwMiwgMHgyQTZGMkI5NCwgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQixcbiAgICAgMHgyRDAyRUY4RF0sXG5cbiAgICBjcmMzMjogZnVuY3Rpb24gY3JjMzIoZGF0YSkge1xuICAgICAgdmFyIHRibCA9IHV0aWwuY3J5cHRvLmNyYzMyVGFibGU7XG4gICAgICB2YXIgY3JjID0gMCBeIC0xO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSB1dGlsLmJ1ZmZlci50b0J1ZmZlcihkYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gZGF0YS5yZWFkVUludDgoaSk7XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGJsWyhjcmMgXiBjb2RlKSAmIDB4RkZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChjcmMgXiAtMSkgPj4+IDA7XG4gICAgfSxcblxuICAgIGhtYWM6IGZ1bmN0aW9uIGhtYWMoa2V5LCBzdHJpbmcsIGRpZ2VzdCwgZm4pIHtcbiAgICAgIGlmICghZGlnZXN0KSBkaWdlc3QgPSAnYmluYXJ5JztcbiAgICAgIGlmIChkaWdlc3QgPT09ICdidWZmZXInKSB7IGRpZ2VzdCA9IHVuZGVmaW5lZDsgfVxuICAgICAgaWYgKCFmbikgZm4gPSAnc2hhMjU2JztcbiAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykgc3RyaW5nID0gdXRpbC5idWZmZXIudG9CdWZmZXIoc3RyaW5nKTtcbiAgICAgIHJldHVybiB1dGlsLmNyeXB0by5saWIuY3JlYXRlSG1hYyhmbiwga2V5KS51cGRhdGUoc3RyaW5nKS5kaWdlc3QoZGlnZXN0KTtcbiAgICB9LFxuXG4gICAgbWQ1OiBmdW5jdGlvbiBtZDUoZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmhhc2goJ21kNScsIGRhdGEsIGRpZ2VzdCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBzaGEyNTY6IGZ1bmN0aW9uIHNoYTI1NihkYXRhLCBkaWdlc3QsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdXRpbC5jcnlwdG8uaGFzaCgnc2hhMjU2JywgZGF0YSwgZGlnZXN0LCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIGhhc2g6IGZ1bmN0aW9uKGFsZ29yaXRobSwgZGF0YSwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGhhc2ggPSB1dGlsLmNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgICBpZiAoIWRpZ2VzdCkgeyBkaWdlc3QgPSAnYmluYXJ5JzsgfVxuICAgICAgaWYgKGRpZ2VzdCA9PT0gJ2J1ZmZlcicpIHsgZGlnZXN0ID0gdW5kZWZpbmVkOyB9XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gdXRpbC5idWZmZXIudG9CdWZmZXIoZGF0YSk7XG4gICAgICB2YXIgc2xpY2VGbiA9IHV0aWwuYXJyYXlTbGljZUZuKGRhdGEpO1xuICAgICAgdmFyIGlzQnVmZmVyID0gdXRpbC5CdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG4gICAgICAvL0lkZW50aWZ5aW5nIG9iamVjdHMgd2l0aCBhbiBBcnJheUJ1ZmZlciBhcyBidWZmZXJzXG4gICAgICBpZiAodXRpbC5pc0Jyb3dzZXIoKSAmJiB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgJiYgZGF0YS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgaXNCdWZmZXIgPSB0cnVlO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgdHlwZW9mIGRhdGEub24gPT09ICdmdW5jdGlvbicgJiYgIWlzQnVmZmVyKSB7XG4gICAgICAgIGRhdGEub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykgeyBoYXNoLnVwZGF0ZShjaHVuayk7IH0pO1xuICAgICAgICBkYXRhLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICAgICAgZGF0YS5vbignZW5kJywgZnVuY3Rpb24oKSB7IGNhbGxiYWNrKG51bGwsIGhhc2guZGlnZXN0KGRpZ2VzdCkpOyB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgc2xpY2VGbiAmJiAhaXNCdWZmZXIgJiZcbiAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHRoaXMgbWlnaHQgYmUgYSBGaWxlL0Jsb2JcbiAgICAgICAgdmFyIGluZGV4ID0gMCwgc2l6ZSA9IDEwMjQgKiA1MTI7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZGF0YS4nKSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYnVmID0gbmV3IHV0aWwuQnVmZmVyKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQpKTtcbiAgICAgICAgICBoYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICAgIGluZGV4ICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gZGF0YS5zaXplKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYXNoLmRpZ2VzdChkaWdlc3QpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmFjayA9IGluZGV4ICsgc2l6ZTtcbiAgICAgICAgICBpZiAoYmFjayA+IGRhdGEuc2l6ZSkgYmFjayA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoc2xpY2VGbi5jYWxsKGRhdGEsIGluZGV4LCBiYWNrKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLl9jb250aW51ZVJlYWRpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1dGlsLmlzQnJvd3NlcigpICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhaXNCdWZmZXIpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IHV0aWwuQnVmZmVyKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gaGFzaC51cGRhdGUoZGF0YSkuZGlnZXN0KGRpZ2VzdCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdG9IZXg6IGZ1bmN0aW9uIHRvSGV4KGRhdGEpIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBvdXQucHVzaCgoJzAnICsgZGF0YS5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yLCAyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIYXNoOiBmdW5jdGlvbiBjcmVhdGVIYXNoKGFsZ29yaXRobSkge1xuICAgICAgcmV0dXJuIHV0aWwuY3J5cHRvLmxpYi5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgfVxuXG4gIH0sXG5cbiAgLyoqIEAhaWdub3JlICovXG5cbiAgLyogQWJvcnQgY29uc3RhbnQgKi9cbiAgYWJvcnQ6IHt9LFxuXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqZWN0LCBpdGVyRnVuY3Rpb24pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICB2YXIgcmV0ID0gaXRlckZ1bmN0aW9uLmNhbGwodGhpcywga2V5LCBvYmplY3Rba2V5XSk7XG4gICAgICAgIGlmIChyZXQgPT09IHV0aWwuYWJvcnQpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhcnJheUVhY2g6IGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlckZ1bmN0aW9uKSB7XG4gICAgZm9yICh2YXIgaWR4IGluIGFycmF5KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpZHgpKSB7XG4gICAgICAgIHZhciByZXQgPSBpdGVyRnVuY3Rpb24uY2FsbCh0aGlzLCBhcnJheVtpZHhdLCBwYXJzZUludChpZHgsIDEwKSk7XG4gICAgICAgIGlmIChyZXQgPT09IHV0aWwuYWJvcnQpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmoxLCBvYmoyKSB7XG4gICAgdXRpbC5lYWNoKG9iajIsIGZ1bmN0aW9uIGl0ZXJhdG9yKGtleSwgaXRlbSkge1xuICAgICAgb2JqMVtrZXldID0gaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqMTtcbiAgfSxcblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2Uob2JqMSwgb2JqMikge1xuICAgIHJldHVybiB1dGlsLnVwZGF0ZSh1dGlsLmNvcHkob2JqMSksIG9iajIpO1xuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uIGNvcHkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9iamVjdDtcbiAgICB2YXIgZHVwZSA9IHt9O1xuICAgIC8vIGpzaGludCBmb3JpbjpmYWxzZVxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGR1cGVba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gZHVwZTtcbiAgfSxcblxuICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICBhcnJheVNsaWNlRm46IGZ1bmN0aW9uIGFycmF5U2xpY2VGbihvYmopIHtcbiAgICB2YXIgZm4gPSBvYmouc2xpY2UgfHwgb2JqLndlYmtpdFNsaWNlIHx8IG9iai5tb3pTbGljZTtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nID8gZm4gOiBudWxsO1xuICB9LFxuXG4gIGlzVHlwZTogZnVuY3Rpb24gaXNUeXBlKG9iaiwgdHlwZSkge1xuICAgIC8vIGhhbmRsZSBjcm9zcy1cImZyYW1lXCIgb2JqZWN0c1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgdHlwZSA9IHV0aWwudHlwZU5hbWUodHlwZSk7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbiAgfSxcblxuICB0eXBlTmFtZTogZnVuY3Rpb24gdHlwZU5hbWUodHlwZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwZSwgJ25hbWUnKSkgcmV0dXJuIHR5cGUubmFtZTtcbiAgICB2YXIgc3RyID0gdHlwZS50b1N0cmluZygpO1xuICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaCgvXlxccypmdW5jdGlvbiAoLispXFwoLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBzdHI7XG4gIH0sXG5cbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKGVyciwgb3B0aW9ucykge1xuICAgIHZhciBvcmlnaW5hbEVycm9yID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZSAhPT0gJycpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXNzYWdlKSkge1xuICAgICAgICBvcmlnaW5hbEVycm9yID0gdXRpbC5jb3B5KGVycik7XG4gICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cbiAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnIubWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgdXRpbC51cGRhdGUoZXJyLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UpXG4gICAgICAgIGVyci5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgaWYgKG9wdGlvbnMuY29kZSB8fCBvcHRpb25zLm5hbWUpXG4gICAgICAgIGVyci5jb2RlID0gb3B0aW9ucy5jb2RlIHx8IG9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChvcHRpb25zLnN0YWNrKVxuICAgICAgICBlcnIuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHt3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2V9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdtZXNzYWdlJywge2VudW1lcmFibGU6IHRydWV9KTtcbiAgICB9XG5cbiAgICBlcnIubmFtZSA9IFN0cmluZyhvcHRpb25zICYmIG9wdGlvbnMubmFtZSB8fCBlcnIubmFtZSB8fCBlcnIuY29kZSB8fCAnRXJyb3InKTtcbiAgICBlcnIudGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAob3JpZ2luYWxFcnJvcikgZXJyLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuXG4gICAgcmV0dXJuIGVycjtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbmhlcml0OiBmdW5jdGlvbiBpbmhlcml0KGtsYXNzLCBmZWF0dXJlcykge1xuICAgIHZhciBuZXdPYmplY3QgPSBudWxsO1xuICAgIGlmIChmZWF0dXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmZWF0dXJlcyA9IGtsYXNzO1xuICAgICAga2xhc3MgPSBPYmplY3Q7XG4gICAgICBuZXdPYmplY3QgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN0b3IgPSBmdW5jdGlvbiBDb25zdHJ1Y3RvcldyYXBwZXIoKSB7fTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgbmV3T2JqZWN0ID0gbmV3IGN0b3IoKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBub3Qgc3VwcGxpZWQsIGNyZWF0ZSBwYXNzLXRocm91Z2ggY3RvclxuICAgIGlmIChmZWF0dXJlcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBmZWF0dXJlcy5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoa2xhc3MgIT09IE9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBrbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZlYXR1cmVzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ld09iamVjdDtcbiAgICB1dGlsLnVwZGF0ZShmZWF0dXJlcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGZlYXR1cmVzKTtcbiAgICBmZWF0dXJlcy5jb25zdHJ1Y3Rvci5fX3N1cGVyX18gPSBrbGFzcztcbiAgICByZXR1cm4gZmVhdHVyZXMuY29uc3RydWN0b3I7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgbWl4aW46IGZ1bmN0aW9uIG1peGluKCkge1xuICAgIHZhciBrbGFzcyA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8ganNoaW50IGZvcmluOmZhbHNlXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGFyZ3VtZW50c1tpXS5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2ldLnByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcF0gPSBmbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2xhc3M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaGlkZVByb3BlcnRpZXM6IGZ1bmN0aW9uIGhpZGVQcm9wZXJ0aWVzKG9iaiwgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgdXRpbC5hcnJheUVhY2gocHJvcHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBwcm9wZXJ0eTogZnVuY3Rpb24gcHJvcGVydHkob2JqLCBuYW1lLCB2YWx1ZSwgZW51bWVyYWJsZSwgaXNWYWx1ZSkge1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkID8gZW51bWVyYWJsZSA6IHRydWVcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWlzVmFsdWUpIHtcbiAgICAgIG9wdHMuZ2V0ID0gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0cy52YWx1ZSA9IHZhbHVlOyBvcHRzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCBvcHRzKTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBtZW1vaXplZFByb3BlcnR5OiBmdW5jdGlvbiBtZW1vaXplZFByb3BlcnR5KG9iaiwgbmFtZSwgZ2V0LCBlbnVtZXJhYmxlKSB7XG4gICAgdmFyIGNhY2hlZFZhbHVlID0gbnVsbDtcblxuICAgIC8vIGJ1aWxkIGVudW1lcmFibGUgYXR0cmlidXRlIGZvciBlYWNoIHZhbHVlIHdpdGggbGF6eSBhY2Nlc3Nvci5cbiAgICB1dGlsLnByb3BlcnR5KG9iaiwgbmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY2FjaGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVkVmFsdWUgPSBnZXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICB9LCBlbnVtZXJhYmxlKTtcbiAgfSxcblxuICAvKipcbiAgICogVE9ETyBSZW1vdmUgaW4gbWFqb3IgdmVyc2lvbiByZXZpc2lvblxuICAgKiBUaGlzIGJhY2tmaWxsIHBvcHVsYXRlcyByZXNwb25zZSBkYXRhIHdpdGhvdXQgdGhlXG4gICAqIHRvcC1sZXZlbCBwYXlsb2FkIG5hbWUuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaG9pc3RQYXlsb2FkTWVtYmVyOiBmdW5jdGlvbiBob2lzdFBheWxvYWRNZW1iZXIocmVzcCkge1xuICAgIHZhciByZXEgPSByZXNwLnJlcXVlc3Q7XG4gICAgdmFyIG9wZXJhdGlvbk5hbWUgPSByZXEub3BlcmF0aW9uO1xuICAgIHZhciBvcGVyYXRpb24gPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25OYW1lXTtcbiAgICB2YXIgb3V0cHV0ID0gb3BlcmF0aW9uLm91dHB1dDtcbiAgICBpZiAob3V0cHV0LnBheWxvYWQgJiYgIW9wZXJhdGlvbi5oYXNFdmVudE91dHB1dCkge1xuICAgICAgdmFyIHBheWxvYWRNZW1iZXIgPSBvdXRwdXQubWVtYmVyc1tvdXRwdXQucGF5bG9hZF07XG4gICAgICB2YXIgcmVzcG9uc2VQYXlsb2FkID0gcmVzcC5kYXRhW291dHB1dC5wYXlsb2FkXTtcbiAgICAgIGlmIChwYXlsb2FkTWVtYmVyLnR5cGUgPT09ICdzdHJ1Y3R1cmUnKSB7XG4gICAgICAgIHV0aWwuZWFjaChyZXNwb25zZVBheWxvYWQsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB1dGlsLnByb3BlcnR5KHJlc3AuZGF0YSwga2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGUgU0hBLTI1NiBjaGVja3N1bXMgb2Ygc3RyZWFtc1xuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbXB1dGVTaGEyNTY6IGZ1bmN0aW9uIGNvbXB1dGVTaGEyNTYoYm9keSwgZG9uZSkge1xuICAgIGlmICh1dGlsLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgU3RyZWFtID0gdXRpbC5zdHJlYW0uU3RyZWFtO1xuICAgICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICAgIGlmICh0eXBlb2YgU3RyZWFtID09PSAnZnVuY3Rpb24nICYmIGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5LnBhdGggPT09ICdzdHJpbmcnKSB7IC8vIGFzc3VtZSBmaWxlIG9iamVjdFxuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5zdGFydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnN0YXJ0ID0gYm9keS5zdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBib2R5LmVuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmVuZCA9IGJvZHkuZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib2R5ID0gZnMuY3JlYXRlUmVhZFN0cmVhbShib2R5LnBhdGgsIHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVE9ETyBzdXBwb3J0IG90aGVyIHN0cmVhbSB0eXBlc1xuICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignTm9uLWZpbGUgc3RyZWFtIG9iamVjdHMgYXJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbm90IHN1cHBvcnRlZCB3aXRoIFNpZ1Y0JykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXRpbC5jcnlwdG8uc2hhMjU2KGJvZHksICdoZXgnLCBmdW5jdGlvbihlcnIsIHNoYSkge1xuICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgZWxzZSBkb25lKG51bGwsIHNoYSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaXNDbG9ja1NrZXdlZDogZnVuY3Rpb24gaXNDbG9ja1NrZXdlZChzZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKHNlcnZlclRpbWUpIHtcbiAgICAgIHV0aWwucHJvcGVydHkoQVdTLmNvbmZpZywgJ2lzQ2xvY2tTa2V3ZWQnLFxuICAgICAgICBNYXRoLmFicyhuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHNlcnZlclRpbWUpID49IDMwMDAwMCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIEFXUy5jb25maWcuaXNDbG9ja1NrZXdlZDtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHlDbG9ja09mZnNldDogZnVuY3Rpb24gYXBwbHlDbG9ja09mZnNldChzZXJ2ZXJUaW1lKSB7XG4gICAgaWYgKHNlcnZlclRpbWUpXG4gICAgICBBV1MuY29uZmlnLnN5c3RlbUNsb2NrT2Zmc2V0ID0gc2VydmVyVGltZSAtIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGV4dHJhY3RSZXF1ZXN0SWQ6IGZ1bmN0aW9uIGV4dHJhY3RSZXF1ZXN0SWQocmVzcCkge1xuICAgIHZhciByZXF1ZXN0SWQgPSByZXNwLmh0dHBSZXNwb25zZS5oZWFkZXJzWyd4LWFtei1yZXF1ZXN0LWlkJ10gfHxcbiAgICAgICAgICAgICAgICAgICAgIHJlc3AuaHR0cFJlc3BvbnNlLmhlYWRlcnNbJ3gtYW16bi1yZXF1ZXN0aWQnXTtcblxuICAgIGlmICghcmVxdWVzdElkICYmIHJlc3AuZGF0YSAmJiByZXNwLmRhdGEuUmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgcmVxdWVzdElkID0gcmVzcC5kYXRhLlJlc3BvbnNlTWV0YWRhdGEuUmVxdWVzdElkO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0SWQpIHtcbiAgICAgIHJlc3AucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgIH1cblxuICAgIGlmIChyZXNwLmVycm9yKSB7XG4gICAgICByZXNwLmVycm9yLnJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYWRkUHJvbWlzZXM6IGZ1bmN0aW9uIGFkZFByb21pc2VzKGNvbnN0cnVjdG9ycywgUHJvbWlzZURlcGVuZGVuY3kpIHtcbiAgICB2YXIgZGVsZXRlUHJvbWlzZXMgPSBmYWxzZTtcbiAgICBpZiAoUHJvbWlzZURlcGVuZGVuY3kgPT09IHVuZGVmaW5lZCAmJiBBV1MgJiYgQVdTLmNvbmZpZykge1xuICAgICAgUHJvbWlzZURlcGVuZGVuY3kgPSBBV1MuY29uZmlnLmdldFByb21pc2VzRGVwZW5kZW5jeSgpO1xuICAgIH1cbiAgICBpZiAoUHJvbWlzZURlcGVuZGVuY3kgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIFByb21pc2VEZXBlbmRlbmN5ID0gUHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlRGVwZW5kZW5jeSAhPT0gJ2Z1bmN0aW9uJykgZGVsZXRlUHJvbWlzZXMgPSB0cnVlO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25zdHJ1Y3RvcnMpKSBjb25zdHJ1Y3RvcnMgPSBbY29uc3RydWN0b3JzXTtcblxuICAgIGZvciAodmFyIGluZCA9IDA7IGluZCA8IGNvbnN0cnVjdG9ycy5sZW5ndGg7IGluZCsrKSB7XG4gICAgICB2YXIgY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcnNbaW5kXTtcbiAgICAgIGlmIChkZWxldGVQcm9taXNlcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3IuZGVsZXRlUHJvbWlzZXNGcm9tQ2xhc3MpIHtcbiAgICAgICAgICBjb25zdHJ1Y3Rvci5kZWxldGVQcm9taXNlc0Zyb21DbGFzcygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yLmFkZFByb21pc2VzVG9DbGFzcykge1xuICAgICAgICBjb25zdHJ1Y3Rvci5hZGRQcm9taXNlc1RvQ2xhc3MoUHJvbWlzZURlcGVuZGVuY3kpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gYSBwcm9taXNlIHdob3NlIGZhdGUgaXMgZGVjaWRlZCBieSB0aGVcbiAgICogY2FsbGJhY2sgYmVoYXZpb3Igb2YgdGhlIGdpdmVuIG1ldGhvZCB3aXRoIGBtZXRob2ROYW1lYC4gVGhlIG1ldGhvZCB0byBiZVxuICAgKiBwcm9taXNpZmllZCBzaG91bGQgY29uZm9ybSB0byBub2RlLmpzIGNvbnZlbnRpb24gb2YgYWNjZXB0aW5nIGEgY2FsbGJhY2sgYXNcbiAgICogbGFzdCBhcmd1bWVudCBhbmQgY2FsbGluZyB0aGF0IGNhbGxiYWNrIHdpdGggZXJyb3IgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqIGFuZCBzdWNjZXNzIHZhbHVlIG9uIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAqL1xuICBwcm9taXNpZnlNZXRob2Q6IGZ1bmN0aW9uIHByb21pc2lmeU1ldGhvZChtZXRob2ROYW1lLCBQcm9taXNlRGVwZW5kZW5jeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwcm9taXNlKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlRGVwZW5kZW5jeShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGZbbWV0aG9kTmFtZV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGlzRHVhbHN0YWNrQXZhaWxhYmxlOiBmdW5jdGlvbiBpc0R1YWxzdGFja0F2YWlsYWJsZShzZXJ2aWNlKSB7XG4gICAgaWYgKCFzZXJ2aWNlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIG1ldGFkYXRhID0gcmVxdWlyZSgnLi4vYXBpcy9tZXRhZGF0YS5qc29uJyk7XG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlICE9PSAnc3RyaW5nJykgc2VydmljZSA9IHNlcnZpY2Uuc2VydmljZUlkZW50aWZpZXI7XG4gICAgaWYgKHR5cGVvZiBzZXJ2aWNlICE9PSAnc3RyaW5nJyB8fCAhbWV0YWRhdGEuaGFzT3duUHJvcGVydHkoc2VydmljZSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gISFtZXRhZGF0YVtzZXJ2aWNlXS5kdWFsc3RhY2tBdmFpbGFibGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlUmV0cnlEZWxheTogZnVuY3Rpb24gY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCByZXRyeURlbGF5T3B0aW9ucywgZXJyKSB7XG4gICAgaWYgKCFyZXRyeURlbGF5T3B0aW9ucykgcmV0cnlEZWxheU9wdGlvbnMgPSB7fTtcbiAgICB2YXIgY3VzdG9tQmFja29mZiA9IHJldHJ5RGVsYXlPcHRpb25zLmN1c3RvbUJhY2tvZmYgfHwgbnVsbDtcbiAgICBpZiAodHlwZW9mIGN1c3RvbUJhY2tvZmYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjdXN0b21CYWNrb2ZmKHJldHJ5Q291bnQsIGVycik7XG4gICAgfVxuICAgIHZhciBiYXNlID0gdHlwZW9mIHJldHJ5RGVsYXlPcHRpb25zLmJhc2UgPT09ICdudW1iZXInID8gcmV0cnlEZWxheU9wdGlvbnMuYmFzZSA6IDEwMDtcbiAgICB2YXIgZGVsYXkgPSBNYXRoLnJhbmRvbSgpICogKE1hdGgucG93KDIsIHJldHJ5Q291bnQpICogYmFzZSk7XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVJlcXVlc3RXaXRoUmV0cmllczogZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFdpdGhSZXRyaWVzKGh0dHBSZXF1ZXN0LCBvcHRpb25zLCBjYikge1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBodHRwID0gQVdTLkh0dHBDbGllbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICB2YXIgaHR0cE9wdGlvbnMgPSBvcHRpb25zLmh0dHBPcHRpb25zIHx8IHt9O1xuICAgIHZhciByZXRyeUNvdW50ID0gMDtcblxuICAgIHZhciBlcnJDYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgdmFyIG1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgfHwgMDtcbiAgICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09ICdUaW1lb3V0RXJyb3InKSBlcnIucmV0cnlhYmxlID0gdHJ1ZTtcblxuICAgICAgLy8gQ2FsbCBgY2FsY3VsYXRlUmV0cnlEZWxheSgpYCBvbmx5IHdoZW4gcmVsZXZhbnQsIHNlZSAjMzQwMVxuICAgICAgaWYgKGVyciAmJiBlcnIucmV0cnlhYmxlICYmIHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIHZhciBkZWxheSA9IHV0aWwuY2FsY3VsYXRlUmV0cnlEZWxheShyZXRyeUNvdW50LCBvcHRpb25zLnJldHJ5RGVsYXlPcHRpb25zLCBlcnIpO1xuICAgICAgICBpZiAoZGVsYXkgPj0gMCkge1xuICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICBzZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCBkZWxheSArIChlcnIucmV0cnlBZnRlciB8fCAwKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYihlcnIpO1xuICAgIH07XG5cbiAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0gJyc7XG4gICAgICBodHRwLmhhbmRsZVJlcXVlc3QoaHR0cFJlcXVlc3QsIGh0dHBPcHRpb25zLCBmdW5jdGlvbihodHRwUmVzcG9uc2UpIHtcbiAgICAgICAgaHR0cFJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHsgZGF0YSArPSBjaHVuay50b1N0cmluZygpOyB9KTtcbiAgICAgICAgaHR0cFJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IGh0dHBSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICBjYihudWxsLCBkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJldHJ5QWZ0ZXIgPSBwYXJzZUludChodHRwUmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSwgMTApICogMTAwMCB8fCAwO1xuICAgICAgICAgICAgdmFyIGVyciA9IHV0aWwuZXJyb3IobmV3IEVycm9yKCksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgIHJldHJ5YWJsZTogc3RhdHVzQ29kZSA+PSA1MDAgfHwgc3RhdHVzQ29kZSA9PT0gNDI5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmV0cnlBZnRlciAmJiBlcnIucmV0cnlhYmxlKSBlcnIucmV0cnlBZnRlciA9IHJldHJ5QWZ0ZXI7XG4gICAgICAgICAgICBlcnJDYWxsYmFjayhlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBlcnJDYWxsYmFjayk7XG4gICAgfTtcblxuICAgIEFXUy51dGlsLmRlZmVyKHNlbmRSZXF1ZXN0KTtcbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB1dWlkOiB7XG4gICAgdjQ6IGZ1bmN0aW9uIHV1aWRWNCgpIHtcbiAgICAgIHJldHVybiByZXF1aXJlKCd1dWlkJykudjQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29udmVydFBheWxvYWRUb1N0cmluZzogZnVuY3Rpb24gY29udmVydFBheWxvYWRUb1N0cmluZyhyZXNwKSB7XG4gICAgdmFyIHJlcSA9IHJlc3AucmVxdWVzdDtcbiAgICB2YXIgb3BlcmF0aW9uID0gcmVxLm9wZXJhdGlvbjtcbiAgICB2YXIgcnVsZXMgPSByZXEuc2VydmljZS5hcGkub3BlcmF0aW9uc1tvcGVyYXRpb25dLm91dHB1dCB8fCB7fTtcbiAgICBpZiAocnVsZXMucGF5bG9hZCAmJiByZXNwLmRhdGFbcnVsZXMucGF5bG9hZF0pIHtcbiAgICAgIHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXSA9IHJlc3AuZGF0YVtydWxlcy5wYXlsb2FkXS50b1N0cmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBkZWZlcjogZnVuY3Rpb24gZGVmZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBnZXRSZXF1ZXN0UGF5bG9hZFNoYXBlOiBmdW5jdGlvbiBnZXRSZXF1ZXN0UGF5bG9hZFNoYXBlKHJlcSkge1xuICAgIHZhciBvcGVyYXRpb25zID0gcmVxLnNlcnZpY2UuYXBpLm9wZXJhdGlvbnM7XG4gICAgaWYgKCFvcGVyYXRpb25zKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBvcGVyYXRpb24gPSAob3BlcmF0aW9ucyB8fCB7fSlbcmVxLm9wZXJhdGlvbl07XG4gICAgaWYgKCFvcGVyYXRpb24gfHwgIW9wZXJhdGlvbi5pbnB1dCB8fCAhb3BlcmF0aW9uLmlucHV0LnBheWxvYWQpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG9wZXJhdGlvbi5pbnB1dC5tZW1iZXJzW29wZXJhdGlvbi5pbnB1dC5wYXlsb2FkXTtcbiAgfSxcblxuICBnZXRQcm9maWxlc0Zyb21TaGFyZWRDb25maWc6IGZ1bmN0aW9uIGdldFByb2ZpbGVzRnJvbVNoYXJlZENvbmZpZyhpbmlMb2FkZXIsIGZpbGVuYW1lKSB7XG4gICAgdmFyIHByb2ZpbGVzID0ge307XG4gICAgdmFyIHByb2ZpbGVzRnJvbUNvbmZpZyA9IHt9O1xuICAgIGlmIChwcm9jZXNzLmVudlt1dGlsLmNvbmZpZ09wdEluRW52XSkge1xuICAgICAgdmFyIHByb2ZpbGVzRnJvbUNvbmZpZyA9IGluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICAgIGlzQ29uZmlnOiB0cnVlLFxuICAgICAgICBmaWxlbmFtZTogcHJvY2Vzcy5lbnZbdXRpbC5zaGFyZWRDb25maWdGaWxlRW52XVxuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBwcm9maWxlc0Zyb21DcmVkcz0ge307XG4gICAgdHJ5IHtcbiAgICAgIHZhciBwcm9maWxlc0Zyb21DcmVkcyA9IGluaUxvYWRlci5sb2FkRnJvbSh7XG4gICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSB8fFxuICAgICAgICAgIChwcm9jZXNzLmVudlt1dGlsLmNvbmZpZ09wdEluRW52XSAmJiBwcm9jZXNzLmVudlt1dGlsLnNoYXJlZENyZWRlbnRpYWxzRmlsZUVudl0pXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gaWYgdXNpbmcgY29uZmlnLCBhc3N1bWUgaXQgaXMgZnVsbHkgZGVzY3JpcHRpdmUgd2l0aG91dCBhIGNyZWRlbnRpYWxzIGZpbGU6XG4gICAgICBpZiAoIXByb2Nlc3MuZW52W3V0aWwuY29uZmlnT3B0SW5FbnZdKSB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIHByb2ZpbGVOYW1lcyA9IE9iamVjdC5rZXlzKHByb2ZpbGVzRnJvbUNvbmZpZyk7IGkgPCBwcm9maWxlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gPSBvYmplY3RBc3NpZ24ocHJvZmlsZXNbcHJvZmlsZU5hbWVzW2ldXSB8fCB7fSwgcHJvZmlsZXNGcm9tQ29uZmlnW3Byb2ZpbGVOYW1lc1tpXV0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgcHJvZmlsZU5hbWVzID0gT2JqZWN0LmtleXMocHJvZmlsZXNGcm9tQ3JlZHMpOyBpIDwgcHJvZmlsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9maWxlc1twcm9maWxlTmFtZXNbaV1dID0gb2JqZWN0QXNzaWduKHByb2ZpbGVzW3Byb2ZpbGVOYW1lc1tpXV0gfHwge30sIHByb2ZpbGVzRnJvbUNyZWRzW3Byb2ZpbGVOYW1lc1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZmlsZXM7XG5cbiAgICAvKipcbiAgICAgKiBSb3VnaGx5IHRoZSBzZW1hbnRpY3Mgb2YgYE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdEFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRba2V5c1tpXV0gPSBzb3VyY2Vba2V5c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBBUk46IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGVBUk4oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyICYmIHN0ci5pbmRleE9mKCdhcm46JykgPT09IDAgJiYgc3RyLnNwbGl0KCc6JykubGVuZ3RoID49IDY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2VBUk4oYXJuKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFybi5zcGxpdCgnOicpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFydGl0aW9uOiBtYXRjaGVkWzFdLFxuICAgICAgICBzZXJ2aWNlOiBtYXRjaGVkWzJdLFxuICAgICAgICByZWdpb246IG1hdGNoZWRbM10sXG4gICAgICAgIGFjY291bnRJZDogbWF0Y2hlZFs0XSxcbiAgICAgICAgcmVzb3VyY2U6IG1hdGNoZWQuc2xpY2UoNSkuam9pbignOicpXG4gICAgICB9O1xuICAgIH0sXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkQVJOKGFybk9iamVjdCkge1xuICAgICAgaWYgKFxuICAgICAgICBhcm5PYmplY3Quc2VydmljZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFybk9iamVjdC5yZWdpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhcm5PYmplY3QuYWNjb3VudElkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJuT2JqZWN0LnJlc291cmNlID09PSB1bmRlZmluZWRcbiAgICAgICkgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0lucHV0IEFSTiBvYmplY3QgaXMgaW52YWxpZCcpKTtcbiAgICAgIHJldHVybiAnYXJuOicrIChhcm5PYmplY3QucGFydGl0aW9uIHx8ICdhd3MnKSArICc6JyArIGFybk9iamVjdC5zZXJ2aWNlICtcbiAgICAgICAgJzonICsgYXJuT2JqZWN0LnJlZ2lvbiArICc6JyArIGFybk9iamVjdC5hY2NvdW50SWQgKyAnOicgKyBhcm5PYmplY3QucmVzb3VyY2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGRlZmF1bHRQcm9maWxlOiAnZGVmYXVsdCcsXG5cbiAgLyoqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uZmlnT3B0SW5FbnY6ICdBV1NfU0RLX0xPQURfQ09ORklHJyxcblxuICAvKipcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBzaGFyZWRDcmVkZW50aWFsc0ZpbGVFbnY6ICdBV1NfU0hBUkVEX0NSRURFTlRJQUxTX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHNoYXJlZENvbmZpZ0ZpbGVFbnY6ICdBV1NfQ09ORklHX0ZJTEUnLFxuXG4gIC8qKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGltZHNEaXNhYmxlZEVudjogJ0FXU19FQzJfTUVUQURBVEFfRElTQUJMRUQnXG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL21vZGVsL3NoYXBlJyk7XG5cbmZ1bmN0aW9uIERvbVhtbFBhcnNlcigpIHsgfVxuXG5Eb21YbWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oeG1sLCBzaGFwZSkge1xuICBpZiAoeG1sLnJlcGxhY2UoL15cXHMrLywgJycpID09PSAnJykgcmV0dXJuIHt9O1xuXG4gIHZhciByZXN1bHQsIGVycm9yO1xuICB0cnkge1xuICAgIGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICByZXN1bHQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICB9IGNhdGNoIChzeW50YXhFcnJvcikge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignUGFyc2UgZXJyb3IgaW4gZG9jdW1lbnQnKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBzeW50YXhFcnJvcixcbiAgICAgICAgICAgIGNvZGU6ICdYTUxQYXJzZXJFcnJvcicsXG4gICAgICAgICAgICByZXRyeWFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdXRpbC5lcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBlbXB0eSBkb2N1bWVudC4nKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0Vycm9yID0gcmVzdWx0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdO1xuICAgICAgaWYgKGlzRXJyb3IgJiYgKGlzRXJyb3IucGFyZW50Tm9kZSA9PT0gcmVzdWx0IHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnYm9keScgfHxcbiAgICAgICAgICBpc0Vycm9yLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PT0gcmVzdWx0IHx8XG4gICAgICAgICAgaXNFcnJvci5wYXJlbnROb2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdib2R5JykpIHtcbiAgICAgICAgdmFyIGVycm9yRWxlbWVudCA9IGlzRXJyb3IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpWzBdIHx8IGlzRXJyb3I7XG4gICAgICAgIHRocm93IHV0aWwuZXJyb3IobmV3IEVycm9yKGVycm9yRWxlbWVudC50ZXh0Q29udGVudCB8fCAnUGFyc2VyIGVycm9yIGluIGRvY3VtZW50JyksXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29kZTogJ1hNTFBhcnNlckVycm9yJyxcbiAgICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xuICAgICAgcmVzdWx0LmFzeW5jID0gZmFsc2U7XG5cbiAgICAgIGlmICghcmVzdWx0LmxvYWRYTUwoeG1sKSkge1xuICAgICAgICB0aHJvdyB1dGlsLmVycm9yKG5ldyBFcnJvcignUGFyc2UgZXJyb3IgaW4gZG9jdW1lbnQnKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb2RlOiAnWE1MUGFyc2VyRXJyb3InLFxuICAgICAgICAgICAgcmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvYWQgWE1MIHBhcnNlcicpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuXG4gIGlmIChyZXN1bHQgJiYgcmVzdWx0LmRvY3VtZW50RWxlbWVudCAmJiAhZXJyb3IpIHtcbiAgICB2YXIgZGF0YSA9IHBhcnNlWG1sKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQsIHNoYXBlKTtcbiAgICB2YXIgbWV0YWRhdGEgPSBnZXRFbGVtZW50QnlUYWdOYW1lKHJlc3VsdC5kb2N1bWVudEVsZW1lbnQsICdSZXNwb25zZU1ldGFkYXRhJyk7XG4gICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICBkYXRhLlJlc3BvbnNlTWV0YWRhdGEgPSBwYXJzZVhtbChtZXRhZGF0YSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfSBlbHNlIGlmIChlcnJvcikge1xuICAgIHRocm93IHV0aWwuZXJyb3IoZXJyb3IgfHwgbmV3IEVycm9yKCksIHtjb2RlOiAnWE1MUGFyc2VyRXJyb3InLCByZXRyeWFibGU6IHRydWV9KTtcbiAgfSBlbHNlIHsgLy8gZW1wdHkgeG1sIGRvY3VtZW50XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50QnlUYWdOYW1lKHhtbCwgdGFnKSB7XG4gIHZhciBlbGVtZW50cyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgIGlmIChlbGVtZW50c1tpXS5wYXJlbnROb2RlID09PSB4bWwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VYbWwoeG1sLCBzaGFwZSkge1xuICBpZiAoIXNoYXBlKSBzaGFwZSA9IHt9O1xuICBzd2l0Y2ggKHNoYXBlLnR5cGUpIHtcbiAgICBjYXNlICdzdHJ1Y3R1cmUnOiByZXR1cm4gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSk7XG4gICAgY2FzZSAnbWFwJzogcmV0dXJuIHBhcnNlTWFwKHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gcGFyc2VMaXN0KHhtbCwgc2hhcGUpO1xuICAgIGNhc2UgdW5kZWZpbmVkOiBjYXNlIG51bGw6IHJldHVybiBwYXJzZVVua25vd24oeG1sKTtcbiAgICBkZWZhdWx0OiByZXR1cm4gcGFyc2VTY2FsYXIoeG1sLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJ1Y3R1cmUoeG1sLCBzaGFwZSkge1xuICB2YXIgZGF0YSA9IHt9O1xuICBpZiAoeG1sID09PSBudWxsKSByZXR1cm4gZGF0YTtcblxuICB1dGlsLmVhY2goc2hhcGUubWVtYmVycywgZnVuY3Rpb24obWVtYmVyTmFtZSwgbWVtYmVyU2hhcGUpIHtcbiAgICBpZiAobWVtYmVyU2hhcGUuaXNYbWxBdHRyaWJ1dGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeG1sLmF0dHJpYnV0ZXMsIG1lbWJlclNoYXBlLm5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHhtbC5hdHRyaWJ1dGVzW21lbWJlclNoYXBlLm5hbWVdLnZhbHVlO1xuICAgICAgICBkYXRhW21lbWJlck5hbWVdID0gcGFyc2VYbWwoe3RleHRDb250ZW50OiB2YWx1ZX0sIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhtbENoaWxkID0gbWVtYmVyU2hhcGUuZmxhdHRlbmVkID8geG1sIDpcbiAgICAgICAgZ2V0RWxlbWVudEJ5VGFnTmFtZSh4bWwsIG1lbWJlclNoYXBlLm5hbWUpO1xuICAgICAgaWYgKHhtbENoaWxkKSB7XG4gICAgICAgIGRhdGFbbWVtYmVyTmFtZV0gPSBwYXJzZVhtbCh4bWxDaGlsZCwgbWVtYmVyU2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgIW1lbWJlclNoYXBlLmZsYXR0ZW5lZCAmJlxuICAgICAgICBtZW1iZXJTaGFwZS50eXBlID09PSAnbGlzdCcgJiZcbiAgICAgICAgIXNoYXBlLmFwaS54bWxOb0RlZmF1bHRMaXN0cykge1xuICAgICAgICBkYXRhW21lbWJlck5hbWVdID0gbWVtYmVyU2hhcGUuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWFwKHhtbCwgc2hhcGUpIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIHhtbEtleSA9IHNoYXBlLmtleS5uYW1lIHx8ICdrZXknO1xuICB2YXIgeG1sVmFsdWUgPSBzaGFwZS52YWx1ZS5uYW1lIHx8ICd2YWx1ZSc7XG4gIHZhciB0YWdOYW1lID0gc2hhcGUuZmxhdHRlbmVkID8gc2hhcGUubmFtZSA6ICdlbnRyeSc7XG5cbiAgdmFyIGNoaWxkID0geG1sLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXRFbGVtZW50QnlUYWdOYW1lKGNoaWxkLCB4bWxLZXkpLnRleHRDb250ZW50O1xuICAgICAgdmFyIHZhbHVlID0gZ2V0RWxlbWVudEJ5VGFnTmFtZShjaGlsZCwgeG1sVmFsdWUpO1xuICAgICAgZGF0YVtrZXldID0gcGFyc2VYbWwodmFsdWUsIHNoYXBlLnZhbHVlKTtcbiAgICB9XG4gICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGlzdCh4bWwsIHNoYXBlKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHZhciB0YWdOYW1lID0gc2hhcGUuZmxhdHRlbmVkID8gc2hhcGUubmFtZSA6IChzaGFwZS5tZW1iZXIubmFtZSB8fCAnbWVtYmVyJyk7XG5cbiAgdmFyIGNoaWxkID0geG1sLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZU5hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIGRhdGEucHVzaChwYXJzZVhtbChjaGlsZCwgc2hhcGUubWVtYmVyKSk7XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNjYWxhcih4bWwsIHNoYXBlKSB7XG4gIGlmICh4bWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIGVuY29kaW5nID0geG1sLmdldEF0dHJpYnV0ZSgnZW5jb2RpbmcnKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICBzaGFwZSA9IG5ldyBTaGFwZS5jcmVhdGUoe3R5cGU6IGVuY29kaW5nfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRleHQgPSB4bWwudGV4dENvbnRlbnQ7XG4gIGlmICh0ZXh0ID09PSAnJykgdGV4dCA9IG51bGw7XG4gIGlmICh0eXBlb2Ygc2hhcGUudG9UeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNoYXBlLnRvVHlwZSh0ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVVua25vd24oeG1sKSB7XG4gIGlmICh4bWwgPT09IHVuZGVmaW5lZCB8fCB4bWwgPT09IG51bGwpIHJldHVybiAnJztcblxuICAvLyBlbXB0eSBvYmplY3RcbiAgaWYgKCF4bWwuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICBpZiAoeG1sLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIGlmICh4bWwuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICBlbHNlIHJldHVybiB4bWwudGV4dENvbnRlbnQ7XG4gIH1cblxuICAvLyBvYmplY3QsIHBhcnNlIGFzIHN0cnVjdHVyZVxuICB2YXIgc2hhcGUgPSB7dHlwZTogJ3N0cnVjdHVyZScsIG1lbWJlcnM6IHt9fTtcbiAgdmFyIGNoaWxkID0geG1sLmZpcnN0RWxlbWVudENoaWxkO1xuICB3aGlsZSAoY2hpbGQpIHtcbiAgICB2YXIgdGFnID0gY2hpbGQubm9kZU5hbWU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzaGFwZS5tZW1iZXJzLCB0YWcpKSB7XG4gICAgICAvLyBtdWx0aXBsZSB0YWdzIG9mIHRoZSBzYW1lIG5hbWUgbWFrZXMgaXQgYSBsaXN0XG4gICAgICBzaGFwZS5tZW1iZXJzW3RhZ10udHlwZSA9ICdsaXN0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2hhcGUubWVtYmVyc1t0YWddID0ge25hbWU6IHRhZ307XG4gICAgfVxuICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBwYXJzZVN0cnVjdHVyZSh4bWwsIHNoYXBlKTtcbn1cblxuLyoqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBEb21YbWxQYXJzZXI7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBYbWxOb2RlID0gcmVxdWlyZSgnLi94bWwtbm9kZScpLlhtbE5vZGU7XG52YXIgWG1sVGV4dCA9IHJlcXVpcmUoJy4veG1sLXRleHQnKS5YbWxUZXh0O1xuXG5mdW5jdGlvbiBYbWxCdWlsZGVyKCkgeyB9XG5cblhtbEJ1aWxkZXIucHJvdG90eXBlLnRvWE1MID0gZnVuY3Rpb24ocGFyYW1zLCBzaGFwZSwgcm9vdEVsZW1lbnQsIG5vRW1wdHkpIHtcbiAgdmFyIHhtbCA9IG5ldyBYbWxOb2RlKHJvb3RFbGVtZW50KTtcbiAgYXBwbHlOYW1lc3BhY2VzKHhtbCwgc2hhcGUsIHRydWUpO1xuICBzZXJpYWxpemUoeG1sLCBwYXJhbXMsIHNoYXBlKTtcbiAgcmV0dXJuIHhtbC5jaGlsZHJlbi5sZW5ndGggPiAwIHx8IG5vRW1wdHkgPyB4bWwudG9TdHJpbmcoKSA6ICcnO1xufTtcblxuZnVuY3Rpb24gc2VyaWFsaXplKHhtbCwgdmFsdWUsIHNoYXBlKSB7XG4gIHN3aXRjaCAoc2hhcGUudHlwZSkge1xuICAgIGNhc2UgJ3N0cnVjdHVyZSc6IHJldHVybiBzZXJpYWxpemVTdHJ1Y3R1cmUoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ21hcCc6IHJldHVybiBzZXJpYWxpemVNYXAoeG1sLCB2YWx1ZSwgc2hhcGUpO1xuICAgIGNhc2UgJ2xpc3QnOiByZXR1cm4gc2VyaWFsaXplTGlzdCh4bWwsIHZhbHVlLCBzaGFwZSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIHNlcmlhbGl6ZVNjYWxhcih4bWwsIHZhbHVlLCBzaGFwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0dXJlKHhtbCwgcGFyYW1zLCBzaGFwZSkge1xuICB1dGlsLmFycmF5RWFjaChzaGFwZS5tZW1iZXJOYW1lcywgZnVuY3Rpb24obWVtYmVyTmFtZSkge1xuICAgIHZhciBtZW1iZXJTaGFwZSA9IHNoYXBlLm1lbWJlcnNbbWVtYmVyTmFtZV07XG4gICAgaWYgKG1lbWJlclNoYXBlLmxvY2F0aW9uICE9PSAnYm9keScpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1ttZW1iZXJOYW1lXTtcbiAgICB2YXIgbmFtZSA9IG1lbWJlclNoYXBlLm5hbWU7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChtZW1iZXJTaGFwZS5pc1htbEF0dHJpYnV0ZSkge1xuICAgICAgICB4bWwuYWRkQXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWVtYmVyU2hhcGUuZmxhdHRlbmVkKSB7XG4gICAgICAgIHNlcmlhbGl6ZSh4bWwsIHZhbHVlLCBtZW1iZXJTaGFwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgICBhcHBseU5hbWVzcGFjZXMoZWxlbWVudCwgbWVtYmVyU2hhcGUpO1xuICAgICAgICBzZXJpYWxpemUoZWxlbWVudCwgdmFsdWUsIG1lbWJlclNoYXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVNYXAoeG1sLCBtYXAsIHNoYXBlKSB7XG4gIHZhciB4bWxLZXkgPSBzaGFwZS5rZXkubmFtZSB8fCAna2V5JztcbiAgdmFyIHhtbFZhbHVlID0gc2hhcGUudmFsdWUubmFtZSB8fCAndmFsdWUnO1xuXG4gIHV0aWwuZWFjaChtYXAsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBuZXcgWG1sTm9kZShzaGFwZS5mbGF0dGVuZWQgPyBzaGFwZS5uYW1lIDogJ2VudHJ5Jyk7XG4gICAgeG1sLmFkZENoaWxkTm9kZShlbnRyeSk7XG5cbiAgICB2YXIgZW50cnlLZXkgPSBuZXcgWG1sTm9kZSh4bWxLZXkpO1xuICAgIHZhciBlbnRyeVZhbHVlID0gbmV3IFhtbE5vZGUoeG1sVmFsdWUpO1xuICAgIGVudHJ5LmFkZENoaWxkTm9kZShlbnRyeUtleSk7XG4gICAgZW50cnkuYWRkQ2hpbGROb2RlKGVudHJ5VmFsdWUpO1xuXG4gICAgc2VyaWFsaXplKGVudHJ5S2V5LCBrZXksIHNoYXBlLmtleSk7XG4gICAgc2VyaWFsaXplKGVudHJ5VmFsdWUsIHZhbHVlLCBzaGFwZS52YWx1ZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVMaXN0KHhtbCwgbGlzdCwgc2hhcGUpIHtcbiAgaWYgKHNoYXBlLmZsYXR0ZW5lZCkge1xuICAgIHV0aWwuYXJyYXlFYWNoKGxpc3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNoYXBlLm1lbWJlci5uYW1lIHx8IHNoYXBlLm5hbWU7XG4gICAgICB2YXIgZWxlbWVudCA9IG5ldyBYbWxOb2RlKG5hbWUpO1xuICAgICAgeG1sLmFkZENoaWxkTm9kZShlbGVtZW50KTtcbiAgICAgIHNlcmlhbGl6ZShlbGVtZW50LCB2YWx1ZSwgc2hhcGUubWVtYmVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB1dGlsLmFycmF5RWFjaChsaXN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG5hbWUgPSBzaGFwZS5tZW1iZXIubmFtZSB8fCAnbWVtYmVyJztcbiAgICAgIHZhciBlbGVtZW50ID0gbmV3IFhtbE5vZGUobmFtZSk7XG4gICAgICB4bWwuYWRkQ2hpbGROb2RlKGVsZW1lbnQpO1xuICAgICAgc2VyaWFsaXplKGVsZW1lbnQsIHZhbHVlLCBzaGFwZS5tZW1iZXIpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVNjYWxhcih4bWwsIHZhbHVlLCBzaGFwZSkge1xuICB4bWwuYWRkQ2hpbGROb2RlKFxuICAgIG5ldyBYbWxUZXh0KHNoYXBlLnRvV2lyZUZvcm1hdCh2YWx1ZSkpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TmFtZXNwYWNlcyh4bWwsIHNoYXBlLCBpc1Jvb3QpIHtcbiAgdmFyIHVyaSwgcHJlZml4ID0gJ3htbG5zJztcbiAgaWYgKHNoYXBlLnhtbE5hbWVzcGFjZVVyaSkge1xuICAgIHVyaSA9IHNoYXBlLnhtbE5hbWVzcGFjZVVyaTtcbiAgICBpZiAoc2hhcGUueG1sTmFtZXNwYWNlUHJlZml4KSBwcmVmaXggKz0gJzonICsgc2hhcGUueG1sTmFtZXNwYWNlUHJlZml4O1xuICB9IGVsc2UgaWYgKGlzUm9vdCAmJiBzaGFwZS5hcGkueG1sTmFtZXNwYWNlVXJpKSB7XG4gICAgdXJpID0gc2hhcGUuYXBpLnhtbE5hbWVzcGFjZVVyaTtcbiAgfVxuXG4gIGlmICh1cmkpIHhtbC5hZGRBdHRyaWJ1dGUocHJlZml4LCB1cmkpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEJ1aWxkZXI7XG4iLCIvKipcbiAqIEVzY2FwZXMgY2hhcmFjdGVycyB0aGF0IGNhbiBub3QgYmUgaW4gYW4gWE1MIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvJy9nLCAnJmFwb3M7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG59XG5cbi8qKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVzY2FwZUF0dHJpYnV0ZTogZXNjYXBlQXR0cmlidXRlXG59O1xuIiwiLyoqXG4gKiBFc2NhcGVzIGNoYXJhY3RlcnMgdGhhdCBjYW4gbm90IGJlIGluIGFuIFhNTCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBlc2NhcGVFbGVtZW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJyYjeDBEOycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnJiN4MEE7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MDA4NS9nLCAnJiN4ODU7JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOC8sICcmI3gyMDI4OycpO1xufVxuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlc2NhcGVFbGVtZW50OiBlc2NhcGVFbGVtZW50XG59O1xuIiwidmFyIGVzY2FwZUF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vZXNjYXBlLWF0dHJpYnV0ZScpLmVzY2FwZUF0dHJpYnV0ZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIFhNTCBub2RlLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFhtbE5vZGUobmFtZSwgY2hpbGRyZW4pIHtcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkgeyBjaGlsZHJlbiA9IFtdOyB9XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG59XG5YbWxOb2RlLnByb3RvdHlwZS5hZGRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5YbWxOb2RlLnByb3RvdHlwZS5hZGRDaGlsZE5vZGUgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblhtbE5vZGUucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5YbWxOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzQ2hpbGRyZW4gPSBCb29sZWFuKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB2YXIgeG1sVGV4dCA9ICc8JyArIHRoaXMubmFtZTtcbiAgICAvLyBhZGQgYXR0cmlidXRlc1xuICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpOyBpIDwgYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlICE9PSAndW5kZWZpbmVkJyAmJiBhdHRyaWJ1dGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHhtbFRleHQgKz0gJyAnICsgYXR0cmlidXRlTmFtZSArICc9XFxcIicgKyBlc2NhcGVBdHRyaWJ1dGUoJycgKyBhdHRyaWJ1dGUpICsgJ1xcXCInO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4bWxUZXh0ICs9ICFoYXNDaGlsZHJlbiA/ICcvPicgOiAnPicgKyB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1N0cmluZygpOyB9KS5qb2luKCcnKSArICc8LycgKyB0aGlzLm5hbWUgKyAnPic7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBYbWxOb2RlOiBYbWxOb2RlXG59O1xuIiwidmFyIGVzY2FwZUVsZW1lbnQgPSByZXF1aXJlKCcuL2VzY2FwZS1lbGVtZW50JykuZXNjYXBlRWxlbWVudDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIFhNTCB0ZXh0IHZhbHVlLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFhtbFRleHQodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cblhtbFRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlc2NhcGVFbGVtZW50KCcnICsgdGhpcy52YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBYbWxUZXh0OiBYbWxUZXh0XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTFJVXzEgPSByZXF1aXJlKFwiLi91dGlscy9MUlVcIik7XG52YXIgQ0FDSEVfU0laRSA9IDEwMDA7XG4vKipcbiAqIEluc3BpcmVkIG5vZGUtbHJ1LWNhY2hlW2h0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1scnUtY2FjaGVdXG4gKi9cbnZhciBFbmRwb2ludENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVuZHBvaW50Q2FjaGUobWF4U2l6ZSkge1xuICAgICAgICBpZiAobWF4U2l6ZSA9PT0gdm9pZCAwKSB7IG1heFNpemUgPSBDQUNIRV9TSVpFOyB9XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTFJVXzEuTFJVQ2FjaGUobWF4U2l6ZSk7XG4gICAgfVxuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGtleVN0cmluZyA9IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnID8gRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcoa2V5KSA6IGtleTtcbiAgICAgICAgdmFyIGVuZHBvaW50UmVjb3JkID0gdGhpcy5wb3B1bGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jYWNoZS5wdXQoa2V5U3RyaW5nLCBlbmRwb2ludFJlY29yZCk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIga2V5U3RyaW5nID0gdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgPyBFbmRwb2ludENhY2hlLmdldEtleVN0cmluZyhrZXkpIDoga2V5O1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLmNhY2hlLmdldChrZXlTdHJpbmcpO1xuICAgICAgICBpZiAocmVjb3Jkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHJlY29yZHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5FeHBpcmUgPCBub3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5yZW1vdmUoa2V5U3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgICB2YXIgaWRlbnRpZmllck5hbWVzID0gT2JqZWN0LmtleXMoa2V5KS5zb3J0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRlbnRpZmllck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaWRlbnRpZmllck5hbWUgPSBpZGVudGlmaWVyTmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5W2lkZW50aWZpZXJOYW1lXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaChrZXlbaWRlbnRpZmllck5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRlbnRpZmllcnMuam9pbignICcpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucG9wdWxhdGVWYWx1ZSA9IGZ1bmN0aW9uIChlbmRwb2ludHMpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBlbmRwb2ludHMubWFwKGZ1bmN0aW9uIChlbmRwb2ludCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIEFkZHJlc3M6IGVuZHBvaW50LkFkZHJlc3MgfHwgJycsXG4gICAgICAgICAgICBFeHBpcmU6IG5vdyArIChlbmRwb2ludC5DYWNoZVBlcmlvZEluTWludXRlcyB8fCAxKSAqIDYwICogMTAwMFxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBFbmRwb2ludENhY2hlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5lbXB0eSgpO1xuICAgIH07XG4gICAgRW5kcG9pbnRDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGtleVN0cmluZyA9IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnID8gRW5kcG9pbnRDYWNoZS5nZXRLZXlTdHJpbmcoa2V5KSA6IGtleTtcbiAgICAgICAgdGhpcy5jYWNoZS5yZW1vdmUoa2V5U3RyaW5nKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmRwb2ludENhY2hlO1xufSgpKTtcbmV4cG9ydHMuRW5kcG9pbnRDYWNoZSA9IEVuZHBvaW50Q2FjaGU7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTGlua2VkTGlzdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlua2VkTGlzdE5vZGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTGlua2VkTGlzdE5vZGU7XG59KCkpO1xudmFyIExSVUNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExSVUNhY2hlKHNpemUpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwID0ge307XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicgfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FjaGUgc2l6ZSBjYW4gb25seSBiZSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVMaW1pdCA9IHNpemU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUucHJlcGVuZFRvTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWxOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZGVyTm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYWRlck5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmVGcm9tVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhaWxOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy50YWlsTm9kZTtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gbm9kZS5wcmV2O1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgIHByZXZOb2RlLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRhaWxOb2RlID0gcHJldk5vZGU7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5kZXRhY2hGcm9tTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlck5vZGUgPT09IG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YWlsTm9kZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgdGhpcy50YWlsTm9kZSA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5wcmV2KSB7XG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5uZXh0KSB7XG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaXplLS07XG4gICAgfTtcbiAgICBMUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgICAgICB0aGlzLmRldGFjaEZyb21MaXN0KG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5wcmVwZW5kVG9MaXN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVNYXBba2V5XSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoRnJvbUxpc3Qobm9kZSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ub2RlTWFwW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExSVUNhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5ub2RlTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zaXplID09PSB0aGlzLnNpemVMaW1pdCkge1xuICAgICAgICAgICAgdmFyIHRhaWxOb2RlID0gdGhpcy5yZW1vdmVGcm9tVGFpbCgpO1xuICAgICAgICAgICAgdmFyIGtleV8xID0gdGFpbE5vZGUua2V5O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubm9kZU1hcFtrZXlfMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld05vZGUgPSBuZXcgTGlua2VkTGlzdE5vZGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMubm9kZU1hcFtrZXldID0gbmV3Tm9kZTtcbiAgICAgICAgdGhpcy5wcmVwZW5kVG9MaXN0KG5ld05vZGUpO1xuICAgIH07XG4gICAgTFJVQ2FjaGUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZU1hcCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZU1hcFtrZXldO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hGcm9tTGlzdChub2RlKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVNYXBba2V5XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExSVUNhY2hlO1xufSgpKTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTsiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIihmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICBpZiAob2JqICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpY3REZWVwRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIC8vIENoZWNrIHRoZSBzY2FsYXIgY2FzZSBmaXJzdC5cbiAgICBpZiAoZmlyc3QgPT09IHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhleSBhcmUgdGhlIHNhbWUgdHlwZS5cbiAgICB2YXIgZmlyc3RUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZpcnN0KTtcbiAgICBpZiAoZmlyc3RUeXBlICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBrbm93IHRoYXQgZmlyc3QgYW5kIHNlY29uZCBoYXZlIHRoZSBzYW1lIHR5cGUgc28gd2UgY2FuIGp1c3QgY2hlY2sgdGhlXG4gICAgLy8gZmlyc3QgdHlwZSBmcm9tIG5vdyBvbi5cbiAgICBpZiAoaXNBcnJheShmaXJzdCkgPT09IHRydWUpIHtcbiAgICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgdGhleSdyZSBub3QgdGhlIHNhbWUgbGVuZ3RoO1xuICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3RbaV0sIHNlY29uZFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gQW4gb2JqZWN0IGlzIGVxdWFsIGlmIGl0IGhhcyB0aGUgc2FtZSBrZXkvdmFsdWUgcGFpcnMuXG4gICAgICB2YXIga2V5c1NlZW4gPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBmaXJzdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmaXJzdCwga2V5KSkge1xuICAgICAgICAgIGlmIChzdHJpY3REZWVwRXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzU2VlbltrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTm93IGNoZWNrIHRoYXQgdGhlcmUgYXJlbid0IGFueSBrZXlzIGluIHNlY29uZCB0aGF0IHdlcmVuJ3RcbiAgICAgIC8vIGluIGZpcnN0LlxuICAgICAgZm9yICh2YXIga2V5MiBpbiBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc2Vjb25kLCBrZXkyKSkge1xuICAgICAgICAgIGlmIChrZXlzU2VlbltrZXkyXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFsc2Uob2JqKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyBBIGZhbHNlIHZhbHVlIGNvcnJlc3BvbmRzIHRvIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgIC8vIEVtcHR5IGxpc3RcbiAgICAvLyBFbXB0eSBvYmplY3RcbiAgICAvLyBFbXB0eSBzdHJpbmdcbiAgICAvLyBGYWxzZSBib29sZWFuXG4gICAgLy8gbnVsbCB2YWx1ZVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgdGhlIHNjYWxhciB2YWx1ZXMuXG4gICAgaWYgKG9iaiA9PT0gXCJcIiB8fCBvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBhcnJheS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChvYmopKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkga2V5cywgdGhlblxuICAgICAgICAgICAgLy8gdGhlIG9iamVjdCBpcyBub3QgZW1wdHkgc28gdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXMgbm90IGZhbHNlLlxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqVmFsdWVzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXMucHVzaChvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGFba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleTIgaW4gYikge1xuICAgICAgICAgIG1lcmdlZFtrZXkyXSA9IGJba2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgdmFyIHRyaW1MZWZ0O1xuICBpZiAodHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRyaW1MZWZ0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnRyaW1MZWZ0KCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0cmltTGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5tYXRjaCgvXlxccyooLiopLylbMV07XG4gICAgfTtcbiAgfVxuXG4gIC8vIFR5cGUgY29uc3RhbnRzIHVzZWQgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgdmFyIFRZUEVfTlVNQkVSID0gMDtcbiAgdmFyIFRZUEVfQU5ZID0gMTtcbiAgdmFyIFRZUEVfU1RSSU5HID0gMjtcbiAgdmFyIFRZUEVfQVJSQVkgPSAzO1xuICB2YXIgVFlQRV9PQkpFQ1QgPSA0O1xuICB2YXIgVFlQRV9CT09MRUFOID0gNTtcbiAgdmFyIFRZUEVfRVhQUkVGID0gNjtcbiAgdmFyIFRZUEVfTlVMTCA9IDc7XG4gIHZhciBUWVBFX0FSUkFZX05VTUJFUiA9IDg7XG4gIHZhciBUWVBFX0FSUkFZX1NUUklORyA9IDk7XG4gIHZhciBUWVBFX05BTUVfVEFCTEUgPSB7XG4gICAgMDogJ251bWJlcicsXG4gICAgMTogJ2FueScsXG4gICAgMjogJ3N0cmluZycsXG4gICAgMzogJ2FycmF5JyxcbiAgICA0OiAnb2JqZWN0JyxcbiAgICA1OiAnYm9vbGVhbicsXG4gICAgNjogJ2V4cHJlc3Npb24nLFxuICAgIDc6ICdudWxsJyxcbiAgICA4OiAnQXJyYXk8bnVtYmVyPicsXG4gICAgOTogJ0FycmF5PHN0cmluZz4nXG4gIH07XG5cbiAgdmFyIFRPS19FT0YgPSBcIkVPRlwiO1xuICB2YXIgVE9LX1VOUVVPVEVESURFTlRJRklFUiA9IFwiVW5xdW90ZWRJZGVudGlmaWVyXCI7XG4gIHZhciBUT0tfUVVPVEVESURFTlRJRklFUiA9IFwiUXVvdGVkSWRlbnRpZmllclwiO1xuICB2YXIgVE9LX1JCUkFDS0VUID0gXCJSYnJhY2tldFwiO1xuICB2YXIgVE9LX1JQQVJFTiA9IFwiUnBhcmVuXCI7XG4gIHZhciBUT0tfQ09NTUEgPSBcIkNvbW1hXCI7XG4gIHZhciBUT0tfQ09MT04gPSBcIkNvbG9uXCI7XG4gIHZhciBUT0tfUkJSQUNFID0gXCJSYnJhY2VcIjtcbiAgdmFyIFRPS19OVU1CRVIgPSBcIk51bWJlclwiO1xuICB2YXIgVE9LX0NVUlJFTlQgPSBcIkN1cnJlbnRcIjtcbiAgdmFyIFRPS19FWFBSRUYgPSBcIkV4cHJlZlwiO1xuICB2YXIgVE9LX1BJUEUgPSBcIlBpcGVcIjtcbiAgdmFyIFRPS19PUiA9IFwiT3JcIjtcbiAgdmFyIFRPS19BTkQgPSBcIkFuZFwiO1xuICB2YXIgVE9LX0VRID0gXCJFUVwiO1xuICB2YXIgVE9LX0dUID0gXCJHVFwiO1xuICB2YXIgVE9LX0xUID0gXCJMVFwiO1xuICB2YXIgVE9LX0dURSA9IFwiR1RFXCI7XG4gIHZhciBUT0tfTFRFID0gXCJMVEVcIjtcbiAgdmFyIFRPS19ORSA9IFwiTkVcIjtcbiAgdmFyIFRPS19GTEFUVEVOID0gXCJGbGF0dGVuXCI7XG4gIHZhciBUT0tfU1RBUiA9IFwiU3RhclwiO1xuICB2YXIgVE9LX0ZJTFRFUiA9IFwiRmlsdGVyXCI7XG4gIHZhciBUT0tfRE9UID0gXCJEb3RcIjtcbiAgdmFyIFRPS19OT1QgPSBcIk5vdFwiO1xuICB2YXIgVE9LX0xCUkFDRSA9IFwiTGJyYWNlXCI7XG4gIHZhciBUT0tfTEJSQUNLRVQgPSBcIkxicmFja2V0XCI7XG4gIHZhciBUT0tfTFBBUkVOPSBcIkxwYXJlblwiO1xuICB2YXIgVE9LX0xJVEVSQUw9IFwiTGl0ZXJhbFwiO1xuXG4gIC8vIFRoZSBcIiZcIiwgXCJbXCIsIFwiPFwiLCBcIj5cIiB0b2tlbnNcbiAgLy8gYXJlIG5vdCBpbiBiYXNpY1Rva2VuIGJlY2F1c2VcbiAgLy8gdGhlcmUgYXJlIHR3byB0b2tlbiB2YXJpYW50c1xuICAvLyAoXCImJlwiLCBcIls/XCIsIFwiPD1cIiwgXCI+PVwiKS4gIFRoaXMgaXMgc3BlY2lhbGx5IGhhbmRsZWRcbiAgLy8gYmVsb3cuXG5cbiAgdmFyIGJhc2ljVG9rZW5zID0ge1xuICAgIFwiLlwiOiBUT0tfRE9ULFxuICAgIFwiKlwiOiBUT0tfU1RBUixcbiAgICBcIixcIjogVE9LX0NPTU1BLFxuICAgIFwiOlwiOiBUT0tfQ09MT04sXG4gICAgXCJ7XCI6IFRPS19MQlJBQ0UsXG4gICAgXCJ9XCI6IFRPS19SQlJBQ0UsXG4gICAgXCJdXCI6IFRPS19SQlJBQ0tFVCxcbiAgICBcIihcIjogVE9LX0xQQVJFTixcbiAgICBcIilcIjogVE9LX1JQQVJFTixcbiAgICBcIkBcIjogVE9LX0NVUlJFTlRcbiAgfTtcblxuICB2YXIgb3BlcmF0b3JTdGFydFRva2VuID0ge1xuICAgICAgXCI8XCI6IHRydWUsXG4gICAgICBcIj5cIjogdHJ1ZSxcbiAgICAgIFwiPVwiOiB0cnVlLFxuICAgICAgXCIhXCI6IHRydWVcbiAgfTtcblxuICB2YXIgc2tpcENoYXJzID0ge1xuICAgICAgXCIgXCI6IHRydWUsXG4gICAgICBcIlxcdFwiOiB0cnVlLFxuICAgICAgXCJcXG5cIjogdHJ1ZVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gaXNBbHBoYShjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSBcImFcIiAmJiBjaCA8PSBcInpcIikgfHxcbiAgICAgICAgICAgICAoY2ggPj0gXCJBXCIgJiYgY2ggPD0gXCJaXCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiX1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI5XCIpIHx8XG4gICAgICAgICAgICAgY2ggPT09IFwiLVwiO1xuICB9XG4gIGZ1bmN0aW9uIGlzQWxwaGFOdW0oY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gXCJhXCIgJiYgY2ggPD0gXCJ6XCIpIHx8XG4gICAgICAgICAgICAgKGNoID49IFwiQVwiICYmIGNoIDw9IFwiWlwiKSB8fFxuICAgICAgICAgICAgIChjaCA+PSBcIjBcIiAmJiBjaCA8PSBcIjlcIikgfHxcbiAgICAgICAgICAgICBjaCA9PT0gXCJfXCI7XG4gIH1cblxuICBmdW5jdGlvbiBMZXhlcigpIHtcbiAgfVxuICBMZXhlci5wcm90b3R5cGUgPSB7XG4gICAgICB0b2tlbml6ZTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSAwO1xuICAgICAgICAgIHZhciBzdGFydDtcbiAgICAgICAgICB2YXIgaWRlbnRpZmllcjtcbiAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FscGhhKHN0cmVhbVt0aGlzLl9jdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSB0aGlzLl9jb25zdW1lVW5xdW90ZWRJZGVudGlmaWVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX1VOUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBiYXNpY1Rva2Vuc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN0cmVhbVt0aGlzLl9jdXJyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLl9jdXJyZW50fSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTnVtYmVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBpbmNyZW1lbnQgdGhpcy5fY3VycmVudC4gIFRoaXMgaGFwcGVuc1xuICAgICAgICAgICAgICAgICAgLy8gaW4gX2NvbnN1bWVMQnJhY2tldFxuICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9jb25zdW1lTEJyYWNrZXQoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiXFxcIlwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVF1b3RlZElkZW50aWZpZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUVVPVEVESURFTlRJRklFUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gdGhpcy5fY29uc3VtZVJhd1N0cmluZ0xpdGVyYWwoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfTElURVJBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiYFwiKSB7XG4gICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHRoaXMuX2NvbnN1bWVMaXRlcmFsKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogVE9LX0xJVEVSQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3JTdGFydFRva2VuW3N0cmVhbVt0aGlzLl9jdXJyZW50XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcy5fY29uc3VtZU9wZXJhdG9yKHN0cmVhbSkpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNraXBDaGFyc1tzdHJlYW1bdGhpcy5fY3VycmVudF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCImXCIpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiJlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfQU5ELCB2YWx1ZTogXCImJlwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FWFBSRUYsIHZhbHVlOiBcIiZcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcInxcIikge1xuICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19PUiwgdmFsdWU6IFwifHxcIiwgc3RhcnQ6IHN0YXJ0fSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt0eXBlOiBUT0tfUElQRSwgdmFsdWU6IFwifFwiLCBzdGFydDogc3RhcnR9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlVua25vd24gY2hhcmFjdGVyOlwiICsgc3RyZWFtW3RoaXMuX2N1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIkxleGVyRXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVVucXVvdGVkSWRlbnRpZmllcjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQgPCBzdHJlYW0ubGVuZ3RoICYmIGlzQWxwaGFOdW0oc3RyZWFtW3RoaXMuX2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVRdW90ZWRJZGVudGlmaWVyOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdICE9PSBcIlxcXCJcIiAmJiB0aGlzLl9jdXJyZW50IDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIFlvdSBjYW4gZXNjYXBlIGEgZG91YmxlIHF1b3RlIGFuZCB5b3UgY2FuIGVzY2FwZSBhbiBlc2NhcGUuXG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVtjdXJyZW50XSA9PT0gXCJcXFxcXCIgJiYgKHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcXFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbVtjdXJyZW50ICsgMV0gPT09IFwiXFxcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZVJhd1N0cmluZ0xpdGVyYWw6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiJ1wiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBzaW5nbGUgcXVvdGUgYW5kIHlvdSBjYW4gZXNjYXBlIGFuIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCInXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICB2YXIgbGl0ZXJhbCA9IHN0cmVhbS5zbGljZShzdGFydCArIDEsIHRoaXMuX2N1cnJlbnQgLSAxKTtcbiAgICAgICAgICByZXR1cm4gbGl0ZXJhbC5yZXBsYWNlKFwiXFxcXCdcIiwgXCInXCIpO1xuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVOdW1iZXI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpc051bShzdHJlYW1bdGhpcy5fY3VycmVudF0pICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZUludChzdHJlYW0uc2xpY2Uoc3RhcnQsIHRoaXMuX2N1cnJlbnQpKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFRPS19OVU1CRVIsIHZhbHVlOiB2YWx1ZSwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgIH0sXG5cbiAgICAgIF9jb25zdW1lTEJyYWNrZXQ6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIGlmIChzdHJlYW1bdGhpcy5fY3VycmVudF0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfRklMVEVSLCB2YWx1ZTogXCJbP1wiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIl1cIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0ZMQVRURU4sIHZhbHVlOiBcIltdXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTEJSQUNLRVQsIHZhbHVlOiBcIltcIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfY29uc3VtZU9wZXJhdG9yOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgIHZhciBzdGFydGluZ0NoYXIgPSBzdHJlYW1bc3RhcnRdO1xuICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICBpZiAoc3RhcnRpbmdDaGFyID09PSBcIiFcIikge1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW3RoaXMuX2N1cnJlbnRdID09PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTkUsIHZhbHVlOiBcIiE9XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfTk9ULCB2YWx1ZTogXCIhXCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xURSwgdmFsdWU6IFwiPD1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0xULCB2YWx1ZTogXCI8XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dURSwgdmFsdWU6IFwiPj1cIiwgc3RhcnQ6IHN0YXJ0fTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0dULCB2YWx1ZTogXCI+XCIsIHN0YXJ0OiBzdGFydH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nQ2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0cmVhbVt0aGlzLl9jdXJyZW50XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0VRLCB2YWx1ZTogXCI9PVwiLCBzdGFydDogc3RhcnR9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX2NvbnN1bWVMaXRlcmFsOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Kys7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fY3VycmVudDtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGl0ZXJhbDtcbiAgICAgICAgICB3aGlsZShzdHJlYW1bdGhpcy5fY3VycmVudF0gIT09IFwiYFwiICYmIHRoaXMuX2N1cnJlbnQgPCBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gWW91IGNhbiBlc2NhcGUgYSBsaXRlcmFsIGNoYXIgb3IgeW91IGNhbiBlc2NhcGUgdGhlIGVzY2FwZS5cbiAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RyZWFtW2N1cnJlbnRdID09PSBcIlxcXFxcIiAmJiAoc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJcXFxcXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtW2N1cnJlbnQgKyAxXSA9PT0gXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsaXRlcmFsU3RyaW5nID0gdHJpbUxlZnQoc3RyZWFtLnNsaWNlKHN0YXJ0LCB0aGlzLl9jdXJyZW50KSk7XG4gICAgICAgICAgbGl0ZXJhbFN0cmluZyA9IGxpdGVyYWxTdHJpbmcucmVwbGFjZShcIlxcXFxgXCIsIFwiYFwiKTtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va3NMaWtlSlNPTihsaXRlcmFsU3RyaW5nKSkge1xuICAgICAgICAgICAgICBsaXRlcmFsID0gSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gSlNPTiBwYXJzZSBpdCBhcyBcIjxsaXRlcmFsPlwiXG4gICAgICAgICAgICAgIGxpdGVyYWwgPSBKU09OLnBhcnNlKFwiXFxcIlwiICsgbGl0ZXJhbFN0cmluZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gKzEgZ2V0cyB1cyB0byB0aGUgZW5kaW5nIFwiYFwiLCArMSB0byBtb3ZlIG9uIHRvIHRoZSBuZXh0IGNoYXIuXG4gICAgICAgICAgdGhpcy5fY3VycmVudCsrO1xuICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgfSxcblxuICAgICAgX2xvb2tzTGlrZUpTT046IGZ1bmN0aW9uKGxpdGVyYWxTdHJpbmcpIHtcbiAgICAgICAgICB2YXIgc3RhcnRpbmdDaGFycyA9IFwiW3tcXFwiXCI7XG4gICAgICAgICAgdmFyIGpzb25MaXRlcmFscyA9IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm51bGxcIl07XG4gICAgICAgICAgdmFyIG51bWJlckxvb2tpbmcgPSBcIi0wMTIzNDU2Nzg5XCI7XG5cbiAgICAgICAgICBpZiAobGl0ZXJhbFN0cmluZyA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydGluZ0NoYXJzLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGpzb25MaXRlcmFscy5pbmRleE9mKGxpdGVyYWxTdHJpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChudW1iZXJMb29raW5nLmluZGV4T2YobGl0ZXJhbFN0cmluZ1swXSkgPj0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShsaXRlcmFsU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICAgICAgdmFyIGJpbmRpbmdQb3dlciA9IHt9O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FT0ZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfVU5RVU9URURJREVOVElGSUVSXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1FVT1RFRElERU5USUZJRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUkJSQUNLRVRdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUlBBUkVOXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0NPTU1BXSA9IDA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1JCUkFDRV0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OVU1CRVJdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfQ1VSUkVOVF0gPSAwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19FWFBSRUZdID0gMDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfUElQRV0gPSAxO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19PUl0gPSAyO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19BTkRdID0gMztcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRVFdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTFRdID0gNTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfR1RFXSA9IDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xURV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19ORV0gPSA1O1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19GTEFUVEVOXSA9IDk7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX1NUQVJdID0gMjA7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0ZJTFRFUl0gPSAyMTtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfRE9UXSA9IDQwO1xuICAgICAgYmluZGluZ1Bvd2VyW1RPS19OT1RdID0gNDU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xCUkFDRV0gPSA1MDtcbiAgICAgIGJpbmRpbmdQb3dlcltUT0tfTEJSQUNLRVRdID0gNTU7XG4gICAgICBiaW5kaW5nUG93ZXJbVE9LX0xQQVJFTl0gPSA2MDtcblxuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gIH1cblxuICBQYXJzZXIucHJvdG90eXBlID0ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLl9sb2FkVG9rZW5zKGV4cHJlc3Npb24pO1xuICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgIHZhciBhc3QgPSB0aGlzLmV4cHJlc3Npb24oMCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX0VPRikge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgdG9rZW4gdHlwZTogXCIgKyB0LnR5cGUgKyBcIiwgdmFsdWU6IFwiICsgdC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgfSxcblxuICAgICAgX2xvYWRUb2tlbnM6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgICB2YXIgdG9rZW5zID0gbGV4ZXIudG9rZW5pemUoZXhwcmVzc2lvbik7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFRPS19FT0YsIHZhbHVlOiBcIlwiLCBzdGFydDogZXhwcmVzc2lvbi5sZW5ndGh9KTtcbiAgICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgIH0sXG5cbiAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciBsZWZ0VG9rZW4gPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm51ZChsZWZ0VG9rZW4pO1xuICAgICAgICAgIHZhciBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgd2hpbGUgKHJicCA8IGJpbmRpbmdQb3dlcltjdXJyZW50VG9rZW5dKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgbGVmdCA9IHRoaXMubGVkKGN1cnJlbnRUb2tlbiwgbGVmdCk7XG4gICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9LFxuXG4gICAgICBfbG9va2FoZWFkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleCArIG51bWJlcl0udHlwZTtcbiAgICAgIH0sXG5cbiAgICAgIF9sb29rYWhlYWRUb2tlbjogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaW5kZXggKyBudW1iZXJdO1xuICAgICAgfSxcblxuICAgICAgX2FkdmFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgIH0sXG5cbiAgICAgIG51ZDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIHZhciByaWdodDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgVE9LX0xJVEVSQUw6XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTGl0ZXJhbFwiLCB2YWx1ZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgIGNhc2UgVE9LX1VOUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJGaWVsZFwiLCBuYW1lOiB0b2tlbi52YWx1ZX07XG4gICAgICAgICAgY2FzZSBUT0tfUVVPVEVESURFTlRJRklFUjpcbiAgICAgICAgICAgIHZhciBub2RlID0ge3R5cGU6IFwiRmllbGRcIiwgbmFtZTogdG9rZW4udmFsdWV9O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0xQQVJFTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RlZCBpZGVudGlmaWVyIG5vdCBhbGxvd2VkIGZvciBmdW5jdGlvbiBuYW1lcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICBjYXNlIFRPS19OT1Q6XG4gICAgICAgICAgICByaWdodCA9IHRoaXMuZXhwcmVzc2lvbihiaW5kaW5nUG93ZXIuTm90KTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJOb3RFeHByZXNzaW9uXCIsIGNoaWxkcmVuOiBbcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19TVEFSOlxuICAgICAgICAgICAgbGVmdCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgcmlnaHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1JCUkFDS0VUKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIGEgbXVsdGlzZWxlY3QsXG4gICAgICAgICAgICAgICAgLy8gW2EsIGIsICpdXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB7dHlwZTogXCJJZGVudGl0eVwifTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlZhbHVlUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVkKHRva2VuLnR5cGUsIHt0eXBlOiBcIklkZW50aXR5XCJ9KTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0U6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VNdWx0aXNlbGVjdEhhc2goKTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgbGVmdCA9IHt0eXBlOiBUT0tfRkxBVFRFTiwgY2hpbGRyZW46IFt7dHlwZTogXCJJZGVudGl0eVwifV19O1xuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xCUkFDS0VUOlxuICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX05VTUJFUiB8fCB0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT0xPTikge1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VJbmRleEV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvamVjdElmU2xpY2Uoe3R5cGU6IFwiSWRlbnRpdHlcIn0sIHJpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfU1RBUiAmJlxuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb29rYWhlYWQoMSkgPT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJQcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW3t0eXBlOiBcIklkZW50aXR5XCJ9LCByaWdodF19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgY2FzZSBUT0tfQ1VSUkVOVDpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgIGNhc2UgVE9LX0VYUFJFRjpcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLkV4cHJlZik7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRXhwcmVzc2lvblJlZmVyZW5jZVwiLCBjaGlsZHJlbjogW2V4cHJlc3Npb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19MUEFSRU46XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SUEFSRU4pO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBsZWQ6IGZ1bmN0aW9uKHRva2VuTmFtZSwgbGVmdCkge1xuICAgICAgICB2YXIgcmlnaHQ7XG4gICAgICAgIHN3aXRjaCh0b2tlbk5hbWUpIHtcbiAgICAgICAgICBjYXNlIFRPS19ET1Q6XG4gICAgICAgICAgICB2YXIgcmJwID0gYmluZGluZ1Bvd2VyLkRvdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19TVEFSKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZURvdFJIUyhyYnApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJTdWJleHByZXNzaW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0aW5nIGEgcHJvamVjdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKHJicCk7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiVmFsdWVQcm9qZWN0aW9uXCIsIGNoaWxkcmVuOiBbbGVmdCwgcmlnaHRdfTtcbiAgICAgICAgICBjYXNlIFRPS19QSVBFOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLlBpcGUpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBUT0tfUElQRSwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX09SOlxuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyLk9yKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogXCJPckV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0FORDpcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKGJpbmRpbmdQb3dlci5BbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkFuZEV4cHJlc3Npb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGNhc2UgVE9LX0xQQVJFTjpcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGVmdC5uYW1lO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uLCBub2RlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2xvb2thaGVhZCgwKSAhPT0gVE9LX1JQQVJFTikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfQ1VSUkVOVCkge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB7dHlwZTogVE9LX0NVUlJFTlR9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19DT01NQSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JQQVJFTik7XG4gICAgICAgICAgICBub2RlID0ge3R5cGU6IFwiRnVuY3Rpb25cIiwgbmFtZTogbmFtZSwgY2hpbGRyZW46IGFyZ3N9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgY2FzZSBUT0tfRklMVEVSOlxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRkxBVFRFTikge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiRmlsdGVyUHJvamVjdGlvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0LCBjb25kaXRpb25dfTtcbiAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgdmFyIGxlZnROb2RlID0ge3R5cGU6IFRPS19GTEFUVEVOLCBjaGlsZHJlbjogW2xlZnRdfTtcbiAgICAgICAgICAgIHZhciByaWdodE5vZGUgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLkZsYXR0ZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0Tm9kZSwgcmlnaHROb2RlXX07XG4gICAgICAgICAgY2FzZSBUT0tfRVE6XG4gICAgICAgICAgY2FzZSBUT0tfTkU6XG4gICAgICAgICAgY2FzZSBUT0tfR1Q6XG4gICAgICAgICAgY2FzZSBUT0tfR1RFOlxuICAgICAgICAgIGNhc2UgVE9LX0xUOlxuICAgICAgICAgIGNhc2UgVE9LX0xURTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUNvbXBhcmF0b3IobGVmdCwgdG9rZW5OYW1lKTtcbiAgICAgICAgICBjYXNlIFRPS19MQlJBQ0tFVDpcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRPS19OVU1CRVIgfHwgdG9rZW4udHlwZSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZUluZGV4RXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0SWZTbGljZShsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfU1RBUik7XG4gICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLl9wYXJzZVByb2plY3Rpb25SSFMoYmluZGluZ1Bvd2VyLlN0YXIpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBcIlByb2plY3Rpb25cIiwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLl9lcnJvclRva2VuKHRoaXMuX2xvb2thaGVhZFRva2VuKDApKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgX21hdGNoOiBmdW5jdGlvbih0b2tlblR5cGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSB0b2tlblR5cGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCk7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkV4cGVjdGVkIFwiICsgdG9rZW5UeXBlICsgXCIsIGdvdDogXCIgKyB0LnR5cGUpO1xuICAgICAgICAgICAgICBlcnJvci5uYW1lID0gXCJQYXJzZXJFcnJvclwiO1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfZXJyb3JUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuIChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgKyBcIik6IFxcXCJcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlICsgXCJcXFwiXCIpO1xuICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9LFxuXG5cbiAgICAgIF9wYXJzZUluZGV4RXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0NPTE9OIHx8IHRoaXMuX2xvb2thaGVhZCgxKSA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZVNsaWNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJJbmRleFwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2xvb2thaGVhZFRva2VuKDApLnZhbHVlfTtcbiAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfUkJSQUNLRVQpO1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBfcHJvamVjdElmU2xpY2U6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGluZGV4RXhwciA9IHt0eXBlOiBcIkluZGV4RXhwcmVzc2lvblwiLCBjaGlsZHJlbjogW2xlZnQsIHJpZ2h0XX07XG4gICAgICAgICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwiU2xpY2VcIikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJQcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW2luZGV4RXhwciwgdGhpcy5fcGFyc2VQcm9qZWN0aW9uUkhTKGJpbmRpbmdQb3dlci5TdGFyKV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXhFeHByO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZVNsaWNlRXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gW3N0YXJ0OmVuZDpzdGVwXSB3aGVyZSBlYWNoIHBhcnQgaXMgb3B0aW9uYWwsIGFzIHdlbGwgYXMgdGhlIGxhc3RcbiAgICAgICAgICAvLyBjb2xvbi5cbiAgICAgICAgICB2YXIgcGFydHMgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgY3VycmVudFRva2VuID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIHdoaWxlIChjdXJyZW50VG9rZW4gIT09IFRPS19SQlJBQ0tFVCAmJiBpbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUb2tlbiA9PT0gVE9LX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUb2tlbiA9PT0gVE9LX05VTUJFUikge1xuICAgICAgICAgICAgICAgICAgcGFydHNbaW5kZXhdID0gdGhpcy5fbG9va2FoZWFkVG9rZW4oMCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xvb2thaGVhZCgwKTtcbiAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5leHBlY3RlZCB0b2tlbjogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudmFsdWUgKyBcIihcIiArIHQudHlwZSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlcmVycm9yXCI7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSB0aGlzLl9sb29rYWhlYWQoMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19SQlJBQ0tFVCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJTbGljZVwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogcGFydHNcbiAgICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlQ29tcGFyYXRvcjogZnVuY3Rpb24obGVmdCwgY29tcGFyYXRvcikge1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24oYmluZGluZ1Bvd2VyW2NvbXBhcmF0b3JdKTtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBcIkNvbXBhcmF0b3JcIiwgbmFtZTogY29tcGFyYXRvciwgY2hpbGRyZW46IFtsZWZ0LCByaWdodF19O1xuICAgICAgfSxcblxuICAgICAgX3BhcnNlRG90UkhTOiBmdW5jdGlvbihyYnApIHtcbiAgICAgICAgICB2YXIgbG9va2FoZWFkID0gdGhpcy5fbG9va2FoZWFkKDApO1xuICAgICAgICAgIHZhciBleHByVG9rZW5zID0gW1RPS19VTlFVT1RFRElERU5USUZJRVIsIFRPS19RVU9URURJREVOVElGSUVSLCBUT0tfU1RBUl07XG4gICAgICAgICAgaWYgKGV4cHJUb2tlbnMuaW5kZXhPZihsb29rYWhlYWQpID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbihyYnApO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9va2FoZWFkID09PSBUT0tfTEJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0xCUkFDS0VUKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlTXVsdGlzZWxlY3RMaXN0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsb29rYWhlYWQgPT09IFRPS19MQlJBQ0UpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0xCUkFDRSk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZU11bHRpc2VsZWN0SGFzaCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIF9wYXJzZVByb2plY3Rpb25SSFM6IGZ1bmN0aW9uKHJicCkge1xuICAgICAgICAgIHZhciByaWdodDtcbiAgICAgICAgICBpZiAoYmluZGluZ1Bvd2VyW3RoaXMuX2xvb2thaGVhZCgwKV0gPCAxMCkge1xuICAgICAgICAgICAgICByaWdodCA9IHt0eXBlOiBcIklkZW50aXR5XCJ9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfTEJSQUNLRVQpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmV4cHJlc3Npb24ocmJwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0ZJTFRFUikge1xuICAgICAgICAgICAgICByaWdodCA9IHRoaXMuZXhwcmVzc2lvbihyYnApO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbG9va2FoZWFkKDApID09PSBUT0tfRE9UKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21hdGNoKFRPS19ET1QpO1xuICAgICAgICAgICAgICByaWdodCA9IHRoaXMuX3BhcnNlRG90UkhTKHJicCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLl9sb29rYWhlYWRUb2tlbigwKTtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiU3l0YW54IGVycm9yLCB1bmV4cGVjdGVkIHRva2VuOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnZhbHVlICsgXCIoXCIgKyB0LnR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBcIlBhcnNlckVycm9yXCI7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VNdWx0aXNlbGVjdExpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICAgIHdoaWxlICh0aGlzLl9sb29rYWhlYWQoMCkgIT09IFRPS19SQlJBQ0tFVCkge1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMuZXhwcmVzc2lvbigwKTtcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX0NPTU1BKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfQ09NTUEpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1JCUkFDS0VUKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gUmJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDS0VUKTtcbiAgICAgICAgICByZXR1cm4ge3R5cGU6IFwiTXVsdGlTZWxlY3RMaXN0XCIsIGNoaWxkcmVuOiBleHByZXNzaW9uc307XG4gICAgICB9LFxuXG4gICAgICBfcGFyc2VNdWx0aXNlbGVjdEhhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXJUeXBlcyA9IFtUT0tfVU5RVU9URURJREVOVElGSUVSLCBUT0tfUVVPVEVESURFTlRJRklFUl07XG4gICAgICAgIHZhciBrZXlUb2tlbiwga2V5TmFtZSwgdmFsdWUsIG5vZGU7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBrZXlUb2tlbiA9IHRoaXMuX2xvb2thaGVhZFRva2VuKDApO1xuICAgICAgICAgIGlmIChpZGVudGlmaWVyVHlwZXMuaW5kZXhPZihrZXlUb2tlbi50eXBlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhbiBpZGVudGlmaWVyIHRva2VuLCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlUb2tlbi50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5TmFtZSA9IGtleVRva2VuLnZhbHVlO1xuICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICB0aGlzLl9tYXRjaChUT0tfQ09MT04pO1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5leHByZXNzaW9uKDApO1xuICAgICAgICAgIG5vZGUgPSB7dHlwZTogXCJLZXlWYWx1ZVBhaXJcIiwgbmFtZToga2V5TmFtZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgICBwYWlycy5wdXNoKG5vZGUpO1xuICAgICAgICAgIGlmICh0aGlzLl9sb29rYWhlYWQoMCkgPT09IFRPS19DT01NQSkge1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX0NPTU1BKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xvb2thaGVhZCgwKSA9PT0gVE9LX1JCUkFDRSkge1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2goVE9LX1JCUkFDRSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpU2VsZWN0SGFzaFwiLCBjaGlsZHJlbjogcGFpcnN9O1xuICAgICAgfVxuICB9O1xuXG5cbiAgZnVuY3Rpb24gVHJlZUludGVycHJldGVyKHJ1bnRpbWUpIHtcbiAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICB9XG5cbiAgVHJlZUludGVycHJldGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIHNlYXJjaDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLCB2YWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB2aXNpdDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlZCwgY3VycmVudCwgcmVzdWx0LCBmaXJzdCwgc2Vjb25kLCBmaWVsZCwgbGVmdCwgcmlnaHQsIGNvbGxlY3RlZCwgaTtcbiAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkZpZWxkXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkID0gdmFsdWVbbm9kZS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJTdWJleHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmlnaHQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGxlZnQpO1xuICAgICAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlIFwiSW5kZXhcIjpcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHZhbHVlLmxlbmd0aCArIGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIlNsaWNlXCI6XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgc2xpY2VQYXJhbXMgPSBub2RlLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICAgICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVTbGljZVBhcmFtcyh2YWx1ZS5sZW5ndGgsIHNsaWNlUGFyYW1zKTtcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tcHV0ZWRbMF07XG4gICAgICAgICAgICAgIHZhciBzdG9wID0gY29tcHV0ZWRbMV07XG4gICAgICAgICAgICAgIHZhciBzdGVwID0gY29tcHV0ZWRbMl07XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIGNhc2UgXCJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGxlZnQgY2hpbGQuXG4gICAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmICghaXNBcnJheShiYXNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMV0sIGJhc2VbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJWYWx1ZVByb2plY3Rpb25cIjpcbiAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbGVmdCBjaGlsZC5cbiAgICAgICAgICAgICAgYmFzZSA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sbGVjdGVkID0gW107XG4gICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBvYmpWYWx1ZXMoYmFzZSk7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZDtcbiAgICAgICAgICAgIGNhc2UgXCJGaWx0ZXJQcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgIGJhc2UgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gW107XG4gICAgICAgICAgICAgIHZhciBmaW5hbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzJdLCBiYXNlW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmFsc2UobWF0Y2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goYmFzZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsdGVyZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCBmaWx0ZXJlZFtqXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsUmVzdWx0cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmluYWxSZXN1bHRzO1xuICAgICAgICAgICAgY2FzZSBcIkNvbXBhcmF0b3JcIjpcbiAgICAgICAgICAgICAgZmlyc3QgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgc2Vjb25kID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHN3aXRjaChub2RlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19FUTpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX05FOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIXN0cmljdERlZXBFcXVhbChmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVE9LX0dUOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPiBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19HVEU6XG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdCA+PSBzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRPS19MVDpcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0IDwgc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUT0tfTFRFOlxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3QgPD0gc2Vjb25kO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY29tcGFyYXRvcjogXCIgKyBub2RlLm5hbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBjYXNlIFRPS19GTEFUVEVOOlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yaWdpbmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaC5hcHBseShtZXJnZWQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgICAgIGNhc2UgXCJJZGVudGl0eVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RMaXN0XCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0ZWQ7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlTZWxlY3RIYXNoXCI6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbGxlY3RlZCA9IHt9O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RlZFtjaGlsZC5uYW1lXSA9IHRoaXMudmlzaXQoY2hpbGQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgICAgICAgICAgY2FzZSBcIk9yRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzBdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKG1hdGNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICAgICAgICBjYXNlIFwiQW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpc0ZhbHNlKGZpcnN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdChub2RlLmNoaWxkcmVuWzFdLCB2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiTm90RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBmaXJzdCA9IHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblswXSwgdmFsdWUpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNGYWxzZShmaXJzdCk7XG4gICAgICAgICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgVE9LX1BJUEU6XG4gICAgICAgICAgICAgIGxlZnQgPSB0aGlzLnZpc2l0KG5vZGUuY2hpbGRyZW5bMF0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXQobm9kZS5jaGlsZHJlblsxXSwgbGVmdCk7XG4gICAgICAgICAgICBjYXNlIFRPS19DVVJSRU5UOlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgdmFyIHJlc29sdmVkQXJncyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcmdzLnB1c2godGhpcy52aXNpdChub2RlLmNoaWxkcmVuW2ldLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bnRpbWUuY2FsbEZ1bmN0aW9uKG5vZGUubmFtZSwgcmVzb2x2ZWRBcmdzKTtcbiAgICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgIHZhciByZWZOb2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgLy8gVGFnIHRoZSBub2RlIHdpdGggYSBzcGVjaWZpYyBhdHRyaWJ1dGUgc28gdGhlIHR5cGVcbiAgICAgICAgICAgICAgLy8gY2hlY2tlciB2ZXJpZnkgdGhlIHR5cGUuXG4gICAgICAgICAgICAgIHJlZk5vZGUuam1lc3BhdGhUeXBlID0gVE9LX0VYUFJFRjtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZk5vZGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBub2RlLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGNvbXB1dGVTbGljZVBhcmFtczogZnVuY3Rpb24oYXJyYXlMZW5ndGgsIHNsaWNlUGFyYW1zKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHNsaWNlUGFyYW1zWzBdO1xuICAgICAgICB2YXIgc3RvcCA9IHNsaWNlUGFyYW1zWzFdO1xuICAgICAgICB2YXIgc3RlcCA9IHNsaWNlUGFyYW1zWzJdO1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XG4gICAgICAgICAgc3RlcCA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkludmFsaWQgc2xpY2UsIHN0ZXAgY2Fubm90IGJlIDBcIik7XG4gICAgICAgICAgZXJyb3IubmFtZSA9IFwiUnVudGltZUVycm9yXCI7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ZXBWYWx1ZU5lZ2F0aXZlID0gc3RlcCA8IDAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gYXJyYXlMZW5ndGggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5jYXBTbGljZVJhbmdlKGFycmF5TGVuZ3RoLCBzdGFydCwgc3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcCA9IHN0ZXBWYWx1ZU5lZ2F0aXZlID8gLTEgOiBhcnJheUxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3AgPSB0aGlzLmNhcFNsaWNlUmFuZ2UoYXJyYXlMZW5ndGgsIHN0b3AsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkWzBdID0gc3RhcnQ7XG4gICAgICAgIGNvbXB1dGVkWzFdID0gc3RvcDtcbiAgICAgICAgY29tcHV0ZWRbMl0gPSBzdGVwO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgICB9LFxuXG4gICAgICBjYXBTbGljZVJhbmdlOiBmdW5jdGlvbihhcnJheUxlbmd0aCwgYWN0dWFsVmFsdWUsIHN0ZXApIHtcbiAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgIGFjdHVhbFZhbHVlICs9IGFycmF5TGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYWN0dWFsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gLTEgOiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWxWYWx1ZSA+PSBhcnJheUxlbmd0aCkge1xuICAgICAgICAgICAgICBhY3R1YWxWYWx1ZSA9IHN0ZXAgPCAwID8gYXJyYXlMZW5ndGggLSAxIDogYXJyYXlMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY3R1YWxWYWx1ZTtcbiAgICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIFJ1bnRpbWUoaW50ZXJwcmV0ZXIpIHtcbiAgICB0aGlzLl9pbnRlcnByZXRlciA9IGludGVycHJldGVyO1xuICAgIHRoaXMuZnVuY3Rpb25UYWJsZSA9IHtcbiAgICAgICAgLy8gbmFtZTogW2Z1bmN0aW9uLCA8c2lnbmF0dXJlPl1cbiAgICAgICAgLy8gVGhlIDxzaWduYXR1cmU+IGNhbiBiZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGFyZ3M6IFtbdHlwZTEsIHR5cGUyXSwgW3R5cGUxLCB0eXBlMl1dLFxuICAgICAgICAvLyAgIHZhcmlhZGljOiB0cnVlfGZhbHNlXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRWFjaCBhcmcgaW4gdGhlIGFyZyBsaXN0IGlzIGEgbGlzdCBvZiB2YWxpZCB0eXBlc1xuICAgICAgICAvLyAoaWYgdGhlIGZ1bmN0aW9uIGlzIG92ZXJsb2FkZWQgYW5kIHN1cHBvcnRzIG11bHRpcGxlXG4gICAgICAgIC8vIHR5cGVzLiAgSWYgdGhlIHR5cGUgaXMgXCJhbnlcIiB0aGVuIG5vIHR5cGUgY2hlY2tpbmdcbiAgICAgICAgLy8gb2NjdXJzIG9uIHRoZSBhcmd1bWVudC4gIFZhcmlhZGljIGlzIG9wdGlvbmFsXG4gICAgICAgIC8vIGFuZCBpZiBub3QgcHJvdmlkZWQgaXMgYXNzdW1lZCB0byBiZSBmYWxzZS5cbiAgICAgICAgYWJzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQWJzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBhdmc6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25BdmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIGNlaWw6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25DZWlsLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBjb250YWluczoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uQ29udGFpbnMsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJlbmRzX3dpdGhcIjoge1xuICAgICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uRW5kc1dpdGgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkddfSwge3R5cGVzOiBbVFlQRV9TVFJJTkddfV19LFxuICAgICAgICBmbG9vcjoge19mdW5jOiB0aGlzLl9mdW5jdGlvbkZsb29yLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9OVU1CRVJdfV19LFxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkxlbmd0aCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX1NUUklORywgVFlQRV9BUlJBWSwgVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1hcCxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0VYUFJFRl19LCB7dHlwZXM6IFtUWVBFX0FSUkFZXX1dfSxcbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NYXgsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtZXJnZVwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NZXJnZSxcbiAgICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX09CSkVDVF0sIHZhcmlhZGljOiB0cnVlfV1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYXhfYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1heEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHN1bToge19mdW5jOiB0aGlzLl9mdW5jdGlvblN1bSwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfTlVNQkVSXX1dfSxcbiAgICAgICAgXCJzdGFydHNfd2l0aFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25TdGFydHNXaXRoLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfU1RSSU5HXX0sIHt0eXBlczogW1RZUEVfU1RSSU5HXX1dfSxcbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25NaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BUlJBWV9OVU1CRVIsIFRZUEVfQVJSQVlfU1RSSU5HXX1dfSxcbiAgICAgICAgXCJtaW5fYnlcIjoge1xuICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbk1pbkJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25UeXBlLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBrZXlzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uS2V5cywgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfT0JKRUNUXX1dfSxcbiAgICAgICAgdmFsdWVzOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVmFsdWVzLCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9PQkpFQ1RdfV19LFxuICAgICAgICBzb3J0OiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydCwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQVJSQVlfU1RSSU5HLCBUWVBFX0FSUkFZX05VTUJFUl19XX0sXG4gICAgICAgIFwic29ydF9ieVwiOiB7XG4gICAgICAgICAgX2Z1bmM6IHRoaXMuX2Z1bmN0aW9uU29ydEJ5LFxuICAgICAgICAgIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FSUkFZXX0sIHt0eXBlczogW1RZUEVfRVhQUkVGXX1dXG4gICAgICAgIH0sXG4gICAgICAgIGpvaW46IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvbkpvaW4sXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbXG4gICAgICAgICAgICAgICAge3R5cGVzOiBbVFlQRV9TVFJJTkddfSxcbiAgICAgICAgICAgICAgICB7dHlwZXM6IFtUWVBFX0FSUkFZX1NUUklOR119XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICAgIF9mdW5jOiB0aGlzLl9mdW5jdGlvblJldmVyc2UsXG4gICAgICAgICAgICBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9TVFJJTkcsIFRZUEVfQVJSQVldfV19LFxuICAgICAgICBcInRvX2FycmF5XCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub0FycmF5LCBfc2lnbmF0dXJlOiBbe3R5cGVzOiBbVFlQRV9BTlldfV19LFxuICAgICAgICBcInRvX3N0cmluZ1wiOiB7X2Z1bmM6IHRoaXMuX2Z1bmN0aW9uVG9TdHJpbmcsIF9zaWduYXR1cmU6IFt7dHlwZXM6IFtUWVBFX0FOWV19XX0sXG4gICAgICAgIFwidG9fbnVtYmVyXCI6IHtfZnVuYzogdGhpcy5fZnVuY3Rpb25Ub051bWJlciwgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXX1dfSxcbiAgICAgICAgXCJub3RfbnVsbFwiOiB7XG4gICAgICAgICAgICBfZnVuYzogdGhpcy5fZnVuY3Rpb25Ob3ROdWxsLFxuICAgICAgICAgICAgX3NpZ25hdHVyZTogW3t0eXBlczogW1RZUEVfQU5ZXSwgdmFyaWFkaWM6IHRydWV9XVxuICAgICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFJ1bnRpbWUucHJvdG90eXBlID0ge1xuICAgIGNhbGxGdW5jdGlvbjogZnVuY3Rpb24obmFtZSwgcmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgZnVuY3Rpb25FbnRyeSA9IHRoaXMuZnVuY3Rpb25UYWJsZVtuYW1lXTtcbiAgICAgIGlmIChmdW5jdGlvbkVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1bmN0aW9uOiBcIiArIG5hbWUgKyBcIigpXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsaWRhdGVBcmdzKG5hbWUsIHJlc29sdmVkQXJncywgZnVuY3Rpb25FbnRyeS5fc2lnbmF0dXJlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbkVudHJ5Ll9mdW5jLmNhbGwodGhpcywgcmVzb2x2ZWRBcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlQXJnczogZnVuY3Rpb24obmFtZSwgYXJncywgc2lnbmF0dXJlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRpbmcgdGhlIGFyZ3MgcmVxdWlyZXMgdmFsaWRhdGluZ1xuICAgICAgICAvLyB0aGUgY29ycmVjdCBhcml0eSBhbmQgdGhlIGNvcnJlY3QgdHlwZSBvZiBlYWNoIGFyZy5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgZGVjbGFyZWQgYXMgdmFyaWFkaWMsIHRoZW4gd2UgbmVlZFxuICAgICAgICAvLyBhIG1pbmltdW0gbnVtYmVyIG9mIGFyZ3MgdG8gYmUgcmVxdWlyZWQuICBPdGhlcndpc2UgaXQgaGFzIHRvXG4gICAgICAgIC8vIGJlIGFuIGV4YWN0IGFtb3VudC5cbiAgICAgICAgdmFyIHBsdXJhbGl6ZWQ7XG4gICAgICAgIGlmIChzaWduYXR1cmVbc2lnbmF0dXJlLmxlbmd0aCAtIDFdLnZhcmlhZGljKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGx1cmFsaXplZCA9IHNpZ25hdHVyZS5sZW5ndGggPT09IDEgPyBcIiBhcmd1bWVudFwiIDogXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgYXQgbGVhc3RcIiArIHNpZ25hdHVyZS5sZW5ndGggKyBwbHVyYWxpemVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoICE9PSBzaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBwbHVyYWxpemVkID0gc2lnbmF0dXJlLmxlbmd0aCA9PT0gMSA/IFwiIGFyZ3VtZW50XCIgOiBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50RXJyb3I6IFwiICsgbmFtZSArIFwiKCkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFrZXMgXCIgKyBzaWduYXR1cmUubGVuZ3RoICsgcGx1cmFsaXplZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIFwiICsgYXJncy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50U3BlYztcbiAgICAgICAgdmFyIGFjdHVhbFR5cGU7XG4gICAgICAgIHZhciB0eXBlTWF0Y2hlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjdXJyZW50U3BlYyA9IHNpZ25hdHVyZVtpXS50eXBlcztcbiAgICAgICAgICAgIGFjdHVhbFR5cGUgPSB0aGlzLl9nZXRUeXBlTmFtZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY3VycmVudFNwZWMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZU1hdGNoZXMoYWN0dWFsVHlwZSwgY3VycmVudFNwZWNbal0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0eXBlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IGN1cnJlbnRTcGVjXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odHlwZUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUWVBFX05BTUVfVEFCTEVbdHlwZUlkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvcjogXCIgKyBuYW1lICsgXCIoKSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgYXJndW1lbnQgXCIgKyAoaSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gYmUgdHlwZSBcIiArIGV4cGVjdGVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYnV0IHJlY2VpdmVkIHR5cGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUWVBFX05BTUVfVEFCTEVbYWN0dWFsVHlwZV0gKyBcIiBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdHlwZU1hdGNoZXM6IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIGFyZ1ZhbHVlKSB7XG4gICAgICAgIGlmIChleHBlY3RlZCA9PT0gVFlQRV9BTlkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9TVFJJTkcgfHxcbiAgICAgICAgICAgIGV4cGVjdGVkID09PSBUWVBFX0FSUkFZX05VTUJFUiB8fFxuICAgICAgICAgICAgZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBleHBlY3RlZCB0eXBlIGNhbiBlaXRoZXIganVzdCBiZSBhcnJheSxcbiAgICAgICAgICAgIC8vIG9yIGl0IGNhbiByZXF1aXJlIGEgc3BlY2lmaWMgc3VidHlwZSAoYXJyYXkgb2YgbnVtYmVycykuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIHNpbXBsZXN0IGNhc2UgaXMgaWYgXCJhcnJheVwiIHdpdGggbm8gc3VidHlwZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsID09PSBUWVBFX0FSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IFRZUEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayBzdWJ0eXBlcy5cbiAgICAgICAgICAgICAgICAvLyBJIHRoaW5rIHRoaXMgaGFzIHBvdGVudGlhbCB0byBiZSBpbXByb3ZlZC5cbiAgICAgICAgICAgICAgICB2YXIgc3VidHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0ZWQgPT09IFRZUEVfQVJSQVlfTlVNQkVSKSB7XG4gICAgICAgICAgICAgICAgICBzdWJ0eXBlID0gVFlQRV9OVU1CRVI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZCA9PT0gVFlQRV9BUlJBWV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgIHN1YnR5cGUgPSBUWVBFX1NUUklORztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3R5cGVNYXRjaGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldFR5cGVOYW1lKGFyZ1ZhbHVlW2ldKSwgc3VidHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1ZhbHVlW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRUeXBlTmFtZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IFN0cmluZ11cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfU1RSSU5HO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgTnVtYmVyXVwiOlxuICAgICAgICAgICAgICByZXR1cm4gVFlQRV9OVU1CRVI7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfQVJSQVk7XG4gICAgICAgICAgICBjYXNlIFwiW29iamVjdCBCb29sZWFuXVwiOlxuICAgICAgICAgICAgICByZXR1cm4gVFlQRV9CT09MRUFOO1xuICAgICAgICAgICAgY2FzZSBcIltvYmplY3QgTnVsbF1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFRZUEVfTlVMTDtcbiAgICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IE9iamVjdF1cIjpcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhbiBleHByZWYuICBJZiBpdCBoYXMsIGl0J3MgYmVlblxuICAgICAgICAgICAgICAvLyB0YWdnZWQgd2l0aCBhIGptZXNwYXRoVHlwZSBhdHRyIG9mICdFeHByZWYnO1xuICAgICAgICAgICAgICBpZiAob2JqLmptZXNwYXRoVHlwZSA9PT0gVE9LX0VYUFJFRikge1xuICAgICAgICAgICAgICAgIHJldHVybiBUWVBFX0VYUFJFRjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVFlQRV9PQkpFQ1Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25TdGFydHNXaXRoOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1swXS5sYXN0SW5kZXhPZihyZXNvbHZlZEFyZ3NbMV0pID09PSAwO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25FbmRzV2l0aDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBzZWFyY2hTdHIgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIHZhciBzdWZmaXggPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHJldHVybiBzZWFyY2hTdHIuaW5kZXhPZihzdWZmaXgsIHNlYXJjaFN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblJldmVyc2U6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsU3RyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgIHZhciByZXZlcnNlZFN0ciA9IFwiXCI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IG9yaWdpbmFsU3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIHJldmVyc2VkU3RyICs9IG9yaWdpbmFsU3RyW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV2ZXJzZWRTdHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJldmVyc2VkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF0uc2xpY2UoMCk7XG4gICAgICAgICAgcmV2ZXJzZWRBcnJheS5yZXZlcnNlKCk7XG4gICAgICAgICAgcmV0dXJuIHJldmVyc2VkQXJyYXk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uQWJzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhyZXNvbHZlZEFyZ3NbMF0pO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25DZWlsOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChyZXNvbHZlZEFyZ3NbMF0pO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Bdmc6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgdmFyIGlucHV0QXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGlucHV0QXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bSAvIGlucHV0QXJyYXkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Db250YWluczogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0uaW5kZXhPZihyZXNvbHZlZEFyZ3NbMV0pID49IDA7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbkZsb29yOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTGVuZ3RoOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICBpZiAoIWlzT2JqZWN0KHJlc29sdmVkQXJnc1swXSkpIHtcbiAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF0ubGVuZ3RoO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAvLyBBcyBmYXIgYXMgSSBjYW4gdGVsbCwgdGhlcmUncyBubyB3YXkgdG8gZ2V0IHRoZSBsZW5ndGhcbiAgICAgICAgIC8vIG9mIGFuIG9iamVjdCB3aXRob3V0IE8obikgaXRlcmF0aW9uIHRocm91Z2ggdGhlIG9iamVjdC5cbiAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXNvbHZlZEFyZ3NbMF0pLmxlbmd0aDtcbiAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1hcDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICB2YXIgaW50ZXJwcmV0ZXIgPSB0aGlzLl9pbnRlcnByZXRlcjtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgdmFyIGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1hcHBlZC5wdXNoKGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGVsZW1lbnRzW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25NZXJnZTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgbWVyZ2VkID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHJlc29sdmVkQXJnc1tpXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgICBtZXJnZWRba2V5XSA9IGN1cnJlbnRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWF4OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIGlmIChyZXNvbHZlZEFyZ3NbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF1bMF0pO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHJlc29sdmVkQXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgIHZhciBtYXhFbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAobWF4RWxlbWVudC5sb2NhbGVDb21wYXJlKGVsZW1lbnRzW2ldKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG1heEVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF4RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWluOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIGlmIChyZXNvbHZlZEFyZ3NbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF1bMF0pO1xuICAgICAgICBpZiAodHlwZU5hbWUgPT09IFRZUEVfTlVNQkVSKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIHJlc29sdmVkQXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICAgIHZhciBtaW5FbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudHNbaV0ubG9jYWxlQ29tcGFyZShtaW5FbGVtZW50KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG1pbkVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWluRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblN1bTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIHZhciBsaXN0VG9TdW0gPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RUb1N1bS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gbGlzdFRvU3VtW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVHlwZTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzWzBdKSkge1xuICAgICAgICAgIGNhc2UgVFlQRV9OVU1CRVI6XG4gICAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX0FSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgICBjYXNlIFRZUEVfT0JKRUNUOlxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgICAgICAgY2FzZSBUWVBFX0JPT0xFQU46XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgICAgY2FzZSBUWVBFX0VYUFJFRjpcbiAgICAgICAgICAgIHJldHVybiBcImV4cHJlZlwiO1xuICAgICAgICAgIGNhc2UgVFlQRV9OVUxMOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbktleXM6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzb2x2ZWRBcmdzWzBdKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVmFsdWVzOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIG9iaiA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gob2JqW2tleXNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG5cbiAgICBfZnVuY3Rpb25Kb2luOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgdmFyIGpvaW5DaGFyID0gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB2YXIgbGlzdEpvaW4gPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICAgIHJldHVybiBsaXN0Sm9pbi5qb2luKGpvaW5DaGFyKTtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVG9BcnJheTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pID09PSBUWVBFX0FSUkFZKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtyZXNvbHZlZEFyZ3NbMF1dO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblRvU3RyaW5nOiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFR5cGVOYW1lKHJlc29sdmVkQXJnc1swXSkgPT09IFRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRBcmdzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlc29sdmVkQXJnc1swXSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uVG9OdW1iZXI6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLl9nZXRUeXBlTmFtZShyZXNvbHZlZEFyZ3NbMF0pO1xuICAgICAgICB2YXIgY29udmVydGVkVmFsdWU7XG4gICAgICAgIGlmICh0eXBlTmFtZSA9PT0gVFlQRV9OVU1CRVIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09IFRZUEVfU1RSSU5HKSB7XG4gICAgICAgICAgICBjb252ZXJ0ZWRWYWx1ZSA9ICtyZXNvbHZlZEFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGNvbnZlcnRlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTm90TnVsbDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x2ZWRBcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ2V0VHlwZU5hbWUocmVzb2x2ZWRBcmdzW2ldKSAhPT0gVFlQRV9OVUxMKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQXJnc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uU29ydDogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBzb3J0ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXS5zbGljZSgwKTtcbiAgICAgICAgc29ydGVkQXJyYXkuc29ydCgpO1xuICAgICAgICByZXR1cm4gc29ydGVkQXJyYXk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvblNvcnRCeTogZnVuY3Rpb24ocmVzb2x2ZWRBcmdzKSB7XG4gICAgICAgIHZhciBzb3J0ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXS5zbGljZSgwKTtcbiAgICAgICAgaWYgKHNvcnRlZEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnByZXRlciA9IHRoaXMuX2ludGVycHJldGVyO1xuICAgICAgICB2YXIgZXhwcmVmTm9kZSA9IHJlc29sdmVkQXJnc1sxXTtcbiAgICAgICAgdmFyIHJlcXVpcmVkVHlwZSA9IHRoaXMuX2dldFR5cGVOYW1lKFxuICAgICAgICAgICAgaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgc29ydGVkQXJyYXlbMF0pKTtcbiAgICAgICAgaWYgKFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddLmluZGV4T2YocmVxdWlyZWRUeXBlKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGVFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGdldCBhIHN0YWJsZSBzb3J0IG91dCBvZiBhbiB1bnN0YWJsZVxuICAgICAgICAvLyBzb3J0IGFsZ29yaXRobSwgd2UgZGVjb3JhdGUvc29ydC91bmRlY29yYXRlIChEU1UpXG4gICAgICAgIC8vIGJ5IGNyZWF0aW5nIGEgbmV3IGxpc3Qgb2YgW2luZGV4LCBlbGVtZW50XSBwYWlycy5cbiAgICAgICAgLy8gSW4gdGhlIGNtcCBmdW5jdGlvbiwgaWYgdGhlIGV2YWx1YXRlZCBlbGVtZW50cyBhcmVcbiAgICAgICAgLy8gZXF1YWwsIHRoZW4gdGhlIGluZGV4IHdpbGwgYmUgdXNlZCBhcyB0aGUgdGllYnJlYWtlci5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGRlY29yYXRlZCBsaXN0IGhhcyBiZWVuIHNvcnRlZCwgaXQgd2lsbCBiZVxuICAgICAgICAvLyB1bmRlY29yYXRlZCB0byBleHRyYWN0IHRoZSBvcmlnaW5hbCBlbGVtZW50cy5cbiAgICAgICAgdmFyIGRlY29yYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGVjb3JhdGVkLnB1c2goW2ksIHNvcnRlZEFycmF5W2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb3JhdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHZhciBleHByQSA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGFbMV0pO1xuICAgICAgICAgIHZhciBleHByQiA9IGludGVycHJldGVyLnZpc2l0KGV4cHJlZk5vZGUsIGJbMV0pO1xuICAgICAgICAgIGlmICh0aGF0Ll9nZXRUeXBlTmFtZShleHByQSkgIT09IHJlcXVpcmVkVHlwZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlR5cGVFcnJvcjogZXhwZWN0ZWQgXCIgKyByZXF1aXJlZFR5cGUgKyBcIiwgcmVjZWl2ZWQgXCIgK1xuICAgICAgICAgICAgICAgICAgdGhhdC5fZ2V0VHlwZU5hbWUoZXhwckEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuX2dldFR5cGVOYW1lKGV4cHJCKSAhPT0gcmVxdWlyZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVHlwZUVycm9yOiBleHBlY3RlZCBcIiArIHJlcXVpcmVkVHlwZSArIFwiLCByZWNlaXZlZCBcIiArXG4gICAgICAgICAgICAgICAgICB0aGF0Ll9nZXRUeXBlTmFtZShleHByQikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhwckEgPiBleHByQikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChleHByQSA8IGV4cHJCKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXkncmUgZXF1YWwgY29tcGFyZSB0aGUgaXRlbXMgYnkgdGhlaXJcbiAgICAgICAgICAgIC8vIG9yZGVyIHRvIG1haW50YWluIHJlbGF0aXZlIG9yZGVyIG9mIGVxdWFsIGtleXNcbiAgICAgICAgICAgIC8vIChpLmUuIHRvIGdldCBhIHN0YWJsZSBzb3J0KS5cbiAgICAgICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVbmRlY29yYXRlOiBleHRyYWN0IG91dCB0aGUgb3JpZ2luYWwgbGlzdCBlbGVtZW50cy5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkZWNvcmF0ZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzb3J0ZWRBcnJheVtqXSA9IGRlY29yYXRlZFtqXVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc29ydGVkQXJyYXk7XG4gICAgfSxcblxuICAgIF9mdW5jdGlvbk1heEJ5OiBmdW5jdGlvbihyZXNvbHZlZEFyZ3MpIHtcbiAgICAgIHZhciBleHByZWZOb2RlID0gcmVzb2x2ZWRBcmdzWzFdO1xuICAgICAgdmFyIHJlc29sdmVkQXJyYXkgPSByZXNvbHZlZEFyZ3NbMF07XG4gICAgICB2YXIga2V5RnVuY3Rpb24gPSB0aGlzLmNyZWF0ZUtleUZ1bmN0aW9uKGV4cHJlZk5vZGUsIFtUWVBFX05VTUJFUiwgVFlQRV9TVFJJTkddKTtcbiAgICAgIHZhciBtYXhOdW1iZXIgPSAtSW5maW5pdHk7XG4gICAgICB2YXIgbWF4UmVjb3JkO1xuICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdmVkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudCA9IGtleUZ1bmN0aW9uKHJlc29sdmVkQXJyYXlbaV0pO1xuICAgICAgICBpZiAoY3VycmVudCA+IG1heE51bWJlcikge1xuICAgICAgICAgIG1heE51bWJlciA9IGN1cnJlbnQ7XG4gICAgICAgICAgbWF4UmVjb3JkID0gcmVzb2x2ZWRBcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFJlY29yZDtcbiAgICB9LFxuXG4gICAgX2Z1bmN0aW9uTWluQnk6IGZ1bmN0aW9uKHJlc29sdmVkQXJncykge1xuICAgICAgdmFyIGV4cHJlZk5vZGUgPSByZXNvbHZlZEFyZ3NbMV07XG4gICAgICB2YXIgcmVzb2x2ZWRBcnJheSA9IHJlc29sdmVkQXJnc1swXTtcbiAgICAgIHZhciBrZXlGdW5jdGlvbiA9IHRoaXMuY3JlYXRlS2V5RnVuY3Rpb24oZXhwcmVmTm9kZSwgW1RZUEVfTlVNQkVSLCBUWVBFX1NUUklOR10pO1xuICAgICAgdmFyIG1pbk51bWJlciA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pblJlY29yZDtcbiAgICAgIHZhciBjdXJyZW50O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNvbHZlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBrZXlGdW5jdGlvbihyZXNvbHZlZEFycmF5W2ldKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBtaW5OdW1iZXIpIHtcbiAgICAgICAgICBtaW5OdW1iZXIgPSBjdXJyZW50O1xuICAgICAgICAgIG1pblJlY29yZCA9IHJlc29sdmVkQXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5SZWNvcmQ7XG4gICAgfSxcblxuICAgIGNyZWF0ZUtleUZ1bmN0aW9uOiBmdW5jdGlvbihleHByZWZOb2RlLCBhbGxvd2VkVHlwZXMpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBpbnRlcnByZXRlciA9IHRoaXMuX2ludGVycHJldGVyO1xuICAgICAgdmFyIGtleUZ1bmMgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gaW50ZXJwcmV0ZXIudmlzaXQoZXhwcmVmTm9kZSwgeCk7XG4gICAgICAgIGlmIChhbGxvd2VkVHlwZXMuaW5kZXhPZih0aGF0Ll9nZXRUeXBlTmFtZShjdXJyZW50KSkgPCAwKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiVHlwZUVycm9yOiBleHBlY3RlZCBvbmUgb2YgXCIgKyBhbGxvd2VkVHlwZXMgK1xuICAgICAgICAgICAgICAgICAgICBcIiwgcmVjZWl2ZWQgXCIgKyB0aGF0Ll9nZXRUeXBlTmFtZShjdXJyZW50KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ga2V5RnVuYztcbiAgICB9XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjb21waWxlKHN0cmVhbSkge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKCk7XG4gICAgdmFyIGFzdCA9IHBhcnNlci5wYXJzZShzdHJlYW0pO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbml6ZShzdHJlYW0pIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcigpO1xuICAgICAgcmV0dXJuIGxleGVyLnRva2VuaXplKHN0cmVhbSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2goZGF0YSwgZXhwcmVzc2lvbikge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgaW1wcm92ZWQuICBCb3RoIHRoZSBpbnRlcnByZXRlciBhbmQgcnVudGltZSBkZXBlbmQgb25cbiAgICAgIC8vIGVhY2ggb3RoZXIuICBUaGUgcnVudGltZSBuZWVkcyB0aGUgaW50ZXJwcmV0ZXIgdG8gc3VwcG9ydCBleHByZWZzLlxuICAgICAgLy8gVGhlcmUncyBsaWtlbHkgYSBjbGVhbiB3YXkgdG8gYXZvaWQgdGhlIGN5Y2xpYyBkZXBlbmRlbmN5LlxuICAgICAgdmFyIHJ1bnRpbWUgPSBuZXcgUnVudGltZSgpO1xuICAgICAgdmFyIGludGVycHJldGVyID0gbmV3IFRyZWVJbnRlcnByZXRlcihydW50aW1lKTtcbiAgICAgIHJ1bnRpbWUuX2ludGVycHJldGVyID0gaW50ZXJwcmV0ZXI7XG4gICAgICB2YXIgbm9kZSA9IHBhcnNlci5wYXJzZShleHByZXNzaW9uKTtcbiAgICAgIHJldHVybiBpbnRlcnByZXRlci5zZWFyY2gobm9kZSwgZGF0YSk7XG4gIH1cblxuICBleHBvcnRzLnRva2VuaXplID0gdG9rZW5pemU7XG4gIGV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG4gIGV4cG9ydHMuc2VhcmNoID0gc2VhcmNoO1xuICBleHBvcnRzLnN0cmljdERlZXBFcXVhbCA9IHN0cmljdERlZXBFcXVhbDtcbn0pKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gdGhpcy5qbWVzcGF0aCA9IHt9IDogZXhwb3J0cyk7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIGlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyB0aGUgcGFydCBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgICAgdmFyIGRvbWFpbkFycmF5ID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmIChpc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICBpc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAoaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHJlc3VsdFtrXSA9IHRoaXNba107XG4gIH0sIHRoaXMpO1xuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgIH0pO1xuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHxcbiAgICAgIGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuICBhcmcgPT0gbnVsbDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xufVxuXG5mdW5jdGlvbiBieXRlc1RvVXVpZChidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IG9mZnNldCB8fCAwO1xuICB2YXIgYnRoID0gYnl0ZVRvSGV4OyAvLyBqb2luIHVzZWQgdG8gZml4IG1lbW9yeSBpc3N1ZSBjYXVzZWQgYnkgY29uY2F0ZW5hdGlvbjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzE3NSNjNFxuXG4gIHJldHVybiBbYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJywgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dXS5qb2luKCcnKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gYnl0ZXNUb1V1aWQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInYxXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF92LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3YzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidjVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3Y0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX3YgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3YxLmpzXCIpKTtcblxudmFyIF92MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdjMuanNcIikpO1xuXG52YXIgX3YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92NC5qc1wiKSk7XG5cbnZhciBfdjQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3Y1LmpzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgdmFyIGk7XG4gIHZhciB4O1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICB2YXIgaGV4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4WyhsZW4gKyA2NCA+Pj4gOSA8PCA0KSArIDE0XSA9IGxlbjtcbiAgdmFyIGk7XG4gIHZhciBvbGRhO1xuICB2YXIgb2xkYjtcbiAgdmFyIG9sZGM7XG4gIHZhciBvbGRkO1xuICB2YXIgYSA9IDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgb2xkYSA9IGE7XG4gICAgb2xkYiA9IGI7XG4gICAgb2xkYyA9IGM7XG4gICAgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIHZhciBpO1xuICB2YXIgb3V0cHV0ID0gW107XG4gIG91dHB1dFsoaW5wdXQubGVuZ3RoID4+IDIpIC0gMV0gPSB1bmRlZmluZWQ7XG5cbiAgZm9yIChpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIG91dHB1dFtpXSA9IDA7XG4gIH1cblxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG52YXIgX2RlZmF1bHQgPSBtZDU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJuZztcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxuLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuZnVuY3Rpb24gcm5nKCkge1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICB9XG59XG5cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xufVxuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIHZhciBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgTVtpXSA9IG5ldyBBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgIE1baV1bal0gPSBieXRlc1tpICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tpICogNjQgKyBqICogNCArIDFdIDw8IDE2IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgdmFyIFcgPSBuZXcgQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgdCsrKSBXW3RdID0gTVtpXVt0XTtcblxuICAgIGZvciAodmFyIHQgPSAxNjsgdCA8IDgwOyB0KyspIHtcbiAgICAgIFdbdF0gPSBST1RMKFdbdCAtIDNdIF4gV1t0IC0gOF0gXiBXW3QgLSAxNF0gXiBXW3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIHZhciBhID0gSFswXTtcbiAgICB2YXIgYiA9IEhbMV07XG4gICAgdmFyIGMgPSBIWzJdO1xuICAgIHZhciBkID0gSFszXTtcbiAgICB2YXIgZSA9IEhbNF07XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDgwOyB0KyspIHtcbiAgICAgIHZhciBzID0gTWF0aC5mbG9vcih0IC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1t0XSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG52YXIgX2RlZmF1bHQgPSBzaGExO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfcm5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ybmcuanNcIikpO1xuXG52YXIgX2J5dGVzVG9VdWlkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ieXRlc1RvVXVpZC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcbnZhciBfbm9kZUlkO1xuXG52YXIgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmID8gYnVmIDogKDAsIF9ieXRlc1RvVXVpZC5kZWZhdWx0KShiKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX21kID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9tZDUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCB2MyA9ICgwLCBfdi5kZWZhdWx0KSgndjMnLCAweDMwLCBfbWQuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2MztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5leHBvcnRzLlVSTCA9IGV4cG9ydHMuRE5TID0gdm9pZCAwO1xuXG52YXIgX2J5dGVzVG9VdWlkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9ieXRlc1RvVXVpZC5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHV1aWRUb0J5dGVzKHV1aWQpIHtcbiAgLy8gTm90ZTogV2UgYXNzdW1lIHdlJ3JlIGJlaW5nIHBhc3NlZCBhIHZhbGlkIHV1aWQgc3RyaW5nXG4gIHZhciBieXRlcyA9IFtdO1xuICB1dWlkLnJlcGxhY2UoL1thLWZBLUYwLTldezJ9L2csIGZ1bmN0aW9uIChoZXgpIHtcbiAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgfSk7XG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIHZhciBieXRlcyA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmNvbnN0IEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0cy5ETlMgPSBETlM7XG5jb25zdCBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydHMuVVJMID0gVVJMO1xuXG5mdW5jdGlvbiBfZGVmYXVsdChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICB2YXIgZ2VuZXJhdGVVVUlEID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIG9mZiA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09ICdzdHJpbmcnKSBuYW1lc3BhY2UgPSB1dWlkVG9CeXRlcyhuYW1lc3BhY2UpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRocm93IFR5cGVFcnJvcigndmFsdWUgbXVzdCBiZSBhbiBhcnJheSBvZiBieXRlcycpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShuYW1lc3BhY2UpIHx8IG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB0aHJvdyBUeXBlRXJyb3IoJ25hbWVzcGFjZSBtdXN0IGJlIHV1aWQgc3RyaW5nIG9yIGFuIEFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzJyk7IC8vIFBlciA0LjNcblxuICAgIHZhciBieXRlcyA9IGhhc2hmdW5jKG5hbWVzcGFjZS5jb25jYXQodmFsdWUpKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgMTY7ICsraWR4KSB7XG4gICAgICAgIGJ1ZltvZmYgKyBpZHhdID0gYnl0ZXNbaWR4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmIHx8ICgwLCBfYnl0ZXNUb1V1aWQuZGVmYXVsdCkoYnl0ZXMpO1xuICB9OyAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lO1xuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3JuZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcm5nLmpzXCIpKTtcblxudmFyIF9ieXRlc1RvVXVpZCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vYnl0ZXNUb1V1aWQuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZy5kZWZhdWx0KSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgKDAsIF9ieXRlc1RvVXVpZC5kZWZhdWx0KShybmRzKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdjQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi92MzUuanNcIikpO1xuXG52YXIgX3NoYSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vc2hhMS5qc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHY1ID0gKDAsIF92LmRlZmF1bHQpKCd2NScsIDB4NTAsIF9zaGEuZGVmYXVsdCk7XG52YXIgX2RlZmF1bHQgPSB2NTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsImltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrL2dsb2JhbCc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSAnLi8uLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xubG9nKCdjb2duaXRvIGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgY2xhc3MgQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgcHVibGljIHN0YXRpYyBpcElEID0gJ3VzLWVhc3QtMjo5NGY3NjNlYy0zODY0LTRlODktODEwZC02ZDJiYTcwMTcyYmEnO1xuICAgIHB1YmxpYyBzdGF0aWMgcmVnaW9uID0gJ3VzLWVhc3QtMic7XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldChcbiAgICAgICAgaWRlbnRpdHlQb29sSWQgPSBDcmVkZW50aWFsc1Byb3ZpZGVyLmlwSUQsXG4gICAgICAgIHJlZ2lvbiA9IENyZWRlbnRpYWxzUHJvdmlkZXIucmVnaW9uXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ3JlZGVudGlhbHNQcm92aWRlcihpZGVudGl0eVBvb2xJZCwgcmVnaW9uKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWRzOiBBV1MuQ29nbml0b0lkZW50aXR5Q3JlZGVudGlhbHM7XG5cbiAgICBjb25zdHJ1Y3RvcihpZGVudGl0eVBvb2xJZDogc3RyaW5nLCBwcml2YXRlIHJlZ2lvbjogc3RyaW5nKSB7XG4gICAgICAgIEFXUy5jb25maWcucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmNyZWRzID0gbmV3IEFXUy5Db2duaXRvSWRlbnRpdHlDcmVkZW50aWFscyh7XG4gICAgICAgICAgICBJZGVudGl0eVBvb2xJZDogaWRlbnRpdHlQb29sSWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNyZWRzLmdldCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgPyBsb2coZXJyb3IubWVzc2FnZSwgRGVidWdMZXZlbEVudW0uREVUQUlMRUQpXG4gICAgICAgICAgICAgICAgOiBsb2coJ05vIGVycm9yIHdhcyByZXBvcnRlZC4nLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgIH0pO1xuICAgICAgICBBV1MuY29uZmlnLmNyZWRlbnRpYWxzID0gdGhpcy5jcmVkcztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGNyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVkcztcbiAgICB9XG59XG4iLCJpbXBvcnQgUzMgZnJvbSAnYXdzLXNkay9jbGllbnRzL3MzJztcbmltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBlcnJvciwgbG9nIH0gZnJvbSAnLi4vdXRpbHMvY29uc29sZV93cmFwcGVyJztcbmltcG9ydCB7IENyZWRlbnRpYWxzUHJvdmlkZXIgfSBmcm9tICcuL2NvZ25pdG8nO1xuaW1wb3J0IHsgUzNDbGllbnQgfSBmcm9tICcuL3MzJztcbmxvZygnbXR1cmsgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBNdHVya0NsaWVudCB7XG4gICAgcHVibGljIHN0YXRpYyBpbml0KGJ1Y2tldE5hbWU6IHN0cmluZywga2V5UHJlZml4OiBzdHJpbmcpIHtcbiAgICAgICAgTXR1cmtDbGllbnQuczMgPSBTM0NsaWVudC5nZXQoYnVja2V0TmFtZSwga2V5UHJlZml4KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih3aW5kb3csIHtcbiAgICAgICAgICAgIHMzOiBNdHVya0NsaWVudC5zMyxcbiAgICAgICAgICAgIGNvZzogTXR1cmtDbGllbnQuY29nbml0byxcbiAgICAgICAgICAgIHN1YjogTXR1cmtDbGllbnQuc3VibWl0LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHN1Ym1pdChuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyRGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coc3RyRGF0YSk7XG4gICAgICAgICAgICBsZXQgcmV0ID0gYXdhaXQgTXR1cmtDbGllbnQuczMudXBsb2FkKG5hbWUsIHN0ckRhdGEpO1xuICAgICAgICAgICAgcmV0ID0gcmV0IGFzIFMzLlB1dE9iamVjdE91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBrZXlHZW4oaGl0SUQ6IHN0cmluZywgYXNzaWdubWVudElEOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGAke2hpdElEfV8ke2Fzc2lnbm1lbnRJRH1fbG9nLmpzb25gO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgdXBkYXRlQ29nbml0byhjcDogQ3JlZGVudGlhbHNQcm92aWRlcikge1xuICAgICAgICBNdHVya0NsaWVudC5jb2duaXRvID0gY3A7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyB1cGRhdGVTMyhzMzogUzNDbGllbnQpIHtcbiAgICAgICAgTXR1cmtDbGllbnQuczMgPSBzMztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBDaGFuZ2UgdGhlc2UgYmFjayB0byBwcml2YXRlIGFmdGVyIGRlYnVnZ2luZy5cbiAgICBwdWJsaWMgc3RhdGljIGNvZ25pdG8gPSBDcmVkZW50aWFsc1Byb3ZpZGVyLmdldCgpO1xuICAgIHB1YmxpYyBzdGF0aWMgczM6IFMzQ2xpZW50O1xufVxuIiwiaW1wb3J0IFMzIGZyb20gJ2F3cy1zZGsvY2xpZW50cy9zMyc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkay9nbG9iYWwnO1xuaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gJy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5sb2coJ3MzIGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgY2xhc3MgUzNDbGllbnQge1xuICAgIHB1YmxpYyBzdGF0aWMgYnVja2V0TmFtZSA9ICcnO1xuICAgIHB1YmxpYyBzdGF0aWMgYXBpVmVyc2lvbiA9ICcyMDA2LTAzLTAxJztcbiAgICBwdWJsaWMgc3RhdGljIGtleVByZWZpeCA9ICcnO1xuXG4gICAgcHVibGljIHN0YXRpYyBnZXQoYnVja2V0OiBzdHJpbmcgPSBTM0NsaWVudC5idWNrZXROYW1lLCBrZXlQcmVmaXg6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IFMzQ2xpZW50KGJ1Y2tldCwga2V5UHJlZml4KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHMzOiBTMztcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYnVja2V0TmFtZTogc3RyaW5nLCBwcml2YXRlIGtleVByZWZpeDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuczMgPSBuZXcgUzMoe1xuICAgICAgICAgICAgYXBpVmVyc2lvbjogUzNDbGllbnQuYXBpVmVyc2lvbixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBidWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldE5hbWU7XG4gICAgfVxuXG4gICAgcHVibGljIHVwbG9hZChcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICBkYXRhOiBhbnlcbiAgICApOiBQcm9taXNlPEFXUy5BV1NFcnJvciB8IFMzLlB1dE9iamVjdE91dHB1dD4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zMy5wdXRPYmplY3QoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBLZXk6IHRoaXMua2V5UHJlZml4ICsgJy8nICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgQm9keTogZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnI6IEFXUy5BV1NFcnJvciwgc3VjY2VzczogUzMuUHV0T2JqZWN0T3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IFRyYWNrZXJFdmVudCB9IGZyb20gJy4vZXZlbnQnO1xuY29uc29sZS5sb2coJ2RhdGEgbG9hZGVkLicpO1xuZXhwb3J0IGludGVyZmFjZSBNdHVya1VSTERhdGEge1xuICAgIHJhdzogc3RyaW5nO1xuICAgIGFzc2lnbm1lbnRJRDogc3RyaW5nIHwgbnVsbDtcbiAgICBoaXRJRDogc3RyaW5nIHwgbnVsbDtcbiAgICB3b3JrZXJJRDogc3RyaW5nIHwgbnVsbDtcbiAgICBzdWJtaXRUbzogc3RyaW5nIHwgbnVsbDtcbn1cblxuY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnPycpWzFdKTtcblxuZXhwb3J0IGNvbnN0IHVybERhdGE6IE10dXJrVVJMRGF0YSA9IHtcbiAgICByYXc6IHVybFBhcmFtcy50b1N0cmluZygpLFxuICAgIGFzc2lnbm1lbnRJRDogdXJsUGFyYW1zLmdldCgnYXNzaWdubWVudElkJyksXG4gICAgaGl0SUQ6IHVybFBhcmFtcy5nZXQoJ2hpdElkJyksXG4gICAgd29ya2VySUQ6IHVybFBhcmFtcy5nZXQoJ3dvcmtlcklkJyksXG4gICAgc3VibWl0VG86IHVybFBhcmFtcy5nZXQoJ3R1cmtTdWJtaXRUbycpLFxufTtcblxuZXhwb3J0IGNsYXNzIERhdGEge1xuICAgIHB1YmxpYyBsb2dzOiB7IFtldmVudFR5cGU6IHN0cmluZ106IFRyYWNrZXJFdmVudFtdIH0gPSB7fTtcbiAgICBwdWJsaWMgZGF0YTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuICAgIHB1YmxpYyBlcnJvcnM6IGFueVtdID0gW107XG4gICAgcHVibGljIHVybERhdGE6IE10dXJrVVJMRGF0YTtcblxuICAgIGNvbnN0cnVjdG9yKHJhd010dXJrVVJMRGF0YTogTXR1cmtVUkxEYXRhKSB7XG4gICAgICAgIHRoaXMudXJsRGF0YSA9IHJhd010dXJrVVJMRGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2VyaWFsaXplKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBkYXRhID0gbmV3IERhdGEodXJsRGF0YSk7XG5cbk9iamVjdC5hc3NpZ24od2luZG93LCB7IGRhdGEgfSk7XG4iLCJpbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSBcIi4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlclwiO1xuaW1wb3J0IHsgbm93IH0gZnJvbSBcIi4uL3V0aWxzL2Z1bmNzXCI7XG5sb2coXCJldmVudCBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjb25zdCBlbnVtIEFjdGlvbkVudW0ge1xuICBDTElDSyA9IFwiY2xpY2tcIixcbiAgQlVUVE9OID0gXCJidXR0b25cIixcbiAgU0NST0xMID0gXCJzY3JvbGxcIixcbiAgSElTVE9SWSA9IFwiaGlzdG9yeVwiLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrZXJFdmVudCB7XG4gIGFjdGlvbjogc3RyaW5nO1xuICB0aW1lOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RUb1RyYWNrZXJFdmVudChvYmo6IGFueSwgYWN0aW9uOiBzdHJpbmcpIHtcbiAgb2JqLmFjdGlvbiA9IGFjdGlvbjtcbiAgb2JqLnRpbWUgPSBub3coKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2tlckV2ZW50KG9iajogYW55KTogb2JqIGlzIFRyYWNrZXJFdmVudCB7XG4gIHJldHVybiBvYmouYWN0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqLnRpbWUgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIEJhc2VUcmFja2VyRXZlbnQ8VD4gaW1wbGVtZW50cyBUcmFja2VyRXZlbnQge1xuICBwdWJsaWMgY3VzdEV2OiBDdXN0b21FdmVudDtcbiAgcHVibGljIGFjdGlvbjogc3RyaW5nO1xuICBwdWJsaWMgdGltZTogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcihhY3Rpb246IHN0cmluZywgZXZlbnRJbml0RGljdD86IEN1c3RvbUV2ZW50SW5pdDxUPiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuY3VzdEV2ID0gbmV3IEN1c3RvbUV2ZW50KGFjdGlvbiwgZXZlbnRJbml0RGljdCk7XG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgdGhpcy50aW1lID0gbm93KCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGRldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXN0RXYuZGV0YWlsO1xuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWNsYXNzZXMtcGVyLWZpbGVcbmV4cG9ydCBjbGFzcyBDbGlja0V2ZW50IGV4dGVuZHMgQmFzZVRyYWNrZXJFdmVudDx7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBpZDogc3RyaW5nO1xufT4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB4OiBudW1iZXIsXG4gICAgeTogbnVtYmVyLFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZXZlbnRJbml0RGljdD86XG4gICAgICB8IEN1c3RvbUV2ZW50SW5pdDx7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBpZDogc3RyaW5nIH0+XG4gICAgICB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBzdXBlcihBY3Rpb25FbnVtLkNMSUNLLCBldmVudEluaXREaWN0KTtcbiAgICB0aGlzLmRldGFpbC54ID0geDtcbiAgICB0aGlzLmRldGFpbC55ID0geTtcbiAgICB0aGlzLmRldGFpbC5pZCA9IGlkO1xuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWNsYXNzZXMtcGVyLWZpbGVcbmV4cG9ydCBjbGFzcyBCdXR0b25FdmVudCBleHRlbmRzIEJhc2VUcmFja2VyRXZlbnQ8eyBrZXk6IHN0cmluZzsgaWQ6IHN0cmluZyB9PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGtleTogc3RyaW5nLFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZXZlbnRJbml0RGljdD86IEN1c3RvbUV2ZW50SW5pdDx7IGtleTogc3RyaW5nOyBpZDogc3RyaW5nIH0+IHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKEFjdGlvbkVudW0uQ0xJQ0ssIGV2ZW50SW5pdERpY3QpO1xuICAgIHRoaXMuZGV0YWlsLmtleSA9IGtleTtcbiAgICB0aGlzLmRldGFpbC5pZCA9IGlkO1xuICB9XG59XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWNsYXNzZXMtcGVyLWZpbGVcbmV4cG9ydCBjbGFzcyBIaXN0b3J5RXZlbnQgZXh0ZW5kcyBCYXNlVHJhY2tlckV2ZW50PHtcbiAgdXJsOiBzdHJpbmc7XG4gIGV4dHJhPzogYW55O1xufT4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB1cmw6IHN0cmluZyxcbiAgICBleHRyYT86IGFueSxcbiAgICBldmVudEluaXREaWN0PzogQ3VzdG9tRXZlbnRJbml0PHsgdXJsOiBzdHJpbmcgfT4gfCB1bmRlZmluZWRcbiAgKSB7XG4gICAgc3VwZXIoQWN0aW9uRW51bS5ISVNUT1JZLCBldmVudEluaXREaWN0KTtcbiAgICB0aGlzLmRldGFpbC51cmwgPSB1cmw7XG4gICAgdGhpcy5kZXRhaWwuZXh0cmEgPSBleHRyYTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gXCIuLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIjtcbmltcG9ydCB7IGlzVHJhY2tlckV2ZW50LCBUcmFja2VyRXZlbnQgfSBmcm9tIFwiLi9ldmVudFwiO1xubG9nKFwicmVjZWl2ZXIgbG9hZGVkLlwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgY2xhc3MgRXZlbnRSZWNlaXZlciB7XG4gIHByaXZhdGUgbWFwID0gbmV3IE1hcDxzdHJpbmcsIChldmVudDogVHJhY2tlckV2ZW50KSA9PiB2b2lkPigpO1xuICBwcml2YXRlIGVtaXR0ZXIgPSBuZXcgRXZlbnRUYXJnZXQoKTtcblxuICBwdWJsaWMgcmVnaXN0ZXIoZXZlbnRUeXBlOiBzdHJpbmcsIGNhbGxiYWNrPzogKGV2ZW50OiBUcmFja2VyRXZlbnQpID0+IHZvaWQpIHtcbiAgICB0aGlzLmVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIChldmVudDogRXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrRXYgPSAoKGV2ZW50IGFzIHVua25vd24pIGFzIEN1c3RvbUV2ZW50KVxuICAgICAgICAuZGV0YWlsIGFzIFRyYWNrZXJFdmVudDtcbiAgICAgIGlmIChpc1RyYWNrZXJFdmVudCh0cmFja0V2KSAmJiBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh0cmFja0V2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubWFwLnNldChldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZG9FdmVudChldmVudDogVHJhY2tlckV2ZW50KSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLm1hcC5nZXQoXCJcIiArIGV2ZW50LmFjdGlvbik7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBSb3V0ZXIgfSBmcm9tIFwiLi4vcm91dGVyL3JvdXRlclwiO1xuaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gXCIuLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIjtcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tIFwiLi8uLi9yb3V0ZXIvaGlzdG9yeVwiO1xuaW1wb3J0IHsgRCB9IGZyb20gXCIuL2RvY3VtZW50XCI7XG5pbXBvcnQgeyBFbGVtZW50cyB9IGZyb20gXCIuL2VsZW1lbnRzXCI7XG5sb2coXCJiYW5uZXIgbG9hZGVkLlwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgY2xhc3MgVG9wQmFubmVyIHtcbiAgcHVibGljIHN0YXRpYyBzaG93KCkge1xuICAgIFRvcEJhbm5lci5zaG93aW5nID0gdHJ1ZTtcbiAgICBELmRpc3BsYXkoRWxlbWVudHMuZGRVcCwgdHJ1ZSk7XG4gICAgRC5kaXNwbGF5KEVsZW1lbnRzLmRkRG93biwgZmFsc2UpO1xuICAgIEQuZGlzcGxheShFbGVtZW50cy5kZENvbnRlbnQsIHRydWUpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBoaWRlKCkge1xuICAgIFRvcEJhbm5lci5zaG93aW5nID0gZmFsc2U7XG4gICAgRC5kaXNwbGF5KEVsZW1lbnRzLmRkRG93biwgdHJ1ZSk7XG4gICAgRC5kaXNwbGF5KEVsZW1lbnRzLmRkVXAsIGZhbHNlKTtcbiAgICBELmRpc3BsYXkoRWxlbWVudHMuZGRDb250ZW50LCBmYWxzZSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGRvRGlzcGxheUNoYW5nZSgpIHtcbiAgICBUb3BCYW5uZXIuc2hvd2luZyA/IFRvcEJhbm5lci5oaWRlKCkgOiBUb3BCYW5uZXIuc2hvdygpO1xuICB9XG4gIHB1YmxpYyBzdGF0aWMgc2V0dXAoKSB7XG4gICAgRC5hZGRFdmVudExpc3RlbmVyKEVsZW1lbnRzLmRkQXJyb3csIFwiY2xpY2tcIiwgVG9wQmFubmVyLmRvRGlzcGxheUNoYW5nZSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBzaG93aW5nID0gdHJ1ZTtcbn1cblxuRC5hZGRFdmVudExpc3RlbmVyKFwibXR1cmstdG9wLWJhbm5lci1iYWNrXCIsIFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgaWYgKEhpc3RvcnkuY2FuQmFja3dhcmQoKSkge1xuICAgIFJvdXRlci5sb2FkV2l0aFBhdGhQcmVmaXgoSGlzdG9yeS5iYWNrd2FyZCgpKTtcbiAgfSBlbHNlIHtcbiAgICBhbGVydChcIlRoZXJlIGlzIG5vIHBhZ2UgaGlzdG9yeSB0byBnbyBiYWNrIGZvciBhdCB0aGlzIHRpbWUhXCIpO1xuICB9XG59KTtcbiIsImltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBlcnJvciwgbG9nIH0gZnJvbSBcIi4vLi4vdXRpbHMvY29uc29sZV93cmFwcGVyXCI7XG5sb2coXCJkb2N1bWVudCBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBEIHtcbiAgcHVibGljIHN0YXRpYyBkb2M6IERvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgcHVibGljIHN0YXRpYyBlbGVtKGVsZW06IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHtcbiAgICBpZiAodHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBELmlkKGVsZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbSBhcyBFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgZGlzcGxheShlbGVtOiBFbGVtZW50IHwgc3RyaW5nLCBzaG93OiBib29sZWFuKTogdm9pZCB7XG4gICAgZWxlbSA9IEQuZWxlbShlbGVtKTtcbiAgICBpZiAoc2hvdykge1xuICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKFwibm9uZVwiKTtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChcImRpc3BsYXlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShcImRpc3BsYXlcIik7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoXCJub25lXCIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgaWQoaWQ6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgICBjb25zdCBlbGVtZW50ID0gRC5kb2MuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnQgd2FzIG5vdCBmb3VuZCwgaWQ6IDwke2lkfT4uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgfVxuICBwdWJsaWMgc3RhdGljIGNsYXooY2xhejogc3RyaW5nKTogSFRNTENvbGxlY3Rpb25PZjxFbGVtZW50PiB7XG4gICAgcmV0dXJuIEQuZG9jLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xheik7XG4gIH1cbiAgcHVibGljIHN0YXRpYyB0YWcodGFnOiBzdHJpbmcpOiBIVE1MQ29sbGVjdGlvbk9mPEVsZW1lbnQ+IHtcbiAgICByZXR1cm4gRC5kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcbiAgfVxuICBwdWJsaWMgc3RhdGljIGltYWdlKGlkOiBzdHJpbmcsIHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgZXJyb3IoKCkgPT4gRC5pZChpZCkuc2V0QXR0cmlidXRlKFwic3JjXCIsIHVybCkpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhZGRFdmVudExpc3RlbmVyKFxuICAgIGVsZW06IEVsZW1lbnQgfCBzdHJpbmcsXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGxpc3RlbmVyOiAoZTogRXZlbnQpID0+IGFueVxuICApIHtcbiAgICBlbGVtID0gdGhpcy5lbGVtKGVsZW0pO1xuICAgIGNvbnN0IHdyYXBwZXJGdW5jID0gKGU6IEV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcihlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICAoZWxlbSBhcyBFbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHdyYXBwZXJGdW5jKTtcbiAgICByZXR1cm4gd3JhcHBlckZ1bmM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGVhY2goZWxlbTogRWxlbWVudCB8IHN0cmluZywgYXBwbHk6IChub2RlOiBFbGVtZW50KSA9PiBhbnkpIHtcbiAgICBlbGVtID0gdGhpcy5lbGVtKGVsZW0pO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcHBseShjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBlYWNoUmVjdXIoXG4gICAgZWxlbTogRWxlbWVudCB8IHN0cmluZyxcbiAgICBhcHBseTogKG5vZGU6IEVsZW1lbnQpID0+IGFueVxuICApIHtcbiAgICBlbGVtID0gdGhpcy5lbGVtKGVsZW0pO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlbjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgYXBwbHkoY2hpbGQpO1xuICAgICAgRC5lYWNoUmVjdXIoY2hpbGQsIGFwcGx5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZTxLIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwPihcbiAgICB0YWdOYW1lOiBLLFxuICAgIG9wdGlvbnM/OiBFbGVtZW50Q3JlYXRpb25PcHRpb25zXG4gICk6IEhUTUxFbGVtZW50VGFnTmFtZU1hcFtLXSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgb3B0aW9ucyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2cgfSBmcm9tICcuLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgRCB9IGZyb20gJy4vZG9jdW1lbnQnO1xubG9nKCdlbGVtZW50IGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG4vKipcbiAqIFRoZXNlIGFyZSBlbGVtZW50cyB0aGF0IGFyZSBpbiBldmVyeSBzaW5nbGUgcHJvamVjdC4gRXZlbiBpZiB0aGV5IGFyZSBub3QgdXNlZCB0aGV5IHNob3VsZFxuICogYmUgcGxhY2UgaW4gdGhlIHByb2plY3QgYW5kIGRpc3BsYXkgc2hvdWxkIGJlIHNldCB0byBub25lLiBUaGlzIHNpbXBsaWZpZXMgY29uZmlndXJhdGlvblxuICogYW5kIHNvbWUgY29tbW9uIGZ1bmN0aW9ucyBhbmQgYWxsb3dzIGxlc3MgbnVsbCBjaGVja3MgdG8gYmUgcGVyZm9ybWVkIG92ZXJhbGwuIElmIHRoZVxuICogZWxlbWVudCBkb2VzIG5vdCBleGlzdCBhdCBydW4gdGltZSBhbiBlbXB0eSBkaXYgd2l0aCB0aGF0IGlkIGlzIGNyZWF0ZWQgYW5kIGl0cyBkaXNwbGF5XG4gKiBpcyBzZXQgdG8gbm9uZSB0aGVuIGFwcGVuZGVkIHRvIHRoZSBib2R5LlxuICovXG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IGFuIGVsZW1lbnQsIGlmIHVuc3VjY2Vzc2Z1bCwgY3JlYXRlcyBkaXYgd2l0aCBpZCBhbmQgYXBwZW5kcyB0byBib2R5LlxuICpcbiAqIEBwYXJhbSBpZCAtIHRoZSBpZCBvZiB0aGUgZWxlbWVudCB0byByZXRyaWV2ZS5cbiAqL1xuZnVuY3Rpb24gbWFrZUVsZW1JZk5vdEV4aXN0KGlkOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gICAgbGV0IGVsZW07XG4gICAgdHJ5IHtcbiAgICAgICAgZWxlbSA9IEQuaWQoaWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlbGVtID0gRC5jcmVhdGUoJ2RpdicpO1xuICAgICAgICBlbGVtLmlkID0gaWQ7XG4gICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtO1xufVxuXG4vKipcbiAqIENvbW1vbmx5IGFjY2Vzc2VkIGVsZW1lbnRzLCBhbGxvd3MgZm9yIGNsZWFyZXIgZG9tIG1hbmlwIG9uIHRoZXNlIGVsZW1lbnRzLlxuICovXG5leHBvcnQgY29uc3QgRWxlbWVudHMgPSB7XG4gICAgZG9jdW1lbnQ6IEQuZG9jLmRvY3VtZW50RWxlbWVudCxcbiAgICB3cmFwcGVyOiBtYWtlRWxlbUlmTm90RXhpc3QoJ3dyYXBwZXInKSxcbiAgICBodG1sTG9jOiBtYWtlRWxlbUlmTm90RXhpc3QoJ2h0bWwtbG9jJyksXG4gICAgaW5uZXJCb2R5OiBtYWtlRWxlbUlmTm90RXhpc3QoJ2lubmVyLWJvZHknKSxcbiAgICBkZERvd246IG1ha2VFbGVtSWZOb3RFeGlzdCgnbXR1cmstdG9wLWJhbm5lci1kcm9wLWRvd24tYnV0dG9uJyksXG4gICAgZGRVcDogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWNvbGxhcHNlLWJ1dHRvbicpLFxuICAgIGRkQ29udGVudDogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWRyb3AtZG93bi1jb250ZW50JyksXG4gICAgYmFja0J1dHRvbjogbWFrZUVsZW1JZk5vdEV4aXN0KCdtdHVyay10b3AtYmFubmVyLWJhY2snKSxcbiAgICBkZEFycm93OiBtYWtlRWxlbUlmTm90RXhpc3QoJ210dXJrLXRvcC1iYW5uZXItYXJyb3cnKSxcbiAgICBtdFRvcEJhbm5lclRleHQ6IG1ha2VFbGVtSWZOb3RFeGlzdCgnbXR1cmstdG9wLWJhbm5lci10ZXh0JyksXG4gICAgbXRTY2VuYXJpb0NvbnRleHQ6IG1ha2VFbGVtSWZOb3RFeGlzdCgnc2NlbmFyaW9fY29udGV4dCcpLFxuICAgIG10U2NlbmFyaW9RdWVzdGlvbjogbWFrZUVsZW1JZk5vdEV4aXN0KCdzY2VuYXJpb19xdWVzdGlvbicpLFxuICAgIGxvZ0ZpbGVJbnB1dDogbWFrZUVsZW1JZk5vdEV4aXN0KFxuICAgICAgICAnbXR1cmstdG9wLWJhbm5lci1kcm9wLWRvd24tY29udGVudC1sb2ctZmlsZS1pbnB1dCdcbiAgICApLFxuICAgIHN1Ym1pdEZvcm06IG1ha2VFbGVtSWZOb3RFeGlzdCgnbXR1cmstc3VibWl0LWZvcm0nKSxcbiAgICBtb2RhbDogbWFrZUVsZW1JZk5vdEV4aXN0KCdtb2RhbCcpLFxufTtcbiIsImltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2cgfSBmcm9tICcuLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuLy4uL2RvbS9lbGVtZW50cyc7XG5sb2coJ2h0bWwgbG9jIGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgZW51bSBBcHBFbnVtIHtcbiAgICBJTkZPUk1BVElPTl9GT1JBR0lORyA9ICdpbmZvcm1hdGlvbi1mb3JhZ2luZycsXG4gICAgQ09HTklUSVZFX0xPQUQgPSAnY29nbml0aXZlLWxvYWQnLFxuICAgIEdFTkRFUl9NQUcgPSAnZ2VuZGVyLW1hZycsXG4gICAgRVJST1IgPSAnZXJyb3InLFxufVxuXG5leHBvcnQgZW51bSBNb2RlRW51bSB7XG4gICAgUkVBTCA9ICdyZWFsJyxcbiAgICBTQU5EQk9YID0gJ3NhbmRib3gnLFxuICAgIFRFU1QgPSAndGVzdCcsXG4gICAgRVJST1IgPSAnZXJyb3InLFxufVxuXG5leHBvcnQgY2xhc3MgSFRNTExvYyB7XG4gICAgcHVibGljIHN0YXRpYyBlbGVtID0gRWxlbWVudHMuaHRtbExvYztcbiAgICBwdWJsaWMgc3RhdGljIGFwcDogQXBwRW51bTtcbiAgICBwdWJsaWMgc3RhdGljIG1vZGU6IE1vZGVFbnVtO1xuICAgIHB1YmxpYyBzdGF0aWMgc2NlbmFyaW86IHN0cmluZztcblxuICAgIHB1YmxpYyBzdGF0aWMgc2V0dXAoKSB7XG4gICAgICAgIEhUTUxMb2MuYXBwID0gKEhUTUxMb2MuZWxlbS5kYXRhc2V0LmFwcCBhcyBBcHBFbnVtKSB8fCBBcHBFbnVtLkVSUk9SO1xuICAgICAgICBIVE1MTG9jLm1vZGUgPVxuICAgICAgICAgICAgKEhUTUxMb2MuZWxlbS5kYXRhc2V0Lm1vZGUgYXMgTW9kZUVudW0pIHx8IE1vZGVFbnVtLkVSUk9SO1xuICAgICAgICBIVE1MTG9jLnNjZW5hcmlvID0gSFRNTExvYy5lbGVtLmRhdGFzZXQuc2NlbmFyaW8gfHwgJ2Vycm9yJztcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSAnLi8uLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgRCB9IGZyb20gJy4vZG9jdW1lbnQnO1xuaW1wb3J0IHsgRWxlbWVudHMgfSBmcm9tICcuL2VsZW1lbnRzJztcbmxvZygnbW9kYWwgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjbGFzcyBNb2RhbCB7XG4gICAgcHVibGljIHN0YXRpYyBlbGVtID0gRWxlbWVudHMubW9kYWw7XG5cbiAgICBwdWJsaWMgc3RhdGljIGRpc3BsYXkoc3JjOiBzdHJpbmcpIHtcbiAgICAgICAgTW9kYWwuZWxlbS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgYGxlZnQ6ICR7TWF0aC5yb3VuZCh3aW5kb3cucGFnZVhPZmZzZXQpfXB4OyB0b3A6ICR7TWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICl9cHg7YFxuICAgICAgICApO1xuICAgICAgICBNb2RhbC5lbGVtLmNsYXNzTGlzdC5yZXBsYWNlKCdoaWRlLW1vZGFsJywgJ3Nob3ctbW9kYWwnKTtcbiAgICAgICAgRC5lYWNoKE1vZGFsLmVsZW0sIChub2RlKSA9PiB7XG4gICAgICAgICAgICAobm9kZSBhcyBIVE1MSUZyYW1lRWxlbWVudCkuc3JjID0gc3JjO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdub3Njcm9sbCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaGlkZSgpIHtcbiAgICAgICAgTW9kYWwuZWxlbS5jbGFzc0xpc3QucmVwbGFjZSgnc2hvdy1tb2RhbCcsICdoaWRlLW1vZGFsJyk7XG4gICAgICAgIEQuZWFjaChNb2RhbC5lbGVtLCAobm9kZSkgPT4ge1xuICAgICAgICAgICAgKG5vZGUgYXMgSFRNTElGcmFtZUVsZW1lbnQpLnNyYyA9ICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdub3Njcm9sbCcpO1xuICAgIH1cbn1cblxuRC5hZGRFdmVudExpc3RlbmVyKE1vZGFsLmVsZW0sICdjbGljaycsIChlKSA9PiB7XG4gICAgTW9kYWwuaGlkZSgpO1xufSk7XG5ELmVhY2goTW9kYWwuZWxlbSwgKG5vZGUpID0+IHtcbiAgICBELmFkZEV2ZW50TGlzdGVuZXIobm9kZSwgJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xufSk7XG4iLCJpbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgZXJyb3IsIGxvZyB9IGZyb20gXCIuLi91dGlscy9jb25zb2xlX3dyYXBwZXJcIjtcbmltcG9ydCB7IG5vb3AsIG5vdyB9IGZyb20gXCIuLy4uL3V0aWxzL2Z1bmNzXCI7XG5sb2coXCJzY3JvbGwgbG9hZGVkLlwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG4vKipcbiAqIExpbmVhciBpbXBsZW1lbnRhdGlvbiBvZiBzY3JvbGxpbmcuXG4gKiBGb2xsb3dzIHRoZSBzaW5nbGV0b24gcGF0dGVybiwgY2FsbCBkbyB0byBzdGFydCBhIHNjcm9sbCBvcGVyYXRpb24uXG4gKlxuICogSWYgYSBzY3JvbGwgaXMgY2FsbGVkIHdoZW4gYW5vdGhlciBzY3JvbGwgaGFzIGFscmVhZHkgYmVndW4gYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLCBidXQgdGhlIGZpcnN0IHNjcm9sbCB3aWxsIGNvbnRpbnVlIHVudGlsIGNvbXBsZXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTY3JvbGwge1xuICBwdWJsaWMgc3RhdGljIFNURVBfSU5fTVMgPSAxNztcblxuICBwdWJsaWMgc3RhdGljIGNhbGxiYWNrKFxuICAgIGVuZFBvczogbnVtYmVyLFxuICAgIGR1cmF0aW9uOiBudW1iZXIgPSAyMDAsXG4gICAgY29tcGxldGU6ICguLi5hcmdzOiBhbnkpID0+IGFueSA9IG5vb3BcbiAgKTogdm9pZCB7XG4gICAgaWYgKFNjcm9sbC5ydW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWFrZSBtdWx0aXBsZSBjYWxscyB0byBzY3JvbGwgYXQgdGhlIHNhbWUgdGltZS5cIik7XG4gICAgfVxuICAgIFNjcm9sbC5ydW5uaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBvbGRDb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgU2Nyb2xsLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGVycm9yKG9sZENvbXBsZXRlKTtcbiAgICB9O1xuICAgIHRoaXMuaW5zdGFuY2UudXBkYXRlKGVuZFBvcywgZHVyYXRpb24sIGNvbXBsZXRlKS5hdHRlbXB0U2Nyb2xsKCk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHByb21pc2UoZW5kUG9zOiBudW1iZXIsIGR1cmF0aW9uOiBudW1iZXIgPSAyMDApIHtcbiAgICBpZiAoU2Nyb2xsLnJ1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtYWtlIG11bHRpcGxlIGNhbGxzIHRvIHNjcm9sbCBhdCB0aGUgc2FtZSB0aW1lLlwiKTtcbiAgICB9XG4gICAgU2Nyb2xsLnJ1bm5pbmcgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZTogKCkgPT4gdm9pZCwgcmVqZWN0OiAoYXJnMDogYW55KSA9PiB2b2lkKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBydW5SZXNvbHZlciA9ICgpID0+IHtcbiAgICAgICAgICBTY3JvbGwucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS51cGRhdGUoZW5kUG9zLCBkdXJhdGlvbiwgcnVuUmVzb2x2ZXIpLmF0dGVtcHRTY3JvbGwoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBTY3JvbGwucnVubmluZyA9IGZhbHNlO1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJ1bm5pbmcgPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2UgPSBuZXcgU2Nyb2xsKDAsIDAsIG5vb3ApO1xuICBwcml2YXRlIGNvbXBsZXRlOiAoLi4uYXJnczogYW55KSA9PiBhbnk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVuZFBvczogbnVtYmVyLFxuICAgIHByaXZhdGUgZHVyYXRpb246IG51bWJlcixcbiAgICBjb21wbGV0ZTogKC4uLmFyZ3M6IGFueSkgPT4gYW55XG4gICkge1xuICAgIHRoaXMuY29tcGxldGUgPSAoLi4uYXJnczogYW55KSA9PiB7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInNjcm9sbFwiKSk7XG4gICAgICBjb21wbGV0ZShhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXQgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiBTY3JvbGwucnVubmluZztcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlKFxuICAgIGVuZFBvczogbnVtYmVyLFxuICAgIGR1cmF0aW9uOiBudW1iZXIsXG4gICAgY29tcGxldGU6ICguLi5hcmdzOiBhbnkpID0+IGFueVxuICApOiBTY3JvbGwge1xuICAgIHRoaXMuZW5kUG9zID0gZW5kUG9zO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcml2YXRlIGNhbGNTY3JvbGxBbW91bnQoKSB7XG4gICAgY29uc3QgY3VyVGltZSA9IG5vdygpO1xuICAgIGNvbnN0IHN0ZXBzID0gTWF0aC5tYXgoMSwgKHRoaXMuZHVyYXRpb24gLSBjdXJUaW1lKSAvIFNjcm9sbC5TVEVQX0lOX01TKTtcbiAgICBjb25zdCBjdXJQb3MgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgodGhpcy5lbmRQb3MgLSBjdXJQb3MpIC8gc3RlcHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY3JvbGwoKSB7XG4gICAgd2luZG93LnNjcm9sbCgwLCB0aGlzLmNhbGNTY3JvbGxBbW91bnQoKSk7XG4gICAgaWYgKHdpbmRvdy5wYWdlWU9mZnNldCA9PT0gdGhpcy5lbmRQb3MpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuc2Nyb2xsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGF0dGVtcHRTY3JvbGwoKSB7XG4gICAgaWYgKFwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIgaW4gd2luZG93ID09PSBmYWxzZSkge1xuICAgICAgd2luZG93LnNjcm9sbCgwLCB0aGlzLmVuZFBvcyk7XG4gICAgfVxuICAgIHRoaXMuc2Nyb2xsKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlscy9mdW5jcyc7XG5pbXBvcnQgeyBNdHVya0NsaWVudCB9IGZyb20gJy4vLi4vYXdzL210dXJrJztcbmltcG9ydCB7IGRhdGEgfSBmcm9tICcuLy4uL2RhdGEtbG9nL2RhdGEnO1xuaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gJy4vLi4vdXRpbHMvY29uc29sZV93cmFwcGVyJztcbmltcG9ydCB7IEQgfSBmcm9tICcuL2RvY3VtZW50JztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi9lbGVtZW50cyc7XG5sb2coJ3N1Ym1pdCBmb3JtIGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgaW50ZXJmYWNlIEFsbG93U3VibWlzc2lvbiB7XG4gICAgYWxsb3coKTogc3RyaW5nIHwgbnVsbDtcbiAgICBwcmVTdWJtaXQoLi4uYXJnczogYW55KTogYW55O1xufVxuXG5jb25zdCBBbGxvd1N1Ym1pc3Npb25EZWZhdWx0OiBBbGxvd1N1Ym1pc3Npb24gPSB7XG4gICAgYWxsb3c6ICgpID0+IG51bGwsXG4gICAgcHJlU3VibWl0OiBub29wLFxufTtcblxuZXhwb3J0IGNsYXNzIFN1Ym1pdEZvcm0ge1xuICAgIHB1YmxpYyBzdGF0aWMgZWxlbSA9IEVsZW1lbnRzLnN1Ym1pdEZvcm0gYXMgSFRNTEZvcm1FbGVtZW50O1xuICAgIHB1YmxpYyBzdGF0aWMgYWxsb3dTdWJtaXREZWZhdWx0ID0geyBhbGxvdzogKCkgPT4gdHJ1ZSwgcHJlU3VibWl0OiBub29wIH07XG5cbiAgICBwdWJsaWMgc3RhdGljIHNldHVwKFxuICAgICAgICBhbGxvd1N1Ym1pc3Npb246IEFsbG93U3VibWlzc2lvbiA9IEFsbG93U3VibWlzc2lvbkRlZmF1bHRcbiAgICApIHtcbiAgICAgICAgaWYgKGRhdGEudXJsRGF0YS5hc3NpZ25tZW50SUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIChELmlkKCdhc3NpZ25tZW50LWlkJykgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPVxuICAgICAgICAgICAgICAgIGRhdGEudXJsRGF0YS5hc3NpZ25tZW50SUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEudXJsRGF0YS5oaXRJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgKEQuaWQoJ2hpdC1pZCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gZGF0YS51cmxEYXRhLmhpdElEO1xuICAgICAgICB9XG4gICAgICAgIFN1Ym1pdEZvcm0uc3VibWl0RnVuYyA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93ZWQgPSBhbGxvd1N1Ym1pc3Npb24uYWxsb3coKTtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dTdWJtaXNzaW9uLnByZVN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIGxldCBoaXRJRCA9IGRhdGEudXJsRGF0YS5oaXRJRDtcbiAgICAgICAgICAgICAgICBpZiAoaGl0SUQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0SUQgPSAnaGl0aWQnICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFzc2lnbm1uZXRJRCA9IGRhdGEudXJsRGF0YS5hc3NpZ25tZW50SUQ7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2lnbm1uZXRJRCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tbmV0SUQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Fzc2lnbm1uZXRpZCcgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBNdHVya0NsaWVudC5zdWJtaXQoXG4gICAgICAgICAgICAgICAgICAgIE10dXJrQ2xpZW50LmtleUdlbihoaXRJRCwgYXNzaWdubW5ldElEKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvJyk7XG4gICAgICAgICAgICAgICAgU3VibWl0Rm9ybS5lbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgICdzdWJtaXQnLFxuICAgICAgICAgICAgICAgICAgICBTdWJtaXRGb3JtLnN1Ym1pdEZ1bmNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFN1Ym1pdEZvcm0uZWxlbS5zdWJtaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoYWxsb3dlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFN1Ym1pdEZvcm0uZWxlbS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBTdWJtaXRGb3JtLnN1Ym1pdEZ1bmMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHN1Ym1pdEZ1bmM6IChldmVudDogRXZlbnQpID0+IGFueTtcbn1cbiIsImltcG9ydCB7IFRvcEJhbm5lciB9IGZyb20gXCIuL2Jhbm5lclwiO1xuaW1wb3J0IHsgSFRNTExvYyB9IGZyb20gXCIuL2h0bWxfbG9jXCI7XG5cbmV4cG9ydCBjbGFzcyBUcmFja2VyRWxlbWVudHMge1xuICBwdWJsaWMgc3RhdGljIHNldHVwVHJhY2tlckVsZW1lbnRzKCkge1xuICAgIC8vIHNldHVwIGRvbSBlbGVtZW50c1xuICAgIFRvcEJhbm5lci5zZXR1cCgpO1xuICAgIEhUTUxMb2Muc2V0dXAoKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgVHJhY2tlciB9IGZyb20gJy4vLi4vdHJhY2tlci90cmFja2VyJztcblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5RW50cnkge1xuICAgIGhhc1ByZXZVUkw6IGJvb2xlYW47XG4gICAgcHJldkVudHJ5PzogSGlzdG9yeUVudHJ5O1xuICAgIGN1cnJVUkw6IHN0cmluZztcbiAgICBleHRyYT86IGFueTtcbiAgICBuZXh0RW50cmllczogSGlzdG9yeUVudHJ5W107XG59XG5cbmZ1bmN0aW9uIG5ld0hpc3RvcnlFbnRyeShcbiAgICBjdXJyVVJMOiBzdHJpbmcsXG4gICAgaGFzUHJldlVSTDogYm9vbGVhbixcbiAgICBwcmV2RW50cnk/OiBIaXN0b3J5RW50cnksXG4gICAgZXh0cmE/OiBhbnlcbik6IEhpc3RvcnlFbnRyeSB7XG4gICAgVHJhY2tlci5nZXRFdmVudERpc3BhdGNoRnVuYygnaGlzdG9yeScpKHsgdXJsOiBjdXJyVVJMLCBleHRyYSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjdXJyVVJMLFxuICAgICAgICBoYXNQcmV2VVJMLFxuICAgICAgICBwcmV2RW50cnksXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBuZXh0RW50cmllczogW10sXG4gICAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEhpc3Rvcnkge1xuICAgIHB1YmxpYyBzdGF0aWMgZm9yd2FyZCh1cmw6IHN0cmluZywgZXh0cmE/OiBhbnkpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBoaXN0RW50ID0gbmV3SGlzdG9yeUVudHJ5KHVybCwgdHJ1ZSwgSGlzdG9yeS5jdXJyaGlzdG9yeSwgZXh0cmEpO1xuICAgICAgICBIaXN0b3J5LmN1cnJoaXN0b3J5Lm5leHRFbnRyaWVzLnB1c2goaGlzdEVudCk7XG4gICAgICAgIEhpc3RvcnkuY3Vycmhpc3RvcnkgPSBoaXN0RW50O1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY2FuQmFja3dhcmQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBIaXN0b3J5LmN1cnJoaXN0b3J5Lmhhc1ByZXZVUkwgJiZcbiAgICAgICAgICAgICFIaXN0b3J5LmN1cnJoaXN0b3J5LnByZXZFbnRyeT8uZXh0cmE/LndyYXBwZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGJhY2t3YXJkKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICghSGlzdG9yeS5jYW5CYWNrd2FyZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnbyBiYWNrIGFueSBmdXJ0aGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKEhpc3RvcnkuY3Vycmhpc3RvcnkucHJldkVudHJ5KTtcbiAgICAgICAgY29uc3QgcHJldkVudHJ5ID0gSGlzdG9yeS5jdXJyaGlzdG9yeS5wcmV2RW50cnkgYXMgSGlzdG9yeUVudHJ5O1xuICAgICAgICBjb25zdCBuZXh0VVJMID0gcHJldkVudHJ5LmN1cnJVUkw7XG4gICAgICAgIGNvbnN0IGhpc3RFbnQgPSBuZXdIaXN0b3J5RW50cnkoXG4gICAgICAgICAgICBuZXh0VVJMLFxuICAgICAgICAgICAgcHJldkVudHJ5Lmhhc1ByZXZVUkwsXG4gICAgICAgICAgICBwcmV2RW50cnkucHJldkVudHJ5LFxuICAgICAgICAgICAgeyBiYWNrOiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgICAgSGlzdG9yeS5jdXJyaGlzdG9yeSA9IGhpc3RFbnQ7XG4gICAgICAgIHJldHVybiBuZXh0VVJMO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc2V0dXAodXJsOiBzdHJpbmcsIGV4dHJhPzogYW55KSB7XG4gICAgICAgIEhpc3RvcnkuZmlyc3RIaXN0b3J5ID0gbmV3SGlzdG9yeUVudHJ5KHVybCwgZmFsc2UsIHVuZGVmaW5lZCwgZXh0cmEpO1xuICAgICAgICBIaXN0b3J5LmN1cnJoaXN0b3J5ID0gSGlzdG9yeS5maXJzdEhpc3Rvcnk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmlyc3RIaXN0b3J5OiBIaXN0b3J5RW50cnk7XG4gICAgcHJpdmF0ZSBzdGF0aWMgY3Vycmhpc3Rvcnk6IEhpc3RvcnlFbnRyeTtcbn1cblxuKHdpbmRvdyBhcyBhbnkpLmggPSBIaXN0b3J5O1xuIiwiaW1wb3J0IHsgRCB9IGZyb20gJy4uL2RvbS9kb2N1bWVudCc7XG5pbXBvcnQgeyBFbGVtZW50cyB9IGZyb20gJy4uL2RvbS9lbGVtZW50cyc7XG5pbXBvcnQgeyBNb2RhbCB9IGZyb20gJy4uL2RvbS9tb2RhbCc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgZXJyb3IsIGxvZyB9IGZyb20gJy4uL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vdXRpbHMvZnVuY3MnO1xuaW1wb3J0IHsgSFRNTExvYWRlciB9IGZyb20gJy4uL3V0aWxzL2h0bWxfbG9hZGVyJztcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICcuL2hpc3RvcnknO1xubG9nKCdyb3V0ZXIgbG9hZGVkLicsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbmV4cG9ydCBjb25zdCBlbnVtIFJvdXRlck1vZGUge1xuICAgIE9GRixcbiAgICBPTixcbiAgICBTVEFOREFSRF9BTExPV0FOQ0VTLFxufVxuXG4vLyBUT0RPOiBOZWVkIHRvIGltcHJvdmUgdGhpcyB0byB0YWtlIGluIGEgZnVuY3Rpb24gZm9yIHRoZSBhbGxvd2FuY2Ugb3IgcmVkdWNlIGFic3RyYWN0bmVzcyBvdmVyYWxsLlxuXG5leHBvcnQgY29uc3QgZW51bSBSb3V0ZXJNb2R1bGUge1xuICAgIEEgPSAnQScsXG4gICAgSU1HID0gJ0lNRycsXG4gICAgRk9STSA9ICdGT1JNJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJDb25maWcge1xuICAgIG1vZHVsZTogUm91dGVyTW9kdWxlO1xuICAgIG1vZGU6IFJvdXRlck1vZGU7XG59XG5cbmludGVyZmFjZSBGdWxsUm91dGVyQ29uZmlnIGV4dGVuZHMgUm91dGVyQ29uZmlnIHtcbiAgICBzZXR1cChjb25maWc6IEZ1bGxSb3V0ZXJDb25maWcsIGVsZW06IEVsZW1lbnQpOiBhbnk7XG59XG5cbmZ1bmN0aW9uIHRlc3RPbihlbGVtOiBFbGVtZW50LCBjb25maWc6IFJvdXRlckNvbmZpZykge1xuICAgIHJldHVybiAoXG4gICAgICAgIGVsZW0udGFnTmFtZSA9PT0gY29uZmlnLm1vZHVsZSAmJlxuICAgICAgICAoY29uZmlnLm1vZGUgPT09IFJvdXRlck1vZGUuT04gfHxcbiAgICAgICAgICAgIGNvbmZpZy5tb2RlID09PSBSb3V0ZXJNb2RlLlNUQU5EQVJEX0FMTE9XQU5DRVMpXG4gICAgKTtcbn1cbmZ1bmN0aW9uIHRlc3RBbGxvd2FuY2UoY29uZmlnOiBSb3V0ZXJDb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnLm1vZGUgPT09IFJvdXRlck1vZGUuU1RBTkRBUkRfQUxMT1dBTkNFUztcbn1cblxuZXhwb3J0IGNsYXNzIFJvdXRlciB7XG4gICAgcHVibGljIHN0YXRpYyBIQVNIX1RBR1MgPSBuZXcgUmVnRXhwKCcjJyk7XG4gICAgcHVibGljIHN0YXRpYyBFTVBUWSA9IG5ldyBSZWdFeHAoJ14kJyk7XG4gICAgcHVibGljIHN0YXRpYyBBVF9TWU1CT0wgPSBuZXcgUmVnRXhwKCdAJyk7XG5cbiAgICBwdWJsaWMgc3RhdGljIEhBU0hfVEFHX1JFU1BPTkRFUiA9IG5vb3A7XG4gICAgcHVibGljIHN0YXRpYyBFTVBUWV9SRVNQT05ERVIgPSAoZXZlbnQ6IEV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHB1YmxpYyBzdGF0aWMgQVRfU1lNQk9MX1JFU1BPTkRFUiA9IChldmVudDogRXZlbnQpID0+XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBwdWJsaWMgc3RhdGljIHBhdGhQcmVmaXggPSAnJztcblxuICAgIHB1YmxpYyBzdGF0aWMgY29uZmlndXJlKGNvbmZpZ3M6IFJvdXRlckNvbmZpZ1tdLCBwYXRoUHJlZml4OiBzdHJpbmcpIHtcbiAgICAgICAgY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IHtcbiAgICAgICAgICAgIFJvdXRlci5jb25maWdzLnNldChjb25maWcubW9kdWxlLCBSb3V0ZXIudXBncmFkZUNvbmZpZyhjb25maWcpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFJvdXRlci5wYXRoUHJlZml4ID0gcGF0aFByZWZpeDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNldHVwKGVsZW06IEVsZW1lbnQgfCBzdHJpbmcpIHtcbiAgICAgICAgRC5lYWNoUmVjdXIoZWxlbSwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIFJvdXRlci5jb25maWdzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RPbihub2RlLCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zZXR1cChjb25maWcsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBTVEFOREFSRF9MSU5LX0xJU1RFTkVSKGU6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCgpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdGFyZ2V0LmhyZWY7XG4gICAgICAgICAgICBIaXN0b3J5LmZvcndhcmQoUm91dGVyLmdldFBhdGhOYW1lKHVybCkpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gSFRNTExvYWRlci5sb2FkVVJMKHVybCwgRWxlbWVudHMuaHRtbExvYyk7XG4gICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ25ld1BhZ2VMb2FkJykpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBPTl9DT01QTEVURV9TTEwocG9zdDogKGU6IE1vdXNlRXZlbnQpID0+IGFueSkge1xuICAgICAgICByZXR1cm4gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGVycm9yKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlKTtcbiAgICAgICAgICAgICAgICBwb3N0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBJTUFHRV9MSU5LX0xJU1RFTkVSKGU6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IExvYWQgbW9kYWwgb3IgbG9hZCBub3RoaW5nIGF0IGFsbCwgZml4IHRoaXNcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0YXJnZXQuc3JjO1xuICAgICAgICAgICAgSGlzdG9yeS5mb3J3YXJkKFJvdXRlci5nZXRQYXRoTmFtZSh1cmwpKTtcbiAgICAgICAgICAgIHJldHVybiBIVE1MTG9hZGVyLmxvYWRVUkwodXJsLCBFbGVtZW50cy5odG1sTG9jKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBGT1JNX09GRl9MSVNURU5FUihlOiBFdmVudCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQWxsIGZvcm1zIGV4Y2VwdCBmb3IgdGhlIG9uZSBpbiB0aGUgdG9wIGhlYWRlciBhcmUgaW5hY3RpdmUuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdEFsbG93YW5jZXNPbigpIHtcbiAgICAgICAgUm91dGVyLnJlZ2lzdGVyQWxsb3dhbmNlKFxuICAgICAgICAgICAgeyByZWdleDogUm91dGVyLkVNUFRZLCBmdW5jOiBSb3V0ZXIuRU1QVFlfUkVTUE9OREVSIH0sXG4gICAgICAgICAgICB7IHJlZ2V4OiBSb3V0ZXIuSEFTSF9UQUdTLCBmdW5jOiBSb3V0ZXIuSEFTSF9UQUdfUkVTUE9OREVSIH0sXG4gICAgICAgICAgICB7IHJlZ2V4OiBSb3V0ZXIuQVRfU1lNQk9MLCBmdW5jOiBSb3V0ZXIuQVRfU1lNQk9MX1JFU1BPTkRFUiB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIHB1YmxpYyBzdGF0aWMgZGVmYXVsdEFsbG93YW5jZXNPZmYoKSB7XG4gICAgICAgIFJvdXRlci51bnJlZ2lzdGVyQWxsb3dhbmNlKFxuICAgICAgICAgICAgUm91dGVyLkVNUFRZLFxuICAgICAgICAgICAgUm91dGVyLkhBU0hfVEFHUyxcbiAgICAgICAgICAgIFJvdXRlci5BVF9TWU1CT0xcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlckFsbG93YW5jZShcbiAgICAgICAgLi4ucmVnZXhzOiBBcnJheTx7IHJlZ2V4OiBSZWdFeHA7IGZ1bmM6IChldmVudDogRXZlbnQpID0+IGFueSB9PlxuICAgICkge1xuICAgICAgICByZWdleHMuZm9yRWFjaCgocmVnZXgpID0+XG4gICAgICAgICAgICBSb3V0ZXIubGlua0FsbG93YW5jZXMuc2V0KHJlZ2V4LnJlZ2V4LCByZWdleC5mdW5jKVxuICAgICAgICApO1xuICAgIH1cbiAgICBwdWJsaWMgc3RhdGljIHVucmVnaXN0ZXJBbGxvd2FuY2UoLi4ucmVnZXhzOiBSZWdFeHBbXSkge1xuICAgICAgICByZWdleHMuZm9yRWFjaCgocmVnZXgpID0+IFJvdXRlci5saW5rQWxsb3dhbmNlcy5kZWxldGUocmVnZXgpKTtcbiAgICB9XG4gICAgcHVibGljIHN0YXRpYyBjbGVhckFsbG93YW5jZXMoKSB7XG4gICAgICAgIFJvdXRlci5saW5rQWxsb3dhbmNlcy5jbGVhcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZCh1cmw6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBIaXN0b3J5LmZvcndhcmQoUm91dGVyLmdldFBhdGhOYW1lKHVybCkpO1xuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBIVE1MTG9hZGVyLmxvYWRVUkwodXJsLCBFbGVtZW50cy5odG1sTG9jKTtcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCduZXdQYWdlTG9hZCcpKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvYWRXaXRoUGF0aFByZWZpeChwYWdlOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgcmV0ID0gSFRNTExvYWRlci5sb2FkVVJMKFxuICAgICAgICAgICAgUm91dGVyLnBhdGhQcmVmaXggKyBwYWdlLFxuICAgICAgICAgICAgRWxlbWVudHMuaHRtbExvY1xuICAgICAgICApO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ25ld1BhZ2VMb2FkJykpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIFNldHVwRnVuY3Rpb25zID0ge1xuICAgICAgICBBOiAoY29uZmlnOiBGdWxsUm91dGVyQ29uZmlnLCBlbGVtOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhTm9kZSA9IGVsZW0gYXMgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodGVzdEFsbG93YW5jZShjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3Nlc1JlZ2V4VGVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGFOb2RlLmhyZWY7XG4gICAgICAgICAgICAgICAgUm91dGVyLmxpbmtBbGxvd2FuY2VzLmZvckVhY2goKGZ1bmMsIHJlZ2V4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSByZWdleC50ZXN0KGhyZWYpO1xuICAgICAgICAgICAgICAgICAgICBwYXNzZXNSZWdleFRlc3QgPSBwYXNzZXNSZWdleFRlc3QgJiYgIXRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VzUmVnZXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChocmVmLnN1YnN0cihocmVmLmxlbmd0aCAtIDMpID09PSAncGRmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1vZGFsLmRpc3BsYXkoaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihlbGVtLCAnY2xpY2snLCAoZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlIGFzIE1vdXNlRXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKGUpID0+XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5TVEFOREFSRF9MSU5LX0xJU1RFTkVSKGUgYXMgTW91c2VFdmVudClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBJTUc6IChjb25maWc6IEZ1bGxSb3V0ZXJDb25maWcsIGVsZW06IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltZ05vZGUgPSBlbGVtIGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodGVzdEFsbG93YW5jZShjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhc3Nlc1JlZ2V4VGVzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgUm91dGVyLmxpbmtBbGxvd2FuY2VzLmZvckVhY2goKGZ1bmMsIHJlZ2V4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSAhcmVnZXgudGVzdChpbWdOb2RlLnNyYyk7XG4gICAgICAgICAgICAgICAgICAgIHBhc3Nlc1JlZ2V4VGVzdCA9IHBhc3Nlc1JlZ2V4VGVzdCAmJiB0ZXN0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdjbGljaycsIGZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3Nlc1JlZ2V4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKGUpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuU1RBTkRBUkRfTElOS19MSVNURU5FUihlIGFzIE1vdXNlRXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgKGUpID0+XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5TVEFOREFSRF9MSU5LX0xJU1RFTkVSKGUgYXMgTW91c2VFdmVudClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBGT1JNOiAoY29uZmlnOiBGdWxsUm91dGVyQ29uZmlnLCBlbGVtOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtTm9kZSA9IGVsZW0gYXMgSFRNTEZvcm1FbGVtZW50O1xuICAgICAgICAgICAgaWYgKHRlc3RBbGxvd2FuY2UoY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXNzZXNSZWdleFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIFJvdXRlci5saW5rQWxsb3dhbmNlcy5mb3JFYWNoKChmdW5jLCByZWdleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gIXJlZ2V4LnRlc3QoZm9ybU5vZGUuc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VzUmVnZXhUZXN0ID0gcGFzc2VzUmVnZXhUZXN0ICYmIHRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgJ2NsaWNrJywgZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGFzc2VzUmVnZXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3VibWl0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5GT1JNX09GRl9MSVNURU5FUlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRC5hZGRFdmVudExpc3RlbmVyKGVsZW0sICdzdWJtaXQnLCBSb3V0ZXIuRk9STV9PRkZfTElTVEVORVIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBwcml2YXRlIHN0YXRpYyBjb25maWdzID0gbmV3IE1hcDxSb3V0ZXJNb2R1bGUsIEZ1bGxSb3V0ZXJDb25maWc+KCk7XG5cbiAgICBwcml2YXRlIHN0YXRpYyBsaW5rQWxsb3dhbmNlczogTWFwPFJlZ0V4cCwgKGV2ZW50OiBFdmVudCkgPT4gYW55PiA9IG5ldyBNYXA8XG4gICAgICAgIFJlZ0V4cCxcbiAgICAgICAgKGV2ZW50OiBFdmVudCkgPT4gYW55XG4gICAgPigpO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGF0aFJlZ2V4ID0gL1xcLyhbXFx3XSsuaHRtbCkvO1xuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdXBncmFkZUNvbmZpZyhjb25maWc6IFJvdXRlckNvbmZpZyk6IEZ1bGxSb3V0ZXJDb25maWcge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kdWxlOiBjb25maWcubW9kdWxlLFxuICAgICAgICAgICAgbW9kZTogY29uZmlnLm1vZGUsXG4gICAgICAgICAgICBzZXR1cDogUm91dGVyLlNldHVwRnVuY3Rpb25zW2NvbmZpZy5tb2R1bGVdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRQYXRoTmFtZSh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHJldCA9IFJvdXRlci5wYXRoUmVnZXguZXhlYyh1cmwpO1xuICAgICAgICByZXR1cm4gcmV0ID09PSBudWxsID8gdXJsIDogcmV0Lmxlbmd0aCA+IDEgPyByZXRbMV0gOiB1cmw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaXNUcmFja2VyRXZlbnQsIG9iamVjdFRvVHJhY2tlckV2ZW50IH0gZnJvbSAnLi4vZGF0YS1sb2cvZXZlbnQnO1xuaW1wb3J0IHsgRXZlbnRSZWNlaXZlciB9IGZyb20gJy4uL2RhdGEtbG9nL3JlY2VpdmVyJztcbmltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSAnLi4vZG9tL2VsZW1lbnRzJztcbmltcG9ydCB7IFRyYWNrZXJFbGVtZW50cyB9IGZyb20gJy4uL2RvbS90cmFja2VyX2VsZW1zJztcbmltcG9ydCB7IERlYnVnTGV2ZWxFbnVtLCBsb2csIHNldERlYnVnTGV2ZWwgfSBmcm9tICcuLi91dGlscy9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgU2NlbmFyaW8gfSBmcm9tICcuLi91dGlscy9zY2VuYXJpb3MnO1xuaW1wb3J0IHsgTXR1cmtDbGllbnQgfSBmcm9tICcuLy4uL2F3cy9tdHVyayc7XG5pbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi8uLi9kYXRhLWxvZy9kYXRhJztcbmltcG9ydCB7IEFsbG93U3VibWlzc2lvbiwgU3VibWl0Rm9ybSB9IGZyb20gJy4vLi4vZG9tL3N1Ym1pdF9mb3JtJztcblxubG9nKCd0cmFja2VyIGxvYWRlZC4nLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlckNvbmZpZ3VyYXRpb24ge1xuICAgIGFsbG93U3VibWlzc2lvbjogQWxsb3dTdWJtaXNzaW9uO1xuICAgIGRlYnVnTGV2ZWw6IERlYnVnTGV2ZWxFbnVtO1xuICAgIGJ1Y2tldE5hbWU6IHN0cmluZztcbiAgICBrZXlQcmVmaXg6IHN0cmluZztcbiAgICBzZXR1cCgpOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgVHJhY2tlciB7XG4gICAgcHVibGljIHN0YXRpYyBsYXN0UG9zID0geyB4OiAwLCB5OiAwLCB0aW1lOiAwIH07XG5cbiAgICBwdWJsaWMgc3RhdGljIGxvYWRTY2VuYXJpbyhzY2VuOiBTY2VuYXJpbykge1xuICAgICAgICBsZXQgc3ViID0gc2Nlbi5zY2VuYXJpbztcbiAgICAgICAgaWYgKHN1Yi5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgc3ViID0gc3ViLnN1YnN0cmluZygwLCA1MCk7XG4gICAgICAgICAgICBjb25zdCBpbmRzID0gW1xuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignICcpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignLicpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignLCcpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignPycpLFxuICAgICAgICAgICAgICAgIHN1Yi5sYXN0SW5kZXhPZignIScpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGluZCA9IE1hdGgubWF4KC4uLmluZHMpO1xuICAgICAgICAgICAgc3ViID0gc3ViLnN1YnN0cmluZygwLCBpbmQpICsgJy4uLic7XG4gICAgICAgIH1cblxuICAgICAgICBFbGVtZW50cy5tdFRvcEJhbm5lclRleHQuaW5uZXJUZXh0ID0gc3ViO1xuICAgICAgICBFbGVtZW50cy5tdFNjZW5hcmlvQ29udGV4dC5pbm5lclRleHQgPSBzY2VuLnNjZW5hcmlvO1xuICAgICAgICBFbGVtZW50cy5tdFNjZW5hcmlvUXVlc3Rpb24uaW5uZXJUZXh0ID0gc2Nlbi5xdWVzdGlvbjtcbiAgICAgICAgRWxlbWVudHMuaHRtbExvYy5kYXRhc2V0LnRhc2sgPSBzY2VuLnRhZztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHN0YXJ0KGNvbmZpZzogVHJhY2tlckNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgc2V0RGVidWdMZXZlbChjb25maWcuZGVidWdMZXZlbCk7XG4gICAgICAgIC8vIGNvbmZpZ3VyZSB0cmFja2VyIHNwZWNpZmljIGVsZW1lbnRzXG4gICAgICAgIFRyYWNrZXJFbGVtZW50cy5zZXR1cFRyYWNrZXJFbGVtZW50cygpO1xuICAgICAgICBTdWJtaXRGb3JtLnNldHVwKGNvbmZpZy5hbGxvd1N1Ym1pc3Npb24pO1xuICAgICAgICBNdHVya0NsaWVudC5pbml0KGNvbmZpZy5idWNrZXROYW1lLCBjb25maWcua2V5UHJlZml4KTtcbiAgICAgICAgZGF0YS5kYXRhLnRhc2sgPSBFbGVtZW50cy5odG1sTG9jLmRhdGFzZXQudGFzaztcbiAgICAgICAgY29uZmlnLnNldHVwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlckV2ZW50KGV2ZW50VHlwZTogc3RyaW5nKSB7XG4gICAgICAgIGRhdGEubG9nc1tldmVudFR5cGVdID0gW107XG4gICAgICAgIHRoaXMucmVjZWl2ZXIucmVnaXN0ZXIoZXZlbnRUeXBlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGRhdGEubG9nc1tldmVudFR5cGVdLnB1c2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXZlbnREaXNwYXRjaEZ1bmMoZXZlbnRUeXBlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEV2ZW50RGlzcGF0Y2hGdW5jKGV2ZW50VHlwZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAoZXZEYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZEYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICghaXNUcmFja2VyRXZlbnQoZXZEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RUb1RyYWNrZXJFdmVudChldkRhdGEsIGV2ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZXIuZG9FdmVudChldkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXR0YWNoRGF0YShrZXk6IHN0cmluZywgYXR0cmlidXRlOiBhbnkpIHtcbiAgICAgICAgZGF0YS5kYXRhW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjb21wdXRlQXR0cmlidXRlKG5hbWU6IHN0cmluZywgY29tcHV0ZTogKHZhbDogYW55KSA9PiBhbnkpIHtcbiAgICAgICAgZGF0YS5kYXRhW25hbWVdID0gY29tcHV0ZShkYXRhLmRhdGFbbmFtZV0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHJlY2VpdmVyID0gbmV3IEV2ZW50UmVjZWl2ZXIoKTtcbn1cbiIsImltcG9ydCB7IGRhdGEgfSBmcm9tIFwiLi8uLi9kYXRhLWxvZy9kYXRhXCI7XG5sb2coXCJjb25zb2xlIHdyYXBwZXIgbG9hZGVkLlwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXJyb3I8VD4oXG4gIGZ1bmM6ICguLi5hcmdzOiBhbnkpID0+IFRcbik6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICByZXR1cm4gZXJyb3JITyhmdW5jKSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3JITzxUPihcbiAgZnVuYzogKC4uLmFyZ3M6IGFueSkgPT4gVFxuKTogKC4uLmFyZ3M6IGFueSkgPT4gUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gIHJldHVybiBhc3luYyAoLi4uYXJnczogYW55KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jKGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkYXRhLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gRGVidWdMZXZlbEVudW0ge1xuICBOT05FID0gMSxcbiAgQkFTSUMgPSAyLFxuICBERVRBSUxFRCA9IDMsXG59XG5cbmxldCBkZWJ1Z0xldmVsOiBEZWJ1Z0xldmVsRW51bSA9IERlYnVnTGV2ZWxFbnVtLkJBU0lDO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdMZXZlbChsZXZlbDogRGVidWdMZXZlbEVudW0pIHtcbiAgZGVidWdMZXZlbCA9IGxldmVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nKG1lc3NhZ2U6IHN0cmluZywgaW1wb3J0YW5jZTogRGVidWdMZXZlbEVudW0pIHtcbiAgaWYgKGRlYnVnTGV2ZWwgPj0gaW1wb3J0YW5jZSkge1xuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSBcIi4vY29uc29sZV93cmFwcGVyXCI7XG5sb2coXCJmdW5jcyBsb2FkZWQuXCIsIERlYnVnTGV2ZWxFbnVtLkJBU0lDKTtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZW1wdHlcbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cbmV4cG9ydCBmdW5jdGlvbiBub3coKTogbnVtYmVyIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuIiwiaW1wb3J0IHsgRCB9IGZyb20gJy4uL2RvbS9kb2N1bWVudCc7XG5pbXBvcnQgeyBEZWJ1Z0xldmVsRW51bSwgbG9nIH0gZnJvbSAnLi9jb25zb2xlX3dyYXBwZXInO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vZnVuY3MnO1xubG9nKCdodG1sIGxvYWRlciBsb2FkZWQuJywgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuZXhwb3J0IGludGVyZmFjZSBDYWNoZSB7XG4gICAgW25hbWU6IHN0cmluZ106IEVsZW1lbnQ7XG59XG5leHBvcnQgY2xhc3MgSFRNTExvYWRlciB7XG4gICAgcHVibGljIHN0YXRpYyBDQUNIRTogQ2FjaGUgPSB7fTtcblxuICAgIHB1YmxpYyBzdGF0aWMgZmluaXNoKCkge1xuICAgICAgICBIVE1MTG9hZGVyLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgSFRNTExvYWRlci5mbGF0dGVuVFNMb2FkVGFncygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIEhUTUxMb2FkZXIuZmluaXNoZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjYWNoZUhUTUwobmFtZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKEhUTUxMb2FkZXIuZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGNhY2hlIG5ldyBIVE1MIGVudGl0aWVzIGFmdGVyIHRoZSBhcHBsaWNhdGlvbiBoYXMgYmVlbiBzdGFydGVkLidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHNsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHMtbG9hZCcpO1xuICAgICAgICB0c2wuZGF0YXNldC5uYW1lID0gbmFtZTtcbiAgICAgICAgdHNsLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuQ0FDSEVbbmFtZV0gPSB0c2w7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlclBvc3RMb2FkRnVuYyhmdW5jOiAoKSA9PiBhbnkpIHtcbiAgICAgICAgbG9nKCdyZWdzaXRlciBwb3N0IGxvYWQgZnVuY3Rpb24nLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgIEhUTUxMb2FkZXIucG9zdExvYWRGdW5jID0gZnVuYztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGxvYWQoaHRtbDogc3RyaW5nLCBlbGVtOiBFbGVtZW50IHwgc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZygnYmVnaW4gbG9hZCcsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gRC5lbGVtKGVsZW0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhZyA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChodG1sKTtcbiAgICAgICAgICAgICAgICBIVE1MTG9hZGVyLnJlbW92ZVRhZ3NGcm9tRG9jdW1lbnRGcmFnbWVudChmcmFnLCAnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgSFRNTExvYWRlci5sb2FkQWxsQ2FjaGVkRWxlbWVudHMoZnJhZyk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgICAgICAgICAgIGxvZygnZW5kIGxvYWQnLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgICAgICAgICAgSFRNTExvYWRlci5wb3N0TG9hZEZ1bmMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9hZFVSTCh1cmw6IHN0cmluZywgZWxlbTogRWxlbWVudCB8IHN0cmluZykge1xuICAgICAgICByZXR1cm4gSFRNTExvYWRlci5sb2FkKGF3YWl0IEhUTUxMb2FkZXIuZ2V0SFRNTCh1cmwpLCBlbGVtKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEhUTUwodXJsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZygnYmVnaW4gcmVxdWVzdCcsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdyZXNvbHZlIHJlcXVlc3QnLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluaXNoZWQgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgc3RhdGljIHBvc3RMb2FkRnVuYzogKCkgPT4gYW55ID0gbm9vcDtcblxuICAgIHByaXZhdGUgc3RhdGljIHJlbW92ZVRhZ3NGcm9tRG9jdW1lbnRGcmFnbWVudChcbiAgICAgICAgZnJhZzogRG9jdW1lbnRGcmFnbWVudCxcbiAgICAgICAgdGFnTmFtZTogc3RyaW5nXG4gICAgKSB7XG4gICAgICAgIGZyYWcucXVlcnlTZWxlY3RvckFsbCh0YWdOYW1lKS5mb3JFYWNoKCh0YWcpID0+IGZyYWcucmVtb3ZlQ2hpbGQodGFnKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmxhdHRlblRTTG9hZFRhZ3MoKSB7XG4gICAgICAgIGxvZygnRmxhdHRlbmluZycsIERlYnVnTGV2ZWxFbnVtLkRFVEFJTEVEKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICBPYmplY3Qua2V5cyhIVE1MTG9hZGVyLkNBQ0hFKS5mb3JFYWNoKFxuICAgICAgICAgICAgKG5hbWUpID0+XG4gICAgICAgICAgICAgICAgKEhUTUxMb2FkZXIuQ0FDSEVbbmFtZV0gPSBIVE1MTG9hZGVyLmZsYXR0ZW5UU0xvYWRUYWcoXG4gICAgICAgICAgICAgICAgICAgIEhUTUxMb2FkZXIuZ2V0Q2FjaGVkQ29udGVudChuYW1lKSBhcyBFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKSBhcyBFbGVtZW50KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIG11bHRpcGxlVGFicyhuOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBsZXQgcmV0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICByZXQgKz0gJ1xcdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmbGF0dGVuVFNMb2FkVGFnKFxuICAgICAgICBlbGVtOiBFbGVtZW50LFxuICAgICAgICBmbGF0dGVuZWQ6IFNldDxzdHJpbmc+LFxuICAgICAgICBjb3VudDogbnVtYmVyXG4gICAgKTogRWxlbWVudCB8IG51bGwge1xuICAgICAgICBjb25zdCB0YWJzID0gSFRNTExvYWRlci5tdWx0aXBsZVRhYnMoY291bnQpO1xuICAgICAgICBpZiAoY291bnQgPiAxMDApIHtcbiAgICAgICAgICAgIGFsZXJ0KCdDaGVjayB0aGUgY29uc29sZSwgYW4gZXJyb3IgaGFzIG9jY3VycmVkLicpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdJdCBzZWVtcyBsaWtlIHlvdSBtaWdodCBoYXZlIGluZmluaXRlbHkgcmVjdXJzaXZlbHkgbmVzdGVkIHRhZ3MuJyArXG4gICAgICAgICAgICAgICAgICAgICdcXG5IZXJlIGFyZSBhbGwgb2YgdGhlIHRhZ3MgdGhhdCBoYXZlIGJlZW4gZmxhdHRlbmVkIHNvIGZhcjogJyArXG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZCArXG4gICAgICAgICAgICAgICAgICAgICdcXG5IZXJlIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLW5hbWUnKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBIVE1MTG9hZGVyLmdldENhY2hlZENvbnRlbnQobmFtZSk7XG4gICAgICAgIGlmIChjb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhdHRlbmVkLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKS5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZSgpKTtcbiAgICAgICAgY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCd0cy1sb2FkJykuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBIVE1MTG9hZGVyLmZsYXR0ZW5UU0xvYWRUYWcoZSwgZmxhdHRlbmVkLCBjb3VudCArIDEpO1xuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZS5yZXBsYWNlV2l0aChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmbGF0dGVuZWQuYWRkKG5hbWUpO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRDYWNoZWRDb250ZW50KFxuICAgICAgICBuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgKTogRWxlbWVudCB8IG51bGwge1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBIVE1MTG9hZGVyLkNBQ0hFW25hbWVdO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50LmNsb25lTm9kZSh0cnVlKSBhcyBFbGVtZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGxvYWRBbGxDYWNoZWRFbGVtZW50cyhmcmFnOiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGZyYWcucXVlcnlTZWxlY3RvckFsbCgndHMtbG9hZCcpLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJyk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gSFRNTExvYWRlci5nZXRDYWNoZWRDb250ZW50KG5hbWUpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsZW0ucmVwbGFjZVdpdGgoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEVsZW1lbnRzIH0gZnJvbSBcIi4uL2RvbS9lbGVtZW50c1wiO1xuaW1wb3J0IHsgRCB9IGZyb20gXCIuLy4uL2RvbS9kb2N1bWVudFwiO1xuaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gXCIuL2NvbnNvbGVfd3JhcHBlclwiO1xubG9nKFwiaWQgZ2VuZXJhdG9yIGxvYWRlZFwiLCBEZWJ1Z0xldmVsRW51bS5CQVNJQyk7XG5leHBvcnQgY2xhc3MgSURHZW5lcmF0b3Ige1xuICBwdWJsaWMgc3RhdGljIHJlc2V0KCkge1xuICAgIElER2VuZXJhdG9yLmlkQ291bnQgPSAwO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBnZXQgbmV4dCgpIHtcbiAgICBJREdlbmVyYXRvci5pZENvdW50ICs9IDE7XG4gICAgcmV0dXJuIElER2VuZXJhdG9yLnByZWZpeCArIElER2VuZXJhdG9yLmlkQ291bnQ7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFwcGx5SUQoZWxlbTogRWxlbWVudCkge1xuICAgIGVsZW0uaWQgPSBlbGVtLmlkID8gZWxlbS5pZCA6IElER2VuZXJhdG9yLm5leHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgYWRkcyBpZHMgdG8gYWxsIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSBnaXZlblxuICAgKiBlbGVtZW50IGluIHRoZSBoZWlyYXJjaHkuXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW1lbnQgdG8gc3RhcnQgYXBwbHlpbmcgaWRzIHRvIGl0cyBjaGlsZHJlbi5cbiAgICogICAgICAgICAgICAgICAgICBXaWxsIG5vdCBhcHBseSBhbiBpZCB0byB0aGlzIGVsZW1lbnQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcGx5UmVjdXIoZWxlbTogRWxlbWVudCB8IHN0cmluZykge1xuICAgIEQuZWFjaFJlY3VyKGVsZW0sIHRoaXMuYXBwbHlJRCk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoZXMgaWRzIHRvIGFsbCBodG1sIGVsZW1lbnRzIGluIHRoZSB0YXJnZXQgbG9jYXRpb24gaW4gdGhlIERPTSB0aGF0IGRvIG5vdCBoYXZlIGlkcy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXR0YWNoSWRzVG9BbGxFbGVtZW50cygpIHtcbiAgICBJREdlbmVyYXRvci5hcHBseVJlY3VyKEVsZW1lbnRzLmh0bWxMb2MpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgaWRDb3VudCA9IDA7XG4gIHByaXZhdGUgc3RhdGljIHByZWZpeCA9IFwiYXV0b19nZW5faWRfdW5xX1wiO1xufVxuIiwiaW1wb3J0IHsgRGVidWdMZXZlbEVudW0sIGxvZyB9IGZyb20gXCIuL2NvbnNvbGVfd3JhcHBlclwiO1xuXG5sb2coXCJyZWFkeSBsb2FkZWRcIiwgRGVidWdMZXZlbEVudW0uQkFTSUMpO1xuXG5sZXQgcmVhZHkgPSBmYWxzZTtcblxubGV0IHJlc29sdmVGdW5jOiAodmFsOiBib29sZWFuKSA9PiBhbnk7XG5sZXQgcmVqZWN0RnVuYztcbmNvbnN0IHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlOiAodmFsOiBib29sZWFuKSA9PiBhbnksIHJlamVjdCkgPT4ge1xuICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gIHJlamVjdEZ1bmMgPSByZWplY3Q7XG59KTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICBsb2coXCJkb2N1bWVudCBpcyByZWFkeVwiLCBEZWJ1Z0xldmVsRW51bS5ERVRBSUxFRCk7XG4gIHJlYWR5ID0gdHJ1ZTtcbiAgcmVzb2x2ZUZ1bmModHJ1ZSk7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVhZHkoKSB7XG4gIHJldHVybiByZWFkeTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3YWl0VW50aWxSZWFkeSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIHJlYWR5ID8gUHJvbWlzZS5yZXNvbHZlKHRydWUpIDogcmVhZHlQcm9taXNlO1xufVxuIiwiaW1wb3J0IHsgRCB9IGZyb20gXCIuLy4uL2NvcmUvZG9tL2RvY3VtZW50XCI7XG5cbmV4cG9ydCBjbGFzcyBBY2NvcmRpb24ge1xuICBwdWJsaWMgc3RhdGljIHNldHVwQWxsKCkge1xuICAgIEFjY29yZGlvbi5kaXNjYXJkQWxsKCk7XG4gICAgY29uc3QgYWNjb3JkaW9ucyA9IEQuY2xheihcImFjY29yZGlvblwiKTtcbiAgICBmb3IgKGxldCBhY2NJbmRleCA9IDA7IGFjY0luZGV4IDwgYWNjb3JkaW9ucy5sZW5ndGg7ICsrYWNjSW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBhY2NvcmRpb25zLml0ZW0oYWNjSW5kZXgpO1xuICAgICAgaWYgKGVsZW0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIEFjY29yZGlvbi5hY2NvcmRpb25zLnB1c2gobmV3IEFjY29yZGlvbihlbGVtKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBkaXNjYXJkQWxsKCkge1xuICAgIEFjY29yZGlvbi5hY2NvcmRpb25zID0gW107XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBhY2NvcmRpb25zOiBBY2NvcmRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3V0ZXI6IEVsZW1lbnQpIHtcbiAgICBELmFkZEV2ZW50TGlzdGVuZXIob3V0ZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgLyogVG9nZ2xlIGJldHdlZW4gYWRkaW5nIGFuZCByZW1vdmluZyB0aGUgXCJhY3RpdmVcIiBjbGFzcyxcbiAgICAgICAgICAgICAgICB0byBoaWdobGlnaHQgdGhlIGJ1dHRvbiB0aGF0IGNvbnRyb2xzIHRoZSBwYW5lbCAqL1xuICAgICAgdGhpcy5vdXRlci5jbGFzc0xpc3QudG9nZ2xlKFwiYWN0aXZlXCIpO1xuXG4gICAgICAvKiBUb2dnbGUgYmV0d2VlbiBoaWRpbmcgYW5kIHNob3dpbmcgdGhlIGFjdGl2ZSBwYW5lbCAqL1xuICAgICAgY29uc3QgcGFuZWwgPSB0aGlzLm91dGVyLm5leHRFbGVtZW50U2libGluZyBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmIChwYW5lbC5zdHlsZS5kaXNwbGF5ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgcGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRvU29tZXRoaW5nKCkge1xuICBjb25zb2xlLmxvZyhcIlB1dCBzb21lIGNvZGUgaW4gaGVyZSFcIik7XG59XG4iLCJpbXBvcnQgeyBIVE1MTG9hZGVyIH0gZnJvbSAnLi4vY29yZS91dGlscy9odG1sX2xvYWRlcic7XG5pbXBvcnQgeyBBY2NvcmRpb24gfSBmcm9tICcuL2FjY29yZGlvbic7XG5pbXBvcnQgeyBkb1NvbWV0aGluZyB9IGZyb20gJy4vZG8tc29tZXRoaW5nJztcbmltcG9ydCB7IEhUTUxDb250ZW50LCBpdGVtc1RvQ2FjaGUgfSBmcm9tICcuL2h0bWwtaW1wb3J0cyc7XG5pbXBvcnQgeyBTbGlkZXNob3cgfSBmcm9tICcuL3NsaWRlc2hvdyc7XG5cbi8vIFB1dCBhbGwgZnVuY3Rpb24gY2FsbHMgdGhhdCBuZWVkIHRvIGJlIG1hZGUgb24gZXZlcnkgcGFnZSBsb2FkIGluc2lkZSB0aGUgc2V0dXBBbGwgZnVuY3Rpb24gYm9keS5cbmV4cG9ydCBmdW5jdGlvbiBQdXRTdHVkZW50UGFnZUxvYWRPcGVyYXRpb25zSW5zaWRlVGhpc1N0dWRlbnRCb2R5KCkge1xuICAgIC8vIFRPRE86IFB1dCBhbGwgb3BlcmF0aW9ucyB0aGF0IHlvdSB3YW50IHRvIGhhcHBlbiBvbiBldmVyIHBhZ2UgbG9hZCBpbiB0aGlzIGZ1bmN0aW9uLlxuICAgIC8vIEZvciBleGFtcGxlIHlvdSBjb3VsZCB3cml0ZTogU3RpY2t5LnNldHVwKClcbiAgICBkb1NvbWV0aGluZygpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBBbGwoKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHI6IGFueSkgPT4gc2V0VGltZW91dChyLCAxMDApKTtcbiAgICBjb25zb2xlLmxvZygncmVsb2FkaW5nJyk7XG4gICAgU2xpZGVzaG93LnNldHVwQWxsKCk7XG4gICAgQWNjb3JkaW9uLnNldHVwQWxsKCk7XG4gICAgUHV0U3R1ZGVudFBhZ2VMb2FkT3BlcmF0aW9uc0luc2lkZVRoaXNTdHVkZW50Qm9keSgpO1xuICAgIGNvbnNvbGUubG9nKCdyZWxvYWRlZCcpO1xufVxuXG5pdGVtc1RvQ2FjaGUuZm9yRWFjaCgoaXRlbTogSFRNTENvbnRlbnQpID0+IHtcbiAgICBIVE1MTG9hZGVyLmNhY2hlSFRNTChpdGVtLm5hbWUsIGl0ZW0uY29udGVudCk7XG59KTtcbih3aW5kb3cgYXMgYW55KS5IVE1MTG9hZGVyID0gSFRNTExvYWRlcjtcblxuY29uc29sZS5sb2coJ2R5bmFtaWMtZG9tIGxvYWRlZCcpO1xuLy8gRG8gbm90IHRvdWNoIHRoaXMgbGluZSwgbmVlZGVkIHRvIHJlaW5pdGlhbGl6ZSBjb2RlIGluIHRoZSBkeW5hbWljLWRvbS50cyBzZXR1cEFsbCBmdW5jdGlvblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25ld1BhZ2VMb2FkJywgKCkgPT4gc2V0dXBBbGwoKSk7XG4iLCJkZWNsYXJlIGZ1bmN0aW9uIHJlcXVpcmUoaWQ6IHN0cmluZyk6IHN0cmluZztcblxuLy8gVGhpcyBkZWZpbmVzIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgcGFzc2VkIHRvIHRoZSBIVE1MTG9hZGVyIHRvIGNhY2hlIHlvdXIgaHRtbCBjb250ZW50LlxuZXhwb3J0IGludGVyZmFjZSBIVE1MQ29udGVudCB7XG4gICAgbmFtZTogc3RyaW5nOyAvLyBUaGUgbmFtZSB0aGF0IHlvdSB3aWxsIHVzZSB0byByZWZlcmVuY2UgdGhlIGNvbnRlbnQgaW4geW91ciBodG1sIHBhZ2VzLlxuICAgIGNvbnRlbnQ6IHN0cmluZzsgLy8gVGhlIGFjdHVhbCBodG1sIHN0cmluZyB0aGF0IHdpbGwgYmUgcHVsbGVkIGZyb20gdGhlIHNvdXJjZSBmaWxlIHRoYXQgeW91IHNwZWNpZnkuXG59XG5cbi8vIEFuIEhUTUxDb250ZW50IG9iamVjdCBzaG91bGQgbG9vayBsaWtlIHRoZSBmb2xsb3dpbmc6XG4vLyB7XG4vLyAgICAgbmFtZTogJ2Zvb3RlcicsXG4vLyAgICAgY29udGVudDogcmVxdWlyZSgnLi9odG1sL2Zvb3Rlci5odG1sJyksXG4vLyB9XG5cbi8vIFRoZW4geW91IGNhbiByZWZlcmVuY2UgdGhhdCBjb250ZW50IGluIHlvdXIgaHRtbCB1c2luZyB0aGUgZm9sbG93aW5nIHRhZyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG5hbWUgYXR0cmlidXRlLlxuLy8gPHRzLWxvYWQgZGF0YS1uYW1lPVwiaGVhZGVyXCI+PC90cy1sb2FkPlxuXG4vLyBZb3UgY2FuIHNwZWNpZnkgYXMgbWFueSBhcyB5b3Ugd2FudCBpbnNpZGUgb2YgdGhlIGFycmF5IGFuZCB0aGV5IHdpbGwgYWxsIGJlIGJ1bmRsZWQgdXAgd2l0aCB5b3VyIHdlYnNpdGUuXG4vLyBNYWtlIHN1cmUgdG8gbWFrZSBhIGNvcnJlc3BvbmRpbmcgaHRtbCBmaWxlIGluIHRoZSBodG1sIGZpbGUgZm9sZGVyIGZvciBlYWNoIGVsZW1lbnQgeW91IHNwZWNpZnkuXG5cbmV4cG9ydCBjb25zdCBpdGVtc1RvQ2FjaGUgPSBbXG4gICAgLy8gRmVlbCBmcmVlIHRvIGNoYW5nZSB0aGUgY29udGVudCBpbnNpZGUgYW55IG9mIHRoZSBodG1sIGZpbGVzIGluIHRoZSBodG1sIGZpbGUgZm9sZGVyIHRvIHN1aXQgeW91ciBuZWVkcy5cbiAgICB7XG4gICAgICAgIG5hbWU6ICdoZWFkZXInLFxuICAgICAgICBjb250ZW50OiByZXF1aXJlKCcuL2h0bWwvaGVhZGVyLmh0bWwnKSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2Zvb3RlcicsXG4gICAgICAgIGNvbnRlbnQ6IHJlcXVpcmUoJy4vaHRtbC9mb290ZXIuaHRtbCcpLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbmVzdGVkJyxcbiAgICAgICAgY29udGVudDogcmVxdWlyZSgnLi9odG1sL25lc3RlZC5odG1sJyksXG4gICAgfSxcbiAgICAvLyBQdXQgbW9yZSBpdGVtcyBpbiB0aGUgYXJyYXkgYmVsb3cgaGVyZS5cbl07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiPGZvb3RlciBpZD1cXFwiY29sb3Bob25cXFwiIGNsYXNzPVxcXCJmb290ZXJcXFwiIHJvbGU9XFxcImNvbnRlbnRpbmZvXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImZvb3Rlci13aWRnZXRzXFxcIj5cXG4gICAgICA8YXNpZGUgY2xhc3M9XFxcIndpZGdldCBzaXRlLWNvbnRhY3RcXFwiPlxcbiAgICAgICAgPGgyIGNsYXNzPVxcXCJmb290ZXItd2lkZ2V0LXRpdGxlXFxcIj5OdXJzZXJ5IFNjaG9vbDwvaDI+XFxuICAgICAgICA8cD42OTI2IEZvcmVzdCBQYXJrIFBhcmt3YXk8L3A+XFxuICAgICAgICA8cD5TdC4gTG91aXMsIE1PIDYzMTMwPC9wPlxcbiAgICAgICAgPHAgY2xhc3M9XFxcInBob25lXFxcIj4zMTQtOTM1LTY2ODkgPHNwYW4+fDwvc3Bhbj4gRmF4OiAzMTQtOTM1LTcyNDk8L3A+XFxuICAgICAgICA8cD5cXG4gICAgICAgICAgPGEgaHJlZj1cXFwiZmlsZXMvbWFpbHRvOm51cnNlcnlAd3VzdGwuZWR1XFxcIj5udXJzZXJ5QHd1c3RsLmVkdTwvYT5cXG4gICAgICAgIDwvcD5cXG4gICAgICA8L2FzaWRlPlxcblxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIndpZGdldC13cmFwcGVyXFxcIj5cXG4gICAgICAgIDxhc2lkZSBpZD1cXFwidGV4dC00XFxcIiBjbGFzcz1cXFwid2lkZ2V0IHdpZGdldF90ZXh0IHdpZGdldC1jb3VudC0yXFxcIj5cXG4gICAgICAgICAgPGgyIGNsYXNzPVxcXCJmb290ZXItd2lkZ2V0LXRpdGxlXFxcIj5Ib3VycyBvZiBPcGVyYXRpb248L2gyPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0ZXh0d2lkZ2V0XFxcIj5cXG4gICAgICAgICAgICA8cD5cXG4gICAgICAgICAgICAgIENsYXNzZXMgbWVldCBNb24uIHRocm91Z2ggRnJpLjxiciAvPlxcbiAgICAgICAgICAgICAgTW9ybmluZzogOS0xMTo0NSBhLm0uPGJyIC8+XFxuICAgICAgICAgICAgICBBZnRlcm5vb246IDEyOjMwLTM6MTUgcC5tLjxiciAvPlxcbiAgICAgICAgICAgICAgRnVsbCBkYXk6IDkgYS5tLi0zOjE1IHAubS5cXG4gICAgICAgICAgICA8L3A+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9hc2lkZT5cXG4gICAgICAgIDxhc2lkZSBpZD1cXFwidGV4dC0zXFxcIiBjbGFzcz1cXFwid2lkZ2V0IHdpZGdldF90ZXh0IHdpZGdldC1jb3VudC0yXFxcIj5cXG4gICAgICAgICAgPGgyIGNsYXNzPVxcXCJmb290ZXItd2lkZ2V0LXRpdGxlXFxcIj5BcHBseSBmb3IgdGhlIE51cnNlcnkgU2Nob29sPC9oMj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwidGV4dHdpZGdldFxcXCI+XFxuICAgICAgICAgICAgPHA+XFxuICAgICAgICAgICAgICBFeHBlcmllbmNlIHRoZSBpbm5vdmF0aXZlIGFwcHJvYWNoIGFuZCBkeW5hbWljIHRlYWNoaW5nXFxuICAgICAgICAgICAgICBlbnZpcm9ubWVudCBvZiB0aGUgV2FzaGluZ3RvbiBVbml2ZXJzaXR5IE51cnNlcnkgU2Nob29sLlxcbiAgICAgICAgICAgIDwvcD5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCJmaWxlcy9hcHBseS5odG1sXFxcIj5SZWdpc3RlciBOb3c8L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9hc2lkZT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcInNpdGUtaW5mb1xcXCI+XFxuICAgICAgPHAgY2xhc3M9XFxcImZvb3Rlci1jb3B5cmlnaHRcXFwiPsKpMjAxOSBXYXNoaW5ndG9uIFVuaXZlcnNpdHkgaW4gU3QuIExvdWlzPC9wPlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZm9vdGVyPlwiO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgaWQ9XFxcInd1c3RsLWJyYW5kaW5nXFxcIj5cXG4gIDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMzIxXFxcIiBoZWlnaHQ9XFxcIjI4XFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIxIDI4XFxcIiBjbGFzcz1cXFwid2FzaHUtbG9nb1xcXCJcXG4gICAgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ0aXRsZVxcXCI+XFxuICAgIDx0aXRsZSBpZD1cXFwidGl0bGVcXFwiPldhc2hpbmd0b24gVW5pdmVyc2l0eSBpbiBTdC4gTG91aXM8L3RpdGxlPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjRkZGXFxcIlxcbiAgICAgIGQ9XFxcIk0xMC40NiAxLjc2Yy0uMDkgMC00LjQxLjA0LTEwLjQ2LTEuMjFWMThjMCAuMjcuMDEuNDcuMDEuNDd2LjAyYy4wNC44MS4yOCAxLjQ1Ljc3IDIgLjMyLjM0Ljc2LjcgMS4zOCAxLjA1LjE3LjEuMzUuMTguNTUuMjguMTUuMDcuMzEuMTQuNDcuMi4xNC4wNi41NS4yNC42OS4yOWw2LjU5IDIuNSA2LjU5LTIuNWMuMTUtLjA1LjU2LS4yNC42OS0uMjkuMTYtLjA3LjMyLS4xNC40Ny0uMi4xOS0uMS4zOC0uMTguNTUtLjI4LjYyLS4zNSAxLjA2LS43IDEuMzgtMS4wNS40OC0uNTUuNzMtMS4xOS43Ny0ydi0uMDJzMC0uMTkuMDEtLjQ3Vi41NUMxNC44NiAxLjggMTAuNTUgMS43NiAxMC40NiAxLjc2elxcXCI+XFxuICAgIDwvcGF0aD5cXG4gICAgPHBhdGggZmlsbD1cXFwiIzAwNzM2MFxcXCJcXG4gICAgICBkPVxcXCJNMTAuNDYgMi44Yy0uMDkgMC00LjAzLjA0LTkuNTYtMS4xdjE1Ljk1YzAgLjI1LjAxLjQzLjAxLjQ0di4wMmMuMDQuNzQuMjUgMS4zMy43IDEuODMuMjkuMzEuNy42NCAxLjI2Ljk1LjE1LjA5LjMyLjE3LjUuMjYuMTQuMDcuMjguMTMuNDQuMTkuMTIuMDUuNS4yMi42My4yN2w2LjAzIDIuMjkgNi4wMy0yLjI5Yy4xMy0uMDUuNTEtLjIyLjYzLS4yNy4xNS0uMDYuMy0uMTMuNDQtLjE5LjE4LS4wOS4zNS0uMTcuNS0uMjYuNTYtLjMxLjk3LS42NCAxLjI2LS45NS40NC0uNS42Ni0xLjA5LjctMS44M3YtLjAyczAtLjE4LjAxLS40NFYxLjdjLTUuNTUgMS4xNC05LjUgMS4xLTkuNTggMS4xelxcXCI+XFxuICAgIDwvcGF0aD5cXG4gICAgPHBhdGggZmlsbD1cXFwiI0UxQzRBQ1xcXCJcXG4gICAgICBkPVxcXCJNMTAuNDYgMy43NWMtLjA4IDAtMy42OC4wNC04Ljc0LTEuMDJ2NC4wOGM1LjA1IDEuMDUgOC42NyAxLjAyIDguNzQgMS4wMnMzLjY4LjA0IDguNzQtMS4wMlYyLjczYy01LjA2IDEuMDUtOC42NiAxLjAyLTguNzQgMS4wMnpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNBNTE0MTdcXFwiXFxuICAgICAgZD1cXFwiTTEwLjQ2IDcuODNjLS4wOCAwLTMuNjguMDQtOC43NC0xLjAydjkuMDVjNS4wNSAxLjA1IDguNjcgMS4wMiA4Ljc0IDEuMDJzMy42OC4wNCA4Ljc0LTEuMDJWNi44MmMtNS4wNiAxLjA0LTguNjYgMS4wMS04Ljc0IDEuMDF6XFxcIj5cXG4gICAgPC9wYXRoPlxcbiAgICA8cGF0aCBmaWxsPVxcXCIjRTFDNEFDXFxcIlxcbiAgICAgIGQ9XFxcIk0xLjcyIDE3LjcyYy4wMy42OS4yMyAxLjIzLjY0IDEuNjguMjYuMjguNjQuNTggMS4xNS44Ny4xNS4wOC4yOS4xNS40Ni4yMy4xMy4wNi4yNi4xMi40LjE3LjExLjA1LjQ2LjIuNTguMjRMMTAuNDYgMjNsNS41MS0yLjA5Yy4xMi0uMDQuNDYtLjIuNTgtLjI0LjE0LS4wNi4yNy0uMTIuNC0uMTcuMTYtLjA4LjMyLS4xNS40Ni0uMjMuNTEtLjI5Ljg4LS41OCAxLjE1LS44Ny40MS0uNDYuNi0xIC42NC0xLjY4di0uMDJzMC0uMTYuMDEtLjR2LTEuNDRjLTUuMDUgMS4wNS04LjY3IDEuMDItOC43NCAxLjAycy0zLjY4LjA0LTguNzQtMS4wMnYxLjQ1Yy0uMDIuMjUtLjAxLjQxLS4wMS40MXpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiMwMDczNjBcXFwiXFxuICAgICAgZD1cXFwiTTQuOCAzLjY5bC40MSAxLjIzIDEuMjkuMDEtMS4wNC43Ny4zOSAxLjI0LTEuMDUtLjc2LTEuMDUuNzYuMzktMS4yNC0xLjA0LS43NyAxLjI5LS4wMS40MS0xLjIzem0xMS4zMSAwbC40MiAxLjIzIDEuMjkuMDEtMS4wNC43Ny4zOSAxLjI0LTEuMDYtLjc2LTEuMDUuNzYuMzktMS4yNC0xLjA0LS43NyAxLjI5LS4wMS40MS0xLjIzem0tNS42NS40OGwuNDIgMS4yMyAxLjI5LjAxLTEuMDQuNzcuMzkgMS4yNC0xLjA2LS43Ni0xLjA2Ljc1LjM5LTEuMjQtMS4wNC0uNzcgMS4zLS4wMS40MS0xLjIyek0xMC40NiAxNy4yMWwtLjQ2LjQ1djEuMjJsLjIzLjY1djEuMDloLjQ1di0xLjA5bC4yMy0uNjV2LTEuMjJsLS40NS0uNDV6bS4yMiA0LjQxdi0uNjVoLS40NXYuNjVsLS4yMy40Mi40Ni41Ni40Ni0uNTYtLjI0LS40MnptLjMzLS42NXYuNWwuMjkuMzEuNTEtLjQxdi0uNDFoLS44em0uNTQtMi4wNGwtLjU0LjZ2MS4wOWguNDR2LS42NWwuNDMtLjQ2LjU1LjM2LjM1LS4zNnYtLjU4aC0xLjIzem0tMS42NCAyLjA0di41bC0uMjkuMzEtLjUyLS40MXYtLjQxaC44MXptLS41NS0yLjA0bC41NC42djEuMDloLS40M3YtLjY1bC0uNDMtLjQ2LS41NS4zNi0uMzUtLjM2di0uNThoMS4yMnpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNFMUM0QUNcXFwiXFxuICAgICAgZD1cXFwiTTE0LjYyIDkuMjd2NS4xOWgtMy40OWwtLjI1LjIxLS40My4zNy0uNDMtLjM3LS4yNS0uMjFINi4yOVY5LjI3bC0uNzQuNTR2NS4zOGg0LjEybC4zNy4zMS40My4zOC40My0uMzguMzctLjMxaDQuMTJWOS44MWwtLjc3LS41NHpcXFwiPlxcbiAgICA8L3BhdGg+XFxuICAgIDxwYXRoIGZpbGw9XFxcIiNFMUM0QUNcXFwiXFxuICAgICAgZD1cXFwiTTExLjAyIDguODNsLS4xNC4xMS0uNDMuMzgtLjQzLS4zOC0uMTItLjExSDcuMDN2NC44OWgyLjg4bC4yLjE3LjM1LjMxLjM2LS4zMS4xOS0uMTdoMi44OFY4LjgzaC0yLjg3ek0xNi4xMSAxMC4zNXYzLjMxYy45NS0uMTQgMS45OC0uMzEgMy4wOC0uNTRWOS44MWE1MC41IDUwLjUgMCAwIDEtMy4wOC41NHptLTExLjMxIDBjLS45NS0uMTQtMS45OC0uMzEtMy4wOC0uNTR2My4zMWMxLjEuMjMgMi4xNC40MSAzLjA4LjU0di0zLjMxelxcXCI+XFxuICAgIDwvcGF0aD5cXG4gICAgPHBhdGggZmlsbD1cXFwiIzAwNzM2MFxcXCJcXG4gICAgICBkPVxcXCJNMTYuMTEgMTYuNzZsLS4zMS4zMnYuODZsLjE1LjQ2di43N2guMzF2LS43N2wuMTYtLjQ2di0uODZsLS4zMS0uMzJ6bS4xNiAzLjA5di0uNDVoLS4zMXYuNDZsLS4xNS4zLjMxLjQuMzItLjQtLjE3LS4zMXptLjIzLS40NXYuMzVsLjIuMjIuMzYtLjI4di0uMjloLS41NnptLjM4LTEuNDNsLS4zOC40M3YuNzdoLjMxdi0uNDZsLjMtLjMzLjM4LjI1LjI0LS4yNXYtLjQxaC0uODV6bS0xLjE0IDEuNDN2LjM1bC0uMjEuMjItLjM1LS4yOHYtLjI5aC41NnptLS4zOS0xLjQzbC4zOS40M3YuNzdoLS4zMXYtLjQ2bC0uMy0uMzMtLjM5LjI1LS4yNC0uMjV2LS40MWguODV6TTQuOCAxNi43NmwtLjMyLjMydi44NmwuMTYuNDZ2Ljc3aC4zMXYtLjc3bC4xNS0uNDZ2LS44NmwtLjMtLjMyem0uMTYgMy4wOXYtLjQ1aC0uMzF2LjQ2bC0uMTYuMy4zMi40LjMxLS40LS4xNi0uMzF6bS4yMi0uNDV2LjM1bC4yMS4yMi4zNS0uMjh2LS4yOWgtLjU2em0uMzktMS40M2wtLjM5LjQzdi43N2guMzF2LS40NmwuMy0uMzMuMzkuMjUuMjQtLjI1di0uNDFoLS44NXpNNC40MiAxOS40di4zNWwtLjIuMjItLjM2LS4yOHYtLjI5aC41NnptLS4zOC0xLjQzbC4zOC40M3YuNzdoLS4zMXYtLjQ2bC0uMy0uMzMtLjM4LjI1LS4yNC0uMjV2LS40MWguODV6XFxcIj5cXG4gICAgPC9wYXRoPlxcbiAgICA8ZyBmaWxsPVxcXCIjRkZGXFxcIiBjbGFzcz1cXFwid2FzaHUtbG9nby10ZXh0XFxcIj5cXG4gICAgICA8cGF0aFxcbiAgICAgICAgZD1cXFwiTTIzMi40NyA4LjE2Yy4zMyAwIDEuMDctMS4yIDEuMDctMS41NyAwLS4zNi0uNzQtMS42LTEuMDctMS42LS4zIDAtMS4wNyAxLjI2LTEuMDcgMS42cy43NiAxLjU3IDEuMDcgMS41N3ptMTMuODIgMTIuMDN2LTUuMDhjMC0yLjM0LS43Ni01Ljc2LTQuMjItNS43Ni0yLjUxIDAtMy44MSAyLjM4LTMuNzYgMi4wMVY5LjU5YzAtLjMxLS4xNS0uNDktLjMxLS40OS0uNiAwLTEuMDQgMS4wMS0zLjA2IDEuNjItLjEzLjAzLS41LjA0LS41MS4yNyAwIC42NSAyLjAzLS44NCAxLjk5IDEuNjh2Ny42NGMwIDEuNDMtLjcgMS41NS0xLjIxIDEuNjgtLjAzIDAtLjA2LS4wMS0uMSAwLS41Mi0uMDMtMS42My0uMjMtMS42My0xLjM1VjkuNTljMC0uMzEtLjE1LS40OS0uMzEtLjQ5LS42IDAtLjk4IDEuMDgtMi42MyAxLjY0LS4xMy4wMy0uMzcuMDYtLjM3LjI0IDAgLjY1IDEuNDktLjYxIDEuNDIgMS42OXY3LjI3Yy4wNiAxLjg2LS45NiAyLjA0LTEuNTIgMi4wNC0uODQtLjAxLS42My4xLS42My4zNi4wMy4zMS41My4zMyAxLjM3LjM0LjI5IDAgMS0uMTEgMS44Mi0uMTEgMS4wNyAwIDEuODcuMTIgMi40MS4xMi4zMSAwIDEuMTUtLjEzIDIuNTMtLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZWMTMuMWMtLjAzLS40OS44OC0yLjQgMy4wNi0yLjQgMi4xIDAgMy4wMyAyLjMxIDMuMDMgMy44NXY1Ljc2Yy0uMDMgMi4yNy0uOCAxLjU1LTEuMTEgMi0uMTcuMjUuMTMuMzcuNDYuMzdzLjg4LS4xMyAxLjg3LS4xM2MxLjI3IDAgMS44Mi4xMiAyLjE2LjEyLjI2IDAgLjczLS4yLjQ1LS40NC0uNjgtLjUtMS45Ny4zLTEuOTUtMi4wNHpNNDguOTEgMi40Yy4zNy0uMDUuNTUtLjE5LjU1LS4xOSAwLS4yNC0uMDUtLjMtLjM5LS4zLS42NSAwLTEuMDUuMTEtMS42OS4xMS0uNzEgMC0xLjI1LS4wOC0xLjg1LS4wOC0uMzQgMC0uMzEuMTEtLjMxLjMgMCAuMjEuNjUuMDggMS4wMi44OS4yMS40NC4xMyAxLjM2LS4wOCAxLjlsLTUuMDEgMTMuNzQtMi4xNC02LjEtLjgzLTIuMjNzLS4xMy4wNi40Ni0xLjc5bDEuMTctMy41MmMuNTctMS43MyAxLjE0LTIuNjQgMS44OC0yLjY1LjkyLS4wMi45Mi0uNTcuMjEtLjU3cy0xLjEzLjA2LTEuNzUuMDZjLS42NSAwLS45OS0uMDYtMS42OS0uMDYtLjI2IDAtLjU1LjA4LS41Mi4zLjAzLjIxLjQyLjE0LjcxLjMuNDcuMjQuNzggMS4yNS40NSAyLjNsLTEuMzggNC40Mi0xLjU4LTQuMTNjLS4zMS0uNzgtLjczLTIuNTIuMDMtMi42Ny43My0uMTUuNjMtLjUyLjE4LS41Mi0uODYgMC0xLjMyLjExLTIuMTUuMTEtLjkxIDAtMS41OS0uMTEtMi40NS0uMTEtLjE4IDAtLjUyLjAzLS40Mi4zOC4wNS4yMS40OS4xNC43Ni4zIDEuMDUuNjggMS4yNSAxLjU1IDEuNjIgMi41MmwyLjMgNi40OGMuNDIgMS4xNi40NS43NC4xMSAxLjczbC0yIDUuNS00Ljk1LTE0LjExYy0uMzktMS4wNi0uNi0xLjc5LjI2LTIuMi4zNy0uMTkuNDctLjIyLjUyLS4zLjA1LS4wNy4xLS4zMi0uNDUtLjMtLjg5LjAzLTEuNDMuMTEtMi4zMi4xMS0uOTQgMC0xLjU5LS4xMS0yLjQ1LS4xMS0uMjkgMC0uMzQuMTQtLjM0LjM1IDAgLjMzLjcxLjExIDEuMzEuODEuMzQuMzguOTkgMS42NiAxLjE0IDIuMTJMMzIuOCAyMi4zYy4xMS4yNS4xNC43Ni40OC43Ni4yNyAwIC4zMy0uNTcuNDItLjc5bDMuMTMtOC41OSAzLjA1IDguMTZjLjEzLjMzLjMxIDEuMjIuNjMgMS4yMi4yNiAwIC4zNi0uNDMuNDktLjgzbDUuOS0xNi44N2MuNS0xLjM2IDEuMDctMi43OSAyLjAxLTIuOTZ6bTY1LjQ2IDYuNzFjLTMuMjYgMC01Ljc3IDMuMjgtNS43NyA3LjEzIDAgMS45Ni41MiAzLjUxIDEuNDIgNC42My0uMzEuMjEtLjkyLjctMi4xNS43LTEuMDcgMC0xLjY4LS42NC0xLjc0LTJWMTEuMmwzLjM4LS4wMWMuMjIgMCAuNjUtMS40NC42Ny0xLjUyLjA0LS4xOC4xLS4zMy4xMi0uNDYuMDQtLjI4LS4xNy0uMy0uMzctLjAxLS4xNS4xNS0uMzIuNTUtLjk5LjU1aC0yLjgxYzAtMi40MS4wMy0zLjUxLS4zNS0zLjUxLS4zNiAwLS4zLjEtLjYzIDEuMTctLjQ0IDEuNDQtMS43OSAyLjIzLTIuNjMgMi42OC0uMzguMDktLjgxLjEyLTEuMjkuMDEtLjc0LS4xNi0xLjYtMS4wNi0zLjgzLTEuMDYtMi4zOCAwLTQuNDYgMS45NS00LjQ2IDQuNTUgMCAxLjQuNjIgMi43NiAxLjcxIDMuNDgtLjIuMTItMS41MyAxLjI0LTEuMzcgMi41NiAwIDAtLjAzIDEuMzcgMS4wNSAxLjgyLS4zMy4xNC0uNjcuMzYtLjk2LjYzLS43LS4yNi0xLjcyLS4wNi0xLjcyLTEuOTFWMTUuMWMwLTIuMzQtLjc2LTUuNzYtNC4yMi01Ljc2LTIuNTEgMC0zLjgxIDIuMzgtMy43NiAyLjAxVjkuNTljMC0uMzEtLjE1LS40OS0uMzEtLjQ5LS42IDAtLjczLjk5LTIuOTEgMS41NS0uMTMuMDMtLjQzLjEtLjQ0LjM0IDAgLjY1IDEuNzUtLjcxIDEuNzYgMS42OHY3LjY0YzAgMS42NS0xLjMxIDEuNjUtMS41NCAxLjY3LS4xIDAtLjE5IDAtLjMxLjAxLS41NS0uMDUtMS41MS0uMy0xLjUxLTEuMzRWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0uOTggMS4wOC0yLjYzIDEuNjQtLjEzLjAzLS4zNy4wNi0uMzcuMjQgMCAuNjUgMS40OS0uNjEgMS40MiAxLjY5djcuMjdjLjA2IDEuNzgtLjg2IDIuMDEtMS40MyAyLjAzLS42OS0uMDktMS4yMi0uMzctMS4yMi0xLjQxdi01LjE0YzAtMi42NS0xLjAxLTYuMDctNC4zMy02LjA3LTEuNDcgMC0yLjc1LjgxLTMuNzMgMS45MlYyLjQxYzAtLjMxLS4xNS0uNDgtLjMxLS40OS0uNC0uMDMtMS4wNyAxLjE5LTIuOTYgMS42My0uMTMuMDMtLjYyLjA3LS42Mi4yNSAwIC42NSAxLjk3LS4zMSAxLjk5IDEuNjlWMjAuNmMwIDEuNTEtMS4zIDEuMzEtMS41MyAxLjc5LS4wNC4yMS4wOC4zMS4yNi4zMS40MiAwIDEuNTUtLjEyIDIuMzUtLjEyczIuMS4xMiAyLjY0LjEyYy4zMSAwIC40NC0uMDYuNDQtLjQ0LS4yNy0uNTItMi4yOC4yOC0yLjI4LTIuMzd2LTYuNWMwLTEuNTcgMS44Ny0yLjc4IDMuMDMtMi43OC45MSAwIDMuMTQuNzEgMy4xNCA0LjUzdjUuNjRjMCAxLjExLTEuMTggMS4yMy0xLjI3IDEuNTcgMCAuMjQuMTUuMzQuNDIuMzQuMjggMCAxLjExLS4xMiAyLjEyLS4xMi41NiAwIDEuMDcuMDMgMS41LjA2LjIzLjA1LjU3LjA1Ljk5LjA1LjI4IDAgMS0uMTEgMS44Mi0uMTFzMS40OC4wNyAxLjk5LjExYy4xLjAxLjIuMDEuMy4wMS4wNCAwIC4wOC4wMS4xMi4wMWguMDFjLjMyLjAxLjYxIDAgLjc0IDAgLjMxIDAgLjgzLS4xMyAyLjItLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZ2LTcuMDljLS4wMy0uNDkuODgtMi40IDMuMDYtMi40IDIuMSAwIDMuMDMgMi4zMSAzLjAzIDMuODV2NS43NmMwIDItLjggMS41NS0xLjExIDItLjE3LjI1LjEzLjM3LjQ2LjM3cy44OC0uMTMgMS44Ny0uMTNjLjkzIDAgMS41My4wNyAxLjkxLjEtLjI5LjQyLS40OC45LS41MSAxLjQtLjE0IDIuNTEgMi45MyAzLjQxIDUuNTEgMy4zNyA1LjEyLS4wNyA2LjU3LTMuNjIgNS41MS01LjUxLTEuMDktMS45NS0zLjQ0LTEuODctNS42OC0xLjg2LTQuMi4wMi0zLjQxLTIuNTktMS42OS0yLjQ5LjQuMDIuMi4xNCAxLjU3LjE0IDIuNDMgMCA0Ljc2LTEuNjYgNC43LTQuMzgtLjAxLS4yMy4wNS0xLjAzLS41My0yLjE0IDEuMTQuMDEuNjkgMCAyLjQxIDBsLS4wMSA3LjYzYzAgMy40NSAxLjY0IDQuMDMgMi44NyA0LjAzIDEuNzQgMCAzLjAxLTEuMTUgMy4yNC0xLjY4IDEuMDMgMS4xIDIuNDYgMS42OCA0LjEyIDEuNjggMy4xOSAwIDUuNi0yLjkzIDUuNi02Ljc4IDAtNS44LTMuNjUtNi45Ni01LjYxLTYuOTZ6TTk1LjYyIDIxLjcyYy4yMS0uMDEuMjcuMDggMi42NC4xNyAyLjQ1LjA2IDMuMzMuNzcgMy40OSAxLjQuMjYgMS4xMi0uNTMgMy41Mi00LjA1IDMuMjktMi4yMi0uMTUtMi44Ny0xLjItMy4wMy0xLjQ0LS44NC0xLjE2LS4xNi0zLjM1Ljk1LTMuNDJ6bTIuMDEtNC41N2MtMi4wOCAwLTIuNzgtMi0yLjc4LTMuOTEgMC0xLjk2LjU5LTMuNTggMi42Ny0zLjU4IDIuMTEgMCAyLjk1IDIuMTYgMi45NSA0LjA3LjAxIDEuOTMtLjg3IDMuNDItMi44NCAzLjQyem0xNi45OSA0LjgxYy0zLjAzIDAtNC4yMi0zLjc2LTQuMjItNi44MiAwLTIuNjUgMS4wNC01LjEgMy41Ny01LjEgMy4wOCAwIDQuMTkgMy4yOSA0LjE5IDYuNTEuMDEgMy44Ny0xLjM2IDUuNDEtMy41NCA1LjQxelxcXCI+XFxuICAgICAgPC9wYXRoPlxcbiAgICAgIDxwYXRoXFxuICAgICAgICBkPVxcXCJNMTMxLjExIDIwLjE5di01LjA4YzAtMi4zNC0uNzYtNS43Ni00LjIyLTUuNzYtMi41MSAwLTMuODEgMi4zOC0zLjc2IDIuMDFWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0xLjA0IDEuMDEtMy4wNyAxLjYyLS4xMy4wMy0uNS4wNC0uNTEuMjcgMCAuNjUgMi4wMy0uODQgMiAxLjY4djcuNjRjMCAyLTEuMzUgMS41Mi0xLjY2IDIuMDQtLjE1LjI3LjI1LjMzLjU5LjMzLjMxIDAgLjgzLS4xMyAyLjItLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZ2LTcuMDljLS4wMy0uNDkuODgtMi40IDMuMDYtMi40IDIuMSAwIDMuMDMgMi4zMSAzLjAzIDMuODV2NS43NmMtLjAzIDIuMjctLjggMS41NS0xLjExIDItLjE3LjI1LjEzLjM3LjQ2LjM3cy44OC0uMTMgMS44Ny0uMTNjMS4yNyAwIDEuODIuMTIgMi4xNi4xMi4yNiAwIC43My0uMi40NC0uNDQtLjY1LS40OS0xLjk0LjMxLTEuOTItMi4wM3pNNzcuNDEgOC4xNmMuMzMgMCAxLjA3LTEuMiAxLjA3LTEuNTcgMC0uMzYtLjc0LTEuNi0xLjA3LTEuNi0uMyAwLTEuMDcgMS4yNi0xLjA3IDEuNi4wMi4zNS43NyAxLjU3IDEuMDcgMS41N3ptLTE3LjMgNi45NmMtLjUxLS4yNC0xLjI3LS42OC0xLjY1LS44OC0xLjYzLS44OS0yLjI3LTEuNDctMi4zMS0yLjMtLjA4LTEuNDQgMS4xNS0yLjE5IDIuMjEtMi4wOCAyLjU0LS4wNCAyLjg4IDIuOCAzLjE0IDIuOC4zOSAwIC4yOC0uMzcuMjgtMS4yMSAwLS4yMS4wMy0xLjI3LS4xMy0xLjUyLS4zMS0uNDYtMi4xLS43NC0yLjU1LS43NC0uMTEgMC0uNTItLjAxLS42LS4wMi0uMTMgMC0uMjguMDItLjI4LjAyLTEuODEtLjAzLTMuNSAxLjExLTMuNDUgMy41My4wNSAyLjIxIDIuNjQgMy40NyA0LjA0IDQuMyAxLjA0LjU5IDIuMjYgMS4xNSAyLjI0IDIuNTctLjAyIDEuNjEtMS4yNyAyLjY4LTIuNjEgMi42LTMuMTUtLjA1LTIuNzItNC0zLjI4LTQtLjM5IDAtLjMxIDEtLjMxIDEuNTIgMCAuNTEtLjAxLjk4LS4wMSAxLjM4LS4wNy4zNi0uMi43LS41NC43Mi0xLjI0LjA4LS45NC0xLjktLjk0LTIuOTV2LTYuNDNjLS4wNi0xLjk3LTEuNTQtMy4yNS0zLjgtMy4yNS0zLjA5IDAtNS4zMSAzLjgxLTQuMjUgNSAuMjUuMjggMS4yNi0uOCAxLjMyLS44NnMuMDgtLjEzLjA4LS4xM2MtLjAxLTEuMy45Ny0yLjk1IDIuMzctMy4wOSAxLjYtLjE1IDIuNCAxLjA0IDIuNCAyLjY1djIuMDljLTYuMDYgMS4yMS02LjkzIDMuMjItNi45MyA0Ljg3IDAgMi4yMSAxLjU1IDMuMiAzLjIzIDMuMiAxLjQ1IDAgMi44OC0uNjkgMy45Ni0xLjguMzQgMS4wMyAxLjAxIDEuNjUgMi4wMiAxLjYyLjM1LS4wMS40MS4wOSAxLjQ2LS4zNy4zNy0uMS4zNS0uMDkuNzctLjAxLjU2LjE5IDEuMzIuNTcgMi42Ni41NyAyLjAzLjAzIDMuODUtMS44NSAzLjg1LTQuMTcgMC0xLjUtLjQzLTIuNDEtMi4zOS0zLjYzem0tOC40MyA0LjMyYzAgMS42NS0xLjY4IDIuNTItMi42IDIuNTItMS4zOCAwLTIuMzMtLjg5LTIuMzMtMi42NiAwLTIuNzMgMy4yOC0zLjIzIDQuOTQtMy42Ny0uMDEtLjAxLS4wMSAzLjgxLS4wMSAzLjgxem0yMTkuOTkuMTljLS4zMSAwLTEuMDcgMS4yOS0xLjA3IDEuNjMgMCAuMzQuNzcgMS42IDEuMDcgMS42LjMzIDAgMS4wNy0xLjIzIDEuMDctMS42cy0uNzMtMS42My0xLjA3LTEuNjN6bTMzLjcxIDEuMTJWOS45MmMwLS42MS0uMzQtLjc3LS40NC0uNzctLjM5IDAtLjYxLjEtLjg4LjE2LS4yNy4xLS41OC4yMy0xLjI5LjIzLS4xMyAwLS43OS0uMTItLjc2LjI1LjA0LjM3IDEuNTcuMTUgMS41OCAxLjIzdjcuODNjLS4xMiAxLjM3LTEuMjcgMi44OC0yLjY2IDIuODgtLjMyIDAtMi4zOS0uMjItMi4zNy0zLjY1VjkuOTJjMC0uNjEtLjM0LS43Ny0uNDQtLjc3LS4zOSAwLS42MS4xLS44OC4xNi0uMjcuMS0uNjEuMjItMS4zMi4xOS0uMzgtLjAyLS43OS0uMDctLjczLjI5LjA2LjMyIDEuNTkgMCAxLjU5IDEuMjN2Ny41MWMwIDIuNzQgMS42MSA0LjMyIDMuNTYgNC4zMiAxLjMgMCAyLjQ5LS4yOCAzLjI0LTEuOGguMDV2MS4zMmMwIC4xMy4wMy40OC4yMi40OC4zNyAwIC41Ni0uMy44My0uNC4yOS0uMDcuMzctLjMzIDEuMjgtLjQyLjM5LS4wNC44Mi0uMjQuODItLjUtLjExLS41My0xLjQuMDYtMS40LS43OHpNMjkwLjA5IDkuMTFjLTMuMjYgMC01Ljc3IDMuMjgtNS43NyA3LjEzIDAgMS43My40MiAzLjE1IDEuMTMgNC4yMy0uNzkuNTctMi4yMyAxLjEtNC45NiAxLjEtMi4xMyAwLTEuOTMtLjc0LTEuOTMtMi41NVY0LjU3YzAtMi42NiAxLjk5LTEuODkgMi4wMy0yLjM3LjAzLS4zNC0uMjgtLjI2LS42MS0uMjYtLjM4IDAtMS4wNy4xNS0yLjUyLjE1LTEuMjUgMC0yLjM0LS4xMi0yLjg4LS4xMi0uMzMgMC0uNjMuMS0uNTIuMzUuMjUuNTcgMi4xNC4wNSAyLjE0IDEuNjV2MTUuMWMwIDEuNDQuMjEgMi4zNi0uNDUgMi43My0uODEuNDktMS43Ni41MS0xLjY4LjgzLjA1LjE5LjQ1LjIuNjguMiAxLjAyIDAgMi40Mi0uMTMgMy40NC0uMTUgMS45NC0uMDYgMy44Ni4xMyA1Ljc5LjEzIDEuMTIgMCAxLjQtLjIyIDIuMjItMS4zMy4wMS0uMDIuMDItLjAzLjA0LS4wNSAxLjAxLjk0IDIuMzQgMS40NCAzLjg3IDEuNDQgMy4xOSAwIDUuNi0yLjkzIDUuNi02Ljc4LjAxLTUuODItMy42NS02Ljk4LTUuNjItNi45OHptLjI2IDEyLjg1Yy0zLjAzIDAtNC4yMi0zLjc2LTQuMjItNi44MiAwLTIuNjUgMS4wNC01LjEgMy41Ny01LjEgMy4wOCAwIDQuMTkgMy4yOSA0LjE5IDYuNTEuMDEgMy44Ny0xLjM2IDUuNDEtMy41NCA1LjQxem0tMzIuMDMtMTAuNDljLS43NS0uMzctMS44NS0xLjA0LTIuMzktMS4zNi0yLjM3LTEuMzctMy4zLTIuMjYtMy4zNy0zLjUyLS4xMi0yLjIxIDIuMDQtMy41MiAzLjU4LTMuMzUgMS45NiAwIDMuNTcgMS4xOSA0LjI0IDMuNzMuMDcuMjcuMzEuODkuNTYuODkuMjIgMCAuMjYtLjIuMjQtLjQ1bC0uMzMtNC4wMmMtLjAyLS4zMy0uMTQtLjQyLS4yNy0uNDItLjIyIDAtLjM2LjMzLS41Ni4zMy0uMzEgMC0xLjEtMS4xMS0zLjgtMS4wOS0uMTgtLjAxLS40My4wMi0uNDMuMDItMi42My0uMDUtNS4xIDEuNy01LjAyIDUuNC4wNyAzLjM3IDMuODUgNS4zIDUuODkgNi41OSAxLjUxLjkgMy4wOSAyLjM0IDMuMDQgMy45NS0uMDggMi40Ny0xLjYzIDQuMDgtMy41OCAzLjk0LTQuNTktLjA4LTMuOTYtNi4xMy00Ljc4LTYuMTMtLjU2IDAtLjQ1IDEuNTItLjQ2IDIuMzIgMCAxLjkyLS4wOCAzLjQ5LjE0IDMuNzcuMDcuMDkuMjkuMDUuNzQuMDUuOSAwIDIgMS4wNSA0LjY1IDEuMDUgMi45NS4wNSA1LjM4LTIuNjkgNS4zOC02LjI1LS4wMS0yLjE5LS42Mi0zLjU4LTMuNDctNS40NXptNTEuNjktMy4zMWMuMzMgMCAxLjA3LTEuMiAxLjA3LTEuNTcgMC0uMzYtLjc0LTEuNi0xLjA3LTEuNi0uMyAwLTEuMDcgMS4yNi0xLjA3IDEuNnMuNzYgMS41NyAxLjA3IDEuNTd6TTMxMi42NCAyMmMtLjUyLS4wMy0xLjYzLS4yMy0xLjYzLTEuMzVWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0uOTggMS4wOC0yLjYzIDEuNjQtLjEzLjAzLS4zNy4wNi0uMzcuMjQgMCAuNjUgMS40OS0uNjEgMS40MiAxLjY5djcuMjdjLjA2IDEuODYtLjk2IDIuMDQtMS41MiAyLjA0LS44NC0uMDEtLjYzLjEtLjYzLjM2LjAzLjMxLjUzLjMzIDEuMzcuMzQuMjggMCAxLS4xMSAxLjgyLS4xMSAxLjA3IDAgMS44Ny4xMiAyLjQxLjEyLjMzIDAgLjc2LS44LjA3LS42OXptNS45OC02Ljg4Yy0uNTEtLjI0LTEuMjctLjY4LTEuNjUtLjg4LTEuNjMtLjg5LTIuMjctMS40Ny0yLjMxLTIuMy0uMDgtMS40NCAxLjE1LTIuMTkgMi4yMS0yLjA4IDIuNTQtLjA1IDIuODggMi44IDMuMTQgMi44LjM5IDAgLjI4LS4zNy4yOC0xLjIxIDAtLjIxLjAzLTEuMjctLjEzLTEuNTItLjMxLS40Ni0yLjExLS43NC0yLjU1LS43NC0uMTEgMC0uNTItLjAxLS42LS4wMS0uMTMgMC0uMjguMDEtLjI4LjAxLTEuODEtLjAzLTMuNSAxLjExLTMuNDQgMy41My4wNSAyLjIxIDIuNjQgMy40NiA0LjA0IDQuMyAxLjA0LjU5IDIuMjYgMS4xNSAyLjI0IDIuNTctLjAyIDEuNjEtMS4yNyAyLjY4LTIuNjEgMi42LTMuMTUtLjA1LTIuNzItNC0zLjI4LTQtLjM5IDAtLjMxIDEtLjMxIDEuNTItLjAxIDEuMjUtLjA2IDIuMjguMSAyLjQ2LjA1LjA2LjIuMDMuNS4wMy42MiAwIDEuMzguNjkgMy4xOS42OSAyLjAzLjAzIDMuODUtMS44NSAzLjg1LTQuMTctLjAxLTEuNDgtLjQzLTIuMzktMi4zOS0zLjZ6bS00OC43MyA1LjY2Yy0uMjYuMTMtLjg1Ljc3LTIuMjguNzctMS4wNyAwLTEuNjgtLjY0LTEuNzQtMnYtOC44MmwzLjM4LS4wMWMuMjIgMCAuNjUtMS40NC42Ny0xLjUyLjA0LS4xOC4xLS4zMy4xMi0uNDYuMDQtLjI4LS4xNy0uMy0uMzctLjAxLS4xNS4xNS0uMzIuNTUtLjk5LjU1aC0yLjgxYzAtMi40MS4wMy0zLjA0LS4zNS0zLjA0LS4zNiAwLS4zLjEtLjYzIDEuMTctLjU0IDEuNzktMi41MiAyLjU4LTMuMTUgMi45Ny0uMTUuMDgtLjE1LjExLS4xNS4xOS0uMDEuMjMuNzUuMTQgMi4zMS4xN2wtLjAxIDguMDdjMCAzLjQ1IDEuNjQgNC4wMyAyLjg3IDQuMDMgMS44NyAwIDMuMjEtMS4zNCAzLjI4LTEuOC4wMy0uMjUgMC0uMjgtLjE1LS4yNnptLTgxLjMyLTEuMDljLS41NyAwLTEuNDIgMS42Mi0zLjY2IDEuNjItMS41OCAwLTQuMTctMS41My00LjE3LTYuNjZoNi45Yy42IDAgLjg4LjAzLjg4LS41MiAwLTEuMjUtMS40LTQuOTUtNC41OS00Ljk1LTMuMjQgMC01LjA4IDMuMzMtNS4wOCA3LjMxIDAgMi4wNSAxLjM1IDYuMzggNS4yNCA2LjM4IDIuMzMgMCA0LjU5LTIuMjQgNC41OS0yLjk1LS4wMS0uMTEtLjAxLS4yMy0uMTEtLjIzem0tNS4wOC05LjgxYzEuNDIgMCAyLjg4IDEuNTYgMi44OCAzLjMgMCAuNDYtLjE1LjYyLS41Mi42MmgtNS4xMWMwLTEuNzEgMS4xMy0zLjkyIDIuNzUtMy45MnptLTMxLjctNy4zM2MuMS0uMTYtLjI1LS4yNC0uMzctLjI0LS40MiAwLTEuMzcuMTEtMS44LjExLS44OSAwLTEuNjQtLjA5LTIuNTMtLjA5LS4wNyAwLS40Ni4wNS0uNDYuMTgtLjAxLjYzIDIuMTMtLjExIDIuMTMgMi42djEwLjU3YzAgMy4xMy0uOTkgNi40MS01LjI5IDYuNDEtMy4wOSAwLTQuNzYtMS45NC00Ljc2LTYuMTdWNC40MWMwLTEuOTEgMS40OS0xLjQ5IDEuNTItMS45Mi4wMy0uNDEtMS4zMy0uMTYtMS40My0uMTYtLjcxIDAtMS4yMS4wOC0xLjk1LjA4LS42MiAwLTEuMzctLjEtMS45Ny0uMS0uMTIgMC0uNTMtLjAyLS42MS4xNS0uMjMuNTYgMS45MS4yNiAxLjkxIDEuODN2MTAuOTJjMCA0LjA4IDEuMTQgOC4wOCA3LjE3IDcuOTcgNy4xNC0uMTIgNy4wMS02LjU0IDcuMDEtNy44M1Y1LjEyYy4wMS0yLjQzIDEuMi0yLjIgMS40My0yLjU3em0yOC4xOSA3LjI0Yy4xNy0uMi4yMi0uNTMtLjU3LS40Ni0uNDUgMC0uNzcuMDgtMS4yMi4wOC0uNTcgMC0uNjgtLjAyLTEuMjItLjA0LS42OC0uMDItLjg2LjA1LS44Mi4yNS4xMi42IDEuNTUuMDEgMS4zNiAxLjgtLjE2IDEuNS0uNjUgMi43OS0xLjE0IDQuMDdsLTEuNzMgNC42Mi0yLjU0LTcuN2MtLjMxLS45Ni0uNDUtMS40Ny0uNDUtMS41NyAwLS45NiAxLjE2LS43NSAxLjQyLTEuMTQuMTYtLjI2LS4xNy0uNC0uNTQtLjQtLjMxIDAtLjY3LjExLTEuNjMuMTMtLjc5LjAyLTEuMzYuMDItMS43LS4wNS0uODktLjE2LS44Mi4zMy0uNTEuNDhzLjQ2LjAxLjkxIDEuMzZsMy45MSAxMS4wNmMuMDguMjIuMTguNzcuNTIuNzcuMzkgMCAuMzktLjM5Ljg4LTEuNjkgMCAwIDMuNzUtMTAuNDggNC0xMC44Ni41MS0uNzQuODktLjUgMS4wNy0uNzF6bTE0LjQ3LS41Yy0xLjA3IDAtMS44IDEuMjgtMi4zMyAyLjE2aC0uMDVWOS41M2MwLS4zLS4xNS0uNDgtLjMtLjQ4LS40MSAwLS43Mi44MS0yLjg3IDEuMzMtLjEzLjAzLS40OC4xLS40OC4yOCAwIC42NCAxLjgyLS4xOSAxLjgyIDEuOTN2OC4wN2MwIDEuMjUtMS4yOSAxLjEyLTEuMjkgMS43NyAwIC4xOC4wOC4yNy4yOC4yNy4xNyAwIC42My0uMTIgMi4zMi0uMTIgMS40MSAwIDIuMDIuMTIgMi4zNy4xMi4yOCAwIC40MS0uMDYuNDEtLjM0IDAtLjk4LTIuMjUuNDgtMi4yNS0yLjM0di02Ljg4YzAtLjQuNi0xLjggMS42NC0xLjguOTEgMCAxLjAyLjcgMS41LjcuMyAwIC45MS0uOTEuOTEtMS4zOC0uMDEtLjU4LTEuMTYtMS4zNy0xLjY4LTEuMzd6bTMyLjU1LjFjLS4yNyAwLS45Ni4wNC0xLjU5LjA0LS43NiAwLTEuMTMtLjA5LTEuNDUtLjA5LS40OCAwLS45NiAwLS44Ny4zMi4xLjM2IDEuNzMuMjMgMS43MyAyLjAxIDAgLjIzIDAgLjUyLS4zMyAxLjcxbC0yLjA4IDYuNjMtMi45LTguMTVzLS4xNC0uMjYtLjE0LS43OWMwLTEuMzIgMS41NC0xLjE3IDEuNi0xLjQxLjA1LS4xOS0uMjEtLjQtLjYyLS40aC0zLjYzYy0uMDIgMC0uMDMuMDEtLjA1LjAxaC0yLjgxYzAtMi40MS4wMy0zLjA0LS4zNS0zLjA0LS4zNiAwLS4zLjEtLjYzIDEuMTctLjU0IDEuNzktMi41MiAyLjU4LTMuMTUgMi45Ny0uMTUuMDgtLjE1LjExLS4xNS4xOS0uMDEuMjIuNzYuMTQgMi4zMS4xN2wtLjAxIDguMDdjMCAzLjQ1IDEuNjQgNC4wMyAyLjg3IDQuMDMgMS44NyAwIDMuMjEtMS4zMyAzLjI4LTEuOCAwLS4yNy0uMDQtLjI5LS4xOC0uMjctLjI2LjEzLS44NS43Ny0yLjI4Ljc3LTEuMDcgMC0xLjY4LS42NC0xLjc0LTJWMTAuN3MyLjUtLjAxIDMuMjEtLjAxYy4wNC4wNi4wOC4xMy4xLjE5bDIuOTkgOC40NWMuMjQuNjkuMzkuOTIuNjggMi4xNC4xOS43OS4xMiAxLjUxLjEyIDEuNTEtLjI5IDEuMjctMS4wNyAxLjk5LTIuMjYgNC4zNC0uMTIuMjIgMS43MS0uMDIgMS44MS0uMDUuMTUtLjA1LjEzLS4wOS4zMS0uNDJsMS4zMi0zLjkzIDMuNjktMTEuMzRjLjU0LTEuOTggMS4zOS0xLjYyIDEuNTMtMS44OS4xMi0uMTMgMC0uMy0uMzMtLjN6XFxcIj5cXG4gICAgICA8L3BhdGg+XFxuICAgICAgPHBhdGhcXG4gICAgICAgIGQ9XFxcIk0yMjIuMjIgMjIuNzZsLS4wNy4xOVYyM2wuMDctLjI0em0tMTQuNzQtMTQuNmMuMzMgMCAxLjA3LTEuMiAxLjA3LTEuNTcgMC0uMzYtLjc0LTEuNi0xLjA3LTEuNi0uMyAwLTEuMDcgMS4yNi0xLjA3IDEuNnMuNzYgMS41NyAxLjA3IDEuNTd6TTIxMC4xMSAyMmMtLjUyLS4wMy0xLjYzLS4yMy0xLjYzLTEuMzVWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0uOTggMS4wOC0yLjYzIDEuNjQtLjEzLjAzLS4zNy4wNi0uMzcuMjQgMCAuNjUgMS40OS0uNjEgMS40MiAxLjY5djcuMjdjLjA2IDEuODYtLjk2IDIuMDQtMS41MiAyLjA0LS44NC0uMDEtLjYzLjEtLjYzLjM2LjAzLjMxLjUzLjMzIDEuMzcuMzQuMjggMCAxLS4xMSAxLjgyLS4xMSAxLjA3IDAgMS44Ny4xMiAyLjQxLjEyLjMzIDAgLjc2LS44LjA3LS42OXpNMTY2LjUyIDguMTZjLjMzIDAgMS4wNy0xLjIgMS4wNy0xLjU3IDAtLjM2LS43NC0xLjYtMS4wNy0xLjYtLjMgMC0xLjA3IDEuMjYtMS4wNyAxLjZzLjc3IDEuNTcgMS4wNyAxLjU3ek0xNjkuMTcgMjJjLS41Mi0uMDMtMS42My0uMjMtMS42My0xLjM1VjkuNTljMC0uMzEtLjE1LS40OS0uMzEtLjQ5LS42IDAtLjk4IDEuMDgtMi42MyAxLjY0LS4xMy4wMy0uMzcuMDYtLjM3LjI0IDAgLjY1IDEuNDktLjYxIDEuNDIgMS42OXY3LjI3Yy4wNiAxLjg2LS45NiAyLjA0LTEuNTIgMi4wNGgtLjE3Yy0uNTQtLjEtMS4wNi0uMzItMS4wNS0xLjc5di01LjA4YzAtMi4zNC0uNzYtNS43Ni00LjIyLTUuNzYtMi41MSAwLTMuODEgMi4zOC0zLjc2IDIuMDFWOS41OWMwLS4zMS0uMTUtLjQ5LS4zMS0uNDktLjYgMC0xLjA0IDEuMDEtMy4wNyAxLjYyLS4xMy4wMy0uNS4wNC0uNTEuMjcgMCAuNjUgMi4wMy0uODQgMiAxLjY4djcuNjRjMCAyLTEuMzUgMS41Mi0xLjY2IDIuMDQtLjE1LjI3LjI1LjMzLjU5LjMzLjMxIDAgLjgzLS4xMyAyLjItLjEzIDEuNSAwIDIuMDIuMTMgMi40Ni4xMy4zOSAwIC44My0uMTcuNTctLjQ0LS40Mi0uNDEtMi4yOC4wNi0yLjI4LTIuMDZ2LTcuMDljLS4wMy0uNDkuODgtMi40IDMuMDYtMi40IDIuMSAwIDMuMDMgMi4zMSAzLjAzIDMuODV2NS43NmMtLjAzIDIuMjctLjggMS41NS0xLjExIDItLjE3LjI1LjEzLjM3LjQ2LjM3cy44OC0uMTMgMS44Ny0uMTNjMS4yNyAwIDEuODIuMTIgMi4xNi4xMi4wNCAwIC4wOS0uMDEuMTMtLjAxLjExIDAgLjIxLjAxLjM0LjAxLjI4IDAgMS0uMTEgMS44Mi0uMTEgMS4wNyAwIDEuODcuMTIgMi40MS4xMi4zNC4wMi43NS0uNzguMDgtLjY3em0zMi43Mi02Ljg5Yy0uNTEtLjI0LTEuMjctLjY4LTEuNjUtLjg4LTEuNjMtLjg5LTIuMjctMS40Ny0yLjMxLTIuMy0uMDgtMS40NCAxLjE1LTIuMTkgMi4yMS0yLjA4IDIuNTQtLjA1IDIuODggMi44IDMuMTQgMi44LjM5IDAgLjI4LS4zNy4yOC0xLjIxIDAtLjIxLjAzLTEuMjctLjEzLTEuNTItLjMxLS40Ni0yLjEtLjc0LTIuNTUtLjc0LS4xMSAwLS41Mi0uMDEtLjYtLjAyLS4xMyAwLS4yOC4wMi0uMjguMDItMS44MS0uMDMtMy41IDEuMTEtMy40NSAzLjUzLjA1IDIuMjEgMi42NCAzLjQ2IDQuMDQgNC4zIDEuMDQuNTkgMi4yNiAxLjE1IDIuMjQgMi41Ny0uMDIgMS42Mi0xLjI3IDIuNjgtMi42MSAyLjYtMy4xNS0uMDUtMi43Mi00LTMuMjgtNC0uMzkgMC0uMzEgMS0uMzEgMS41MiAwIDEuMjUtLjA2IDIuMjguMSAyLjQ2LjA1LjA2LjIuMDMuNS4wMy42MiAwIDEuMzguNjkgMy4xOS42OSAyLjAzLjAzIDMuODUtMS44NSAzLjg1LTQuMTcgMC0xLjQ3LS40Mi0yLjM4LTIuMzgtMy42elxcXCI+XFxuICAgICAgPC9wYXRoPlxcbiAgICA8L2c+XFxuICA8L3N2Zz5cXG48L2Rpdj5cXG48aGVhZGVyIHJvbGU9XFxcImJhbm5lclxcXCI+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICA8IS0tIDxhIGNsYXNzPVxcXCJzaXRlLXRpdGxlXFxcIiBocmVmPVxcXCJmaWxlcy9pbmRleC5odG1sXFxcIj5OdXJzZXJ5IFNjaG9vbDwvYT4gLS0+XFxuICA8L2Rpdj5cXG4gIDxkaXYgaWQ9XFxcIm1haW4tbWVudS1jb250YWluZXJcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhclxcXCI+XFxuICAgICAgICA8YSBjbGFzcz1cXFwic2l0ZS10aXRsZVxcXCIgaHJlZj1cXFwiZmlsZXMvaW5kZXguaHRtbFxcXCI+TnVyc2VyeSBTY2hvb2w8L2E+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImRyb3BidG5cXFwiPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJhYm91dFxcXCIgaHJlZj1cXFwiZmlsZXMvYWJvdXQuaHRtbFxcXCI+QWJvdXRcXG4gICAgICAgICAgICA8L2E+XFxuICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93bi1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8YSBpZD1cXFwidHVpdGlvblxcXCIgaHJlZj1cXFwiZmlsZXMvdHVpdGlvbi5odG1sXFxcIj5UdWl0aW9uPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJwYXJlbnQtaGFuZGJvb2tcXFwiIGhyZWY9XFxcImZpbGVzL3BhcmVudF9oYW5kYm9vay5odG1sXFxcIj5DdXJyaWN1bHVtPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJzdGFmZlxcXCIgaHJlZj1cXFwiZmlsZXMvc3RhZmYuaHRtbFxcXCI+U3RhZmY8L2E+XFxuICAgICAgICAgICAgXFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93blxcXCI+XFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImRyb3BidG5cXFwiPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJjbGFzc3Jvb21zXFxcIiBocmVmPVxcXCJmaWxlcy9jbGFzc3Jvb21zLmh0bWxcXFwiPkNsYXNzcm9vbSBOZXdzXFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24tY29udGVudFxcXCI+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImNsYXNzcm9vbXMtMlxcXCIgaHJlZj1cXFwiZmlsZXMvY2xhc3Nyb29tcy5odG1sXFxcIj5DbGFzc3Jvb21zXFxuICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJzdW1tZXItY2FtcFxcXCIgaHJlZj1cXFwiZmlsZXMvc3VtbWVyX2NhbXAuaHRtbFxcXCI+U3VtbWVyIENhbXA8L2E+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImNhbGVuZGFyXFxcIiBocmVmPVxcXCJmaWxlcy9jYWxlbmRhci5odG1sXFxcIj5DYWxlbmRhcjwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZHJvcGJ0blxcXCI+XFxuICAgICAgICAgICAgPGEgaWQ9XFxcImdldC1pbnZvbHZlZFxcXCIgaHJlZj1cXFwiZmlsZXMvZ2V0X2ludm9sdmVkLmh0bWxcXFwiPkdldCBJbnZvbHZlZDwvYT5cXG4gICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImRyb3Bkb3duLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJudXJzZXJ5LXNjaG9vbC1tZXJjaGFuZGlzZVxcXCIgaHJlZj1cXFwiZmlsZXMvbnVyc2VyeV9zY2hvb2xfbWVyY2hhbmRpc2UuaHRtbFxcXCI+TnVyc2VyeSBTY2hvb2xcXG4gICAgICAgICAgICAgIE1lcmNoYW5kaXNlPC9hPlxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJwYXJlbnQtYXNzb2NpYXRpb25cXFwiIGhyZWY9XFxcImZpbGVzL3BhcmVudF9hc3NvY2lhdGlvbi5odG1sXFxcIj5QYXJlbnQgQXNzb2NpYXRpb248L2E+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICA8YSBpZD1cXFwiYXBwbHlcXFwiIGhyZWY9XFxcImZpbGVzL2FwcGx5Lmh0bWxcXFwiPkFkbWlzc2lvbnM8L2E+XFxuICAgICAgICA8IS0tIDxhIGlkPVxcXCJmb3Jtc1xcXCIgaHJlZj1cXFwiZmlsZXMvZm9ybXMuaHRtbFxcXCI+Rm9ybXM8L2E+IC0tPlxcblxcbiAgICAgICAgPGEgaWQ9XFxcInBhcmVudC1yZXNvdXJjZXNcXFwiIGhyZWY9XFxcImZpbGVzL3BhcmVudF9yZXNvdXJjZXMuaHRtbFxcXCI+UGFyZW50IFJlc291cmNlczwvYT5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L2hlYWRlcj5cIjtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8dHMtbG9hZCBkYXRhLW5hbWU9XFxcImZvb3RlclxcXCI+PC90cy1sb2FkPlwiO1xuIiwiaW1wb3J0IHsgRCB9IGZyb20gXCIuLy4uL2NvcmUvZG9tL2RvY3VtZW50XCI7XG5cbmV4cG9ydCBjbGFzcyBTbGlkZXNob3cge1xuICBwdWJsaWMgc3RhdGljIHNldHVwQWxsKCkge1xuICAgIFNsaWRlc2hvdy5kaXNjYXJkQWxsKCk7XG4gICAgY29uc3Qgc2xpZGVzaG93cyA9IEQuY2xheihcInNsaWRlc2hvd1wiKTtcbiAgICBmb3IgKGxldCBzc0luZGV4ID0gMDsgc3NJbmRleCA8IHNsaWRlc2hvd3MubGVuZ3RoOyArK3NzSW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzbGlkZXNob3dzLml0ZW0oc3NJbmRleCk7XG4gICAgICBpZiAoZWxlbSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgU2xpZGVzaG93LnNsaWRlc2hvd3MucHVzaChuZXcgU2xpZGVzaG93KGVsZW0pKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGRpc2NhcmRBbGwoKSB7XG4gICAgU2xpZGVzaG93LnNsaWRlc2hvd3MgPSBbXTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHNsaWRlc2hvd3M6IFNsaWRlc2hvd1tdID0gW107XG5cbiAgcHJpdmF0ZSBzbGlkZUluZGV4ID0gMDtcbiAgcHJpdmF0ZSBzbGlkZUNvdW50ID0gMDtcbiAgcHJpdmF0ZSBzbGlkZXM6IEVsZW1lbnRbXSA9IFtdO1xuICBwcml2YXRlIGRvdHM6IEVsZW1lbnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3V0ZXI6IEVsZW1lbnQpIHtcbiAgICBELmVhY2hSZWN1cih0aGlzLm91dGVyLCAoZWxlbSkgPT4ge1xuICAgICAgY29uc3QgY0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcbiAgICAgIGlmIChjTGlzdC5jb250YWlucyhcInByZXYtc2xpZGVzaG93LWJ1dHRvblwiKSkge1xuICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLm1pbnVzU2xpZGUoMSkpO1xuICAgICAgfSBlbHNlIGlmIChjTGlzdC5jb250YWlucyhcIm5leHQtc2xpZGVzaG93LWJ1dHRvblwiKSkge1xuICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoZWxlbSwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLnBsdXNTbGlkZSgxKSk7XG4gICAgICB9IGVsc2UgaWYgKGNMaXN0LmNvbnRhaW5zKFwic2xpZGVzaG93LWVudHJ5XCIpKSB7XG4gICAgICAgIHRoaXMuc2xpZGVzLnB1c2goZWxlbSk7XG4gICAgICB9IGVsc2UgaWYgKGNMaXN0LmNvbnRhaW5zKFwic2xpZGVzaG93LWRvdFwiKSkge1xuICAgICAgICB0aGlzLmRvdHMucHVzaChlbGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZG90cy5sZW5ndGg7ICsraSkge1xuICAgICAgRC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZG90c1tpXSwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLnNob3dTbGlkZShpKSk7XG4gICAgfVxuICAgIHRoaXMuc2xpZGVDb3VudCA9IHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgICB0aGlzLnNob3dTbGlkZSh0aGlzLnNsaWRlSW5kZXgpO1xuICB9XG5cbiAgcHVibGljIHBsdXNTbGlkZShuOiBudW1iZXIpIHtcbiAgICB0aGlzLnNob3dTbGlkZSgodGhpcy5zbGlkZUluZGV4ICs9IG4pKTtcbiAgfVxuICBwdWJsaWMgbWludXNTbGlkZShuOiBudW1iZXIpIHtcbiAgICB0aGlzLnNob3dTbGlkZSgodGhpcy5zbGlkZUluZGV4IC09IG4pKTtcbiAgfVxuICBwdWJsaWMgc2hvd1NsaWRlKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLnNsaWRlSW5kZXggPSBpbmRleCAlIHRoaXMuc2xpZGVDb3VudDtcbiAgICB0aGlzLnNsaWRlSW5kZXggPSBNYXRoLm1heCh0aGlzLnNsaWRlSW5kZXgsIC0xICogdGhpcy5zbGlkZUluZGV4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2xpZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAodGhpcy5zbGlkZXNbaV0gYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuZG90c1tpXS5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgIH1cbiAgICAodGhpcy5zbGlkZXNbdGhpcy5zbGlkZUluZGV4XSBhcyBIVE1MRWxlbWVudCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICB0aGlzLmRvdHNbdGhpcy5zbGlkZUluZGV4XS5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBkYXRhIH0gZnJvbSAnLi8uLi9jb3JlL2RhdGEtbG9nL2RhdGEnO1xuaW1wb3J0IHsgQWN0aW9uRW51bSB9IGZyb20gJy4vLi4vY29yZS9kYXRhLWxvZy9ldmVudCc7XG5pbXBvcnQgeyBEIH0gZnJvbSAnLi8uLi9jb3JlL2RvbS9kb2N1bWVudCc7XG5pbXBvcnQgeyBFbGVtZW50cyB9IGZyb20gJy4vLi4vY29yZS9kb20vZWxlbWVudHMnO1xuaW1wb3J0IHsgU2Nyb2xsIH0gZnJvbSAnLi8uLi9jb3JlL2RvbS9zY3JvbGwnO1xuaW1wb3J0IHsgSGlzdG9yeSB9IGZyb20gJy4vLi4vY29yZS9yb3V0ZXIvaGlzdG9yeSc7XG5pbXBvcnQgeyBSb3V0ZXIsIFJvdXRlck1vZGUsIFJvdXRlck1vZHVsZSB9IGZyb20gJy4vLi4vY29yZS9yb3V0ZXIvcm91dGVyJztcbmltcG9ydCB7IFRyYWNrZXIgfSBmcm9tICcuLy4uL2NvcmUvdHJhY2tlci90cmFja2VyJztcbmltcG9ydCB7IERlYnVnTGV2ZWxFbnVtIH0gZnJvbSAnLi8uLi9jb3JlL3V0aWxzL2NvbnNvbGVfd3JhcHBlcic7XG5pbXBvcnQgeyBIVE1MTG9hZGVyIH0gZnJvbSAnLi8uLi9jb3JlL3V0aWxzL2h0bWxfbG9hZGVyJztcbmltcG9ydCB7IElER2VuZXJhdG9yIH0gZnJvbSAnLi8uLi9jb3JlL3V0aWxzL2lkX2dlbmVyYXRvcic7XG5pbXBvcnQgeyB3YWl0VW50aWxSZWFkeSB9IGZyb20gJy4vLi4vY29yZS91dGlscy9yZWFkeSc7XG5pbXBvcnQgeyBzY2VuYXJpb3MgfSBmcm9tICcuLy4uL2NvcmUvdXRpbHMvc2NlbmFyaW9zJztcblxuY29uc3Qgc2V0dXAgPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgd2FpdFVudGlsUmVhZHkoKTtcbiAgICAvLyBjb25zdCBzY2VuYXJpb1RhZyA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNwbGl0KCc/JylbMF0ucmVwbGFjZSgnIycsICcnKTtcbiAgICAvLyBjb25zdCBzY2VuYXJpbyA9IHNjZW5hcmlvcy5maW5kKChzY2VuKSA9PiBzY2VuLnRhZyA9PT0gc2NlbmFyaW9UYWcpO1xuICAgIC8vIGlmIChzY2VuYXJpbyA9PT0gbnVsbCB8fCBzY2VuYXJpbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICAgIGFsZXJ0KCdUaGlzIEhJVCBpcyBicm9rZW4gYW5kIGNhbm5vdCBiZSBjb21wbGV0ZWQgYXQgdGhpcyB0aW1lLicpO1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuICAgIC8vIFRyYWNrZXIubG9hZFNjZW5hcmlvKHNjZW5hcmlvKTtcbiAgICBUcmFja2VyLnN0YXJ0KHtcbiAgICAgICAga2V5UHJlZml4OiAnaW5mb3JtYXRpb24tZm9yYWdpbmcnLFxuICAgICAgICBidWNrZXROYW1lOiAnY3NlLTI1Ni1sb2cnLFxuICAgICAgICBhbGxvd1N1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGFsbG93KCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRBcmVhID0gRC5pZCgndGV4dC1hcmVhJykgYXMgSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codGV4dEFyZWEudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dEFyZWEudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1lvdSBtdXN0IGZpbGwgb3V0IHRoZSB0ZXh0IGJveCB0byB0dXJuIHRoaXMgSElUIGluLic7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdUaGVyZSB3YXMgYW4gZXJyb3IgZmlsbCBvdXQgdGhlIGZvcm0gYW5kIHRyeSBhZ2Fpbi4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVTdWJtaXQoKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5kYXRhLnJlc3BvbnNlID0gKEQuaWQoXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFyZWEnXG4gICAgICAgICAgICAgICAgKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50KS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIGRlYnVnTGV2ZWw6IERlYnVnTGV2ZWxFbnVtLk5PTkUsXG5cbiAgICAgICAgYXN5bmMgc2V0dXAoKSB7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgcm91dGVyXG4gICAgICAgICAgICBSb3V0ZXIuZGVmYXVsdEFsbG93YW5jZXNPbigpO1xuICAgICAgICAgICAgUm91dGVyLmNvbmZpZ3VyZShcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFJvdXRlck1vZGUuU1RBTkRBUkRfQUxMT1dBTkNFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZTogUm91dGVyTW9kdWxlLkEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbW9kZTogUm91dGVyTW9kZS5PRkYsIG1vZHVsZTogUm91dGVyTW9kdWxlLkZPUk0gfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogUm91dGVyTW9kZS5TVEFOREFSRF9BTExPV0FOQ0VTLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlOiBSb3V0ZXJNb2R1bGUuSU1HLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgJ2ZpbGVzLydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBIaXN0b3J5LnNldHVwKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB7IHdyYXBwZXI6IHRydWUgfSk7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgaHRtbCBsb2FkZXIgcG9zdCBvcGVyYXRpb25cbiAgICAgICAgICAgIEhUTUxMb2FkZXIuZmluaXNoKCk7XG4gICAgICAgICAgICBIVE1MTG9hZGVyLnJlZ2lzdGVyUG9zdExvYWRGdW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICBJREdlbmVyYXRvci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIElER2VuZXJhdG9yLmF0dGFjaElkc1RvQWxsRWxlbWVudHMoKTtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuc2V0dXAoRWxlbWVudHMuaHRtbExvYyk7XG4gICAgICAgICAgICAgICAgU2Nyb2xsLnByb21pc2UoMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNvbmZpZ3VyZSBsaXN0ZW5lcnMgb24gaHRtbCBsb2NcbiAgICAgICAgICAgIEQuYWRkRXZlbnRMaXN0ZW5lcihFbGVtZW50cy5odG1sTG9jLCBBY3Rpb25FbnVtLkNMSUNLLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ID0gZSBhcyBNb3VzZUV2ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmlkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgVHJhY2tlci5nZXRFdmVudERpc3BhdGNoRnVuYyhBY3Rpb25FbnVtLkNMSUNLKShvYmopO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBELmFkZEV2ZW50TGlzdGVuZXIoRWxlbWVudHMuZG9jdW1lbnQsICdrZXlwcmVzcycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXYgPSBlIGFzIEtleWJvYXJkRXZlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGV2LmtleSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IChldi5zcmNFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5pZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFRyYWNrZXIuZ2V0RXZlbnREaXNwYXRjaEZ1bmMoQWN0aW9uRW51bS5CVVRUT04pKG9iaik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFNQRUNJQUwgQ0FTRTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IGRvZXMgbm90IGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgZG9jdW1lbnQgc28gdGhlIGJlbG93IGZ1bmN0aW9uIG11c3QgYmVoYXZlIGRpZmZlcmVudGx5IHRoYW4gdGhlIGxpc3RlbmVycyBhYm92ZS5cbiAgICAgICAgICAgIGNvbnN0IHNFbGVtID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCBhcyBFbGVtZW50O1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHNFbGVtLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSBzRWxlbS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgY29uc3QgZHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKFRyYWNrZXIubGFzdFBvcy54IC0gZHgpID4gMTAgfHxcbiAgICAgICAgICAgICAgICAgICAgKE1hdGguYWJzKFRyYWNrZXIubGFzdFBvcy55IC0gZHkpID4gMTAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGR0aW1lIC0gVHJhY2tlci5sYXN0UG9zLnRpbWUgPiAxMDApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIFRyYWNrZXIubGFzdFBvcy54ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIFRyYWNrZXIubGFzdFBvcy55ID0gZHk7XG4gICAgICAgICAgICAgICAgICAgIFRyYWNrZXIubGFzdFBvcy50aW1lID0gZHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHsgeDogZHgsIHk6IGR5IH07XG4gICAgICAgICAgICAgICAgICAgIFRyYWNrZXIuZ2V0RXZlbnREaXNwYXRjaEZ1bmMoQWN0aW9uRW51bS5TQ1JPTEwpKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjb25maWd1cmUgdHJhY2tlZCBldmVudHNcbiAgICAgICAgICAgIFRyYWNrZXIucmVnaXN0ZXJFdmVudChBY3Rpb25FbnVtLkhJU1RPUlkpO1xuICAgICAgICAgICAgVHJhY2tlci5yZWdpc3RlckV2ZW50KEFjdGlvbkVudW0uQlVUVE9OKTtcbiAgICAgICAgICAgIFRyYWNrZXIucmVnaXN0ZXJFdmVudChBY3Rpb25FbnVtLkNMSUNLKTtcbiAgICAgICAgICAgIFRyYWNrZXIucmVnaXN0ZXJFdmVudChBY3Rpb25FbnVtLlNDUk9MTCk7XG4gICAgICAgICAgICAvLyBsb2FkIGZpcnN0IHBhZ2VcbiAgICAgICAgICAgIGF3YWl0IFJvdXRlci5sb2FkKCdmaWxlcy9pbmRleC5odG1sJyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59O1xuXG5zZXR1cCgpO1xuIl19
